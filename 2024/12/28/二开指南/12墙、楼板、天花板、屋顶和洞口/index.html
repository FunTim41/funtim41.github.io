<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>12墙、楼板、天花板、屋顶和洞口 | funtim的博客</title><meta name="author" content="funtim@gmail.com"><meta name="copyright" content="funtim@gmail.com"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="墙、楼板、天花板、屋顶和洞口元素和表示内置位置构造的相应ElementType。 以下部分介绍与内置位置构造（如墙、楼板、天花板、屋顶和洞口）相关的类及其相应的属性。 本节中的页面  墙 楼板、天花板和基础 屋顶 幕墙 其他元素 复合结构 洞口 热属性  墙WallType.Kind枚举表示四种墙：  Stacked 叠层墙 Curtain 幕墙 Basic 基本 Unknown 未知  Wall">
<meta property="og:type" content="article">
<meta property="og:title" content="12墙、楼板、天花板、屋顶和洞口">
<meta property="og:url" content="https://funtim41.github.io/2024/12/28/%E4%BA%8C%E5%BC%80%E6%8C%87%E5%8D%97/12%E5%A2%99%E3%80%81%E6%A5%BC%E6%9D%BF%E3%80%81%E5%A4%A9%E8%8A%B1%E6%9D%BF%E3%80%81%E5%B1%8B%E9%A1%B6%E5%92%8C%E6%B4%9E%E5%8F%A3/">
<meta property="og:site_name" content="funtim的博客">
<meta property="og:description" content="墙、楼板、天花板、屋顶和洞口元素和表示内置位置构造的相应ElementType。 以下部分介绍与内置位置构造（如墙、楼板、天花板、屋顶和洞口）相关的类及其相应的属性。 本节中的页面  墙 楼板、天花板和基础 屋顶 幕墙 其他元素 复合结构 洞口 热属性  墙WallType.Kind枚举表示四种墙：  Stacked 叠层墙 Curtain 幕墙 Basic 基本 Unknown 未知  Wall">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://funtim41.github.io/images/4stars.png">
<meta property="article:published_time" content="2024-12-28T13:19:50.000Z">
<meta property="article:modified_time" content="2024-12-28T13:19:57.700Z">
<meta property="article:author" content="funtim@gmail.com">
<meta property="article:tag" content="Revit二次开发人员指南">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://funtim41.github.io/images/4stars.png"><link rel="shortcut icon" href="/images/OIP.jfif"><link rel="canonical" href="https://funtim41.github.io/2024/12/28/%E4%BA%8C%E5%BC%80%E6%8C%87%E5%8D%97/12%E5%A2%99%E3%80%81%E6%A5%BC%E6%9D%BF%E3%80%81%E5%A4%A9%E8%8A%B1%E6%9D%BF%E3%80%81%E5%B1%8B%E9%A1%B6%E5%92%8C%E6%B4%9E%E5%8F%A3/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: funtim@gmail.com","link":"链接: ","source":"来源: funtim的博客","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'null',
  Snackbar: {"chs_to_cht":"已切换为繁体中文","cht_to_chs":"已切换为简体中文","day_to_night":"已切换为深色模式","night_to_day":"已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: true,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '12墙、楼板、天花板、屋顶和洞口',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  isShuoshuo: false
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background: Color(#995a82);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/images/4stars.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">32</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Timeline</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Links</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/images/topback.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/images/OIP.jfif" alt="Logo"><span class="site-name">funtim的博客</span></a><a class="nav-page-title" href="/"><span class="site-name">12墙、楼板、天花板、屋顶和洞口</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Timeline</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Links</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">12墙、楼板、天花板、屋顶和洞口</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-12-28T13:19:50.000Z" title="发表于 2024-12-28 21:19:50">2024-12-28</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-12-28T13:19:57.700Z" title="更新于 2024-12-28 21:19:57">2024-12-28</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="墙、楼板、天花板、屋顶和洞口"><a href="#墙、楼板、天花板、屋顶和洞口" class="headerlink" title="墙、楼板、天花板、屋顶和洞口"></a><a target="_blank" rel="noopener" href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_Revit_Geometric_Elements_Walls_Floors_Ceilings_Roofs_and_Openings_html">墙、楼板、天花板、屋顶和洞口</a></h1><p>元素和表示内置位置构造的相应ElementType。</p>
<p>以下部分介绍与内置位置构造（如墙、楼板、天花板、屋顶和洞口）相关的类及其相应的属性。</p>
<p>本节中的页面</p>
<ul>
<li>墙</li>
<li>楼板、天花板和基础</li>
<li>屋顶</li>
<li>幕墙</li>
<li>其他元素</li>
<li>复合结构</li>
<li>洞口</li>
<li>热属性</li>
</ul>
<h2 id="墙"><a href="#墙" class="headerlink" title="墙"></a>墙</h2><p>WallType.Kind枚举表示四种墙：</p>
<ul>
<li>Stacked 叠层墙</li>
<li>Curtain 幕墙</li>
<li>Basic 基本</li>
<li>Unknown 未知</li>
</ul>
<p>Wall和WallType类与基本墙类型一起使用，同时为叠层墙和幕墙提供有限的功能。有时您需要检查墙以确定墙类型。例如，不能使用API从叠层墙获取子墙。WallKind是只读的，由系统系列设置。</p>
<p>Wall.Flipped属性和Wall.flip（）方法可以访问和控制墙的方向。在下面的示例中，将在调用flip（）方法之前和之后比较Wall。</p>
<ul>
<li>之前的Orientation属性为（0.0，1.0，0.0）。</li>
<li>翻转调用后的Orientation属性为（0.0，-1.0，0.0）。</li>
<li>“墙定位线（WALL_KEY_REF_PARAM）”参数为3，表示下表中的“饰面：内部”。</li>
<li>以该线为参照，墙将被移动，但“位置”不会更改。</li>
</ul>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-4BFD801E-18BC-4021-8371-C29AF13CF7EE-low.png"></p>
<p><strong>图33：原始墙</strong></p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-85CF3DAD-C029-41C5-ACC6-1FEC8CA304E4-low.png"></p>
<p><strong>图34：翻转后的墙</strong></p>
<p><strong>表24：墙位置线</strong></p>
<table>
<thead>
<tr>
<th><strong>Location Line Value 定位线值</strong></th>
<th><strong>Description 描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>墙中心线</td>
</tr>
<tr>
<td>1</td>
<td>核心层中心线</td>
</tr>
<tr>
<td>2</td>
<td>表面：外部</td>
</tr>
<tr>
<td>3</td>
<td>表面：内部</td>
</tr>
<tr>
<td>4</td>
<td>核心面：外部</td>
</tr>
<tr>
<td>5</td>
<td>核心面：内部</td>
</tr>
</tbody></table>
<p>Wall类中有五个静态覆盖方法可用于创建Wall：</p>
<p>表25：Create（）重载</p>
<table>
<thead>
<tr>
<th><strong>Name 名称</strong></th>
<th><strong>Description 描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Create(Document, Curve, WallType, Level, Double, Double, Boolean, Boolean)</td>
<td>使用指定的墙类型、高度和偏移在项目中创建新的矩形轮廓墙。</td>
</tr>
<tr>
<td>Create(Document, IList Curve , Boolean)</td>
<td>使用默认墙样式在项目中创建非矩形轮廓墙。</td>
</tr>
<tr>
<td>Create(Document, Curve, ElementId, Boolean)</td>
<td>使用默认墙样式在项目中由ElementId指定的标高上创建新的矩形轮廓墙。</td>
</tr>
<tr>
<td>Create(Document, IList Curve , ElementId, ElementId, Boolean)</td>
<td>使用指定的墙类型在项目中创建非矩形轮廓墙。</td>
</tr>
<tr>
<td>Create(Document, IList Curve , ElementId, ElementId, Boolean, XYZ)</td>
<td>使用指定的墙类型和法向量在项目中创建非矩形轮廓墙。</td>
</tr>
</tbody></table>
<p>WallType墙功能（WALL_ATTR_EXTERIOR）参数会影响创建的墙实例“房间边界和结构用途”参数。WALL_ATTR_EXTERIOR值是一个整数：</p>
<p><strong>表26：墙功能</strong></p>
<table>
<thead>
<tr>
<th><strong>Wall Function 墙功能</strong></th>
<th><strong>Interior 内部</strong></th>
<th><strong>Exterior 外部</strong></th>
<th><strong>Foundation 基础墙</strong></th>
<th><strong>Retaining 挡土墙</strong></th>
<th><strong>Soffit 檐底板</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Value 值</td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
</tr>
</tbody></table>
<p>以下规则适用于由API创建的墙：</p>
<ul>
<li>如果输入结构参数为true或Wall Function（WALL_ATTR_EXTERIOR）参数为Foundation，则Wall StructuralUsage参数为Bearing;否则为NonBearing。</li>
<li>如果墙功能（WALL_ATTR_EXTERIOR）参数为“Retaining”，则创建的墙房间边界（WALL_ATTR_ROOM_BOUNDING）参数为false。</li>
</ul>
<p>有关与结构相关的函数（如AnalyticalModel属性）的详细信息，请参见结构工程。</p>
<h2 id="楼板、天花板和基础"><a href="#楼板、天花板和基础" class="headerlink" title="楼板、天花板和基础"></a>楼板、天花板和基础</h2><p>与楼板、天花板和基础关联的类。</p>
<p>楼板、天花板和基础相关的API项目包括：</p>
<p>表28：API中的地板、天花板和基础</p>
<table>
<thead>
<tr>
<th><strong>Object 对象</strong></th>
<th><strong>Element Type 元素类型</strong></th>
<th><strong>ElementType Type ElementType类型</strong></th>
<th><strong>Element Creation 元素创建</strong></th>
<th><strong>Other 其他</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Floor</td>
<td>Floor</td>
<td>FloorType</td>
<td>NewFloor()&#x2F;NewSlab()</td>
<td>FloorType.IsFoundationSlab &#x3D; false</td>
</tr>
<tr>
<td>Slab</td>
<td>Floor</td>
<td>FloorType</td>
<td>NewSlab()</td>
<td>FloorType.IsFoundationSlab &#x3D; false</td>
</tr>
<tr>
<td>Ceiling</td>
<td>Ceiling</td>
<td>CeilingType</td>
<td>No</td>
<td>Category &#x3D; OST_Ceilings</td>
</tr>
<tr>
<td>Wall Foundation</td>
<td>WallFoundation</td>
<td>WallFoundationType</td>
<td>No</td>
<td>Category &#x3D; OST_StructuralFoundation</td>
</tr>
<tr>
<td>Isolated Foundation</td>
<td>FamilyInstance</td>
<td>FamilySymbol</td>
<td>NewFamilyInstance()</td>
<td>Category &#x3D; OST_StructuralFoundation</td>
</tr>
<tr>
<td>Foundation Slab</td>
<td>Floor</td>
<td>FloorType</td>
<td>NewFloor()</td>
<td>Category &#x3D; OST_StructuralFoundation FloorType.IsFoundationSlab &#x3D; true</td>
</tr>
</tbody></table>
<p>注意：Floor和Ceiling派生自CeilingAndFloor类。以下规则适用于Floor：</p>
<ul>
<li>从基础设计栏创建的元素具有相同的类别OST_StructuralFoundation，但对应于不同的类。</li>
<li>FloorType IsFoundationSlab属性将FloorType类别设置为OST_StructuralFoundation或不设置。</li>
</ul>
<p>检索FloorType以使用NewFloor创建楼板或基础底板时，请使用以下方法：</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-26C2760B-04F0-4690-AF22-6EB1A0CDD933-low.png"></p>
<p>图35：创建基础和楼板</p>
<p>当前，API不提供对Floor类中的地板坡度箭头的访问。但是，在使用Revit的结构功能时，可以使用NewSlab（）创建斜板：</p>
<p>代码区域11-1：NewSlab（）</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Floor <span class="title">NewSlab</span>(<span class="params">CurveArray profile, Level level, Line slopedArrow, <span class="built_in">double</span> slope,<span class="built_in">bool</span> isStructural</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>使用slopedArrow参数创建坡度箭头。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-5589AB8C-03FB-4FE6-BB20-065A37058854-low.png"></p>
<p>图36：NewSlab中的slopedArrow参数</p>
<p>NewSlab（）中斜率参数的单位是rise&#x2F;run。</p>
<p>Floor.FloorType属性是使用Floor.GetTypeId（）方法的替代方法。有关与结构相关的成员（如GetSpanDirectionSymbolIds（）方法和SpanDirectionAngle属性）的详细信息，请参见结构工程部分。</p>
<p>在Revit中编辑独立基础时，可以执行以下操作：</p>
<ul>
<li>您可以选取宿主，例如楼板。但是，FamilyInstance对象Host属性始终返回null。</li>
<li>删除宿主楼板时，基础不会随之删除。</li>
<li>Foundation 宿主可通过Host（MANANCE_FREE_HOST_PARAM）参数访问。</li>
<li>使用另一个相关的“偏移”（Offset_FREE_HOST_OFFSET_PARAM）参数控制宿主元素的基础偏移。</li>
</ul>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-6FECE5EE-DCFE-42E5-B3F8-868B44E774D5-low.png"></p>
<p>图37：为FoundationSlab（FamilyInstance）选择宿主</p>
<p>条形基础由API中的WallFoundation类表示。API提供对WallFoundation和WallFoundationType的有限访问，但使用GetAnalyticalModel（）方法时除外（请参阅“结构工程”部分中的分析模型）。例如，附着的墙不能用于Revit的建筑功能。使用Revit的结构功能，可以使用AnalyticalModel类中的GetAnalyticalModelSupports（）方法显示Wall类和WallFoundation类之间的关系。有关详细信息，请参见“结构工程”部分中的分析模型。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-03EA5485-1F1B-429D-8917-02B86A50E627-low.png"></p>
<h3 id="修改板"><a href="#修改板" class="headerlink" title="修改板"></a>修改板</h3><p>您可以使用SlabShapeEditor类修改基于板的元素的形式。此类允许您：</p>
<ul>
<li>操作选定的基于板的元素上的一个或多个点或边</li>
<li>在元素上添加点以更改元素的几何图形</li>
<li>添加线性边并将板的现有面拆分为更小的子面域</li>
<li>删除形状修改器并将图元几何图形重置回未修改的形状。</li>
</ul>
<p>下面是将选定的已修改地板恢复为其原始形状的示例：</p>
<p>代码区域11-2：恢复板的形状</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ResetSlabShapes</span>(<span class="params">Autodesk.Revit.DB.Document document</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        UIDocument uidoc = <span class="keyword">new</span> UIDocument(document);</span><br><span class="line">        Selection choices = uidoc.Selection;</span><br><span class="line">        ElementSet collection = choices.Elements;</span><br><span class="line">        <span class="keyword">foreach</span> (Autodesk.Revit.DB.Element elem <span class="keyword">in</span> collection)</span><br><span class="line">        &#123;</span><br><span class="line">                Floor floor = elem <span class="keyword">as</span> Floor;</span><br><span class="line">                <span class="keyword">if</span> (floor != <span class="literal">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                        SlabShapeEditor slabShapeEditor = floor.SlabShapeEditor;</span><br><span class="line">                        slabShapeEditor.ResetSlabShape();</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有关使用SlabShapeEditor和相关类的详细示例，请参见Revit SDK中包含的SlabShapeEditing示例应用程序。</p>
<h2 id="屋顶"><a href="#屋顶" class="headerlink" title="屋顶"></a>屋顶</h2><p>Revit API中屋顶的表示。</p>
<p>Revit Platform API中的屋顶均派生自RoofBase对象。有两个类：</p>
<ul>
<li>FootPrintRoof -表示由建筑物迹线区构成的屋顶</li>
<li>ExtrusionRoof -表示由拉伸轮廓制成的屋顶</li>
</ul>
<p>两者都有一个RoofType属性，用于获取或设置屋顶的类型。此示例说明如何基于某些选定的墙创建迹线屋顶：</p>
<p>代码区域11-3：创建迹线屋顶</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Before invoking this sample, select some walls to add a roof over.</span></span><br><span class="line"><span class="comment">// Make sure there is a level named &quot;Roof&quot; in the document.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// find the Roof level</span></span><br><span class="line">FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">collector.OfClass(<span class="keyword">typeof</span>(Level));</span><br><span class="line"><span class="keyword">var</span> elements = <span class="keyword">from</span> element <span class="keyword">in</span> collector <span class="keyword">where</span> element.Name == <span class="string">&quot;Roof&quot;</span> <span class="keyword">select</span> element;</span><br><span class="line">Level level = elements.Cast().ElementAt(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">collector.OfClass(<span class="keyword">typeof</span>(RoofType));</span><br><span class="line">RoofType roofType = collector.FirstElement() <span class="keyword">as</span> RoofType; </span><br><span class="line"></span><br><span class="line"><span class="comment">// Get the handle of the application</span></span><br><span class="line">Autodesk.Revit.ApplicationServices.Application application = document.Application;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Define the footprint for the roof based on user selection</span></span><br><span class="line">CurveArray footprint = application.Create.NewCurveArray();</span><br><span class="line">UIDocument uidoc = <span class="keyword">new</span> UIDocument(document);</span><br><span class="line">ICollection selectedIds = uidoc.Selection.GetElementIds();</span><br><span class="line"><span class="keyword">if</span> (selectedIds.Count != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">foreach</span> (ElementId id <span class="keyword">in</span> selectedIds)</span><br><span class="line">    &#123;</span><br><span class="line">        Element element = document.GetElement(id);</span><br><span class="line">        Wall wall = element <span class="keyword">as</span> Wall;</span><br><span class="line">        <span class="keyword">if</span> (wall != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            LocationCurve wallCurve = wall.Location <span class="keyword">as</span> LocationCurve;</span><br><span class="line">            footprint.Append(wallCurve.Curve);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ModelCurve modelCurve = element <span class="keyword">as</span> ModelCurve;</span><br><span class="line">        <span class="keyword">if</span> (modelCurve != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            footprint.Append(modelCurve.GeometryCurve);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;You should select a curve loop, or a wall loop, or loops combination \nof walls and curves to create a footprint roof.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ModelCurveArray footPrintToModelCurveMapping = <span class="keyword">new</span> ModelCurveArray();</span><br><span class="line">FootPrintRoof footprintRoof = document.Create.NewFootPrintRoof(footprint, level, roofType, <span class="keyword">out</span> footPrintToModelCurveMapping);</span><br><span class="line">ModelCurveArrayIterator iterator = footPrintToModelCurveMapping.ForwardIterator();</span><br><span class="line">iterator.Reset();</span><br><span class="line"><span class="keyword">while</span> (iterator.MoveNext())</span><br><span class="line">&#123;</span><br><span class="line">    ModelCurve modelCurve = iterator.Current <span class="keyword">as</span> ModelCurve;</span><br><span class="line">    footprintRoof.set_DefinesSlope(modelCurve, <span class="literal">true</span>);</span><br><span class="line">    footprintRoof.set_SlopeAngle(modelCurve, <span class="number">0.5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有关如何创建ExtrusionRoof的示例，请参见Revit API SDK附带的NewRoof示例应用程序。</p>
<p>天沟、筋膜檐沟和封檐带图元派生自表示屋顶的HostedSweep类。可以通过API创建、删除或修改它们。若要创建这些元素，请使用Document.Create.NewFascia（）或Document.Create.NewGutter（）重写之一。有关如何创建新檐沟和封檐带的示例，请参见SDK示例中包含的NewHostedSweep应用程序。下面是一个代码片段，显示了您可以修改gutter元素的属性。</p>
<p>代码区域11-4：修改天沟</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ModifyGutter</span>(<span class="params">Autodesk.Revit.DB.Document document</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        UIDocument uidoc = <span class="keyword">new</span> UIDocument(document);</span><br><span class="line">        ElementSet collection = uidoc.Selection.Elements;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">foreach</span> (Autodesk.Revit.DB.Element elem <span class="keyword">in</span> collection)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">if</span> (elem <span class="keyword">is</span> Gutter)</span><br><span class="line">                &#123;</span><br><span class="line">                        Gutter gutter = elem <span class="keyword">as</span> Gutter;</span><br><span class="line">                        <span class="comment">// convert degrees to rads:</span></span><br><span class="line">                        gutter.Angle = <span class="number">45.00</span> * Math.PI / <span class="number">180</span>;</span><br><span class="line">                        TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>,<span class="string">&quot;Changed gutter angle&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="幕墙"><a href="#幕墙" class="headerlink" title="幕墙"></a>幕墙</h2><p>幕墙、幕墙系统和幕墙屋顶是CurtainGrid对象的主体图元。幕墙只能有一个CurtainGrid，而幕墙系统和幕墙屋顶可以包含一个或多个CurtainGrid。有关如何创建CurtainSystem的示例，请参见Revit SDK附带的CurtainSystem示例应用程序。有关创建幕墙并使用网格线填充幕墙的示例，请参见CurtainWallGrid示例应用程序。</p>
<h2 id="其他元素"><a href="#其他元素" class="headerlink" title="其他元素"></a>其他元素</h2><p>有些元素不是HostObject（也没有特定的类），但它们是可以承载其他对象的特殊情况。例如，ramp及其关联的元素类型在API中没有特定的类，而是在OST_Ramp类别中表示为Element和ElementType。</p>
<h2 id="复合结构"><a href="#复合结构" class="headerlink" title="复合结构"></a>复合结构</h2><p>描述墙、楼板、屋顶或天花板的内部结构。</p>
<p>墙、楼板、天花板和屋顶都是API类HostObject的子对象。HostObject（及其相关类型类HostObjAttributes）提供对CompoundStructure的只读访问。复合结构由有序层的集合组成，对于墙来说，从外部到内部，或者对于地板，屋顶或天花板来说，从顶部到底部。这些层的属性决定了相关墙、楼板、屋顶或天花板的整体结构的厚度、材质和功能。</p>
<p>层可以通过GetLayers（）方法访问，并使用SetLayers（）完全替换。</p>
<p>通常，这些层是平行的，并以固定的层宽度延伸整个主体对象。然而，对于墙，结构也可以是“垂直复合”的，其中层在距墙的顶部和底部的指定垂直距离处变化。使用CompoundStructure.IsVerticallyCompound来标识它们。对于垂直复合结构，该结构通过矩形描述垂直截面，该矩形被划分为多边形区域，多边形区域的边都是垂直或水平段。映射将这些区域中的每一个与CompoundStructure中的层的索引相关联，该层的索引确定该区域的属性。</p>
<p>可以使用复合结构来找到不同层边界的几何位置。方法CompoundStructure.GetOffsetForLocationLine（）提供从中心定位线到任何定位线选项（芯体中心线、任一侧的饰面面或芯体侧）的偏移。</p>
<p>有了到定位线的偏移，您可以从已知位置开始，使用CompoundStructure.GetLayerWidth（）获取每个边界层的宽度，从而获取每个层边界的位置。</p>
<p>使用CompoundStructure的一些注意事项：</p>
<ul>
<li>元素的总宽度是每个CompoundStructureLayer的宽度之和。您无法直接更改元素的总宽度，但可以通过更改CompoundStructureLayer宽度来更改它。指定的可变长度层的索引（如果已分配）可以从CompoundStructure.VariableLayerIndex获得。</li>
<li>必须将CompoundStructure设置回HostObjAttributes实例（使用HostObjAttributes.SetCompoundStructure（）方法），以便存储任何更改。</li>
<li>对HostObjAttributes的更改会影响当前文档中的每个实例。如果需要新的层组合，则需要创建新的HostObjAttributes（使用ElementType.Duplicate（））并将新的CompoundStructure分配给它。</li>
<li>CompoundStructureLayer DeckProfileId和DeckEmbeddingType属性仅适用于Revit结构要素中的Slab。有关详细信息，请参阅结构工程。</li>
</ul>
<h3 id="材质"><a href="#材质" class="headerlink" title="材质"></a>材质</h3><p>HostObjAttributes中的每个CompoundStructureLayer通常与某种类型的材质一起显示。如果CompoundStructureLayer.MaterialId返回-1，则表示该Material与Category相关。有关详细信息，请参阅材料。获取CompoundStructureLayer材质的示例代码如下：</p>
<p>代码区域11-5：获取CompoundStructureLayer材质</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetWallLayerMaterial</span>(<span class="params">Autodesk.Revit.DB.Document document, Wall wall</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">// get WallType of wall</span></span><br><span class="line">        WallType aWallType = wall.WallType;</span><br><span class="line">        <span class="comment">// Only Basic Wall has compoundStructure</span></span><br><span class="line">        <span class="keyword">if</span> (WallKind.Basic == aWallType.Kind)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Get CompoundStructure</span></span><br><span class="line">                CompoundStructure comStruct = aWallType.GetCompoundStructure();</span><br><span class="line">                Categories allCategories = document.Settings.Categories;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Get the category OST_Walls default Material; </span></span><br><span class="line">                <span class="comment">// use if that layer&#x27;s default Material is </span></span><br><span class="line">                Category wallCategory = allCategories.get_Item(BuiltInCategory.OST_Walls);</span><br><span class="line">                Autodesk.Revit.DB.Material wallMaterial = wallCategory.Material;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">foreach</span> (CompoundStructureLayer structLayer <span class="keyword">in</span> comStruct.GetLayers())</span><br><span class="line">                &#123;</span><br><span class="line">                        Autodesk.Revit.DB.Material layerMaterial = </span><br><span class="line">                                document.GetElement(structLayer.MaterialId) <span class="keyword">as</span> Material;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// If CompoundStructureLayer&#x27;s Material is specified, use default</span></span><br><span class="line">                        <span class="comment">// Material of its Category</span></span><br><span class="line">                        <span class="keyword">if</span> (<span class="literal">null</span> == layerMaterial)</span><br><span class="line">                        &#123;</span><br><span class="line">                                <span class="keyword">switch</span> (structLayer.Function)</span><br><span class="line">                                &#123;</span><br><span class="line">                                        <span class="keyword">case</span> MaterialFunctionAssignment.Finish1:</span><br><span class="line">                                                layerMaterial =</span><br><span class="line">                                                        allCategories.get_Item(BuiltInCategory.OST_WallsFinish1).Material;</span><br><span class="line">                                                <span class="keyword">break</span>;</span><br><span class="line">                                        <span class="keyword">case</span> MaterialFunctionAssignment.Finish2:</span><br><span class="line">                                                layerMaterial =</span><br><span class="line">                                                        allCategories.get_Item(BuiltInCategory.OST_WallsFinish2).Material;</span><br><span class="line">                                                <span class="keyword">break</span>;</span><br><span class="line">                                        <span class="keyword">case</span> MaterialFunctionAssignment.Membrane:</span><br><span class="line">                                                layerMaterial =</span><br><span class="line">                                                        allCategories.get_Item(BuiltInCategory.OST_WallsMembrane).Material;</span><br><span class="line">                                                <span class="keyword">break</span>;</span><br><span class="line">                                        <span class="keyword">case</span> MaterialFunctionAssignment.Structure:</span><br><span class="line">                                                layerMaterial =</span><br><span class="line">                                                        allCategories.get_Item(BuiltInCategory.OST_WallsStructure).Material;</span><br><span class="line">                                                <span class="keyword">break</span>;</span><br><span class="line">                                        <span class="keyword">case</span> MaterialFunctionAssignment.Substrate:</span><br><span class="line">                                                layerMaterial = </span><br><span class="line">                                                        allCategories.get_Item(BuiltInCategory.OST_WallsSubstrate).Material;</span><br><span class="line">                                                <span class="keyword">break</span>;</span><br><span class="line">                                        <span class="keyword">case</span> MaterialFunctionAssignment.Insulation:</span><br><span class="line">                                                layerMaterial = </span><br><span class="line">                                                        allCategories.get_Item(BuiltInCategory.OST_WallsInsulation).Material;</span><br><span class="line">                                                <span class="keyword">break</span>;</span><br><span class="line">                                        <span class="literal">default</span>:</span><br><span class="line">                                                <span class="comment">// It is impossible to reach here</span></span><br><span class="line">                                                <span class="keyword">break</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">if</span> (<span class="literal">null</span> == layerMaterial)</span><br><span class="line">                                &#123;</span><br><span class="line">                                        <span class="comment">// CompoundStructureLayer&#x27;s default Material is its SubCategory</span></span><br><span class="line">                                        layerMaterial = wallMaterial;</span><br><span class="line">                                &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>,<span class="string">&quot;Layer Material: &quot;</span> + layerMaterial);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有时只需要“结构”层的材料。与其在每个层中查找其函数为MaterialFunctionAssignment.Structure的层，不如使用CompoundStructure.StructuralMaterialIndex属性查找其材料定义了类型的结构属性的层的索引，以便进行分析。<br>注意：调用SetLayers（）时，StructuralMaterialIndex值将被清除，需要重置。</p>
<h2 id="洞口"><a href="#洞口" class="headerlink" title="洞口"></a>洞口</h2><p>在Revit Platform API中，Opening对象派生自Element对象，并包含所有Element对象属性和方法。若要检索项目中的所有Openings，请使用Document.ElementIterator查找Elements.Opening对象。</p>
<h3 id="常规属性"><a href="#常规属性" class="headerlink" title="常规属性"></a>常规属性</h3><p>本节说明如何使用洞口属性。</p>
<ul>
<li><p>Isolation Boundary-确定洞口是否具有矩形边界。</p>
<ul>
<li>如果为true，则表示Opening具有矩形边界，并且可以从Opening BoundaryRect属性获取IList集合。否则，属性返回null。</li>
<li>如果为false，则可以从BoundaryCurves属性获取CurveArray对象。</li>
</ul>
</li>
<li><p>BoundaryCurves -如果开口边界不是矩形，则此属性检索几何信息;否则返回null。该属性返回一个CurveArray对象，其中包含表示Opening对象边界的曲线。有关曲线的更多详细信息，请参阅几何体。</p>
</li>
<li><p>BoundaryRect -如果开口边界是矩形，则可以使用此属性获取几何信息;否则返回null。</p>
<ul>
<li>该属性返回一个包含XYZ坐标的IList集合。</li>
<li>IList集合通常包含矩形边界的最小（左下）和最大（右上）坐标。</li>
</ul>
</li>
<li><p>Host -host属性检索Opening host元素。主体图元是由Opening对象剪切的图元。</p>
<p><strong>注意：</strong>如果洞口对象的类别为竖井洞口，则洞口主体为空。</p>
</li>
</ul>
<p>下面的示例说明如何检索现有的Opening属性。</p>
<p>代码区域11-6：检索现有洞口属性</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Getinfo_Opening</span>(<span class="params">Opening opening</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> message = <span class="string">&quot;Opening:&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//get the host element of this opening</span></span><br><span class="line">    message += <span class="string">&quot;\nThe id of the opening&#x27;s host element is : &quot;</span> + opening.Host.Id.IntegerValue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//get the information whether the opening has a rect boundary</span></span><br><span class="line">    <span class="comment">//If the opening has a rect boundary, we can get the geometry information from BoundaryRect property.</span></span><br><span class="line">    <span class="comment">//Otherwise we should get the geometry information from BoundaryCurves property</span></span><br><span class="line">    <span class="keyword">if</span> (opening.IsRectBoundary)</span><br><span class="line">    &#123;</span><br><span class="line">        message += <span class="string">&quot;\nThe opening has a rectangular boundary.&quot;</span>;</span><br><span class="line">        <span class="comment">//array contains two XYZ objects: the max and min coords of boundary</span></span><br><span class="line">        IList boundaryRect = opening.BoundaryRect;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//get the coordinate value of the min coordinate point</span></span><br><span class="line">        XYZ point = opening.BoundaryRect[<span class="number">0</span>];</span><br><span class="line">        message += <span class="string">&quot;\nMin coordinate point:(&quot;</span> + point.X + <span class="string">&quot;, &quot;</span></span><br><span class="line">                                + point.Y + <span class="string">&quot;, &quot;</span> + point.Z + <span class="string">&quot;)&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//get the coordinate value of the Max coordinate point</span></span><br><span class="line">        point = opening.BoundaryRect[<span class="number">1</span>];</span><br><span class="line">        message += <span class="string">&quot;\nMax coordinate point: (&quot;</span> + point.X + <span class="string">&quot;, &quot;</span></span><br><span class="line">                                + point.Y + <span class="string">&quot;, &quot;</span> + point.Z + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        message += <span class="string">&quot;\nThe opening doesn&#x27;t have a rectangular boundary.&quot;</span>;</span><br><span class="line">        <span class="comment">// Get curve number</span></span><br><span class="line">        <span class="built_in">int</span> curves = opening.BoundaryCurves.Size;</span><br><span class="line">        message += <span class="string">&quot;\nNumber of curves is : &quot;</span> + curves;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; curves; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Autodesk.Revit.DB.Curve curve = opening.BoundaryCurves.get_Item(i);</span><br><span class="line">            <span class="comment">// Get curve start point</span></span><br><span class="line">            message += <span class="string">&quot;\nCurve start point: &quot;</span> + XYZToString(curve.GetEndPoint(<span class="number">0</span>));</span><br><span class="line">            <span class="comment">// Get curve end point</span></span><br><span class="line">            message += <span class="string">&quot;; Curve end point: &quot;</span> + XYZToString(curve.GetEndPoint(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>,message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// output the point&#x27;s three coordinates</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">XYZToString</span>(<span class="params">XYZ point</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;(&quot;</span> + point.X + <span class="string">&quot;, &quot;</span> + point.Y + <span class="string">&quot;, &quot;</span> + point.Z + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="创建洞口"><a href="#创建洞口" class="headerlink" title="创建洞口"></a>创建洞口</h3><p>在Revit Platform API中，使用Document.NewOpening（）方法在项目中创建洞口。有四种方法重载可用于在不同的宿主元素中创建洞口：</p>
<p>代码区域11-7：NewOpening（）</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Create a new Opening in a beam, brace and column. </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Opening <span class="title">NewOpening</span>(<span class="params">Element famInstElement, CurveArray profile, eRefFace iFace</span>)</span>; </span><br></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Create a new Opening in a roof, floor and ceiling. </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Opening <span class="title">NewOpening</span>(<span class="params">Element hostElement, CurveArray profile, <span class="built_in">bool</span> bPerpendicularFace</span>)</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Create a new Opening Element. </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Opening <span class="title">NewOpening</span>(<span class="params">Level bottomLevel, Level topLevel, CurveArray  profile</span>)</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Create an opening in a straight wall or arc wall. </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Opening <span class="title">NewOpening</span>(<span class="params">Wall, XYZ pntStart, XYZ pntEnd</span>)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>在梁、支撑或柱中创建洞口-用于在族实例中创建洞口。iFace参数指示放置洞口的面。</li>
<li>创建屋顶、楼板或天花板洞口-用于在屋顶、楼板或天花板中创建洞口。</li>
<li>bPerceptiularFace参数指示洞口是垂直于面还是垂直于面。</li>
<li>如果该参数为true，则洞口垂直于主体图元面。请参见下图：</li>
</ul>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-EED350DF-2DD4-4562-998D-C020C739D6F8-low.png"></p>
<p>图40：垂直于主体元素切割的开口</p>
<ul>
<li>创建新洞口图元-用于在项目中创建竖井洞口。但是，请确保topLevel高于bottomLevel;否则将引发异常。</li>
<li>在直墙或弧形墙中创建洞口-用于在墙中创建矩形洞口。pntStart和pntEnd的坐标应该是可以塑造矩形的角坐标。例如，矩形的左下角和右上角。否则会引发异常。</li>
</ul>
<p>注意：使用“洞口”命令只能创建矩形墙洞口。要在墙上创建一些孔，请编辑墙轮廓而不是“洞口”命令。</p>
<h2 id="热属性"><a href="#热属性" class="headerlink" title="热属性"></a>热属性</h2><p>某些部件类型（如墙、楼板、天花板、屋顶和建筑地坪）具有计算和可设置的热属性，这些热属性由ThermalProperties类表示。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/ThermalProperties-76171.jpg"></p>
<p>hermalProperties类具有上面显示的值的属性。吸收率和粗糙度是可修改的，而传热系数、热阻和热质量是只读的。这些计算值的单位如下表所示。</p>
<table>
<thead>
<tr>
<th><strong>Property 属性</strong></th>
<th><strong>Unit 单位</strong></th>
</tr>
</thead>
<tbody><tr>
<td>HeatTransferCoefficient 导热系数</td>
<td>watts per meter-squared kelvin (W&#x2F;(m^2<em>K)</em></td>
</tr>
<tr>
<td>ThermalResistance 热阻</td>
<td>meter-squared kelvin per watt ((m^2K)&#x2F;Watt)</td>
</tr>
<tr>
<td>ThermalMass 热质量</td>
<td>kilogram feet-squared per second squared kelvin (kg ft^2&#x2F;(s^2 K))</td>
</tr>
</tbody></table>
<p>可以使用以下类型的ThermalProperties属性检索热属性：</p>
<ul>
<li>WallType </li>
<li>FloorType</li>
<li>CeilingType </li>
<li>RoofType </li>
<li>BuildingPadType</li>
</ul>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Revit%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%E4%BA%BA%E5%91%98%E6%8C%87%E5%8D%97/">Revit二次开发人员指南</a></div><div class="post-share"><div class="social-share" data-image="/images/4stars.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2024/12/28/%E4%BA%8C%E5%BC%80%E6%8C%87%E5%8D%97/09%E7%BC%96%E8%BE%91%E5%85%83%E7%B4%A0/" title="09编辑元素"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">09编辑元素</div></div><div class="info-2"><div class="info-item-1">编辑元素在Revit中，可以使用Revit Platform API移动、复制、旋转、对齐、删除、镜像、编组和排列一个元素或一组元素。在API中使用编辑功能与在Revit UI中使用命令类似。 Pages in this section 本节中的页面  Moving Elements 移动元素 Copying Elements 复制元素 Rotating elements 旋转元素 Aligning Elements 对齐元素 Mirroring Elements 镜像元素 Grouping Elements 对元素进行分组 Creating Arrays of Elements 创建元素数组 Deleting Elements 删除元素 Pinned Elements 固定元素  移动元素ElementTransformUtils类提供两个静态方法来将一个或多个元素从一个位置移动到另一个位置。 表19：移动方法    Member **Description **    MoveElement( Document, ElementId,...</div></div></div></a><a class="pagination-related" href="/2024/12/28/%E4%BA%8C%E5%BC%80%E6%8C%87%E5%8D%97/10%E8%A7%86%E5%9B%BE/" title="10视图"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">10视图</div></div><div class="info-2"><div class="info-item-1">视图视图是从 Revit 模型生成的图像，具有对文档中存储的数据的特权访问权限。它们可以是图形 （如计划） 或文本 （如计划）。每个项目文档都有一个或多个不同的视图。最后一个聚焦窗口是活动视图。 Autodesk.Revit.DB.View 类是 Revit 文档中所有视图类型的基类。Autodesk.Revit.UI.UIView 类表示 Revit 用户界面中的窗口视图。 在以下部分中，您将了解如何生成视图、Revit 支持的视图类型、每个视图的功能以及用户界面中视图窗口的可用功能。 Pages in this section 此部分中的页面  About views 关于视图 View Graphics 视图图形 View Types 视图类型 Revisions 修改 View Filters 视图筛选器 View Cropping 视图裁剪 Displaced Views 置换视图 UIView  关于视图Revit API...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2024/12/28/%E4%BA%8C%E5%BC%80%E6%8C%87%E5%8D%97/01%E5%BC%80%E5%A7%8B/" title="01开始"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-28</div><div class="info-item-2">01开始</div></div><div class="info-2"><div class="info-item-1">开始Revit 平台 API 可通过与 Microsoft .NET Framework 4.5.2 或 4.6 兼容的任何语言（如 Visual C# 或 Visual Basic .NET （VB.NET））进行完全访问。Visual C# 和 VB.NET 通常用于开发 Revit 平台 API 应用程序。但是，本手册的重点是使用 Visual C# 开发应用程序。 欢迎使用 Revit Platform API所有基于 Autodesk Revit 的产品都是参数化建筑信息模型 （BIM） 工具。这样的工具可以看作是用于构建 3D 模型的 CAD 程序，而不是一组单独的图纸文件。Autodesk Revit 建模是通过柱、墙、门和窗等真实世界的元素完成的。用户可以创建模型的视图，包括平面图、剖面图和详图索引。所有这些视图都是直接从 3D 物理模型生成的，因此在一个视图中所做的更改将自动传播到所有其他视图。此过程几乎消除了在模型中进行更改时更新多个图纸和细节的需要。 Autodesk Revit API 旨在反映与程序的图形用户界面相同的用户交互范例。因此，了解 API...</div></div></div></a><a class="pagination-related" href="/2024/12/28/%E4%BA%8C%E5%BC%80%E6%8C%87%E5%8D%97/03%E5%BA%94%E7%94%A8%E5%8F%8A%E6%96%87%E6%A1%A3/" title="03应用及文档"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-28</div><div class="info-item-2">03应用及文档</div></div><div class="info-2"><div class="info-item-1">Application及DocumentRevit 平台 API 中的顶级对象是Application和Document。这些类由 Application、UIApplication、Document 和 UIDocument 类表示。 Application对象是指单个 Revit 任务，提供对文档、选项和其他应用程序范围的数据和设置的访问。 Autodesk.Revit.UI.UIApplication - 提供对应用程序的 UI 级界面的访问，包括将 RibbonPanel 添加到用户界面的功能，以及在用户界面中获取活动文档的功能。 Autodesk.Revit.ApplicationServices.Application - 提供对所有其他应用程序级别属性的访问。 Document是表示建筑模型的单个 Revit 项目文件。Revit 可以打开多个项目，并为一个项目打开多个视图。 Autodesk.Revit.UI.UIDocument - 提供对文档的 UI...</div></div></div></a><a class="pagination-related" href="/2024/12/28/%E4%BA%8C%E5%BC%80%E6%8C%87%E5%8D%97/02%E6%8F%92%E4%BB%B6%E9%9B%86%E6%88%90/" title="02插件集成"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-28</div><div class="info-item-2">02插件集成</div></div><div class="info-2"><div class="info-item-1">插件集成开发人员通过创建和实现 External Commands 和 External Applications 来添加功能。Revit 使用 .addin 清单文件标识新命令和应用程序。外部命令显示在 Add-Ins 选项卡上的 External Tools 菜单按钮下。外部应用程序在 Revit 启动时调用，在 Revit 关闭时卸载。 本章重点介绍以下内容：  了解如何使用 External Commands 和 External Applications 添加功能。 如何访问 Revit 事件。 如何自定义 Revit UI。  概述Revit 平台 API 基于 Revit 应用程序功能。Revit 平台 API 由两个类库组成，这两个类库仅在 Revit 运行时工作。 RevitAPI.dll包含用于在数据库级别访问 Revit 的应用程序、文档、图元和参数的方法。它还包含 IExternalDBApplication 和相关接口。 RevitAPIUI.dll包含与 Revit 用户界面的操作和自定义相关的所有 API...</div></div></div></a><a class="pagination-related" href="/2024/12/28/%E4%BA%8C%E5%BC%80%E6%8C%87%E5%8D%97/04%E5%85%83%E7%B4%A0%E8%A6%81%E7%82%B9/" title="04元素要点"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-28</div><div class="info-item-2">04元素要点</div></div><div class="info-2"><div class="info-item-1">元素要点元素对应于单个建筑或绘图构件，例如门、墙或尺寸标注。此外，元素可以是门类型、视图或材质定义。 元素分类Revit 图元分为六组：模型、草图、视图、组、注释和信息。每个组都包含相关的元素及其相应的符号。 模型元素模型元素表示建筑项目中存在的物理项。“模型元素”组中的元素可以细分为以下元素： 族实例 - 族实例包含族实例对象。可以将族对象载入到项目中，也可以从族样板创建族对象。有关更多信息，请参阅系列实例。 主体图元 - 主体图元包含系统族对象，这些对象可以包含其他模型图元，例如墙、屋顶、天花板和楼板。有关主体图元的更多信息，请参见墙、楼板、屋顶和洞口。 结构元素-结构图元包含仅用于 Revit 结构特征的图元。有关 Structure Elements 的更多信息，请参见 Structural Engineering。 视图元素视图图元表示在 Revit 中查看其他对象并与其他对象交互的方式。有关更多信息，请参阅视图。 组元素组图元表示辅助图元，例如 Revit...</div></div></div></a><a class="pagination-related" href="/2024/12/28/%E4%BA%8C%E5%BC%80%E6%8C%87%E5%8D%97/05%E8%BF%87%E6%BB%A4/" title="05过滤"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-28</div><div class="info-item-2">05过滤</div></div><div class="info-2"><div class="info-item-1">Filtering 过滤Revit API提供了一种过滤和迭代Revit文档中图元的机制。这是获取一组相关元素（如文档中的所有墙或门）的最佳方法。过滤器也可以用来找到一个非常具体的元素集，如所有特定大小的梁。 获取通过指定过滤器的元素的基本步骤如下：  创建新的FilteredElementCollector 对它应用一个或多个过滤器 获取过滤后的元素或元素ID（使用以下几种方法之一）  下面的示例涵盖了在文档中筛选和迭代元素的基本步骤。 代码区域6-1：使用元素过滤获取文档中的所有墙实例 1234567891011121314// Find all Wall instances in the document by using category filterElementCategoryFilter filter = new ElementCategoryFilter(BuiltInCategory.OST_Walls);// Apply the filter to the elements in the active document// Use shortcut...</div></div></div></a><a class="pagination-related" href="/2024/12/28/%E4%BA%8C%E5%BC%80%E6%8C%87%E5%8D%97/07%E5%8F%82%E6%95%B0/" title="07参数"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-28</div><div class="info-item-2">07参数</div></div><div class="info-2"><div class="info-item-1">参数Revit提供了一种常规机制，为每个图元提供一组可编辑的参数。 在Revit UI中，某些图元参数在“图元属性”窗口中可见。以下各节介绍如何获取和使用内置参数、共享参数和全局参数。 在Revit Platform...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/images/4stars.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">funtim@gmail.com</div><div class="author-info-description">实践-认识-再实践-再认识</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">32</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/FunTim41"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/FunTim41" target="_blank" title="Github"><i class="fab fa-github" style="color: #FFFFFF;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A2%99%E3%80%81%E6%A5%BC%E6%9D%BF%E3%80%81%E5%A4%A9%E8%8A%B1%E6%9D%BF%E3%80%81%E5%B1%8B%E9%A1%B6%E5%92%8C%E6%B4%9E%E5%8F%A3"><span class="toc-number">1.</span> <span class="toc-text">墙、楼板、天花板、屋顶和洞口</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A2%99"><span class="toc-number">1.1.</span> <span class="toc-text">墙</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A5%BC%E6%9D%BF%E3%80%81%E5%A4%A9%E8%8A%B1%E6%9D%BF%E5%92%8C%E5%9F%BA%E7%A1%80"><span class="toc-number">1.2.</span> <span class="toc-text">楼板、天花板和基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E6%9D%BF"><span class="toc-number">1.2.1.</span> <span class="toc-text">修改板</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%8B%E9%A1%B6"><span class="toc-number">1.3.</span> <span class="toc-text">屋顶</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%95%E5%A2%99"><span class="toc-number">1.4.</span> <span class="toc-text">幕墙</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E5%85%83%E7%B4%A0"><span class="toc-number">1.5.</span> <span class="toc-text">其他元素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%8D%E5%90%88%E7%BB%93%E6%9E%84"><span class="toc-number">1.6.</span> <span class="toc-text">复合结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%90%E8%B4%A8"><span class="toc-number">1.6.1.</span> <span class="toc-text">材质</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B4%9E%E5%8F%A3"><span class="toc-number">1.7.</span> <span class="toc-text">洞口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%84%E5%B1%9E%E6%80%A7"><span class="toc-number">1.7.1.</span> <span class="toc-text">常规属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E6%B4%9E%E5%8F%A3"><span class="toc-number">1.7.2.</span> <span class="toc-text">创建洞口</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%83%AD%E5%B1%9E%E6%80%A7"><span class="toc-number">1.8.</span> <span class="toc-text">热属性</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/28/%E4%BA%8C%E5%BC%80%E6%8C%87%E5%8D%97/33%E5%91%BD%E4%BB%A4/" title="33命令">33命令</a><time datetime="2024-12-28T13:19:57.729Z" title="更新于 2024-12-28 21:19:57">2024-12-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/28/%E4%BA%8C%E5%BC%80%E6%8C%87%E5%8D%97/32%E5%8A%A8%E6%80%81%E6%A8%A1%E5%9E%8B%E6%9B%B4%E6%96%B0/" title="32动态模型更新">32动态模型更新</a><time datetime="2024-12-28T13:19:57.729Z" title="更新于 2024-12-28 21:19:57">2024-12-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/28/%E4%BA%8C%E5%BC%80%E6%8C%87%E5%8D%97/31%E5%8F%AF%E5%81%9C%E9%9D%A0%E5%AF%B9%E8%AF%9D%E6%A1%86%E7%AA%97%E6%A0%BC/" title="31可停靠对话框窗格">31可停靠对话框窗格</a><time datetime="2024-12-28T13:19:57.728Z" title="更新于 2024-12-28 21:19:57">2024-12-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/28/%E4%BA%8C%E5%BC%80%E6%8C%87%E5%8D%97/30%E5%A4%96%E9%83%A8%E4%BA%8B%E4%BB%B6/" title="30外部事件">30外部事件</a><time datetime="2024-12-28T13:19:57.727Z" title="更新于 2024-12-28 21:19:57">2024-12-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/28/%E4%BA%8C%E5%BC%80%E6%8C%87%E5%8D%97/29%E4%BA%8B%E4%BB%B6/" title="29事件">29事件</a><time datetime="2024-12-28T13:19:57.726Z" title="更新于 2024-12-28 21:19:57">2024-12-28</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/images/topback.jpg);"><div id="footer-wrap"><div class="copyright">&copy;2024 By funtim@gmail.com</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">学而不思则罔，思而不学则殆。</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>(() => {
  const panguFn = () => {
    if (typeof pangu === 'object') pangu.autoSpacingPage()
    else {
      btf.getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
        .then(() => {
          pangu.autoSpacingPage()
        })
    }
  }

  const panguInit = () => {
    if (false){
      GLOBAL_CONFIG_SITE.isPost && panguFn()
    } else {
      panguFn()
    }
  }

  btf.addGlobalFn('pjaxComplete', panguInit, 'pangu')
  document.addEventListener('DOMContentLoaded', panguInit)
})()</script><div class="js-pjax"></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>