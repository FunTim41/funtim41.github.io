<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>26结构工程 | funtim的博客</title><meta name="author" content="funtim41@gmail.com"><meta name="copyright" content="funtim41@gmail.com"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="结构工程以下各节介绍了仅与Revit的结构工程功能相关的API功能：  结构模型元素-讨论仅与Revit的结构工程功能相关的特定元素及其属性。  AnalyticalModel -讨论与分析模型相关的类，如AnalyticalModel、RigidLink和AnalyticalModelSupport。  AnalyticalLink -讨论在分析梁和柱之间创建新的分析链接。  荷载-讨论荷载设置">
<meta property="og:type" content="article">
<meta property="og:title" content="26结构工程">
<meta property="og:url" content="https://funtim41.github.io/2024/12/24/%E4%BA%8C%E5%BC%80%E6%8C%87%E5%8D%97/26%E7%BB%93%E6%9E%84%E5%B7%A5%E7%A8%8B/">
<meta property="og:site_name" content="funtim的博客">
<meta property="og:description" content="结构工程以下各节介绍了仅与Revit的结构工程功能相关的API功能：  结构模型元素-讨论仅与Revit的结构工程功能相关的特定元素及其属性。  AnalyticalModel -讨论与分析模型相关的类，如AnalyticalModel、RigidLink和AnalyticalModelSupport。  AnalyticalLink -讨论在分析梁和柱之间创建新的分析链接。  荷载-讨论荷载设置">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://funtim41.github.io/images/4stars.png">
<meta property="article:published_time" content="2024-12-24T10:37:56.000Z">
<meta property="article:modified_time" content="2024-12-29T12:52:26.154Z">
<meta property="article:author" content="funtim41@gmail.com">
<meta property="article:tag" content="Revit">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://funtim41.github.io/images/4stars.png"><link rel="shortcut icon" href="/images/OIP.jfif"><link rel="canonical" href="https://funtim41.github.io/2024/12/24/%E4%BA%8C%E5%BC%80%E6%8C%87%E5%8D%97/26%E7%BB%93%E6%9E%84%E5%B7%A5%E7%A8%8B/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: funtim41@gmail.com","link":"链接: ","source":"来源: funtim的博客","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'null',
  Snackbar: {"chs_to_cht":"已切换为繁体中文","cht_to_chs":"已切换为简体中文","day_to_night":"已切换为深色模式","night_to_day":"已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: true,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '26结构工程',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  isShuoshuo: false
}</script><link rel="stylesheet" href="/css/bar.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background: Color(#995a82);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/images/4stars.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">53</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">3</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Timeline</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/Links/"><i class="fa-fw fas fa-link"></i><span> Links</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/images/topback.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/images/OIP.jfif" alt="Logo"><span class="site-name">funtim的博客</span></a><a class="nav-page-title" href="/"><span class="site-name">26结构工程</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Timeline</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/Links/"><i class="fa-fw fas fa-link"></i><span> Links</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">26结构工程</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-12-24T10:37:56.000Z" title="发表于 2024-12-24 18:37:56">2024-12-24</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-12-29T12:52:26.154Z" title="更新于 2024-12-29 20:52:26">2024-12-29</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Revit%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%E4%BA%BA%E5%91%98%E6%8C%87%E5%8D%97/">Revit二次开发人员指南</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="结构工程"><a href="#结构工程" class="headerlink" title="结构工程"></a><a target="_blank" rel="noopener" href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_Discipline_Specific_Functionality_Structural_Engineering_html">结构工程</a></h1><p>以下各节介绍了仅与Revit的结构工程功能相关的API功能：</p>
<ul>
<li><p>结构模型元素-讨论仅与Revit的结构工程功能相关的特定元素及其属性。</p>
</li>
<li><p>AnalyticalModel -讨论与分析模型相关的类，如AnalyticalModel、RigidLink和AnalyticalModelSupport。</p>
</li>
<li><p>AnalyticalLink -讨论在分析梁和柱之间创建新的分析链接。</p>
</li>
<li><p>荷载-讨论荷载设置和三种荷载。</p>
</li>
</ul>
<p>您的分析链接-为希望将Revit链接到某些Structural Analysis应用程序的API用户提供建议。</p>
<p>本章包含一些高级主题。如果您不熟悉Revit Platform API，请先阅读基本部分，如“入门”、“元素要素”、“参数”等。</p>
<ul>
<li>本节中的主题<ul>
<li>结构模型元素</li>
<li>分析模型<br>在结构工程中，分析模型是结构物理模型的工程描述。</li>
<li>荷载<br>以下部分确定荷载设置并讨论荷载限制指南。</li>
<li>Analysis Link分析链接</li>
<li>Analytical Links</li>
</ul>
</li>
</ul>
<h2 id="结构模型元素"><a href="#结构模型元素" class="headerlink" title="结构模型元素"></a>结构模型元素</h2><p>结构模型元素实际上是支撑结构的元素，如柱、钢筋、桁架等。以下部分介绍如何操作这些元素。</p>
<p>本节中包含的模型元素特定于Revit的结构工程功能。有关其他结构元素类的详细信息，请参见“墙、楼板、屋顶和洞口”和“族”中的相应部分。</p>
<p>本节中的主题</p>
<ul>
<li>结构柱、梁和支撑</li>
<li>桁架</li>
<li>加强<br>Revit API提供了用于管理有效主体（如混凝土柱、梁、墙、基础和结构楼板）中的钢筋（如钢筋、钢筋或钢筋网）的类。</li>
<li>边界条件</li>
<li>板</li>
</ul>
<h3 id="结构柱、梁和支撑"><a href="#结构柱、梁和支撑" class="headerlink" title="结构柱、梁和支撑"></a>结构柱、梁和支撑</h3><p><strong>结构柱、梁和支撑</strong></p>
<p>结构柱、梁和支撑元素都由FamilyInstance类表示。它们由StructuralType属性区分。</p>
<p>代码区域29-1：柱、梁和支撑的区别</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetStructuralType</span>(<span class="params">FamilyInstance familyInstance</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> message = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">switch</span> (familyInstance.StructuralType)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> StructuralType.Beam:</span><br><span class="line">            message = <span class="string">&quot;FamilyInstance is a beam.&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> StructuralType.Brace:</span><br><span class="line">            message = <span class="string">&quot;FamilyInstance is a brace.&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> StructuralType.Column:</span><br><span class="line">            message = <span class="string">&quot;FamilyInstance is a column.&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> StructuralType.Footing:</span><br><span class="line">            message = <span class="string">&quot;FamilyInstance is a footing.&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="literal">default</span>:</span><br><span class="line">            message = <span class="string">&quot;FamilyInstance is non-structural or unknown framing.&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>,message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以使用类别过滤出与结构柱、梁和支撑对应的FamilySymbol对象。结构梁和支撑的类别为BuiltInCategory.OST_StructuralFraming。结构柱的类别为BuiltInCategory.OST_StructuralColumns。</p>
<p>代码区域29-2：使用BuiltInCategory.OST_StructuralFraming</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetBeamAndColumnSymbols</span>(<span class="params">Document document</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    List&lt;FamilySymbol&gt; columnTypes = <span class="keyword">new</span> List&lt;FamilySymbol&gt;();</span><br><span class="line">    List&lt;FamilySymbol&gt; framingTypes = <span class="keyword">new</span> List&lt;FamilySymbol&gt;();</span><br><span class="line">    FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">    ICollection&lt;Element&gt; elements = collector.OfClass(<span class="keyword">typeof</span>(Family)).ToElements();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">foreach</span>(Element element <span class="keyword">in</span> elements)</span><br><span class="line">    &#123;</span><br><span class="line">        Family family = element <span class="keyword">as</span> Family;</span><br><span class="line">        Category category = family.FamilyCategory;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != category)</span><br><span class="line">        &#123;</span><br><span class="line">            ISet&lt;ElementId&gt; familySymbolIds = family.GetFamilySymbolIds();</span><br><span class="line">            <span class="keyword">if</span> ((<span class="built_in">int</span>)BuiltInCategory.OST_StructuralColumns == category.Id.IntegerValue)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">foreach</span> (ElementId id <span class="keyword">in</span> familySymbolIds)</span><br><span class="line">                &#123;</span><br><span class="line">                    FamilySymbol symbol = family.Document.GetElement(id) <span class="keyword">as</span> FamilySymbol;</span><br><span class="line">                    columnTypes.Add(symbol);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((<span class="built_in">int</span>)BuiltInCategory.OST_StructuralFraming == category.Id.IntegerValue)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">foreach</span> (ElementId id <span class="keyword">in</span> familySymbolIds)</span><br><span class="line">                &#123;</span><br><span class="line">                    FamilySymbol symbol = family.Document.GetElement(id) <span class="keyword">as</span> FamilySymbol;</span><br><span class="line">                    framingTypes.Add(symbol);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> message = <span class="string">&quot;Column Types: &quot;</span>;</span><br><span class="line">    <span class="keyword">foreach</span> (FamilySymbol familySymbol <span class="keyword">in</span> columnTypes)</span><br><span class="line">    &#123;</span><br><span class="line">        message += <span class="string">&quot;\n&quot;</span> + familySymbol.Name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>,message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以使用FamilyInstance.ExtensionUtility属性获取和设置梁缩进属性。如果此属性返回null，则无法修改梁缩进。</p>
<p><strong>BeamSystem</strong></p>
<p>BeamSystem提供对梁系统的完全访问和编辑能力。可以获取和设置其所有属性，例如BeamSystemType、BeamType、Direction和Level。方向不限于一条边。它可以设置为与BeamSystem在同一平面上的任何XYZ坐标。</p>
<p>注意：在UI中或通过API更改了Elevation属性后，不能更改StructuralBeam AnalyticalModel。在下图中，梁系统高程更改为10英尺后，分析模型线仍保留在原始位置。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/CHS/Revit-API/images/GUID-1A4BF557-4296-4FE8-BCA3-CD3E1520BA7A.png"></p>
<p>图156：改变梁系统标高</p>
<h3 id="桁架"><a href="#桁架" class="headerlink" title="桁架"></a>桁架</h3><p><strong>桁架</strong></p>
<p>桁架类表示Revit中的所有桁架类型。TrussType属性指示桁架的类型。</p>
<p>代码区域29-7：在两个柱上创建桁架</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Truss <span class="title">CreateTruss</span>(<span class="params">Autodesk.Revit.DB.Document document, FamilyInstance column1, FamilyInstance column2</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Truss truss = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">using</span> (Transaction transaction = <span class="keyword">new</span> Transaction(document, <span class="string">&quot;Add Truss&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (transaction.Start() == TransactionStatus.Started)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//sketchPlane</span></span><br><span class="line">            XYZ origin = <span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            XYZ xDirection = <span class="keyword">new</span> XYZ(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            XYZ yDirection = <span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">            XYZ zDirection = <span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">            Plane plane = Plane.Create(<span class="keyword">new</span> Frame(origin, xDirection, yDirection, zDirection));</span><br><span class="line">            SketchPlane sketchPlane = SketchPlane.Create (document, plane);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//new base Line - use line that spans two selected columns</span></span><br><span class="line">            AnalyticalModel frame1 = column1.GetAnalyticalModel() <span class="keyword">as</span> AnalyticalModel;</span><br><span class="line">            XYZ centerPoint1 = (frame1.GetCurve() <span class="keyword">as</span> Line).GetEndPoint(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            AnalyticalModel frame2 = column2.GetAnalyticalModel() <span class="keyword">as</span> AnalyticalModel;</span><br><span class="line">            XYZ centerPoint2 = (frame2.GetCurve() <span class="keyword">as</span> Line).GetEndPoint(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            XYZ startPoint = <span class="keyword">new</span> XYZ(centerPoint1.X, centerPoint1.Y, <span class="number">0</span>);</span><br><span class="line">            XYZ endPoint = <span class="keyword">new</span> XYZ(centerPoint2.X, centerPoint2.Y, <span class="number">0</span>);</span><br><span class="line">            Autodesk.Revit.DB.Line baseLine = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                baseLine = Line.CreateBound(startPoint, endPoint);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (System.ArgumentException)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Selected columns are too close to create truss.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// use the active view for where the truss&#x27;s tag will be placed; View used in</span></span><br><span class="line">            <span class="comment">// NewTruss should be plan or elevation view parallel to the truss&#x27;s base line </span></span><br><span class="line">            Autodesk.Revit.DB.View view = document.ActiveView;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Get a truss type for the truss</span></span><br><span class="line">            FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">            collector.OfClass(<span class="keyword">typeof</span>(FamilySymbol));</span><br><span class="line">            collector.OfCategory(BuiltInCategory.OST_Truss);</span><br><span class="line"></span><br><span class="line">            TrussType trussType = collector.FirstElement() <span class="keyword">as</span> TrussType;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="literal">null</span> != trussType)</span><br><span class="line">            &#123;</span><br><span class="line">                truss = Truss.Create(document, trussType.Id, sketchPlane.Id, baseLine);</span><br><span class="line">                transaction.Commit();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                transaction.RollBack();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;No truss types found in document.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">return</span> truss;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="加强"><a href="#加强" class="headerlink" title="加强"></a>加强</h3><p>Revit API提供了用于管理有效主体（如混凝土柱、梁、墙、基础和结构楼板）中的钢筋（如钢筋、钢筋或钢筋网）的类。</p>
<p>本节中的主题</p>
<ul>
<li>Rebar 钢筋<br>Rebar类表示用于加强适当元素（如混凝土梁、柱、板或基础）的钢筋。</li>
<li>钢筋连接器<br>钢筋连接器用于连接相邻钢筋。</li>
<li>区域和路径钢筋<br>Revit API提供了表示Revit结构要素中的面积钢筋和路径钢筋的类。</li>
<li>织物增强<br>钢筋网是一层由焊接钢丝网制成的钢筋网，并置于混凝土板或墙内。</li>
<li>钢筋容器<br>钢筋容器是表示一个主体中钢筋聚合的元素。此元素只能通过API创建。</li>
<li>钢筋设置<br>有关模型中钢筋的几个设置在文档级别进行控制，并通过文档的ReinfocementSettings类进行访问。</li>
<li>钢筋舍入<br>钢筋修圆是编制施工图的重要内容。钢筋长度公差小于行业或当地标准通常被视为不适用于指定钢筋。</li>
</ul>
<h4 id="钢筋"><a href="#钢筋" class="headerlink" title="钢筋"></a>钢筋</h4><p>Rebar 类表示用于加固合适元素（如混凝土梁、柱、板或基础）的钢筋。</p>
<p> <strong>创建钢筋</strong></p>
<p>您可以使用以下三种静态 Rebar 方法之一创建钢筋对象。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Rebar Rebar.CreateFromCurves(</span><br><span class="line">        Document doc,</span><br><span class="line">        RebarStyle style,</span><br><span class="line">        RebarBarType rebarType,</span><br><span class="line">        RebarHookType startHook,</span><br><span class="line">        RebarHookType endHook,</span><br><span class="line">        Element host,</span><br><span class="line">        XYZ norm,</span><br><span class="line">        IList&lt;Curve&gt; curves,</span><br><span class="line">        RebarHookOrientation startHookOrient,</span><br><span class="line">        RebarHookOrientation endHookOrient,</span><br><span class="line">        <span class="built_in">bool</span> useExistingShapeIfPossible,</span><br><span class="line">        <span class="built_in">bool</span> createNewShape</span><br><span class="line">);<span class="comment">//在项目中创建 Rebar 元素的新实例。所有曲线都必须属于由法线和原点定义的平面。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Rebar Rebar.CreateFromRebarShape(</span><br><span class="line">        Document doc,</span><br><span class="line">        RebarShape rebarShape,</span><br><span class="line">        RebarBarType rebarType,</span><br><span class="line">        Element host,</span><br><span class="line">        XYZ origin,</span><br><span class="line">        XYZ xVec,</span><br><span class="line">        XYZ yVec</span><br><span class="line">);<span class="comment">//创建一个新的 Rebar 作为 RebarShape 的实例。该实例将具有 RebarShape 中的默认形状参数，其位置基于形状定义中形状的边界框。在计算形状的边界框之前，将从形状中删除钩子。如果在文档中可以找到合适的钩子，它们将被任意分配。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Rebar Rebar.CreateFromCurvesAndShape(</span><br><span class="line">        Document doc,</span><br><span class="line">        RebarShape rebarShape,</span><br><span class="line">        RebarBarType rebarType,</span><br><span class="line">        RebarHookType startHook,</span><br><span class="line">        RebarHookType endHook,  </span><br><span class="line">        Element host,</span><br><span class="line">        XYZ norm,</span><br><span class="line">        IList&lt;Curve&gt; curves,</span><br><span class="line">        RebarHookOrientation startHookOrient,</span><br><span class="line">        RebarHookOrientation endHookOrient</span><br><span class="line">);<span class="comment">//在项目中创建 Rebar 元素的新实例。该实例将具有 RebarShape 中的默认形状参数。所有曲线都必须属于由法线和原点定义的平面。</span></span><br></pre></td></tr></table></figure>

<p>第一个版本从描述钢筋的曲线数组创建钢筋，而第二个版本根据 RebarShape 和位置创建 Rebar 对象。第三个版本从曲线数组中基于 RebarShape 创建钢筋。</p>
<p>使用 CreateFromCurves（） 或 CreateFromCurvesAndShape（） 方法时，参数 RebarBarType 和 RebarHookType 在文档的 RebarBarTypes 和 RebarHookTypes 属性中可用。</p>
<p>以下代码说明了如何创建具有特定布局的 Rebar。</p>
<p>代码区域 29-8：创建具有特定布局的钢筋</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Rebar <span class="title">CreateRebar</span>(<span class="params">Autodesk.Revit.DB.Document document, FamilyInstance column, RebarBarType barType, RebarHookType hookType</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Define the rebar geometry information - Line rebar</span></span><br><span class="line">    LocationPoint location = column.Location <span class="keyword">as</span> LocationPoint;</span><br><span class="line">    XYZ origin = location.Point;</span><br><span class="line">    XYZ normal = <span class="keyword">new</span> XYZ(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// create rebar 9&#x27; long</span></span><br><span class="line">    XYZ rebarLineEnd = <span class="keyword">new</span> XYZ(origin.X, origin.Y, origin.Z + <span class="number">9</span>);</span><br><span class="line">    Line rebarLine = Line.CreateBound(origin, rebarLineEnd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create the line rebar</span></span><br><span class="line">    IList&lt;Curve&gt; curves = <span class="keyword">new</span> List&lt;Curve&gt;();</span><br><span class="line">    curves.Add(rebarLine);</span><br><span class="line"></span><br><span class="line">    Rebar rebar = Rebar.CreateFromCurves(document, Autodesk.Revit.DB.Structure.RebarStyle.Standard, barType, hookType, hookType,</span><br><span class="line">                        column, origin, curves, RebarHookOrientation.Right, RebarHookOrientation.Left, <span class="literal">true</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> != rebar)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// set specific layout for new rebar as fixed number, with 10 bars, distribution path length of 1.5&#x27;</span></span><br><span class="line">        <span class="comment">// with bars of the bar set on the same side of the rebar plane as indicated by normal</span></span><br><span class="line">        <span class="comment">// and both first and last bar in the set are shown</span></span><br><span class="line">        rebar.GetShapeDrivenAccessor().SetLayoutAsFixedNumber(<span class="number">10</span>, <span class="number">1.5</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rebar;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>有关创建钢筋元素的更多示例，请参见 Revit SDK 附带的钢筋和 NewRebar 示例应用程序。</p>
<p>下表列出了 Parameter REBAR_ELEM_LAYOUT_RULE的整数值：</p>
<p>表 59：钢筋布局规则</p>
<table>
<thead>
<tr>
<th><strong>Value 值</strong></th>
<th><strong>0</strong></th>
<th><strong>1</strong></th>
<th><strong>2</strong></th>
<th><strong>3</strong></th>
<th><strong>4</strong></th>
</tr>
</thead>
<tbody><tr>
<td>描述</td>
<td>None</td>
<td>固定数量</td>
<td>最大间距</td>
<td>带间距的数字</td>
<td>最小净间距</td>
</tr>
</tbody></table>
<p>The Rebar.GetShapeDrivenAccessor().ScaleToBox（） 方法提供了一种同时设置所有形状参数的方法。该行为类似于放置 Rebar 的 UI。</p>
<p><strong>RebarHostData 和 RebarCoverType</strong></p>
<p>明确保护层与有效钢筋主体的各个面关联。可以通过Autodesk.Revit.Elements.RebarHostData对象访问主体的保护层设置。通过参数提供了一种更简单、功能更弱的访问相同设置的机制。</p>
<p>Cover 由命名为偏移的距离定义，建模为 Autodesk.Revit.DB.Structure.RebarCoverType 的元素。</p>
<p><strong>编号</strong></p>
<p>钢筋是可以通过Revit API控制其编号的元素类别之一。NumberingSchema和NumberingSchemaType类可用于定义钢筋元素的组织方式，以便对其进行编号&#x2F;标记。每个NumberingSchema控制一种特定类型的元素的编号。NumberingSchema的元素也是元素，并且每个Revit文档中的每种类型始终只有一个。所有内置编号架构的可用类型都在NumberingSchemaTypes类中枚举。</p>
<p>属于特定模式（例如NumberingSchemaTypes.StructuralNumberingSchemas.Rebar）的元素（例如Rebar）按顺序组织和编号。序列是共享相同编号分区的元素的集合，编号分区由它们各自的分区参数（NUMBER_PARTITION_PARAM）值定义。编号序列必须至少包含一个元素。换句话说，一旦存在至少一个元素，其分区参数具有不同于其他元素（在相同的编号模式中）的值，则建立序列。如果最后一个元素被删除（删除或移动到不同的序列），那么空序列将不再存在。</p>
<p>元素在创建时（基于当时的编号分区值）被分配给序列，方法是显式修改元素的Partition参数或使用AssignElementsToSequence（）方法。AssignElementsToSequence（）方法优于显式更改Partition参数，因为该方法会立即将更改应用于序列和元素编号，而更改的参数仅在当前事务关闭后生效。</p>
<p>除了直接或间接更改元素的Partition参数外，还可以使用NumberingSchema类的方法重新组织编号序列。MoveSequence（）方法将现有序列的所有元素移动到架构中尚不存在的新序列，从而有效地重命名所有受影响元素上的Partition参数。方法的作用是：在应用匹配策略的同时，从一个序列中删除所有元素，并将它们追加到另一个现有序列的元素中。方法MergeSequences（）接受所有指定序列的元素，并将它们全部移动到新创建的序列中。所有合并的元素将重新编号，并根据需要根据匹配算法进行匹配。</p>
<p>下面的示例使用MoveSequence（）方法在两个编号序列中交换Rebar的编号。</p>
<p>代码区域：交换号码</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> This method uses multiple moving operations to swap numbers</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> for Rebars in two numbering sequences. The sequences are</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> identified by the names of two numbering partitions.</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;document&quot;&gt;</span>Document to modify<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;part1&quot;&gt;</span>Name of the partition of one numbering sequence<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;part2&quot;&gt;</span>Name of the partition of another numbering sequence<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">SwapNumberingSequences</span>(<span class="params">Document document, <span class="built_in">string</span> part1, <span class="built_in">string</span> part2</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Obtain a schema object for a particular kind of elements </span></span><br><span class="line">    NumberingSchema schema = NumberingSchema.GetNumberingSchema(document,NumberingSchemaTypes.StructuralNumberingSchemas.Rebar);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> (Transaction transaction = <span class="keyword">new</span> Transaction(document))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Changes to numbering sequences must be made inside a transaction</span></span><br><span class="line">        transaction.Start(<span class="string">&quot;Swap Numbering Sequences&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We will use a temporary partition for the swap operation,</span></span><br><span class="line">        <span class="comment">// for the move operation only works if the target partition </span></span><br><span class="line">        <span class="comment">// does not exist yet in the same numbering schema.</span></span><br><span class="line">        <span class="comment">// (We assume this TEMPORARY partition does not exist.)</span></span><br><span class="line">        <span class="built_in">string</span> tempPartition = <span class="string">&quot;TEMPORARY&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Step 1</span></span><br><span class="line">        <span class="comment">// First we move all elements from one sequence into </span></span><br><span class="line">        <span class="comment">// a partition we know does not exist. This action will</span></span><br><span class="line">        <span class="comment">// create the temporary partition and remove the original</span></span><br><span class="line">        <span class="comment">// one (part1).</span></span><br><span class="line">        schema.MoveSequence(part1, tempPartition);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Step 2</span></span><br><span class="line">        <span class="comment">// With the sequence in partition &#x27;part1&#x27; removed</span></span><br><span class="line">        <span class="comment">// we can now move elements from the second sequence to it.</span></span><br><span class="line">        <span class="comment">// This action will re-create a sequence in partition &#x27;part1&#x27;</span></span><br><span class="line">        <span class="comment">// and remove the sequence in partition &#x27;part2&#x27;</span></span><br><span class="line">        schema.MoveSequence(part2, part1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Step 3</span></span><br><span class="line">        <span class="comment">// Finally, we can move elements &#x27;parked&#x27; in the temporary</span></span><br><span class="line">        <span class="comment">// sequence to partition &#x27;part2&#x27;, for that partition was</span></span><br><span class="line">        <span class="comment">// removed in the previous step and thus can now be created</span></span><br><span class="line">        <span class="comment">// again. The temporary partition will be automatically </span></span><br><span class="line">        <span class="comment">// removed upon completing this step.</span></span><br><span class="line">        schema.MoveSequence(tempPartition, part2);</span><br><span class="line"></span><br><span class="line">        transaction.Commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不同序列中的元素独立地编号，这意味着即使元素不同，在两个序列中也可能存在具有相同编号的元素。同样，在两个或更多个序列中可能存在完全相同的元素，其具有不同的数字。然而，在每个编号序列内，任何两个相同的元素将总是具有相同的编号，而不同的元件在编号序列内将永远不具有相同的编号。</p>
<p>创建后，Escape元素始终自动编号。每个新元素将获得一个递增的更大的数字。但是，与同一序列中的现有元素匹配的新元素将被分配相同的编号。元素将尽可能长时间地保留其分配的编号。这意味着，例如，如果删除了以前创建的某些钢筋图元，则所有剩余图元（在相同编号序列中）将保留其编号，这可能会导致相应编号序列中出现间隙。对于不需要空位的序列，可以通过调用RemoveGaps（）来移除空位。</p>
<p>下面的示例通过删除编号序列中的任何剩余间隙并设置每个序列的起始编号以使序列中的编号不重叠来合并钢筋元素上的编号。</p>
<p>代码区域：Consolidate Rebar Numbers</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ConsolidateRebarNumbers</span>(<span class="params">Document document</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Obtain a schema object for a particular kind of elements </span></span><br><span class="line">    NumberingSchema schema = NumberingSchema.GetNumberingSchema(document,NumberingSchemaTypes.StructuralNumberingSchemas.Rebar);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Collect the names of partitions of all the numbering sequences currently contained in the schema</span></span><br><span class="line">    IList&lt;<span class="built_in">string</span>&gt; sequences = schema.GetNumberingSequences();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> (Transaction transaction = <span class="keyword">new</span> Transaction(document))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Changes to numbers must be made inside a transaction</span></span><br><span class="line">        transaction.Start(<span class="string">&quot;Consolidate Rebar Numbers&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// First we make sure numbers in all sequences are consecutive</span></span><br><span class="line">        <span class="comment">// by removing possible gaps in numbers. Note: RemoveGaps does</span></span><br><span class="line">        <span class="comment">// nothing for a sequence where there are no gaps present.</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// We also want to find what the maximum range of numbers is</span></span><br><span class="line">        <span class="comment">// of all the sequences (the one the widest span of used numbers)</span></span><br><span class="line">        <span class="built_in">int</span> maxRange = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">foreach</span> (<span class="built_in">string</span> name <span class="keyword">in</span> sequences)</span><br><span class="line">        &#123;</span><br><span class="line">            schema.RemoveGaps(name);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Here we use First() from the Linq extension.</span></span><br><span class="line">            <span class="comment">// There is always at least one range in every sequence,</span></span><br><span class="line">            <span class="comment">// and after gaps are closed there is exactly one range.</span></span><br><span class="line">            IntegerRange range = schema.GetNumbers(name).First();  </span><br><span class="line">            <span class="built_in">int</span> rangeSpan = <span class="number">1</span> + (range.High - range.Low);</span><br><span class="line">            <span class="keyword">if</span> (rangeSpan &gt; maxRange)</span><br><span class="line">            &#123;</span><br><span class="line">                maxRange = rangeSpan;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Next we give sequences different start numbers</span></span><br><span class="line">        <span class="comment">// starting with 100 and then stepping by at least</span></span><br><span class="line">        <span class="comment">// the maximum range we found in the previous step</span></span><br><span class="line">        <span class="built_in">int</span> startNumber = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We round the range up to the closest 100</span></span><br><span class="line">        <span class="built_in">int</span> step = <span class="number">100</span> * (<span class="built_in">int</span>)((maxRange + <span class="number">99</span>) / <span class="number">100.0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">foreach</span> (<span class="built_in">string</span> name <span class="keyword">in</span> sequences)</span><br><span class="line">        &#123;</span><br><span class="line">            schema.ShiftNumbers(name, startNumber);</span><br><span class="line">            startNumber += step;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        transaction.Commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>数字被存储为每个编号元素上的编号参数的值。通过查询NumberingSchema.NumberingParameterId属性获取参数的ID。可以通过查询相应编号元素的参数来获得编号的值。该值是只读的，因此无法设置;它始终根据编号分区中元素的关系以及每个元素编号顺序中的匹配策略计算。</p>
<p>尽管编号总是自动分配给模式的所有元素，但ChangeNumber（）方法为程序员提供了一种方法，只要新编号在编号序列中是唯一的，就可以显式地覆盖特定编号。调用者指定一个要更改的数字和一个要应用的新值，前提是该值在同一编号序列中还不存在。</p>
<p><strong>分布类型</strong></p>
<p>Rebar.DistributionType属性可用于修改钢筋集的类型。钢筋集可以是“均匀”或“可变长度”，对于均匀分布类型：所有钢筋参数与集中的第一个钢筋相同。对于可变长度分布类型：考虑到集合中第一个钢筋的约束，钢筋参数可以变化（主要是长度）。</p>
<p>Rebar.GetParameterValueAtIndex() 方法的作用是：获取位于指定索引处的条形图的参数值。仅接受0和NumberOfBarPositions-1之间的值。如果DistributionType为Uniform，则无论索引如何，返回的ParameterValue都相同。如果DistributionType为VaryingLength，则返回的ParameterValue在给定索引处计算。</p>
<h3 id="边界条件"><a href="#边界条件" class="headerlink" title="边界条件"></a>边界条件</h3><p><strong>边界条件</strong></p>
<p>有三种类型的边界条件：</p>
<ul>
<li>Point 点</li>
<li>Curve 曲线</li>
<li>Area 区域</li>
</ul>
<p>使用以下代码检索类型和相关的几何信息：</p>
<p>代码区域29-9：获取边界条件类型和几何形状</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetInfo_BoundaryConditions</span>(<span class="params">BoundaryConditions boundaryConditions</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> message = <span class="string">&quot;BoundaryConditions : &quot;</span>;</span><br><span class="line"></span><br><span class="line">    boundaryConditions.GetBoundaryConditionsType();</span><br><span class="line">    <span class="keyword">switch</span> (boundaryConditions.GetBoundaryConditionsType())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> BoundaryConditionsType.Point:</span><br><span class="line">            XYZ point = boundaryConditions.Point;</span><br><span class="line">            message += <span class="string">&quot;\nThis BoundaryConditions is a Point Boundary Conditions.&quot;</span>;</span><br><span class="line">            message += <span class="string">&quot;\nLocation point: (&quot;</span> + point.X + <span class="string">&quot;, &quot;</span></span><br><span class="line">                        + point.Y + <span class="string">&quot;, &quot;</span> + point.Z + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> BoundaryConditionsType.Line:</span><br><span class="line">            message += <span class="string">&quot;\nThis BoundaryConditions is a Line Boundary Conditions.&quot;</span>;</span><br><span class="line">            Curve curve = boundaryConditions.GetCurve();</span><br><span class="line">            <span class="comment">// Get curve start point</span></span><br><span class="line">            message += <span class="string">&quot;\nLocation Line: start point: (&quot;</span> + curve.GetEndPoint(<span class="number">0</span>).X + <span class="string">&quot;, &quot;</span></span><br><span class="line">                    + curve.GetEndPoint(<span class="number">0</span>).Y + <span class="string">&quot;, &quot;</span> + curve.GetEndPoint(<span class="number">0</span>).Z + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">            <span class="comment">// Get curve end point</span></span><br><span class="line">            message += <span class="string">&quot;;  end point:(&quot;</span> + curve.GetEndPoint(<span class="number">1</span>).X + <span class="string">&quot;, &quot;</span></span><br><span class="line">                    + curve.GetEndPoint(<span class="number">1</span>).Y + <span class="string">&quot;, &quot;</span> + curve.GetEndPoint(<span class="number">1</span>).Z + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> BoundaryConditionsType.Area:</span><br><span class="line">            message += <span class="string">&quot;\nThis BoundaryConditions is an Area Boundary Conditions.&quot;</span>;</span><br><span class="line">            IList loops = boundaryConditions.GetLoops();</span><br><span class="line">            <span class="keyword">foreach</span> (CurveLoop curveLoop <span class="keyword">in</span> loops)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">foreach</span> (Curve areaCurve <span class="keyword">in</span> curveLoop)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// Get curve start point</span></span><br><span class="line">                    message += <span class="string">&quot;\nCurve start point:(&quot;</span> + areaCurve.GetEndPoint(<span class="number">0</span>).X + <span class="string">&quot;, &quot;</span></span><br><span class="line">                            + areaCurve.GetEndPoint(<span class="number">0</span>).Y + <span class="string">&quot;, &quot;</span> + areaCurve.GetEndPoint(<span class="number">0</span>).Z + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">                    <span class="comment">// Get curve end point</span></span><br><span class="line">                    message += <span class="string">&quot;; Curve end point:(&quot;</span> + areaCurve.GetEndPoint(<span class="number">1</span>).X + <span class="string">&quot;, &quot;</span></span><br><span class="line">                            + areaCurve.GetEndPoint(<span class="number">1</span>).Y + <span class="string">&quot;, &quot;</span> + areaCurve.GetEndPoint(<span class="number">1</span>).Z + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="literal">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>,message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="板"><a href="#板" class="headerlink" title="板"></a>板</h3><p><strong>板</strong></p>
<p>Slab（结构楼板）和Slab Foundation都由Floor类表示，并由IsFoundationSlab属性区分。</p>
<p>板跨方向由API中的IndependentTag类表示，可用方式如下：</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-23AFA5D3-DFA8-48EE-BDC3-EFB37BADCB7D-low.png"></p>
<p>图157：板跨方向</p>
<p>使用NewSlab（）创建板时，不会自动创建跨方向。也没有办法直接创建它们。</p>
<p>“楼板”复合结构图层“结构桥面”属性由以下属性公开：</p>
<ul>
<li>CompoundStructuralLayer.DeckUsage</li>
<li>DeckProfile</li>
</ul>
<p>属性在以下对话框中列出：</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-F892CB9B-E142-4112-8925-32C543D8A9AA-low.png" alt="img"></p>
<p>图158：楼板复合结构层属性</p>
<h2 id="分析模型"><a href="#分析模型" class="headerlink" title="分析模型"></a>分析模型</h2><p>在结构工程中，分析模型是结构物理模型的工程描述。</p>
<p>以下结构图元具有结构杆件分析模型：</p>
<ul>
<li>Structural Columns 结构柱</li>
<li>Structural Framing elements (such as beams and braces)<br>结构框架图元（如梁和支撑）</li>
<li>Structural Floors 结构楼板</li>
<li>Structural Footings 结构基础</li>
<li>Structural Walls 结构墙</li>
</ul>
<p>可以使用GetAnalyticalModel（）方法获得元素的AnalyticalModel。请注意，新创建的结构图元的AnalyticalModel在再生发生之前不可用。根据图元的族，AnalyticalModel可能不存在。如果AnalyticalModel值不适用于图元的族，则GetAnalyticalModel（）方法返回null。在使用这个类之前检查这个值。AnalyticalModel由以下信息组成：</p>
<ul>
<li>元素相对于分析的位置</li>
<li>参数信息，包括投影、硬点、近似和刚性连接</li>
<li>支持信息</li>
<li>手动和自动调整信息</li>
<li>分析偏移</li>
</ul>
<p>在专业中提供特定选项：</p>
<ul>
<li>AnalyticalModelStick -表示结构框架梁、结构框架支撑和结构柱的分析模型。</li>
<li>AnalyticalModelColumn - AnalyticalModelStick的子类，表示结构柱的分析模型。</li>
<li>AnalyticalModelSurface - 表示结构楼板、结构基础底板和结构墙的分析模型。</li>
</ul>
<h3 id="分析位置"><a href="#分析位置" class="headerlink" title="分析位置"></a>分析位置</h3><p>根据与AnalyticalModel相对应的元素类型，可以通过以下三种方法之一来获得元素相对于分析的位置：GetPoint（）、GetCurve（）或GetCurves（）。</p>
<p>请注意，从这些方法检索的曲线没有设置其“引用”（Reference）特性。因此，它们不能用于Curve.GetEndPointReference（）等方法。相反，您可以通过构造包含必要信息的AnalyticalModelModel对象来获取对曲线及其端点的引用，如下例所示。</p>
<p>代码区域29-10：获取分析曲线的参考</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">GetReferenceData</span>(<span class="params">FamilyInstance familyInst</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        AnalyticalModel analyticalModelFrame = familyInst.GetAnalyticalModel();</span><br><span class="line">        Curve analyticalCurve = analyticalModelFrame.GetCurve();</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != analyticalCurve)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="comment">// test the stable reference to the curve.</span></span><br><span class="line">                AnalyticalModelSelector amSelector = <span class="keyword">new</span> AnalyticalModelSelector(analyticalCurve);</span><br><span class="line">                amSelector.CurveSelector = AnalyticalCurveSelector.WholeCurve;</span><br><span class="line">                Reference curveReference = analyticalModelFrame.GetReference(amSelector);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// test the stable reference to the start point of the curve</span></span><br><span class="line">                amSelector.CurveSelector = AnalyticalCurveSelector.StartPoint;</span><br><span class="line">                Reference startPointReference = analyticalModelFrame.GetReference(amSelector);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// test the stable reference to the start point of the curve</span></span><br><span class="line">                amSelector.CurveSelector = AnalyticalCurveSelector.EndPoint;</span><br><span class="line">                Reference endPointReference = analyticalModelFrame.GetReference(amSelector);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>GetPoint()</strong>  </p>
<p>如果AnalyticalModel可以由单个点（即Structural Footing）表示，则此方法将返回该点。否则，它将引发Autodesk.Revit.Exceptions.InapplicableDataException。IsSinglePoint（）方法可用于确定AnalyticalModel是否可由单个点表示。</p>
<p>下面的示例演示如何获取结构基础的分析位置。</p>
<p>代码区域29-11：获取结构基脚的位置</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// retrieve and iterate current selected element</span></span><br><span class="line">UIDocument uidoc = commandData.Application.ActiveUIDocument;</span><br><span class="line">ElementSet selection = uidoc.Selection.Elements;</span><br><span class="line"><span class="keyword">foreach</span> (Element e <span class="keyword">in</span> selection)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">// if the element is structural footing</span></span><br><span class="line">        FamilyInstance familyInst = e <span class="keyword">as</span> FamilyInstance;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != familyInst &amp;&amp; familyInst.StructuralType == StructuralType.Footing)</span><br><span class="line">        &#123;</span><br><span class="line">                AnalyticalModel model = familyInst.GetAnalyticalModel();</span><br><span class="line">                <span class="comment">// structural footing should be expressable as a single point</span></span><br><span class="line">                <span class="keyword">if</span> (model.IsSinglePoint() == <span class="literal">true</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                        XYZ analyticalLocationPoint = model.GetPoint();</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>GetCurve()</strong>  </p>
<p>如果AnalyticalModel可以由单个曲线（即Structural Column或Structural Framing）表示，则此方法将返回该Curve。否则，它将引发Autodesk. Revit. Exceptions. InapplicableDataException。IsSingleCurve（）方法可用于确定AnalyticalModel是否可由单条曲线表示。</p>
<p>代码区域29-12：获取结构柱的曲线</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetColumnCurve</span>(<span class="params">FamilyInstance familyInst</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">// get AnalyticalModel from structural column</span></span><br><span class="line">        <span class="keyword">if</span> (familyInst.StructuralType == StructuralType.Column)</span><br><span class="line">        &#123;</span><br><span class="line">                AnalyticalModel modelColumn = familyInst.GetAnalyticalModel();</span><br><span class="line">                <span class="comment">// column should be represented by a single curve</span></span><br><span class="line">                <span class="keyword">if</span> (modelColumn.IsSingleCurve() == <span class="literal">true</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                        Curve columnCurve = modelColumn.GetCurve();</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>GetCurves()</strong></p>
<p>此方法需要获取由多条曲线定义的AnalyticalModel的曲线，但可用于所有情况。如果AnalyticalModel可以由单个曲线表示，则该方法将返回仅包含一条曲线的List。如果AnalyticalModel可以由单个点表示，则此方法将返回包含该点的长度几乎为0的Curve。此方法将AnalyticalCurveType枚举作为参数。可能的值为：</p>
<ul>
<li><em>RawCurves</em> - 生成的基础分析模型曲线</li>
<li><em>ActiveCurves</em> - 屏幕上显示的曲线（不包括刚性链接）</li>
<li><em>ApproximatedCurves</em> - 使用直线段近似的曲线</li>
</ul>
<p>The following values related to Rigid Links are also available. See the Rigid Links section later in this chapter for more information.<br>也可以使用与刚性链接相关的以下值。有关详细信息，请参见本章后面的“刚性连杆”部分。</p>
<ul>
<li><em>RigidLinkHead</em> -梁的端点0（头部）处的刚性连杆</li>
<li><em>RigidLinkTail</em> - 梁末端1（尾部）的刚性连杆</li>
<li><em>AllRigidLinks</em> - 所有刚性连杆曲线。端点0（头部）处的刚性连杆将位于第一个条目中。末端1（尾部）的刚性连杆将位于最后一个条目中。</li>
</ul>
<p><strong>GetLoops()</strong></p>
<p>对于结构墙、楼板和楼板，建议使用AnalyticalModelSurface类。使用GetLoops（）方法可以基于AnalyticalLoopType参数检索曲面的一组CurveLoop对象。可能的值为：</p>
<ul>
<li><em>All</em> - 所有分析回路</li>
<li><em>External</em> - 在所有其他循环之外循环。</li>
<li><em>Internal</em> - 位于另一个循环内部的循环。在多个嵌套循环的情况下，这将返回除了最外部循环之外的所有循环。</li>
<li><em>Filled</em> - 内部已填充的循环。在多个嵌套循环的情况下，这将返回最外部的循环，并从外部循环到内部循环。在视图中，返回的回路显示为实体的外部轮廓。</li>
<li><em>Void</em> - 内部为空的循环。在多个嵌套循环的情况下，这将返回一系列循环，从第二个最外部开始，每隔一个标题进入最内部。在视图中，返回的回路显示为开口的外部轮廓。下面的示例演示了如何将AnalyticalModelSurface用于结构墙，以获取所有选定墙的外边缘并显示其坐标。</li>
</ul>
<p>代码区域29-13：获取结构墙的曲线</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// retrieve and iterate current selected element</span></span><br><span class="line">UIDocument uidoc = commandData.Application.ActiveUIDocument;</span><br><span class="line">ICollection selectedIds = uidoc.Selection.GetElementIds();</span><br><span class="line">Document document = uidoc.Document;</span><br><span class="line"><span class="keyword">foreach</span> (ElementId id <span class="keyword">in</span> selectedIds)</span><br><span class="line">&#123;</span><br><span class="line">    Element e = document.GetElement(id);</span><br><span class="line">    Wall aWall = e <span class="keyword">as</span> Wall;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> != aWall)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// get AnalyticalModelSurface from Structural Wall</span></span><br><span class="line">        AnalyticalModelSurface modelWall = aWall.GetAnalyticalModel() <span class="keyword">as</span> AnalyticalModelSurface;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == modelWall)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Architecture wall doesn&#x27;t have analytical model</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// get wall curves</span></span><br><span class="line">        StringBuilder wallString = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        wallString.AppendLine(<span class="string">&quot;Wall curves:&quot;</span>);</span><br><span class="line">        IList wallCurveLoops = modelWall.GetLoops(AnalyticalLoopType.External);</span><br><span class="line">        <span class="keyword">foreach</span> (CurveLoop curveloop <span class="keyword">in</span> wallCurveLoops)</span><br><span class="line">        &#123;</span><br><span class="line">            CurveLoopIterator itr = curveloop.GetCurveLoopIterator();</span><br><span class="line">            itr.Reset();</span><br><span class="line">            <span class="keyword">while</span> (itr.MoveNext())</span><br><span class="line">            &#123;</span><br><span class="line">                Curve wallCurve = itr.Current;</span><br><span class="line">                wallString.AppendLine(String.Format(<span class="string">&quot;&#123;0&#125;, &#123;1&#125;&quot;</span>, wallCurve.GetEndPoint(<span class="number">0</span>).ToString(), wallCurve.GetEndPoint(<span class="number">1</span>).ToString()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TaskDialog.Show(<span class="string">&quot;Wall Analytical Model&quot;</span>, wallString.ToString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <strong>局部坐标系</strong></p>
<p>AnalyticalModelStick和AnalyticalModelSurface元素的局部坐标系的方向可以通过调用重载的GetLocalCoordinateSystem（）方法作为变换获得。对于AnalyticalModelSurface，此方法的重载（不带参数）将返回整个模型的局部坐标系方向的变换，而带XYZ点的重载将返回描述曲面上指定点处的局部坐标系的变换。指定的点必须位于分析模型的表面上，否则Revit将引发异常。</p>
<p>当在AnalyticalModelStick类上调用GetLocalCoordinateSystem（）时，您可以可选地调用GetLocalCoordinateSystem（double），传递沿着曲线的距离，该距离由可以在0和1之间变化的参数表示（例如，0.5表示沿着参数化曲线的中点）。也可以调用GetLocalCoordinateSystem（XYZ point），其约束条件与在AnalyticalModelSurface上调用时相同，即指定的点必须位于沿着分析模型。Face.Evaluate或Curve.Evaluate可用于获取位于曲面上或沿曲线沿着的XYZ点。</p>
<h3 id="参数信息"><a href="#参数信息" class="headerlink" title="参数信息"></a>参数信息</h3><p>AnalyticalModel提供对刚性链接、投影和近似等参数信息的访问。</p>
<p><strong>刚性连杆</strong></p>
<p>刚性连杆将梁的分析模型连接到柱的分析模型。使用CanHaveRigidLinks（）方法和AnalyticalModel.RigidLinksOption属性确定刚性链接是否适用于AnalyticalModel。此外，还可以使用HasRigidLinksWith（）确定AnalyticalModel是否具有与特定图元的刚性链接。</p>
<p>通过使用AnalyticalModel.GetCurves（）方法指定AnalyticalCurveType选项RigidLinkHead和RigidLinkTail，可以检索末端链接。或者，将AnalyticalModel.GetRigidLink（）与AnalyticalModel对象一起使用。</p>
<p>结构梁的AnalyticalModel方法GetCurve（）和GetCurves（）之间的一个区别是，GetCurves（）包括单个Curve以及结构梁RigidLink Curve（如果存在）。将AnalyticalCurveType.RigidLinkHead或AnalyticalCurveType.RigidLinkTail枚举值传递给GetCurves（）方法，以获取梁头部或尾部的RigidLink。</p>
<p>虽然不能直接创建刚性连接（因为它不是独立对象），但可以使用梁和&#x2F;或柱的分析模型上的RigidLinksOption属性来创建刚性连接。梁的刚性连接选项将替代柱的选项。</p>
<p>对于结构梁，RigidLinksOption属性可以具有以下值：</p>
<ul>
<li>AnalyticalRigidLinksOption.Enabled - 将形成刚性链接</li>
<li>AnalyticalRigidLinksOption.Disabled -将不形成刚性链接</li>
<li>AnalyticalRigidLinksOption.FromColumn - 可以形成刚性连接，具体取决于相应结构柱的值。</li>
</ul>
<p>对于结构柱，RigidLinksOption属性可以具有以下值：</p>
<ul>
<li>AnalyticalRigidLinksOption.Enabled - 将形成刚性连接，除非相应的结构梁的设置替代。</li>
<li>AnalyticalRigidLinksOption.Disabled - 除非相应结构梁的设置替代，否则不会形成刚性连接。</li>
</ul>
<p>注意：除了设置正确的值外，要创建刚性连杆，图元还必须重叠。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-80B7AF6C-FF62-4431-AA18-69BD624D7C69-low.png"></p>
<p><strong>对齐、投影和延伸</strong></p>
<p>子类AnalyticalModelSurface、AnalyticalModelStick和AnalyticalModelColumn具有支持检查和操作结构元素的对齐、投影和延伸的专用成员。以下代码示例显示如何更改AnalyticalModelSurface或AnalyticalModelStick的投影。</p>
<p>代码区域：更改AnalyticalModelStick投影</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ChangeBeamProjection</span>(<span class="params">FamilyInstance familyInstance</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    AnalyticalModelStick ams = familyInstance.GetAnalyticalModel() <span class="keyword">as</span> AnalyticalModelStick;</span><br><span class="line">    <span class="keyword">if</span> (ams != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Change the Z projection for the end of the beam</span></span><br><span class="line">        StickElementProjectionZ orgEndProj = ams.GetProjectionZ(AnalyticalElementSelector.EndOrTop);</span><br><span class="line">        StickElementProjectionZ newEndProj = StickElementProjectionZ.Bottom;</span><br><span class="line">        <span class="keyword">using</span> (Transaction tran = <span class="keyword">new</span> Transaction(familyInstance.Document, <span class="string">&quot;ChangeProjection&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            tran.Start();</span><br><span class="line">            ams.SetProjection(AnalyticalElementSelector.EndOrTop, ElementId.InvalidElementId, newEndProj);</span><br><span class="line">            tran.Commit();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TaskDialog.Show(<span class="string">&quot;AnalyticalModelStick&quot;</span>, <span class="string">&quot;AnalyticalModelStick ID: &quot;</span> + ams.Id + <span class="string">&quot;; \nOriginal ProjectionZ value was: &quot;</span> + orgEndProj + <span class="string">&quot;; \nNew ProjectionZ value: &quot;</span> + newEndProj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码区域：更改AnalyticalModel曲面投影</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> </span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> Change the Z projection for all surface elements to BottomOrExterior</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ChangeSurfaceProjections</span>(<span class="params">Document document</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">    IList elements = collector.WherePasses(<span class="keyword">new</span> ElementClassFilter(<span class="keyword">typeof</span>(AnalyticalModelSurface))).WhereElementIsNotElementType().ToElements();</span><br><span class="line">    <span class="keyword">if</span> (elements.Count &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">using</span> (Transaction tran = <span class="keyword">new</span> Transaction(document, <span class="string">&quot;Change Surface Projections&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            tran.Start();</span><br><span class="line">            <span class="keyword">foreach</span> (AnalyticalModelSurface ams <span class="keyword">in</span> elements)</span><br><span class="line">            &#123;</span><br><span class="line">                SurfaceElementProjectionZ orgEndProj = ams.ProjectionZ;</span><br><span class="line">                SurfaceElementProjectionZ newEndProj = SurfaceElementProjectionZ.BottomOrExterior;</span><br><span class="line">                ams.ProjectionZ = newEndProj;</span><br><span class="line">            &#125;</span><br><span class="line">            tran.Commit();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下一个示例演示如何设置柱的顶部拉伸。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> </span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> Change the top extension for the column to Reference Level</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ChangeColumnTopExtension</span>(<span class="params">FamilyInstance column</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    AnalyticalModelColumn amc = column.GetAnalyticalModel() <span class="keyword">as</span> AnalyticalModelColumn;</span><br><span class="line">    <span class="keyword">if</span> (amc != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">using</span> (Transaction tran = <span class="keyword">new</span> Transaction(column.Document, <span class="string">&quot;Change Top Extension&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            tran.Start();</span><br><span class="line"></span><br><span class="line">            StickElementExtension orgTopExt = amc.TopExtension;</span><br><span class="line">            StickElementExtension newTopExt = StickElementExtension.ReferenceLevel;</span><br><span class="line">            amc.TopExtension = newTopExt;</span><br><span class="line"></span><br><span class="line">            TaskDialog.Show(<span class="string">&quot;AnalyticalModelColumn&quot;</span>, <span class="string">&quot;AnalyticalModelColumn ID: &quot;</span> + amc.Id + <span class="string">&quot;; \nOriginal TopExtension value was: &quot;</span> + orgTopExt + <span class="string">&quot;; \nNew TopExtension value: &quot;</span> + newTopExt);</span><br><span class="line"></span><br><span class="line">            tran.Commit();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>近似</strong></p>
<p>当AnalyticalModel由曲线而不是直线定义时（即对于弯曲梁），近似值（由直线组成）可能更可取。AnalyticalModel有几种与曲线近似相关的方法。如果CanApproximate（）返回true，请使用Approximate（）方法在非近似（曲线）分析模型和近似（仅由直线组成）分析模型之间切换。切换到近似后，使用GetCurves（）获取近似曲线的直线。</p>
<p>近似将基于近似偏差值（GetApproximationDeviation（））和使用硬点参数（UsesHardPoints（））。这些值也有相应的Set方法。近似偏差限制平滑曲线与由近似生成的线段之间的距离。硬点是弯曲梁上其他结构元素接触的位置。将此参数设置为true时，将强制分段分析模型在附着到曲梁的杆件端点处具有节点</p>
<p><strong>AnalyzeAs</strong></p>
<p>可以通过AnalyticalModel检索和设置Analyze As参数。此参数向分析程序指示应如何分析元素，或元素是否为NotForAnalysis。由于GetAnalyzeAs（）和SetAnalyzeAs（）使用的AnalyzeAs枚举包含用于不同类型元素的枚举值，因此并非所有值都适用于所有分析模型。使用IsAnalyzeAsValid（）方法确定特定值是否适用于分析模型。</p>
<h3 id="手动调节"><a href="#手动调节" class="headerlink" title="手动调节"></a>手动调节</h3><p>结构杆件分析模型的几何图形也可以相对于它所连接的图元进行调整（假设SupportsManualAdjustment（）方法返回true）。使用AnalyticalModel.ManuallyAdjust（）方法相对于另一个图元调整分析模型。</p>
<p>代码区域29-14：相对于另一个图元调整分析模型</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Pick the source analytical line to adjust to</span></span><br><span class="line">Selection sel = app.ActiveUIDocument.Selection;</span><br><span class="line">Reference refAnalytical = sel.PickObject(ObjectType.Element, <span class="string">&quot;Please Pick the source analytical line to adjust to&quot;</span>);</span><br><span class="line">AnalyticalModel aModel = doc.GetElement(refAnalytical) <span class="keyword">as</span> AnalyticalModel;</span><br><span class="line">Curve aCurve = aModel.GetCurve();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get the reference of the start point</span></span><br><span class="line">AnalyticalModelSelector aSelector = <span class="keyword">new</span> AnalyticalModelSelector(aCurve);</span><br><span class="line">aSelector.CurveSelector = AnalyticalCurveSelector.StartPoint;</span><br><span class="line">Reference refSource = aModel.GetReference(aSelector);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Pick the source analytical line to be adjusted</span></span><br><span class="line">Reference refAnalytical2 = sel.PickObject(ObjectType.Element, <span class="string">&quot;Please pick the source analytical line to be adjusted&quot;</span>);</span><br><span class="line">AnalyticalModel aModel2 = doc.GetElement(refAnalytical2) <span class="keyword">as</span> AnalyticalModel;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get the reference of the start point</span></span><br><span class="line">Curve aCurve2 = aModel2.GetCurve();</span><br><span class="line">AnalyticalModelSelector aSelector2 = <span class="keyword">new</span> AnalyticalModelSelector(aCurve2);</span><br><span class="line">aSelector2.CurveSelector = AnalyticalCurveSelector.StartPoint;</span><br><span class="line"><span class="comment">// Can be adjusted to the middle of the line if WholeCurve is used</span></span><br><span class="line">Reference refTarget = aModel2.GetReference(aSelector2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Adjust the analytical line</span></span><br><span class="line">aModel.ManuallyAdjust(refSource, refTarget, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<p>AnalyticalModel还提供了一些方法，用于确定分析模型是否已被手动调整，以及将其重置回相对于其相应物理模型的原始位置。此外，GetManualAdjustmentMatchedElements（）方法检索元素Id的集合，分析模型已根据这些元素Id进行了调整。</p>
<h3 id="分析偏移"><a href="#分析偏移" class="headerlink" title="分析偏移"></a>分析偏移</h3><p>调整分析模型的另一种方法是使用偏移。设置分析偏移与手动调整分析模型不同。分析偏移是应用于整个分析模型的基本偏移，独立于任何其他图元。AnalyticalModel具有获取和设置分析偏移以及确定是否可以更改分析偏移的方法（CanSetAnalyticalOffset（））。</p>
<h3 id="分析模型支撑"><a href="#分析模型支撑" class="headerlink" title="分析模型支撑"></a>分析模型支撑</h3><p>括每个支撑的优先级（如果多个图元提供支撑）以及提供支撑的点、曲线或面。以下示例说明如何在不同条件下使用AnalyticalModelSupport对象。</p>
<p><strong>楼板和结构梁支撑信息</strong></p>
<p>在草图模式下绘制板时，请选择设计栏上的“拾取支座”。如下图所示，板有三个支撑梁。通过迭代板的AnalyticalModelSupports集合，可以获得三个梁以及CurveSupport AnalyticalSupportType。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-93B7CB30-48F8-4580-88F4-973E91BE718B-low.png" alt="img">图160：楼板和结构梁支撑信息</p>
<p><strong>地板和墙壁支撑信息</strong></p>
<p>通过拾取墙作为支撑来绘制板后，无法从楼板的AnalyticalModelSupport集合中获取墙。相反，Floor在Wall的AnalyticalModelSupports集合中可用。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-9EB168A7-3040-465D-B3B8-D9E39529E4B4-low.png" alt="img">图161：地板和墙壁支撑信息</p>
<p><strong>结构柱、梁和支撑支撑信息</strong></p>
<p>在下图中，水平梁有三个点支撑–两个结构柱和一个结构支撑。支撑有三个点支撑–两个结构柱和一个结构梁。两个柱都没有支撑元件。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-F386B22F-C4FD-4DC3-A751-BE9076FDF4C5-low.png" alt="img"><br>图162：StructuralElements支撑信息</p>
<p><strong>梁系统和墙支撑信息</strong></p>
<p>虽然在绘制BeamSystem时可以拾取墙作为支撑，但由于BeamSystem没有AnalyticalModel属性，因此无法直接获得其支撑信息。解决方案是调用GetBeamIds（）方法，以检索Beams的AnalyticalModelSupport集合。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-8B85D42D-52D3-42DA-B416-B5D63B0884D3-low.png" alt="img"></p>
<p>图163：梁系统和墙支撑信息</p>
<p><strong>墙基础和墙支撑信息</strong></p>
<p>对于具有条形基础的墙，该墙具有可用于条形基础的CurveSupport。可以使用AnalyticalModel.GetCurves（）方法获得支撑曲线。在下面的示例中，曲线中有两个圆弧。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-29E58471-AA23-45AE-9DDB-FAAF03462296-low.png" alt="img"><br>图164：墙基础和墙支撑信息</p>
<p><strong>独立基础和结构柱支撑信息</strong></p>
<p>结构柱可以将独立基脚作为点支撑。在这种情况下，基脚可以随支撑的结构柱移动。具有OST_StructuralFoundation类别的FamilyInstance的ElementId可从AnalyticalModelSupport.GetSupportingElement（）方法获得。通常，支撑点是从AnalyticalModel.GetCurve（）方法检索的曲线的底部点。在从GetPoint（）方法获得独立基脚FamilyInstance和AnalyticalModel Point后，也可以使用该选项。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-70211C95-7FE5-4A12-A4E0-52EA53FC2DEB-low.png" alt="img"><br>图165：独立基础（FamilyInstance)和结构柱支撑信息</p>
<h3 id="分析杆件力"><a href="#分析杆件力" class="headerlink" title="分析杆件力"></a>分析杆件力</h3><p>AnalyticalModelStick类可以在杆元素的每一端存储六个内力。在每个端部处，可以存储3个平移力和3个旋转（力矩）力。这些杆件力可以表示模型上的一组特定载荷的结果，也可以表示用于连接设计的设计力。与荷载工况或组合无关。杆件力对应于分析杆模型（位于梁、支撑和柱上）的UI的“杆件力”属性。</p>
<p>这些力由PermanerForces类表示，该类提供获取和设置所有6个力分量（3个力，3个力矩）的访问权限，并通过Start属性指示对象是表示杆件起点处的力还是表示杆件终点处的力：对于起点和终点力，设置为true;对于终点力，设置为false。</p>
<p>开始和结束力和力矩都存储为由力或力矩的分量值组成的XYZ向量。例如，在一个示例中，力。X表示沿X方向作用的力的值。</p>
<h3 id="阅读杆力"><a href="#阅读杆力" class="headerlink" title="阅读杆力"></a>阅读杆力</h3><p>可以通过调用方法AnalyticalModelStick. GetForces（）来访问与分析模型一起存储的杆件力，该方法返回最小计数为零、最大计数为2（每端一个）的GetForces对象列表。如果没有为成员存储成员力，则列表将为空，如果只有一端指定了力，则列表将仅包含一个MemberForces对象。请注意，在UI中设置为“Released”或通过AnalyticalModleStick.SetReleases（）设置为true（已释放）的任何力或力矩方向在通过AnalyticalModleStick. GetReleaserForces（）查询时将报告为0.0。（释放的力或力矩不能抵抗释放方向上的力或力矩。）</p>
<h3 id="设置构件力"><a href="#设置构件力" class="headerlink" title="设置构件力"></a>设置构件力</h3><p>可以通过调用重载的SetForceForces（）方法之一来在AnalyticalModelStick上设置成员力。SetBumerForces（）将用新提供的杆件力覆盖任何现有杆件力。</p>
<p>对于当前释放的任何力或力矩方向，UI和AnalyticalModelStick. GetReleases（）都将返回这些值为零，但如果您通过AnalyticalModelStick. SetReleases（）方法设置它们，它们将被保留，以便如果用户稍后清除释放，或者您通过AnalyticalModelStick.SetReleases（）清除释放，则将报告先前设置的值。</p>
<h3 id="移除杆件力"><a href="#移除杆件力" class="headerlink" title="移除杆件力"></a>移除杆件力</h3><p>Member forces for AnalyticalModelSticks may be removed for both ends at once or only for an individual end. To remove all AnalyticalModelSticks的杆件力可以同时从两端删除，也可以仅从单个端删除。若要移除元素的所有成员力，请调用AnalyticalModelStick. RemoveAllModelerForces（）。若要仅移除起点或终点的杆件力，请调用AnalyticalModelStick. RemoveModelerForces（）并指示要移除的终点。</p>
<h2 id="荷载"><a href="#荷载" class="headerlink" title="荷载"></a>荷载</h2><p>以下部分确定荷载设置并讨论荷载限制指南。</p>
<p><strong>加载设置</strong></p>
<p>API可以访问“设置”对话框”荷载工况“和”荷载组合“选项卡上的所有功能。</p>
<p>以下属性可从相应的LoadCase BuiltInParameter中获得：</p>
<p><strong>表60荷载工况特性和参数</strong></p>
<table>
<thead>
<tr>
<th>**Property **</th>
<th>**BuiltInParameter **</th>
</tr>
</thead>
<tbody><tr>
<td>Case Number</td>
<td>LOAD_CASE _NUMBER</td>
</tr>
<tr>
<td>Nature</td>
<td>LOAD_CASE_NATURE</td>
</tr>
<tr>
<td>Category</td>
<td>LOAD_CASE_CATEGORY</td>
</tr>
</tbody></table>
<p>LOAD_CASE_CATEGORY参数返回ElementId。下表标识了类别和元素ID值之间的映射。</p>
<p>表61：载荷工况类别</p>
<table>
<thead>
<tr>
<th><strong>Load Case Category 荷载工况类别</strong></th>
<th><strong>BuiltInCategory</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Dead Loads  恒载</td>
<td>OST_LoadCasesDead</td>
</tr>
<tr>
<td>Live Loads  活荷载</td>
<td>OST_LoadCasesLive</td>
</tr>
<tr>
<td>Wind Loads  风荷载</td>
<td>OST_LoadCasesWind</td>
</tr>
<tr>
<td>Snow Loads  雪荷载</td>
<td>OST_LoadCasesSnow</td>
</tr>
<tr>
<td>Roof Live Loads  屋顶活荷载</td>
<td>OST_LoadCasesRoofLive</td>
</tr>
<tr>
<td>Accidental Loads  偶然荷载</td>
<td>OST_LoadCasesAccidental</td>
</tr>
<tr>
<td>Temperature Loads  温度荷载</td>
<td>OST_LoadCasesTemperature</td>
</tr>
<tr>
<td>Seismic Loads  地震荷载</td>
<td>OST_LoadCasesSeismic</td>
</tr>
</tbody></table>
<h3 id="创建荷载和荷载组合"><a href="#创建荷载和荷载组合" class="headerlink" title="创建荷载和荷载组合"></a>创建荷载和荷载组合</h3><p>下面的类有一个或多个静态Create（）方法来创建相应的类：</p>
<ul>
<li>LoadUsage </li>
<li>LoadNature</li>
<li>LoadCase </li>
<li>LoadCombination</li>
<li>PointLoad </li>
<li>LineLoad</li>
<li>AreaLoad</li>
</ul>
<p>因为它们都是Element子类，所以可以使用Document.Delete（）删除它们。</p>
<p>荷载组合是通过静态方法LoadCombination.Create（）创建的，该方法有两个重载。第一种方法只接受对要在其中创建加载组合的文档的引用和新组合名称的字符串。第二个函数接受这些参数加上LoadCombinationType和LoadCombinationState。LoadCombinationType可以是Combination（直接荷载组合）或Envelope（多个荷载工况或组合的效应包络）。</p>
<p>LoadCombinationState可以是Serviceability或Ultimate。如果荷载组合代表结构上的服务荷载水平，则使用“可服务性”。这通常用于设计或检查构件挠度或其他可用性标准，如许用应力设计方法。如果荷载组合表示荷载抗力系数设计方法中通常使用的结构上的极限荷载状态或系数荷载状态，请使用极限荷载。</p>
<p>创建LoadCombination后，需要使用LoadComponents填充它，LoadComponents包含荷载组合及其系数。LoadComponents通过调用LoadCombination.SetComponents（）添加到LoadCombination中，并带有组件列表，如下面的代码片段所示。<br>注意：请确保组件列表不涉及其本身。下面的示例演示如何创建荷载组合，以及如何查找或创建用于设置荷载组合构件的荷载工况和荷载性质。</p>
<p>代码区域：创建新的LoadCombination</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LoadCombination <span class="title">CreateLoadCombinationLoadCaseLoadUsageLoadNatureAndLoadComponent</span>(<span class="params">Document document</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Create a new load combination</span></span><br><span class="line">    LoadCombination loadCombination = LoadCombination.Create(document, <span class="string">&quot;DL1 + RAIN1&quot;</span>, LoadCombinationType.Combination, LoadCombinationState.Ultimate);</span><br><span class="line">    <span class="keyword">if</span> (loadCombination == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Create new load combination failed.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get all existing LoadCase</span></span><br><span class="line">    FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">    ICollection collection = collector.OfClass(<span class="keyword">typeof</span>(LoadCase)).ToElements();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find LoadCase &quot;DL1&quot;</span></span><br><span class="line">    LoadCase case1 = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">foreach</span> (Element e <span class="keyword">in</span> collection)</span><br><span class="line">    &#123;</span><br><span class="line">        LoadCase loadCase = e <span class="keyword">as</span> LoadCase;</span><br><span class="line">        <span class="keyword">if</span> (loadCase.Name == <span class="string">&quot;DL1&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            case1 = loadCase;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get all existing LoadNature</span></span><br><span class="line">    collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">    collection = collector.OfClass(<span class="keyword">typeof</span>(LoadNature)).ToElements();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find LoadNature &quot;Dead&quot;</span></span><br><span class="line">    LoadNature nature1 = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">foreach</span> (Element e <span class="keyword">in</span> collection)</span><br><span class="line">    &#123;</span><br><span class="line">        LoadNature loadNature = e <span class="keyword">as</span> LoadNature;</span><br><span class="line">        <span class="keyword">if</span> (loadNature.Name == <span class="string">&quot;Dead&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            nature1 = loadNature;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create LoadNature &quot;Dead&quot; if not exist</span></span><br><span class="line">    <span class="keyword">if</span> (nature1 == <span class="literal">null</span>)</span><br><span class="line">        nature1 = LoadNature.Create(document, <span class="string">&quot;Dead&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create LoadCase &quot;DL1&quot; if not exist</span></span><br><span class="line">    <span class="keyword">if</span> (case1 == <span class="literal">null</span>)</span><br><span class="line">        case1 = LoadCase.Create(document, <span class="string">&quot;DL1&quot;</span>, nature1.Id, LoadCaseCategory.Dead);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create LoadNature &quot;Rain&quot;</span></span><br><span class="line">    LoadNature nature2 = LoadNature.Create(document, <span class="string">&quot;Rain&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (nature2 == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Create new load nature failed.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create LoadCase &quot;RAIN1&quot;</span></span><br><span class="line">    LoadCase case2 = LoadCase.Create(document, <span class="string">&quot;RAIN1&quot;</span>, nature2.Id, LoadCaseCategory.Snow);</span><br><span class="line">    <span class="keyword">if</span> (case1 == <span class="literal">null</span> || case2 == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Create new load case failed.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create LoadComponents - they consist of LoadCases or nested LoadCombination and Factors</span></span><br><span class="line">    List components = <span class="keyword">new</span> List();</span><br><span class="line">    components.Add(<span class="keyword">new</span> LoadComponent(case1.Id, <span class="number">2.0</span>));</span><br><span class="line">    components.Add(<span class="keyword">new</span> LoadComponent(case2.Id, <span class="number">1.5</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add components to combination</span></span><br><span class="line">    loadCombination.SetComponents(components);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create LoadUsages</span></span><br><span class="line">    LoadUsage usage1 = LoadUsage.Create(document, <span class="string">&quot;Frequent&quot;</span>);</span><br><span class="line">    LoadUsage usage2 = LoadUsage.Create(document, <span class="string">&quot;Rare&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (usage1 == <span class="literal">null</span> || usage2 == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Create new load usage failed.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add load usages to combination</span></span><br><span class="line">    loadCombination.SetUsageIds(<span class="keyword">new</span> List() &#123;usage1.Id, usage2.Id&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Give the user some information</span></span><br><span class="line">    TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>, <span class="built_in">string</span>.Format(<span class="string">&quot;Load Combination ID=&#x27;&#123;0&#125;&#x27; created successfully.&quot;</span>, loadCombination.Id.IntegerValue));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> loadCombination;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>您还可以通过使用LoadCombination.GetComponents（）修改案例、组件、性质等，进行修改，然后再次调用LoadCombination.SetComponents（）。可以通过调用LoadCombination. GetUsageIds（）来修改LoadCombination的LoadUsages，以获取LoadUsage Ids的列表，修改该列表，然后再次调用SetUsageIds（）。下面的代码示例演示如何修改现有的LoadCombination。</p>
<p>代码区域：修改荷载组合</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ModifyLoadCombinationLoadCaseLoadUsageLoadNatureAndLoadComponent</span>(<span class="params">Document document, LoadCombination loadCombination</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Change name of LoadCombination</span></span><br><span class="line">    loadCombination.Name = <span class="string">&quot;DL2 + RAIN1&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get any LoadCase from combination</span></span><br><span class="line">    <span class="comment">// Combination can have assigned LoadCase or other (nested) LoadCombination so we need to filter out any LoadCombination</span></span><br><span class="line">    LoadCase case1 = <span class="literal">null</span>;</span><br><span class="line">    IList caseAndCombinationIds = loadCombination.GetCaseAndCombinationIds();</span><br><span class="line">    <span class="keyword">foreach</span> (ElementId id <span class="keyword">in</span> caseAndCombinationIds)</span><br><span class="line">    &#123;</span><br><span class="line">        Element element = document.GetElement(id);</span><br><span class="line">        <span class="keyword">if</span> (element <span class="keyword">is</span> LoadCase)</span><br><span class="line">        &#123;</span><br><span class="line">            case1 = (LoadCase)element;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (element <span class="keyword">is</span> LoadCombination)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (case1 == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Can&#x27;t get LoadCase.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Change case name and number</span></span><br><span class="line">    case1.Name = <span class="string">&quot;DL2&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (LoadCase.IsNumberUnique(document, <span class="number">3</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        case1.Number = <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create load nature</span></span><br><span class="line">    LoadNature liveNature = LoadNature.Create(document, <span class="string">&quot;Dead nature&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (liveNature == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Create new load nature failed.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Change nature category and ID for case</span></span><br><span class="line">    case1.SubcategoryId = <span class="keyword">new</span> ElementId(BuiltInCategory.OST_LoadCasesDead);</span><br><span class="line">    case1.NatureId = liveNature.Id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Change factor for case1</span></span><br><span class="line">    IList components = loadCombination.GetComponents();</span><br><span class="line">    <span class="keyword">foreach</span> (LoadComponent loadComponent <span class="keyword">in</span> components)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (loadComponent.LoadCaseOrCombinationId == case1.Id)</span><br><span class="line">        &#123;</span><br><span class="line">            loadComponent.Factor = <span class="number">3.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    loadCombination.SetComponents(components);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Remove one usage from combination</span></span><br><span class="line">    IList usages = loadCombination.GetUsageIds();</span><br><span class="line">    usages.RemoveAt(<span class="number">0</span>);</span><br><span class="line">    loadCombination.SetUsageIds(usages);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Give the user some information</span></span><br><span class="line">    TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>, <span class="built_in">string</span>.Format(<span class="string">&quot;Load Combination ID=&#x27;&#123;0&#125;&#x27; modified successfully.&quot;</span>, loadCombination.Id.IntegerValue));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>LoadCase和LoadNature类中没有Duplicate（）方法。若要实现此功能，必须首先创建一个新的LoadCase（或LoadNature）对象，然后从现有的LoadCase（或LoadNature）复制相应的属性和参数。 以下是演示在VB.NET中创建点荷载的最小示例代码：</p>
<p>代码区域：新PointLoad</p>
<figure class="highlight vb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&#x27;Define the location at which the PointLoad is applied. </span></span><br><span class="line"><span class="keyword">Dim</span> point <span class="keyword">As</span> <span class="built_in">New</span> XYZ(<span class="number">0</span>, <span class="number">0</span>, <span class="number">4</span>)</span><br><span class="line"><span class="comment">&#x27;Define the 3d force. </span></span><br><span class="line"><span class="keyword">Dim</span> force <span class="keyword">As</span> <span class="built_in">New</span> XYZ(<span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>)</span><br><span class="line"><span class="comment">&#x27;Define the 3d moment. </span></span><br><span class="line"><span class="keyword">Dim</span> moment <span class="keyword">As</span> <span class="built_in">New</span> XYZ(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">Dim</span> pointLoad <span class="keyword">As</span> PointLoad = pointLoad.Create(document, point, force, moment, <span class="literal">Nothing</span>, <span class="literal">Nothing</span>)</span><br></pre></td></tr></table></figure>

<h2 id="分析链接"><a href="#分析链接" class="headerlink" title="分析链接"></a>分析链接</h2><p>使用Revit，在创建物理模型时会自动生成结构分析模型。分析模型将链接到结构分析应用程序，物理模型将通过Revit API根据结果自动更新。一些第三方软件开发商已经为其结构分析应用程序提供了双向链接。其中包括：</p>
<ul>
<li>ADAPT Corporation（<a target="_blank" rel="noopener" href="http://www.adaptsoft.com/revitstructure/">www.adaptsoft.com/revitstructure/</a>）的ADAPT-Builder Suite</li>
<li>Fastrak和S-Frame来自CSC（<a target="_blank" rel="noopener" href="http://www.cscworld.com/">www.cscworld.com</a>）</li>
<li>来自CSI的ETABS（<a target="_blank" rel="noopener" href="http://www.csiberkeley.com/">www.csiberkeley.com/</a>）</li>
<li>RFEM来自Dlubal（<a target="_blank" rel="noopener" href="https://www.dlubal.com/en/download/rfem_revit_en.pdf">www.dlubal.com/en/download/rfem_revit_en.pdf</a>）</li>
<li>GRAITEC（<a target="_blank" rel="noopener" href="http://www.graitec.com/En/revit.asp">www.graitec.com/En/revit.asp</a>）的高级设计、视觉设计、Arche、Effel和SuperSTRESS</li>
<li>来自Nemetschek的Scia工程师（<a target="_blank" rel="noopener" href="https://www.scia.net/en/software/product-selection/scia-engineer%EF%BC%89">https://www.scia.net/en/software/product-selection/scia-engineer）</a></li>
<li>来自Oasys Software（Arup）的GSA（<a target="_blank" rel="noopener" href="http://www.oasys-software.com/products">www.oasys-software.com/products</a>）</li>
<li>Prokon Software Consultants的ProDESK（<a target="_blank" rel="noopener" href="http://www.prokon.com/">www.prokon.com/</a>）</li>
<li>Bentley的RAM Structural System（<a target="_blank" rel="noopener" href="http://www.bentley.com/en-US/Products/RAM+Structural+System/">www.bentley.com/en-US/Products/RAM+Structural+System/</a>）</li>
<li>RISA-3D和RISAFloor，来自RISA Technologies（<a target="_blank" rel="noopener" href="http://www.risatech.com/partner/revit_structure.asp">www.risatech.com/partner/revit_structure.asp</a>）</li>
<li>SOFiSTiK Structural Desktop Suite来自SOFiSTiK（<a target="_blank" rel="noopener" href="http://www.sofistik.com/">http://www.sofistik.com</a>）</li>
<li>来自SPACE GASS（<a target="_blank" rel="noopener" href="http://www.example.com)的space/">www.example.com）的SPACE</a> GASS<a target="_blank" rel="noopener" href="http://www.spacegass.com/index.asp?resend=/revit.asp">www.spacegass.com/index.asp? resend=/revit.asp</a>）</li>
<li>来自Structural Integrators的Revit Structure STAAD.Pro界面（<a target="_blank" rel="noopener" href="http://www.structuralintegrators.com/products/si_xchange.php">structuralintegrators.com&#x2F;products&#x2F;si_xchange.php</a>）</li>
<li>Autodesk的Robot Structural Analysis Professional（<a target="_blank" rel="noopener" href="http://www.autodesk.com/products/robot-structural-analysis%EF%BC%89">http://www.autodesk.com/products/robot-structural-analysis）</a></li>
</ul>
<p>The key to linking Revit to other analysis applications is to set up the mapping relationship between the objects in different object models. That means the difficulty and level of the integration depends on the similarity between the two object models.<br>将Revit链接到其他分析应用程序的关键是设置不同对象模型中的对象之间的映射关系。这意味着集成的难度和水平取决于两个对象模型之间的相似性。</p>
<p>For example, during the product design process, design a table with at least the first two columns in the object mapping in the following table: one for the Revit API and the other for the structural analysis application, shown as follows:<br>例如，在产品设计过程中，设计一个表，其中至少包含下表中对象映射的前两列：一列用于Revit API，另一列用于结构分析应用程序，如下所示：</p>
<p><strong>表62：Revit和Analysis应用程序对象映射</strong></p>
<table>
<thead>
<tr>
<th><strong>Revit API</strong></th>
<th><strong>Analysis Application 分析应用</strong></th>
<th><strong>Import to Revit 导入到Revit</strong></th>
</tr>
</thead>
<tbody><tr>
<td>StructuralColumn  结构柱</td>
<td>Column  柱</td>
<td>NewStructuralColumn  新建结构柱</td>
</tr>
<tr>
<td>Property:  属性：</td>
<td></td>
<td></td>
</tr>
<tr>
<td>…</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Location  位置</td>
<td></td>
<td>Read-only;  只读;</td>
</tr>
<tr>
<td>Parameter:  参数名称：</td>
<td></td>
<td></td>
</tr>
<tr>
<td>…</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Analyze as  分析为</td>
<td></td>
<td>Editable;  可编辑;</td>
</tr>
<tr>
<td>AnalyticalModel:  分析模型：</td>
<td></td>
<td></td>
</tr>
<tr>
<td>…</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Profile  轮廓</td>
<td></td>
<td>Read-only;  只读;</td>
</tr>
<tr>
<td>RigidLink</td>
<td></td>
<td>Read-only;  只读;</td>
</tr>
<tr>
<td>…</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Material:  材质：</td>
<td></td>
<td></td>
</tr>
<tr>
<td>…</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="Analytical-Links"><a href="#Analytical-Links" class="headerlink" title="Analytical Links"></a>Analytical Links</h2><p>分析链接是连接2个独立分析节点的图元，具有固定状态等属性。在建模过程中，Revit可以根据某些规则自动创建从分析梁到分析柱的分析链接。也可以在Revit UI中或使用Revit API手动创建。</p>
<p>在Revit API中，分析链接由AnalyticalLink类表示。固定度值可从其关联的AnalyticalLinkType获得。</p>
<p>下面的示例演示了如何读取文档中的所有AnalyticalLinks，并显示一个汇总自动生成和手动创建的AnalyticalLinks数量的TaskDialog。</p>
<p>代码区域：阅读分析链接</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ReadAnalyticalLinks</span>(<span class="params">Document document</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    FilteredElementCollector collectorAnalyticalLinks = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">    collectorAnalyticalLinks.OfClass(<span class="keyword">typeof</span>(AnalyticalLink));</span><br><span class="line"></span><br><span class="line">    IEnumerable alinks = collectorAnalyticalLinks.ToElements().Cast();</span><br><span class="line">    <span class="built_in">int</span> nAutoGeneratedLinks = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">int</span> nManualLinks = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">foreach</span> (AnalyticalLink alink <span class="keyword">in</span> alinks)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (alink.IsAutoGenerated() == <span class="literal">true</span>)</span><br><span class="line">            nAutoGeneratedLinks++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            nManualLinks++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">string</span> msg = <span class="string">&quot;Auto-generated AnalyticalLinks: &quot;</span> + nAutoGeneratedLinks;</span><br><span class="line">    msg += <span class="string">&quot;\nManually created AnalyticalLinks: &quot;</span> + nManualLinks;</span><br><span class="line">    TaskDialog.Show(<span class="string">&quot;AnalyticalLinks&quot;</span>, msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>静态方法AnalyticalLink.Create（）创建一个新的分析链接。不是直接连接两个元素，而是在两个集线器之间创建连接。Hub类表示两个或多个Autodesk Revit元素之间的连接。 以下示例在两个选定的FamilyInstance对象之间创建新的分析链接。它使用一个过滤器来查找模型中的所有中心点，然后GetHub（）方法搜索中心点以查找引用每个FamilyInstance的AnalyticalModel的ID的中心点。</p>
<p>代码区域：创建新的AnalyticalLink</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">CreateLink</span>(<span class="params">Document doc, FamilyInstance fi1, FamilyInstance fi2</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    FilteredElementCollector hubCollector = <span class="keyword">new</span> FilteredElementCollector(doc);</span><br><span class="line">    hubCollector.OfClass(<span class="keyword">typeof</span>(Hub));  <span class="comment">//Get all hubs</span></span><br><span class="line">    ICollection allHubs = hubCollector.ToElements();</span><br><span class="line">    FilteredElementCollector linktypeCollector = <span class="keyword">new</span> FilteredElementCollector(doc);</span><br><span class="line">    linktypeCollector.OfClass(<span class="keyword">typeof</span>(AnalyticalLinkType));</span><br><span class="line">    ElementId firstLinkType = linktypeCollector.ToElementIds().First();  <span class="comment">//Get the first analytical link type.</span></span><br><span class="line">    <span class="comment">// Get hub Ids from two selected family instance items</span></span><br><span class="line">    ElementId startHubId = GetHub(fi1.GetAnalyticalModel().Id, allHubs);</span><br><span class="line">    ElementId endHubId = GetHub(fi2.GetAnalyticalModel().Id, allHubs);</span><br><span class="line">    Transaction tran = <span class="keyword">new</span> Transaction(doc, <span class="string">&quot;Create Link&quot;</span>);</span><br><span class="line">    tran.Start();</span><br><span class="line">    <span class="comment">//Create a link between these two hubs.</span></span><br><span class="line">    AnalyticalLink createdLink = AnalyticalLink.Create(doc, firstLinkType, startHubId, endHubId);    tran.Commit();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Get the first Hub on a given AnalyticalModel element</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> ElementId <span class="title">GetHub</span>(<span class="params">ElementId hostId, ICollection allHubs</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">foreach</span> (Element ehub <span class="keyword">in</span> allHubs)</span><br><span class="line">    &#123;</span><br><span class="line">        Hub hub = ehub <span class="keyword">as</span> Hub;</span><br><span class="line">        ConnectorManager manager = hub.GetHubConnectorManager();</span><br><span class="line">        ConnectorSet connectors = manager.Connectors;</span><br><span class="line">        <span class="keyword">foreach</span> (Connector connector <span class="keyword">in</span> connectors)</span><br><span class="line">        &#123;</span><br><span class="line">            ConnectorSet refConnectors = connector.AllRefs;</span><br><span class="line">            <span class="keyword">foreach</span> (Connector refConnector <span class="keyword">in</span> refConnectors)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (refConnector.Owner.Id == hostId)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> hub.Id;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ElementId.InvalidElementId;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="注：翻译自Revit-API-Developers-Guide"><a href="#注：翻译自Revit-API-Developers-Guide" class="headerlink" title="注：翻译自Revit API Developers Guide"></a><em><strong>注：</strong></em>翻译自<a target="_blank" rel="noopener" href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_html">Revit API Developers Guide</a></h2></article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Revit/">Revit</a></div><div class="post-share"><div class="social-share" data-image="/images/4stars.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2024/12/30/%E4%BA%8C%E5%BC%80%E6%8C%87%E5%8D%97/27%E6%9C%BA%E7%94%B5%E5%B7%A5%E7%A8%8B/" title="27机电工程"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">27机电工程</div></div><div class="info-2"><div class="info-item-1">机电工程为了支持Revit软件的MEP工程功能，API提供了对Revit模型中HVAC和管道数据的读写访问，包括：  在系统中穿过风管、管道、管件和接头 添加、删除和更改风管、管道和其他设备 获取和设置系统属性 确定系统是否连接良好 访问机械设置 管理布管配置  本节中的页面  MEP元素创建 MEP系统 连接器 MEP预制件详述 族创建 机械设置 电气设置 布管系统配置  MEP元素创建可以使用Revit API创建MEP图元。 可以使用Autodesk.Revit.Creation.Document类中提供的以下方法创建与风管、管道和电气系统相关的许多图元：  NewFlexDuct NewFlexPipe NewMechanicalSystem  NewPipingSystem NewCrossFitting NewElbowFitting  NewTakeoffFitting  NewTeeFitting  NewTransitionFitting...</div></div></div></a><a class="pagination-related" href="/2024/12/24/%E4%BA%8C%E5%BC%80%E6%8C%87%E5%8D%97/25%E5%BB%BA%E7%AD%91/" title="25建筑"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">25建筑</div></div><div class="info-2"><div class="info-item-1">建筑本章介绍特定于Revit建筑功能的API功能：  与房间相关的功能（Element.Room、RoomTag等）   本节中的主题  Rooms  房间Rooms  以下各节介绍了有关房间类、其参数以及如何在API中使用房间类的信息。 Room类用于表示房间和图元，例如房间明细表和面积平面。下表列出了API中不同房间、面积及其对应标签的属性和创建函数： 表55：房间、面积和标签关系    **Element ** **Class ** **Category ** **Boundary ** **Location ** **Can Create **    Room in Plan View Room OST_Rooms 在封闭区域中有 LocationPoint NewRoom（），NewRoom（Phase）除外   Room in Schedule View Room OST_Rooms Null Null NewRoom(Phase)   Area Room OST_Areas 总是有 LocationPoint No   Room...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2024/11/18/RevitApi%E5%90%88%E9%9B%86/Autodesk.RevitAddIns%20Namespace/" title="Autodesk.RevitAddIns Namespace"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-18</div><div class="info-item-2">Autodesk.RevitAddIns Namespace</div></div><div class="info-2"><div class="info-item-1">Autodesk.RevitAddIns Namespace类AddInManifestUtility此静态类提供从 Revit .addin 文件中读取清单内容的访问。   方法  GetRevitAddInBundleManifests  GetRevitAddInManifest  GetRevitAddInManifests     RevitAddInApplication表示 Revit 外部应用程序。  构造器  RevitAddInApplication 创建 external application info 类的新实例。    属性  Name  Application name    继承关系  System.Object  Autodesk.RevitAddIns.RevitAddInItem  Autodesk.RevitAddIns.RevitAddInApplication    RevitAddInCommand表示 Revit 外部命令。  构造器  RevitAddInCommand 创建 Add-In Command info...</div></div></div></a><a class="pagination-related" href="/2024/11/18/RevitApi%E5%90%88%E9%9B%86/Autodesk.Revit.DB%20CurveArray/" title="Autodesk.Revit.DB CurveArray"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-18</div><div class="info-item-2">Autodesk.Revit.DB CurveArray</div></div><div class="info-2"><div class="info-item-1">Autodesk.Revit.DB CurveArray可以包含曲线的数组。 语法1public class CurveArray : APIObject, IEnumerable  继承层次结构System Object ​	Autodesk.Revit.DB APIObject ​		Autodesk.Revit.DB CurveArray 另见CurveArray Members Autodesk.Revit.DB Namespace 构造函数CurveArray创建CurveArray类的新实例 方法Append将曲线添加到数组的末尾。 Clear从数组中删除每条曲线，使其为空。 ForwardIterator将一个向前移动的迭代器添加到数组中。 GetEnumerator将一个向前移动的迭代器添加到数组中。 Insert将指定的曲线插入数组。 ReverseIterator返回一个向后移动的迭代器到数组。 属性IsEmpty测试数组是否为空。 Item获取或设置数组中指定索引处的曲线。 Size返回数组中的曲线数。 注：翻译自Revit Api docs 2018</div></div></div></a><a class="pagination-related" href="/2024/12/10/RevitApi%E5%90%88%E9%9B%86/Autodesk.Revit.DB%20Opening/" title="Autodesk.Revit.DB Opening"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-10</div><div class="info-item-2">Autodesk.Revit.DB Opening</div></div><div class="info-2"><div class="info-item-1">Autodesk.Revit.DB OpeningAutodesk Revit项目或族文档中的洞口。 语法1public class Opening : Element  附注该对象表示各种不同类型的洞口：  墙中由修订项目中的两个边界点创建的矩形洞口。 由应用于屋顶、楼板、天花板、梁、支撑或柱的一组曲线创建的洞口。 一个垂直的竖井开口延伸到一个或多个水平。 在族文档中的墙或天花板上创建的简单洞口。  根据打开的类型，此类的某些属性将不可用。 这个对象派生自Element基对象，并且支持该对象的所有方法，例如检索该对象的参数的能力。此对象还支持访问结构分析模型，但此功能仅适用于Autodesk Revit Structure。 示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051### private void Getinfo_Opening(Opening opening)&#123;    string message =...</div></div></div></a><a class="pagination-related" href="/2024/12/10/RevitApi%E5%90%88%E9%9B%86/Autodesk.Revit.DB%20ReferenceIntersector/" title="Autodesk.Revit.DB ReferenceIntersector"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-10</div><div class="info-item-2">Autodesk.Revit.DB ReferenceIntersector</div></div><div class="info-2"><div class="info-item-1">Autodesk.Revit.DB ReferenceIntersector用于查找和返回与从原点和方向创建的射线相交的元素的类。 语法1public class ReferenceIntersector : IDisposable    附注可以构造此类的实例，以返回与由原点和方向创建的射线，或者基于过滤和标志返回元素的子集。 调用者可以选择使用ElementFilter过滤结果，或者通过应用特定的可接受的元素。 调用方还可以指定要返回的对象的类型， 整个元素、几何体对象或其组合。 在所有情况下，要求调用者提供 用于评估的3D视图;输入视图上的视图和可见性设置将确定 返回特定元素（例如，此工具永远不会返回隐藏元素、 和几何图形位于视图剖面框之外的元素）。 该类配置为可以构建单个实例，并用于对多个不同光线进行多次评估。在同一个 ReferenceIntersector 上的调用之间，评估结果不会被保留。 该类还提供了一个选项，用于返回在Revit链接中遇到的图元结果。 当设置 FindReferencesInRevitLinks 标志...</div></div></div></a><a class="pagination-related" href="/2024/12/19/RevitApi%E5%90%88%E9%9B%86/Autodesk.Revit.UI.Selection%20Namespace/" title="Autodesk.Revit.UI.Selection"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-19</div><div class="info-item-2">Autodesk.Revit.UI.Selection</div></div><div class="info-2"><div class="info-item-1">Autodesk.Revit.UI.SelectionClassesPickedBox包含两个 XYZ 点的类，表示屏幕上的选取框。  Properties  Max 最大坐标数（拾取框的右上角）。  Min 最小坐标（拾取框的左下角）。     SelectableInViewFilter一个过滤器，用于传递在给定视图中可选的元素。  Constructors  SelectableInViewFilter  (Document, ElementId) 构造 SelectableInViewFilter 的新实例。  SelectableInViewFilter (Document, ElementId, Boolean) 构造 SelectableInViewFilter 的新实例，并可选择传递所有不可选择的元素。    Methods  PassesFilter(Element) 将筛选器应用于给定元素。  PassesFilter(Document,...</div></div></div></a><a class="pagination-related" href="/2024/12/20/RevitApi%E5%90%88%E9%9B%86/Autodesk.Revit.DB%20Transform/" title="Autodesk.Revit.DB Transform"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-20</div><div class="info-item-2">Autodesk.Revit.DB Transform</div></div><div class="info-2"><div class="info-item-1">Autodesk.Revit.DB Transform仿射三维空间的一个变换。 语法public class Transform : APIObject示例12345678910111213141516171819202122### public static XYZ TransformPoint(XYZ point, Transform transform)&#123;    double x = point.X;    double y = point.Y;    double z = point.Z;    //transform basis of the old coordinate system in the new coordinate // system    XYZ b0 = transform.get_Basis(0);    XYZ b1 = transform.get_Basis(1);    XYZ b2 = transform.get_Basis(2);    XYZ origin = transform.Origin;       ...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="giscus-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/images/4stars.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">funtim41@gmail.com</div><div class="author-info-description">实践-认识-再实践-再认识</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">53</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">3</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/FunTim41"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/FunTim41" target="_blank" title="Github"><i class="fab fa-github" style="color: #FFFFFF;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E5%B7%A5%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text">结构工程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E6%A8%A1%E5%9E%8B%E5%85%83%E7%B4%A0"><span class="toc-number">1.1.</span> <span class="toc-text">结构模型元素</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E6%9F%B1%E3%80%81%E6%A2%81%E5%92%8C%E6%94%AF%E6%92%91"><span class="toc-number">1.1.1.</span> <span class="toc-text">结构柱、梁和支撑</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%81%E6%9E%B6"><span class="toc-number">1.1.2.</span> <span class="toc-text">桁架</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0%E5%BC%BA"><span class="toc-number">1.1.3.</span> <span class="toc-text">加强</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%92%A2%E7%AD%8B"><span class="toc-number">1.1.3.1.</span> <span class="toc-text">钢筋</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%B9%E7%95%8C%E6%9D%A1%E4%BB%B6"><span class="toc-number">1.1.4.</span> <span class="toc-text">边界条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%BF"><span class="toc-number">1.1.5.</span> <span class="toc-text">板</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E6%9E%90%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.2.</span> <span class="toc-text">分析模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%9E%90%E4%BD%8D%E7%BD%AE"><span class="toc-number">1.2.1.</span> <span class="toc-text">分析位置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E4%BF%A1%E6%81%AF"><span class="toc-number">1.2.2.</span> <span class="toc-text">参数信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%8B%E5%8A%A8%E8%B0%83%E8%8A%82"><span class="toc-number">1.2.3.</span> <span class="toc-text">手动调节</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%9E%90%E5%81%8F%E7%A7%BB"><span class="toc-number">1.2.4.</span> <span class="toc-text">分析偏移</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%9E%90%E6%A8%A1%E5%9E%8B%E6%94%AF%E6%92%91"><span class="toc-number">1.2.5.</span> <span class="toc-text">分析模型支撑</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%9E%90%E6%9D%86%E4%BB%B6%E5%8A%9B"><span class="toc-number">1.2.6.</span> <span class="toc-text">分析杆件力</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%85%E8%AF%BB%E6%9D%86%E5%8A%9B"><span class="toc-number">1.2.7.</span> <span class="toc-text">阅读杆力</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E6%9E%84%E4%BB%B6%E5%8A%9B"><span class="toc-number">1.2.8.</span> <span class="toc-text">设置构件力</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A7%BB%E9%99%A4%E6%9D%86%E4%BB%B6%E5%8A%9B"><span class="toc-number">1.2.9.</span> <span class="toc-text">移除杆件力</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8D%B7%E8%BD%BD"><span class="toc-number">1.3.</span> <span class="toc-text">荷载</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E8%8D%B7%E8%BD%BD%E5%92%8C%E8%8D%B7%E8%BD%BD%E7%BB%84%E5%90%88"><span class="toc-number">1.3.1.</span> <span class="toc-text">创建荷载和荷载组合</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E6%9E%90%E9%93%BE%E6%8E%A5"><span class="toc-number">1.4.</span> <span class="toc-text">分析链接</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Analytical-Links"><span class="toc-number">1.5.</span> <span class="toc-text">Analytical Links</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%EF%BC%9A%E7%BF%BB%E8%AF%91%E8%87%AARevit-API-Developers-Guide"><span class="toc-number">1.6.</span> <span class="toc-text">注：翻译自Revit API Developers Guide</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/30/CAD%E4%BA%8C%E5%BC%80/AddInManager/" title="AddInManager">AddInManager</a><time datetime="2025-01-08T12:59:08.477Z" title="更新于 2025-01-08 20:59:08">2025-01-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/01/08/%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE/Hexo+Butterfly%E4%BB%A3%E7%A0%81%E5%9D%97%E6%B0%B4%E5%B9%B3%E6%BB%9A%E5%8A%A8%E6%9D%A1/" title="Hexo+Butterfly代码块水平滚动条">Hexo+Butterfly代码块水平滚动条</a><time datetime="2025-01-08T04:24:42.742Z" title="更新于 2025-01-08 12:24:42">2025-01-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/01/05/CAD%E4%BA%8C%E5%BC%80/01%E5%9B%BE%E5%B1%82%E7%9A%84%E5%A2%9E%E5%88%A0%E6%9F%A5/" title="01图层的增删查">01图层的增删查</a><time datetime="2025-01-06T02:26:57.051Z" title="更新于 2025-01-06 10:26:57">2025-01-06</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/18/RevitApi%E5%90%88%E9%9B%86/Autodesk.RevitAddIns%20Namespace/" title="Autodesk.RevitAddIns Namespace">Autodesk.RevitAddIns Namespace</a><time datetime="2025-01-05T09:13:27.547Z" title="更新于 2025-01-05 17:13:27">2025-01-05</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/18/RevitApi%E5%90%88%E9%9B%86/Autodesk.Revit.DB%20CurveArray/" title="Autodesk.Revit.DB CurveArray">Autodesk.Revit.DB CurveArray</a><time datetime="2025-01-04T02:50:53.238Z" title="更新于 2025-01-04 10:50:53">2025-01-04</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/images/topback.jpg);"><div id="footer-wrap"><div class="copyright">&copy;2024 - 2025 By funtim41@gmail.com</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">学而不思则罔，思而不学则殆。</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>(() => {
  const panguFn = () => {
    if (typeof pangu === 'object') pangu.autoSpacingPage()
    else {
      btf.getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
        .then(() => {
          pangu.autoSpacingPage()
        })
    }
  }

  const panguInit = () => {
    if (false){
      GLOBAL_CONFIG_SITE.isPost && panguFn()
    } else {
      panguFn()
    }
  }

  btf.addGlobalFn('pjaxComplete', panguInit, 'pangu')
  document.addEventListener('DOMContentLoaded', panguInit)
})()</script><div class="js-pjax"><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.isShuoshuo
  const option = null

  const getGiscusTheme = theme => theme === 'dark' ? 'dark' : 'light'

  const createScriptElement = config => {
    const ele = document.createElement('script')
    Object.entries(config).forEach(([key, value]) => {
      ele.setAttribute(key, value)
    })
    return ele
  }

  const loadGiscus = (el = document, key) => {
    const mappingConfig = isShuoshuo
      ? { 'data-mapping': 'specific', 'data-term': key }
      : { 'data-mapping': (option && option['data-mapping']) || 'pathname' }

    const giscusConfig = {
      src: 'https://giscus.app/client.js',
      'data-repo': 'FunTim41/funtim41.github.io',
      'data-repo-id': 'R_kgDONjG8ww',
      'data-category-id': 'DIC_kwDONjG8w84Cllg2',
      'data-theme': getGiscusTheme(document.documentElement.getAttribute('data-theme')),
      'data-reactions-enabled': '1',
      crossorigin: 'anonymous',
      async: true,
      ...option,
      ...mappingConfig
    }

    const scriptElement = createScriptElement(giscusConfig)

    el.querySelector('#giscus-wrap').appendChild(scriptElement)

    if (isShuoshuo) {
      window.shuoshuoComment.destroyGiscus = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }
  }

  const changeGiscusTheme = theme => {
    const iframe = document.querySelector('#giscus-wrap iframe')
    if (iframe) {
      const message = {
        giscus: {
          setConfig: {
            theme: getGiscusTheme(theme)
          }
        }
      }
      iframe.contentWindow.postMessage(message, 'https://giscus.app')
    }
  }

  btf.addGlobalFn('themeChange', changeGiscusTheme, 'giscus')

  if (isShuoshuo) {
    'Giscus' === 'Giscus'
      ? window.shuoshuoComment = { loadComment: loadGiscus }
      : window.loadOtherComment = loadGiscus
    return
  }

  if ('Giscus' === 'Giscus' || !false) {
    if (false) btf.loadComment(document.getElementById('giscus-wrap'), loadGiscus)
    else loadGiscus()
  } else {
    window.loadOtherComment = loadGiscus
  }
})()</script></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>