<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>10视图 | funtim的博客</title><meta name="author" content="funtim41@gmail.com"><meta name="copyright" content="funtim41@gmail.com"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="视图视图是从 Revit 模型生成的图像，具有对文档中存储的数据的特权访问权限。它们可以是图形 （如计划） 或文本 （如计划）。每个项目文档都有一个或多个不同的视图。最后一个聚焦窗口是活动视图。 Autodesk.Revit.DB.View 类是 Revit 文档中所有视图类型的基类。Autodesk.Revit.UI.UIView 类表示 Revit 用户界面中的窗口视图。 在以下部分中，您将了">
<meta property="og:type" content="article">
<meta property="og:title" content="10视图">
<meta property="og:url" content="https://funtim41.github.io/2024/12/05/%E4%BA%8C%E5%BC%80%E6%8C%87%E5%8D%97/10%E8%A7%86%E5%9B%BE/">
<meta property="og:site_name" content="funtim的博客">
<meta property="og:description" content="视图视图是从 Revit 模型生成的图像，具有对文档中存储的数据的特权访问权限。它们可以是图形 （如计划） 或文本 （如计划）。每个项目文档都有一个或多个不同的视图。最后一个聚焦窗口是活动视图。 Autodesk.Revit.DB.View 类是 Revit 文档中所有视图类型的基类。Autodesk.Revit.UI.UIView 类表示 Revit 用户界面中的窗口视图。 在以下部分中，您将了">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://funtim41.github.io/images/4stars.png">
<meta property="article:published_time" content="2024-12-05T14:33:57.000Z">
<meta property="article:modified_time" content="2024-12-29T07:31:06.868Z">
<meta property="article:author" content="funtim41@gmail.com">
<meta property="article:tag" content="Revit">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://funtim41.github.io/images/4stars.png"><link rel="shortcut icon" href="/images/OIP.jfif"><link rel="canonical" href="https://funtim41.github.io/2024/12/05/%E4%BA%8C%E5%BC%80%E6%8C%87%E5%8D%97/10%E8%A7%86%E5%9B%BE/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: funtim41@gmail.com","link":"链接: ","source":"来源: funtim的博客","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'null',
  Snackbar: {"chs_to_cht":"已切换为繁体中文","cht_to_chs":"已切换为简体中文","day_to_night":"已切换为深色模式","night_to_day":"已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: true,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '10视图',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  isShuoshuo: false
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background: Color(#995a82);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/images/4stars.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">32</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Timeline</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/Links/"><i class="fa-fw fas fa-link"></i><span> Links</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/images/topback.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/images/OIP.jfif" alt="Logo"><span class="site-name">funtim的博客</span></a><a class="nav-page-title" href="/"><span class="site-name">10视图</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Timeline</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/Links/"><i class="fa-fw fas fa-link"></i><span> Links</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">10视图</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-12-05T14:33:57.000Z" title="发表于 2024-12-05 22:33:57">2024-12-05</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-12-29T07:31:06.868Z" title="更新于 2024-12-29 15:31:06">2024-12-29</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Revit%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%E4%BA%BA%E5%91%98%E6%8C%87%E5%8D%97/">Revit二次开发人员指南</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="视图"><a href="#视图" class="headerlink" title="视图"></a><a target="_blank" rel="noopener" href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_Basic_Interaction_with_Revit_Elements_Views_html">视图</a></h1><p>视图是从 Revit 模型生成的图像，具有对文档中存储的数据的特权访问权限。它们可以是图形 （如计划） 或文本 （如计划）。每个项目文档都有一个或多个不同的视图。最后一个聚焦窗口是活动视图。</p>
<p>Autodesk.Revit.DB.View 类是 Revit 文档中所有视图类型的基类。Autodesk.Revit.UI.UIView 类表示 Revit 用户界面中的窗口视图。</p>
<p>在以下部分中，您将了解如何生成视图、Revit 支持的视图类型、每个视图的功能以及用户界面中视图窗口的可用功能。</p>
<p>Pages in this section 此部分中的页面</p>
<ul>
<li>About views 关于视图</li>
<li>View Graphics 视图图形</li>
<li>View Types 视图类型</li>
<li>Revisions 修改</li>
<li>View Filters 视图筛选器</li>
<li>View Cropping 视图裁剪</li>
<li>Displaced Views 置换视图</li>
<li>UIView</li>
</ul>
<h2 id="关于视图"><a href="#关于视图" class="headerlink" title="关于视图"></a>关于视图</h2><p>Revit API 提供对视图属性的访问，以及以编程方式创建和删除视图的功能。</p>
<p>本节是一个高级概述，其中包括以下内容：</p>
<ul>
<li>视图是如何生成的</li>
<li>视图类型</li>
<li>查看导航工具</li>
<li>创建和删除视图。</li>
</ul>
<h3 id="视图的生成"><a href="#视图的生成" class="headerlink" title="视图的生成"></a>视图的生成</h3><p>下图说明了视图是如何生成的。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-EBFC1A8B-6618-4D25-BAEF-AD97A02830F5-low.png"></p>
<p>图 94： 创建视图过程</p>
<p>每个视图都是通过将三维对象投影到二维投影平面上来生成的。投影分为两个基本类：</p>
<ul>
<li>Perspective 透视</li>
<li>Parallel 平行</li>
</ul>
<p>确定投影类型后，必须指定需要 3D 模型和渲染场景的条件。有关投影的更多信息，请参阅 View3D 部分。</p>
<p>世界坐标包括以下内容：</p>
<ul>
<li>观看者的眼睛位置</li>
<li>显示投影的视图平面位置。</li>
</ul>
<p>Revit 使用两个坐标系：</p>
<ul>
<li>建筑所在的全局空间或模型空间坐标</li>
<li>视图坐标系。</li>
</ul>
<p>视图坐标系表示模型在观察者视图中的呈现方式。它的原点是查看者的眼睛位置，其在模型空间中的坐标由View.Origin属性检索。X、Y和Z轴分别由View.RightDirection、View.UpDirection和View.ViewDirection属性表示。</p>
<ul>
<li>View.RightDirection 朝向屏幕右侧。</li>
<li>View.UpDirection 朝向屏幕的上方。</li>
<li>View.ViewDirection 从屏幕到观察者的方向。</li>
</ul>
<p>视图坐标系是右手坐标系。有关详细信息，请参见View3D和View3D中的平行投影图片。</p>
<p>在投影到投影平面上之前，将排除3D模型空间中不显示的某些部分，例如位于查看器后面或距离太远而无法清晰显示的部分。此操作需要裁剪视图。以下规则适用于裁剪：</p>
<ul>
<li>Elements outside of the crop region are no longer in the view.<br>裁剪区域之外的图元将不再位于视图中。</li>
<li>View.GetCropRegionShapeManager方法返回ViewCropRegionShapeManager，它提供裁剪区域的边界信息，裁剪区域可以是矩形，也可以不是矩形。</li>
<li>View.CropBoxVisible属性确定裁剪框在视图中是否可见。</li>
<li>View.CropBoxActive属性确定裁剪框是否实际用于裁剪视图。</li>
</ul>
<p>裁剪后，模型将投影到投影平面上。以下规则适用于投影：</p>
<ul>
<li>投影内容映射到屏幕视图端口进行显示。</li>
<li>在映射过程中，投影内容会被缩放，以便在屏幕上正确显示。</li>
<li>View.Scale属性是实际模型大小与视图大小的比率。</li>
<li>图纸上的视图边界是裁剪区域，它是裁剪形状在投影平面上的投影。</li>
<li>裁剪区域的大小和位置由View.Outline属性确定。</li>
</ul>
<h3 id="视图导航工具"><a href="#视图导航工具" class="headerlink" title="视图导航工具"></a>视图导航工具</h3><p>您可以访问有关当前在View Cube设置中设置的主视图摄影机的信息。文档只能设置一个主视图摄像机。这对应于用户调用ViewCube UI命令以在ViewCube右键单击关联菜单中“将当前视图设置为主视图”时保存的视图方向和其他摄影机参数。</p>
<p>通过调用静态方法ViewNavigationToolSettings.GetViewNavigationToolSettings（）访问ViewNavigationToolSettings，该方法将返回与文档关联的ViewNavigationToolSettings元素。</p>
<p>ViewNavigationToolSettings将允许您查询是否已使用IsHomeCameraSet（）方法设置主视图，该方法返回指示主视图设置的当前状态的布尔值。</p>
<p>通过使用ViewNavigationToolSettings.GetHomeCamera（）方法获取主摄影机的副本，可以访问有关在ViewCube中设置的主摄影机的只读信息。如果HomeCamera尚未设置，则此函数返回“否”。HomeCamera类提供有关相机和模型中存储的主视图方向（如EyePosition和UpDirection）的视图的信息。</p>
<h3 id="创建和删除视图"><a href="#创建和删除视图" class="headerlink" title="创建和删除视图"></a>创建和删除视图</h3><p>Revit Platform API提供了多种方法来创建从Autodesk.Revit.DB.View类派生的相应视图图元。大多数视图类型都是使用派生视图类的静态方法创建的。如果视图创建成功，这些方法返回对视图的引用，否则返回null。在下面的部分中，将针对每个视图类描述这些方法。</p>
<p>也可以使用View.Duplicate（）方法创建视图。可以从现有视图创建新视图，并可以选择新视图是从属视图还是具有详图。以下示例演示如何创建新的依赖视图。</p>
<p>代码区域：创建依赖视图</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> View <span class="title">CreateDependentCopy</span>(<span class="params">View view</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    View dependentView = <span class="literal">null</span>;</span><br><span class="line">    ElementId newViewId = ElementId.InvalidElementId;</span><br><span class="line">    <span class="keyword">if</span> (view.CanViewBeDuplicated(ViewDuplicateOption.AsDependent))</span><br><span class="line">    &#123;</span><br><span class="line">        newViewId = view.Duplicate(ViewDuplicateOption.AsDependent);</span><br><span class="line">        dependentView = view.Document.GetElement(newViewId) <span class="keyword">as</span> View;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != dependentView)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (dependentView.GetPrimaryViewId() == view.Id)</span><br><span class="line">            &#123;</span><br><span class="line">                TaskDialog.Show(<span class="string">&quot;Dependent View&quot;</span>, <span class="string">&quot;Dependent view created successfully!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dependentView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用Document.Delete（）方法和视图ID删除视图。您还可以删除与视图关联的元素。例如，删除标高图元会导致Revit删除相应的平面视图，或删除相机图元会导致Revit删除相应的三维视图。</p>
<p>依赖视图 如上所述，可以使用View.Duplicate（）方法并传入ViewDuplicationOption枚举器的AsDependent值来创建依赖视图。从属视图将与主视图和所有其他从属视图保持同步，以便在一个视图中进行视图特定更改（如视图比例和注释）时，这些更改将反映在所有视图中。并非所有视图类型都可以复制，并且不能从另一个从属视图创建从属视图。使用View.CanViewBeDuplicated（）确保可以从视图生成依赖视图。此方法采用ViewDuplicationOption枚举来检查是否可以以特定方式复制视图。可以将视图复制为独立视图，但不能复制为从属视图。 从属视图具有有效的主视图元素ID，可以从方法View.GetPrimaryViewId（）获得该ID。独立视图的主视图ID为InvalidElementId。可以使用View.ConvertToIndependent（）方法将依赖视图转换为独立视图。如果视图不是依赖的，这个方法将抛出一个异常。</p>
<p>代码区域：使依赖视图独立</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">MakeViewIndependent</span>(<span class="params">View view</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Independent views will have an InvalidElementId for the Primary View Id</span></span><br><span class="line">    <span class="keyword">if</span> (view.GetPrimaryViewId() != ElementId.InvalidElementId)</span><br><span class="line">    &#123;</span><br><span class="line">        view.ConvertToIndependent();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="视图图形"><a href="#视图图形" class="headerlink" title="视图图形"></a>视图图形</h2><p>视图的许多图形元素和显示选项都是通过API公开的。</p>
<p>视图类具有用于获取和设置显示样式设置和详细程度设置的属性。View. DisplayStyle属性使用DisplayStyle枚举，并与Revit窗口底部可用的显示选项相对应，如下所示。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/DisplayStyles.jpg"></p>
<p>注意：不能从Revit AP将显示样式设置为光线跟踪，因为此显示样式会将Revit置于功能有限的受限模式。View. DetailLevel属性使用ViewDetailLevel枚举，并对应于Revit窗口底部可用的详细程度选项，如下所示。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/DetailLevel.jpg"></p>
<p>ViewDetailLevel枚举在给定View不使用详细级别的情况下包含Undefined。</p>
<h3 id="Thin-Lines-细线"><a href="#Thin-Lines-细线" class="headerlink" title="Thin Lines 细线"></a>Thin Lines 细线</h3><p>“细线”选项（在Revit UI的“视图”选项卡的“图形”面板上可用）控制如何在视图中绘制线。通常，在小比例视图中放大模型时，元素线看起来比实际粗得多。启用“细线”时，无论缩放级别如何，所有线条都将绘制为单一宽度。此选项通过ThinLinesOptions实用程序类提供，该类具有一个名为AreThinLinesEnabled的属性。它是影响整个Revit任务的静态属性。</p>
<h3 id="临时视图模式"><a href="#临时视图模式" class="headerlink" title="临时视图模式"></a>临时视图模式</h3><p>TemporaryViewModes类允许控制临时视图模式。可以从View.TemporaryViewModes属性访问它。对于不支持临时视图模式的视图，此属性将为空。RevealConstraints、RevealHiddenElements和WorksharingDisplay属性可用于获取和设置相应视图中这些模式的当前状态。请注意，某些模式仅在某些视图和&#x2F;或特定上下文中可用。另外，在当前上下文中不一定启用可用模式。TemporaryViewModes方法IsModeAvailable（）和IsModeEnabled（）可用于测试特定模式在使用前是否可用和启用。这些方法采用TemporaryViewMode枚举。可能的选项如下所示。</p>
<table>
<thead>
<tr>
<th><strong>Member Name 成员名称</strong></th>
<th><strong>Description 描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>RevealHiddenElements</td>
<td>显示隐藏元素模式</td>
</tr>
<tr>
<td>TemporaryHideIsolate</td>
<td>临时隐藏&#x2F;隔离模式</td>
</tr>
<tr>
<td>WorksharingDisplay</td>
<td>工作共享显示模式</td>
</tr>
<tr>
<td>TemporaryViewProperties</td>
<td>临时视图属性模式</td>
</tr>
<tr>
<td>Raytrace</td>
<td>在交互式光线跟踪中显示模型的模式</td>
</tr>
<tr>
<td>ExplodedView</td>
<td>以分解视图显示模型并允许用户更改&#x2F;配置的模式</td>
</tr>
<tr>
<td>RevealConstraints</td>
<td>显示模型中元素之间约束的模式</td>
</tr>
</tbody></table>
<p>代码区域：显示视图中的隐藏元素</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">RevealHiddenElementsInView</span>(<span class="params">View view</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">bool</span> hiddenRevealed = <span class="literal">false</span>;</span><br><span class="line">    TemporaryViewModes viewModes = view.TemporaryViewModes;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (viewModes == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        TaskDialog.Show(<span class="string">&quot;Invalid View&quot;</span>, <span class="string">&quot;This view does not support temporary view modes.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Mode must be available and enabled to be activated</span></span><br><span class="line">        <span class="keyword">if</span> (viewModes.IsModeEnabled(TemporaryViewMode.RevealHiddenElements) &amp;&amp; viewModes.IsModeAvailable(TemporaryViewMode.RevealHiddenElements))</span><br><span class="line">        &#123;</span><br><span class="line">            viewModes.RevealHiddenElements = <span class="literal">true</span>;</span><br><span class="line">            hiddenRevealed = viewModes.RevealHiddenElements;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> hiddenRevealed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>IsModeActive（）方法测试给定的模式当前是否在视图中处于活动状态。使用DeactivateAllModes（）方法停用所有当前活动的视图，或使用DeactiveMode（）停用特定模式。 PreviewFamilyVisibility属性获取和设置关联视图中PreviewFamilyVisibility模式的当前状态。仅当视图的文档位于族编辑器的环境中时，此模式才可用。此属性是PreviewFamilyVisibilityMode枚举值而不是bool。此模式的可能状态为：</p>
<table>
<thead>
<tr>
<th>**Member Name **</th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Off</td>
<td>未应用图元可见性。所有族元素均可见。</td>
</tr>
<tr>
<td>On</td>
<td>视图的图元可见性应用于仅显示可见图元。由参照平面剪切的图元将显示其各自的剪切几何图元。</td>
</tr>
<tr>
<td>Uncut</td>
<td>视图的图元可见性应用于在实例未被剪切时显示可见的图元。请注意，此状态仅在某些视图（如楼层平面和天花板）中可用。</td>
</tr>
</tbody></table>
<p>即使视图的PreviewFamilyVisibility模式可用并已启用，也并非所有状态在所有视图中都有效。在将这些状态之一应用于视图之前，调用IsValidState（）以确保可以应用它。</p>
<p>代码区域：关闭预览族可见性模式</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TurnOffFamilyVisibilityMode</span>(<span class="params">View view</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    TemporaryViewModes viewModes = view.TemporaryViewModes;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (viewModes != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (viewModes.IsModeAvailable(TemporaryViewMode.PreviewFamilyVisibility) &amp;&amp; viewModes.IsModeEnabled(TemporaryViewMode.PreviewFamilyVisibility))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (viewModes.IsValidState(PreviewFamilyVisibilityMode.Off))</span><br><span class="line">            &#123;</span><br><span class="line">                viewModes.PreviewFamilyVisibility = PreviewFamilyVisibilityMode.Off;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首次打开视图时，其PreviewFamilyVisibility模式的状态将根据默认设置确定，该默认设置通过静态TemporaryViewModes属性PreviewFamilyVisibilityDefaultOnState和PreviewFamilyVisibilityDefaultUncutState进行控制，如下所示。</p>
<p>代码区域：设置默认预览族可见性状态</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetDefaultPreviewFamilyVisibilityState</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    TemporaryViewModes.PreviewFamilyVisibilityDefaultOnState = <span class="literal">true</span>;</span><br><span class="line">    TemporaryViewModes.PreviewFamilyVisibilityDefaultUncutState = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>PreviewFamilyVisibilityDefaultOnState值控制是否默认打开每个新打开的视图的PreviewFamilyVisibility模式。此属性适用于所有类型的视图。同时支持剪切和未剪切预览的视图（如楼层平面）将使用由PreviewFamilyVisibilityDefaultUncutState属性指示的剪切&#x2F;未剪切状态，但前提是PreviewFamilyVisibilityDefaultOnState属性设置为true。 这些设置适用于整个应用程序，而不是单个族文档;这些值在Revit任务之间保持不变。尽管允许随时设置该值，但在Revit应用程序初始化后所做的任何更改在下一个Revit任务之前都不会生效。 请注意，一旦显式修改PreviewFamilyVisibility属性，即使在关闭视图并稍后再次重新打开之后，应用的设置也会对相应视图保持有效。</p>
<p>视图中元素可见性 </p>
<p>视图跟踪可见元素。所有在视图中可见的图形化元素都可以使用FilteredElementCollector进行检索，该Collector是用文档和视图的id构造的。然而，集合中的某些元素可能被其他元素隐藏或覆盖。可以通过旋转视图或移除覆盖它们的图元来查看它们。删除这些可见图元可能需要Revit重新生成视图的几何图形。当您的代码第一次为给定视图使用此构造函数时，或者当您的代码第一次为显示设置刚刚更改的视图使用此构造函数时，您可能会遇到显著的性能下降。 可以在特定视图中隐藏单个图元。方法Element.IsHidden（）指示元素是否在给定视图中隐藏，Element.CanBeHidden（）返回元素是否可以隐藏。要隐藏单个元素，请使用View.HideElements（），它接受与要隐藏的元素相对应的ElementId集合。 元素可见性也可以按类别更改。 GetCategoryHidden（）方法查询类别ID以确定它在视图中是隐藏还是可见。 方法的作用是：将特定类别中的所有元素设置为隐藏或可见。 * CanCategoryBeHidden（）方法指示是否可以在视图中隐藏特定类别的元素。 基于视图的FilteredElementCollector将仅包含当前视图中可见的元素。不能检索非图形元素或不可见元素。基于文档的FilteredElementCollector检索文档中的所有元素，包括不可见元素和非图形元素。例如，在空项目中创建默认三维视图时，视图中没有元素，但文档中有许多元素，所有这些元素都不可见。 下面的代码示例计算活动文档和活动视图中墙类别元素的数量。活动视图中的元素数量与文档中的元素数量不同，因为文档包含非图形墙类别元素。</p>
<p>代码区域：计算活动视图中的元素</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">CountElements</span>(<span class="params">UIDocument uiDoc</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    StringBuilder message = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    FilteredElementCollector viewCollector = </span><br><span class="line">        <span class="keyword">new</span> FilteredElementCollector(uiDoc.Document, uiDoc.ActiveView.Id);</span><br><span class="line">    viewCollector.OfCategory(BuiltInCategory.OST_Walls);</span><br><span class="line">    message.AppendLine(<span class="string">&quot;Wall category elements within active View: &quot;</span></span><br><span class="line">        + viewCollector.ToElementIds().Count);</span><br><span class="line"></span><br><span class="line">    FilteredElementCollector docCollector = <span class="keyword">new</span> FilteredElementCollector(uiDoc.Document);</span><br><span class="line">    docCollector.OfCategory(BuiltInCategory.OST_Walls);</span><br><span class="line">    message.AppendLine(<span class="string">&quot;Wall category elements within document: &quot;</span></span><br><span class="line">        + docCollector.ToElementIds().Count);</span><br><span class="line"></span><br><span class="line">    TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>, message.ToString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>临时视图模式会影响图元的可见性。IsInTemporaryViewMode（）方法可用于确定View是否处于临时视图模式。方法View.IsElementVisibleInTemporaryViewMode（）标识元素在指定的视图模式中是否应可见。这仅适用于TemporaryHideIsolate和AnalyticalModel视图模式。其他模式将导致异常。 </p>
<p>深度提示 ViewDisplayDepthCueing类提供了对剖面视图和立面视图中远处对象显示的控制。当景深效果处于活动状态时，随着与观察者距离的增加，对象会融入背景色（淡入淡出）。可以使用View.GetDepthCueing（）检索视图的当前深度提示设置。如果对返回的ViewDisplayDepthCueing进行了更改，则在调用View.SetDepthCueing（）之前，这些更改不会应用于视图。 ViewDisplayDepthCueing类具有以下属性：</p>
<table>
<thead>
<tr>
<th><strong>Member Name 成员名称</strong></th>
<th><strong>Description 描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>EnableDepthCueing</td>
<td>为True，则启用深度提示。</td>
</tr>
<tr>
<td>StartPercentage</td>
<td>指示深度提示开始的位置。值为0表示深度提示从视图的前剪辑平面开始。</td>
</tr>
<tr>
<td>EndPercentage</td>
<td>指示深度提示结束的位置。比结束平面更远的对象将与结束平面处的对象淡入淡出相同的量。值100表示远剪裁平面。</td>
</tr>
<tr>
<td>FadeTo</td>
<td>指示通过深度提示淡入淡出对象的最大量。值为100表示完全不可见。</td>
</tr>
</tbody></table>
<p>SetStartEndPerception（）方法可用于在一次调用中设置开始和结束百分比。 下面的示例演示如何获取当前深度提示、更改其属性并将其设置回视图。请注意，并非所有视图都可以使用深度提示。</p>
<p>代码区域：更改视图的深度提示</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">AdjustDepthCueing</span>(<span class="params">View view</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (view.CanUseDepthCueing())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">using</span> (Transaction t = <span class="keyword">new</span> Transaction(view.Document, <span class="string">&quot;Change depth cueing&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            t.Start();</span><br><span class="line">            ViewDisplayDepthCueing depthCueing = view.GetDepthCueing();</span><br><span class="line">            depthCueing.EnableDepthCueing = <span class="literal">true</span>;</span><br><span class="line">            depthCueing.FadeTo = <span class="number">50</span>;    <span class="comment">// set fade to percent</span></span><br><span class="line">            depthCueing.SetStartEndPercentages(<span class="number">0</span>, <span class="number">75</span>);</span><br><span class="line">            view.SetDepthCueing(depthCueing);</span><br><span class="line">            t.Commit();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="视图类型"><a href="#视图类型" class="headerlink" title="视图类型"></a>视图类型</h2><p>不同类型的Revit视图由Revit API中的不同类表示。有关每种视图类型的详细信息，请参阅以下主题。</p>
<p>本节中的页面</p>
<ul>
<li>概述</li>
<li>3D视图</li>
<li>视图平面</li>
<li>视图图纸</li>
<li>剖面图</li>
<li>图纸</li>
<li>图表</li>
</ul>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>一个项目模型可以有几种视图类型。在API中，有三种方法对视图进行分类。第一种方法是使用视图元素View.ViewType属性。它返回指示视图类型的枚举值。下表列出了所有可用的视图类型。</p>
<p>表44：Autodesk.Revit.DB.ViewType</p>
<table>
<thead>
<tr>
<th><strong>Member Name 成员名称</strong></th>
<th><strong>Description 描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>AreaPlan</td>
<td>区域视图。</td>
</tr>
<tr>
<td>CeilingPlan</td>
<td>天花板反射平面图。</td>
</tr>
<tr>
<td>ColumnSchedule</td>
<td>柱表视图。</td>
</tr>
<tr>
<td>CostReport</td>
<td>成本报告视图。</td>
</tr>
<tr>
<td>Detail</td>
<td>局部视图。</td>
</tr>
<tr>
<td>DraftingView</td>
<td>草图视图。</td>
</tr>
<tr>
<td>DrawingSheet</td>
<td>图纸工作表。</td>
</tr>
<tr>
<td>Elevation</td>
<td>立面视图。</td>
</tr>
<tr>
<td>EngineeringPlan</td>
<td>工程视图。</td>
</tr>
<tr>
<td>FloorPlan</td>
<td>楼层平面视图。</td>
</tr>
<tr>
<td>Internal</td>
<td>Revit的内部视图。</td>
</tr>
<tr>
<td>Legend</td>
<td>图例视图。</td>
</tr>
<tr>
<td>LoadsReport</td>
<td>荷载报告视图。</td>
</tr>
<tr>
<td>PanelSchedule</td>
<td>配电盘明细表视图。</td>
</tr>
<tr>
<td>PressureLossReport</td>
<td>压力损失报告视图。</td>
</tr>
<tr>
<td>Rendering</td>
<td>渲染视图。</td>
</tr>
<tr>
<td>Report</td>
<td>报告视图。</td>
</tr>
<tr>
<td>Schedule</td>
<td>视图表。</td>
</tr>
<tr>
<td>Section</td>
<td>剖面视图。</td>
</tr>
<tr>
<td>ThreeD</td>
<td>3D视图。</td>
</tr>
<tr>
<td>Undefined</td>
<td>未定义&#x2F;未指定视图。</td>
</tr>
<tr>
<td>Walkthrough</td>
<td>Walkthrough视图。</td>
</tr>
</tbody></table>
<p>分类视图的第二种方法是按类类型。下表列出了项目浏览器中的视图类型和相应视图。</p>
<p>表45：项目浏览器视图</p>
<table>
<thead>
<tr>
<th><strong>Project Browser Views 项目浏览器视图</strong></th>
<th><strong>View Type 视图类型</strong></th>
<th><strong>Class Type 类类型</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Area Plans</td>
<td>ViewType.AreaPlan</td>
<td>Elements.ViewPlan</td>
</tr>
<tr>
<td>Ceiling Plans</td>
<td>ViewType.CeilingPlan</td>
<td>Elements.ViewPlan</td>
</tr>
<tr>
<td>Graphic Column Schedule</td>
<td>ViewType.ColumnSchedule</td>
<td>Elements.View</td>
</tr>
<tr>
<td>Detail Views</td>
<td>ViewType.Detail</td>
<td>Elements.ViewSection</td>
</tr>
<tr>
<td>Drafting Views</td>
<td>ViewType.DraftingView</td>
<td>Elements.ViewDrafting</td>
</tr>
<tr>
<td>Sheets</td>
<td>ViewType.DrawingSheet</td>
<td>Elements.ViewSheet</td>
</tr>
<tr>
<td>Elevations</td>
<td>ViewType.Elevation</td>
<td>Elements.ViewSection</td>
</tr>
<tr>
<td>Structural Plans</td>
<td>ViewType.EngineeringPlan</td>
<td>Elements.ViewPlan</td>
</tr>
<tr>
<td>Floor Plans</td>
<td>ViewType.FloorPlan</td>
<td>Elements.ViewPlan</td>
</tr>
<tr>
<td>Legends</td>
<td>ViewType.Legend</td>
<td>Elements.View</td>
</tr>
<tr>
<td>Reports (MEP engineering)</td>
<td>ViewType.LoadsReport</td>
<td>Elements.View</td>
</tr>
<tr>
<td>Reports (MEP engineering)</td>
<td>ViewType.PanelSchedule</td>
<td>Elements.PanelScheduleView</td>
</tr>
<tr>
<td>Reports (MEP engineering)</td>
<td>ViewType.PresureLossReport</td>
<td>Elements.View</td>
</tr>
<tr>
<td>Renderings</td>
<td>ViewType.Rendering</td>
<td>Elements.ViewDrafting</td>
</tr>
<tr>
<td>Reports</td>
<td>ViewType.Report</td>
<td>Elements.View</td>
</tr>
<tr>
<td>Schedules&#x2F;Quantities</td>
<td>ViewType.Schedule</td>
<td>Elements.ViewSchedule</td>
</tr>
<tr>
<td>Sections</td>
<td>ViewType.Section</td>
<td>Elements.ViewSection</td>
</tr>
<tr>
<td>3D Views</td>
<td>ViewType.ThreeD</td>
<td>Elements.View3D</td>
</tr>
<tr>
<td>Walkthroughs</td>
<td>ViewType.Walkthrough</td>
<td>Elements.View3D</td>
</tr>
</tbody></table>
<p>此示例说明如何使用视图的ViewType属性来确定视图的类型。</p>
<p>代码区域：确定视图类型</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetViewType</span>(<span class="params">Autodesk.Revit.DB.View view</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">// Get the view type of the given view, and format the prompt string</span></span><br><span class="line">        String prompt = <span class="string">&quot;The view is &quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (view.ViewType)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">case</span> ViewType.AreaPlan:</span><br><span class="line">                        prompt += <span class="string">&quot;an area view.&quot;</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> ViewType.CeilingPlan:</span><br><span class="line">                        prompt += <span class="string">&quot;a reflected ceiling plan view.&quot;</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> ViewType.ColumnSchedule:</span><br><span class="line">                        prompt += <span class="string">&quot;a column schedule view.&quot;</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> ViewType.CostReport:</span><br><span class="line">                        prompt += <span class="string">&quot;a cost report view.&quot;</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> ViewType.Detail:</span><br><span class="line">                        prompt += <span class="string">&quot;a detail view.&quot;</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> ViewType.DraftingView:</span><br><span class="line">                        prompt += <span class="string">&quot;a drafting view.&quot;</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> ViewType.DrawingSheet:</span><br><span class="line">                        prompt += <span class="string">&quot;a drawing sheet view.&quot;</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> ViewType.Elevation:</span><br><span class="line">                        prompt += <span class="string">&quot;an elevation view.&quot;</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> ViewType.EngineeringPlan:</span><br><span class="line">                        prompt += <span class="string">&quot;an engineering view.&quot;</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> ViewType.FloorPlan:</span><br><span class="line">                        prompt += <span class="string">&quot;a floor plan view.&quot;</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">                <span class="literal">default</span>:</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Give the user some information</span></span><br><span class="line">        MessageBox.Show(prompt, <span class="string">&quot;Revit&quot;</span>, MessageBoxButtons.OK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分类视图的第三种方法是使用ViewFamilyType类。大多数视图创建方法需要新视图的ViewFamilyType的ID。可以从View.GetTypeId（）方法中检索ViewFamilyType的ID。ViewFamily属性返回ViewFamily枚举，它指定ViewFamilyType的族，类似于上面记录的ViewType枚举。下面的示例说明如何从View获取ViewFamily。</p>
<p>代码区域：从ViewFamilyType确定视图类型</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ViewFamily <span class="title">GetViewFamily</span>(<span class="params">Document doc, View view</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ViewFamily viewFamily = ViewFamily.Invalid;</span><br><span class="line"></span><br><span class="line">    ElementId viewTypeId = view.GetTypeId();</span><br><span class="line">    <span class="keyword">if</span> (viewTypeId.IntegerValue &gt; <span class="number">1</span>) <span class="comment">// some views may not have a ViewFamilyType</span></span><br><span class="line">    &#123;</span><br><span class="line">        ViewFamilyType viewFamilyType = doc.GetElement(viewTypeId) <span class="keyword">as</span> ViewFamilyType;</span><br><span class="line">        viewFamily = viewFamilyType.ViewFamily;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> viewFamily;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3D视图"><a href="#3D视图" class="headerlink" title="3D视图"></a>3D视图</h3><p>View3D是一个自由导向的三维视图。</p>
<p>有两种三维视图：透视视图和等轴测视图，在Revit用户界面中也称为正交视图。差异基于投影射线关系。View3D.IsPerspective属性指示三维视图是透视视图还是等轴测视图。</p>
<h4 id="透视图"><a href="#透视图" class="headerlink" title="透视图"></a>透视图</h4><p>下图说明了如何创建透视图。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-EF11532A-32D3-40C1-9410-5AADA6FD8701-low.png"></p>
<p>图96：透视投影</p>
<ul>
<li>直投影射线穿过模型中的每个点并与投影平面相交以形成投影内容。</li>
<li>为了便于从世界坐标到视图平面的变换，视图坐标系基于观察者。</li>
<li>它的原点由View.Origin属性表示，是查看者的位置。</li>
<li>使用ViewOrientation3D.EyePosition属性（从View3D.GetOrientation（）检索）检索查看器的世界坐标。因此，在3D视图中，View.Origin始终等于相应的ViewOrientation3D.EyePosition。</li>
<li>如上图所述，<em>观察</em>坐标系确定如下：<ul>
<li>X轴由View.RightDirection确定。</li>
<li>Y轴由View.UpDirection确定。</li>
<li>Z轴由View.ViewDirection确定。</li>
</ul>
</li>
<li>观看方向是在3D空间中从目标点到观看者，以及在屏幕空间中从屏幕到观看者。</li>
</ul>
<p>静态方法View3D.ViewPerspective（）方法可用于创建新的透视图。</p>
<p>代码区域：View3D.CreatePerspective（）</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> View3D View3D.CreatePerspective (Document document, ElementId viewFamilyTypeId;</span><br></pre></td></tr></table></figure>

<p>viewFamilyTypeId参数必须是三维ViewType。 下面的代码示例说明如何创建透视三维视图。</p>
<p>代码区域：创建透视三维视图</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Find a 3D view type</span></span><br><span class="line">IEnumerable viewFamilyTypes = <span class="function"><span class="keyword">from</span> elem <span class="keyword">in</span> <span class="keyword">new</span> <span class="title">FilteredElementCollector</span>(<span class="params">document</span>).<span class="title">OfClass</span>(<span class="params"><span class="keyword">typeof</span>(ViewFamilyType</span>))</span></span><br><span class="line"><span class="function">                                                <span class="keyword">let</span> type</span> = elem <span class="keyword">as</span> ViewFamilyType</span><br><span class="line">                                                <span class="keyword">where</span> type.ViewFamily == ViewFamily.ThreeDimensional</span><br><span class="line">                                                <span class="keyword">select</span> type;</span><br><span class="line"><span class="comment">// Create a new Perspective View3D</span></span><br><span class="line">View3D view3D = View3D.CreatePerspective(document, viewFamilyTypes.First().Id);</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">null</span> != view3D)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// By default, the 3D view uses a default orientation.</span></span><br><span class="line">    <span class="comment">// Change the orientation by creating and setting a ViewOrientation3D </span></span><br><span class="line">    XYZ eye = <span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">-100</span>, <span class="number">10</span>); </span><br><span class="line">    XYZ up = <span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>); </span><br><span class="line">    XYZ forward = <span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>); </span><br><span class="line">    view3D.SetOrientation(<span class="keyword">new</span> ViewOrientation3D(eye, up, forward));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// turn off the far clip plane with standard parameter API</span></span><br><span class="line">    Parameter farClip = view3D.LookupParameter(<span class="string">&quot;Far Clip Active&quot;</span>);</span><br><span class="line">    farClip.Set(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>透视视图裁剪框是锥体的一部分，其顶点位于查看者位置。它是两个平行剪裁平面之间的几何体。裁剪框限定模型中被裁剪并投影到视图平面上的部分。 裁剪框由View.CropBox属性表示，该属性返回一个BoundingBoxXYZ对象。 CropBox.Min和CropBox.Max点在上一张图片中标记。请注意，透视图中的CropBox.Min点是通过将裁剪框前裁剪平面投影到后裁剪平面上而生成的。 裁剪框坐标基于查看坐标系。使用Transform.OfPoint（）将CropBox.Min和CropBox.Max变换到世界坐标系。有关变换的更多详细信息，请参见几何部分中的几何辅助类。 投影平面加上前剪裁平面和后剪裁平面都垂直于视图方向。CropBox.Max和CropBox.Min之间的线与查看方向平行。利用这些因子，可以计算裁剪框几何形状。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-CCAE0F1D-6889-4225-900A-45CF0D207B15-low.png"></p>
<p>图97：透视3D视图</p>
<p>上图显示了裁剪后屏幕上的投影平面。裁剪区域是投影平面和裁剪框的矩形相交。 使用View.CropRegion属性检索几何信息。此属性返回BoundingBoxUV实例。 View.Outline.Max属性指向右上角。 View.Outline.Min属性指向左下角。 与裁剪框类似，裁剪区域坐标基于查看坐标系。下列表达式是相等的。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">View.CropBox.Max.X(Y) / View.OutLine.Max.X(Y) == View.CropBox.Min.X(Y) / View.OutLine.Min.X(Y) </span><br></pre></td></tr></table></figure>

<p>由于物体的透视投影的大小与从该物体到投影中心的距离成反比，因此比例对于透视图来说是没有意义的。透视三维视图的“比例”属性始终返回零。 #管理摄像头目标 相机表示透视视图的查看者正在查看的方向。如果用户或API应用调整裁剪区域以暴露更宽的视场或不对称的视场，则透视图的失真可能变得过于剧烈。可以通过调用View3D方法RestCameraTarget（）将摄像机目标定位在视场的中心，从而将摄像机目标强制定位到观察区域的中心。在调用之前，请检查是否可以使用View3D.CanResetCameraTarget（）方法在此视图中重置摄像机，该方法指示是否可以重置摄像机目标。无法重置目标的主要情况是View3D当前处于等轴测投影中。尝试在等轴测视图中重置相机目标将引发Autodesk. Revit. Exceptions. InvalidOperationException。</p>
<p>等距视图 可以使用静态View3D.NETIsometric（）方法创建新的等轴测视图。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-6B8688A8-D480-4C35-84A2-5CA5CF8D1577-low.png"></p>
<p>图98：平行投影 </p>
<p>等轴测视图是使用平行投影光线通过将模型投影到与光线垂直的平面上而生成的。查看坐标系类似于透视图，但裁剪框是一个平行六面体，其面与投影光线平行或垂直。View.CropBox属性指向两个对角，其坐标基于查看坐标系。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-A25AEAB3-BBF1-41E9-8B40-B1D40168A7AE-low.png"></p>
<p>图99：将视图平面上的窗口缩放到屏幕视口</p>
<p> 模型将投影到视图平面上，然后缩放到屏幕上。View.Scale属性表示实际模型大小与视图大小的比率。相关表达式如下：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">View.CropBox.Max.X(Y) / View.OutLine.Max.X(Y) == View.CropBox.Min.X(Y) / View.OutLine.Min.X(Y) == View.Scale </span><br></pre></td></tr></table></figure>

<p>代码区域：View3D.Other Isometric（）</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> View3D View3D.CreateIsometric (Document document, ElementId viewFamilyTypeId;</span><br></pre></td></tr></table></figure>

<p>viewFamilyTypeId参数必须是三维ViewType。Revit确定以下内容：观察者的位置。 如何使用视图方向创建视图坐标系。 * 如何创建裁剪框来裁剪模型。 创建视图后，可以调整裁剪框的大小以查看模型的不同部分。也可以更改默认方向。API不支持修改查看坐标系。 下面的代码示例说明如何创建等轴测三维视图。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Find a 3D view type</span></span><br><span class="line"></span><br><span class="line">IEnumerable viewFamilyTypes = <span class="function"><span class="keyword">from</span> elem <span class="keyword">in</span> <span class="keyword">new</span> <span class="title">FilteredElementCollector</span>(<span class="params">document</span>).<span class="title">OfClass</span>(<span class="params"><span class="keyword">typeof</span>(ViewFamilyType</span>))</span></span><br><span class="line"><span class="function">                                              <span class="keyword">let</span> type</span> = elem <span class="keyword">as</span> ViewFamilyType</span><br><span class="line">                                              <span class="keyword">where</span> type.ViewFamily == ViewFamily.ThreeDimensional</span><br><span class="line">                                              <span class="keyword">select</span> type;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a new View3D</span></span><br><span class="line">View3D view3D = View3D.CreateIsometric(document, viewFamilyTypes.First().Id);</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">null</span> != view3D)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// By default, the 3D view uses a default orientation.</span></span><br><span class="line">    <span class="comment">// Change the orientation by creating and setting a ViewOrientation3D </span></span><br><span class="line">    XYZ eye = <span class="keyword">new</span> XYZ(<span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line">    XYZ up = <span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    XYZ forward = <span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    ViewOrientation3D viewOrientation3D = newViewOrientation3D(eye, up, forward);</span><br><span class="line">    view3D.SetOrientation(viewOrientation3D);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="在等距和透视之间切换"><a href="#在等距和透视之间切换" class="headerlink" title="在等距和透视之间切换"></a>在等距和透视之间切换</h4><p>大多数情况下，View3D可以在“等轴测”和“透视”之间切换，前提是视图中没有视图特定的元素。View3D类提供了在等轴测和透视模式之间切换视图的方法。在切换之前，使用CanToggleBetweenPerspectiveAndIsometric（）方法，该方法指示是否可以进行切换。</p>
<p>要切换视图，请调用以下两个View 3D类方法之一：ToggleToPerspective（）或ToggleToIsometric（）。如果无法切换视图（可能是由于视图中存在特定于视图的元素），则这两种方法中的任何一种都将引发Autodesk. Revit. Exceptions. InvalidOperationException。</p>
<h4 id="3D视图剖面框"><a href="#3D视图剖面框" class="headerlink" title="3D视图剖面框"></a>3D视图剖面框</h4><p>每个视图都有一个裁剪框。裁剪框聚焦于要投影并显示在视图中的模型部分。对于三维视图，还有另一个名为剖面框的框。</p>
<ul>
<li>剖面框确定在三维视图中显示的模型部分。</li>
<li>剖面框用于剪裁三维模型的可见部分。</li>
<li>即使在裁剪框中，框外的部分也不可见。</li>
<li>剖面框与裁剪框的不同之处在于，剖面框可以随模型一起旋转和移动。</li>
</ul>
<p>剖面框对于大型模型特别有用。例如，如果要渲染大型建筑，请使用剖面框。剖面框限制用于计算的模型部分。若要显示剖面框，请在“三维视图图元属性”对话框的“范围”区域中选择“剖面框”。也可以使用IsSectionBoxActive属性设置它。在下面的示例中，如果活动视图是三维视图，它将设置剖面框是否处于活动状态。</p>
<p>代码区域：显示&#x2F;隐藏剖面框</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ShowHideSectionBox</span>(<span class="params">UIDocument document, <span class="built_in">bool</span> active</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (document.ActiveView <span class="keyword">is</span> View3D)</span><br><span class="line">    &#123;</span><br><span class="line">        View3D view3d = document.ActiveView <span class="keyword">as</span> View3D;</span><br><span class="line">        view3d.IsSectionBoxActive = active;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-016E48BA-138E-4686-B864-D4A978DC406C-low.png"></p>
<p>图100：剖面框</p>
<p> View3D.GetSectionBox（）和View3D.SetSectionBox（）方法用于获取和更改长方体范围。在某些情况下，调用View3D.SetSectionBox（）可能会产生副作用。将该属性设置为某些值可以更改框的容量并将其显示在视图中。若要避免显示剖面框，请将IsSectionBoxActive属性设置为false。 下面的代码示例阐释如何更改剖面框的范围。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ExpandSectionBox</span>(<span class="params">View3D view</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// The original section box</span></span><br><span class="line">    BoundingBoxXYZ sectionBox = view.GetSectionBox();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Expand the section box (doubling in size in all directions while preserving the same center and orientation)</span></span><br><span class="line">    Autodesk.Revit.DB.XYZ deltaXYZ = sectionBox.Max - sectionBox.Min;</span><br><span class="line">    sectionBox.Max += deltaXYZ / <span class="number">2</span>;</span><br><span class="line">    sectionBox.Min -= deltaXYZ / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//After resetting the section box, it will be shown in the view.</span></span><br><span class="line">    <span class="comment">//It only works when the Section Box is active</span></span><br><span class="line">    view.SetSectionBox(sectionBox);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从GetSectionBox（）方法返回的BoundingBoxXYZ的Max和Min点的坐标不是全局坐标。要将Max和Min的坐标转换为全局坐标，需要通过从BoundingBoxXYZ.Transform属性获得的变换来转换每个点。</p>
<p>代码区域：将最大值和最小值转换为全局坐标</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ConvertMaxMinToGlobal</span>(<span class="params">View3D view, <span class="keyword">out</span> XYZ max, <span class="keyword">out</span> XYZ min</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    BoundingBoxXYZ sectionbox = view.GetSectionBox();</span><br><span class="line">    Transform transform = sectionbox.Transform;</span><br><span class="line">    max = transform.OfPoint(sectionbox.Max);</span><br><span class="line">    min = transform.OfPoint(sectionbox.Min);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="视图锁定"><a href="#视图锁定" class="headerlink" title="视图锁定"></a>视图锁定</h4><p>View3D类具有与Revit用户界面中可用的锁定功能相对应的方法和属性。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/3DLocking.jpg"></p>
<p>View3D.SaveOrientationAndLock（）方法将保存方向并锁定视图，而View3D.RestoreOrientationAndLock（）将恢复视图的方向并锁定它。View3D.RestoreOrientationAndLock（）将解锁当前锁定的视图。IsLocked属性将返回3D视图当前是否被锁定。</p>
<h3 id="视图平面"><a href="#视图平面" class="headerlink" title="视图平面"></a>视图平面</h3><p>平面视图是基于标高的。平面视图有三种类型：楼层平面视图、天花板平面视图和面积平面视图。</p>
<h4 id="创建平面视图"><a href="#创建平面视图" class="headerlink" title="创建平面视图"></a>创建平面视图</h4><ul>
<li>通常，楼层平面视图是在新项目中打开的默认视图。</li>
<li>大多数项目至少包括一个楼层平面视图和一个天花板平面视图。</li>
<li>通常在向项目中添加新标高后创建平面视图。</li>
</ul>
<p>使用API添加新标高不会自动添加平面视图。使用静态ViewPlan.Create（）方法创建新的地板和天花板平面视图。使用静态ViewPlan. ViewAreaPlan（）方法创建新的面积平面视图。</p>
<p>代码区域：创建平面视图</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ViewPlan ViewPlan.Create(Document document, ElementId viewFamilyTypeId, ElementId levelId);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ViewPlan ViewPlan.CreateAreaPlan(Document document, ElementId areaSchemeId, ElementId levelId);</span><br></pre></td></tr></table></figure>

<p>ViewPlan.Create（）中的viewFamilyTypeId参数必须是FloorPlan、CeilingPlan、AreaPlan或StructuralPlan ViewType。levelId参数表示与平面视图关联的项目中标高图元的ID。 下面的代码基于某个标高创建楼层平面和天花板平面。</p>
<p>代码区域：创建楼层平面和天花板平面</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">CreateViewPlan</span>(<span class="params">Autodesk.Revit.DB.Document document</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">    IList viewFamilyTypes = collector.OfClass(<span class="keyword">typeof</span>(ViewFamilyType)).ToElements();</span><br><span class="line">    ElementId floorPlanId = <span class="keyword">new</span> ElementId(<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">foreach</span> (Element e <span class="keyword">in</span> viewFamilyTypes)</span><br><span class="line">    &#123;</span><br><span class="line">        ViewFamilyType v = e <span class="keyword">as</span> ViewFamilyType;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (v != <span class="literal">null</span> &amp;&amp; v.ViewFamily == ViewFamily.FloorPlan)</span><br><span class="line">        &#123;</span><br><span class="line">            floorPlanId = e.Id;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ElementId ceilingPlanId = <span class="keyword">new</span> ElementId(<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">foreach</span> (Element e <span class="keyword">in</span> viewFamilyTypes)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.Name == <span class="string">&quot;Ceiling Plan&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ceilingPlanId = e.Id;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create a Level and a Floor Plan based on it</span></span><br><span class="line">    <span class="built_in">double</span> elevation = <span class="number">10.0</span>;</span><br><span class="line">    Level level1 = Level.Create(document, elevation);</span><br><span class="line">    ViewPlan floorView = ViewPlan.Create(document, floorPlanId, level1.Id);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create another Level and a Ceiling Plan based on it</span></span><br><span class="line">    elevation += <span class="number">10.0</span>;</span><br><span class="line">    Level level2 = Level.Create(document, elevation);</span><br><span class="line">    ViewPlan ceilingView = ViewPlan.Create(document, ceilingPlanId, level2.Id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="平面视图属性"><a href="#平面视图属性" class="headerlink" title="平面视图属性"></a>平面视图属性</h4><p>创建新平面视图后，可以使用类型为ViewDiscipline的Discipline参数设置视图的Discipline。选项包括建筑、结构、机械、电气、管道和协调。</p>
<p>对于结构平面视图，可以使用ViewFamilyType.PlanViewDirection属性将视图方向设置为“向上”或“向下”。尽管它是ViewFamilyType类的属性，但如果为StructuralPlan视图以外的视图访问该属性，则将引发异常。</p>
<h4 id="视图范围"><a href="#视图范围" class="headerlink" title="视图范围"></a>视图范围</h4><p>可以通过ViewPlan.GetViewRange（）方法检索平面视图的视图范围。返回的PlanViewRange对象可用于查找平面相对的标高以及每个平面与该标高的偏移量。该信息与Revit用户界面的“视图范围”对话框中提供的信息相同：</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/ViewRange-76168.jpg"></p>
<p>以下示例显示如何获取平面视图的顶部剪裁平面和关联偏移</p>
<p>代码区域：获取视图范围的信息</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ViewRange</span>(<span class="params">Document doc, View view</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (view <span class="keyword">is</span> ViewPlan)</span><br><span class="line">    &#123;</span><br><span class="line">        ViewPlan viewPlan = view <span class="keyword">as</span> ViewPlan;</span><br><span class="line">        PlanViewRange viewRange = viewPlan.GetViewRange();</span><br><span class="line"></span><br><span class="line">        ElementId topClipPlane = viewRange.GetLevelId(PlanViewPlane.TopClipPlane);</span><br><span class="line">        <span class="built_in">double</span> dOffset = viewRange.GetOffset(PlanViewPlane.TopClipPlane);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (topClipPlane.IntegerValue &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Element levelAbove = doc.GetElement(topClipPlane);</span><br><span class="line">            TaskDialog.Show(view.Name, <span class="string">&quot;Top Clip Plane: &quot;</span> + levelAbove.Name + <span class="string">&quot;\r\nTop Offset: &quot;</span> + dOffset + <span class="string">&quot; ft&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="平面图underlay"><a href="#平面图underlay" class="headerlink" title="平面图underlay"></a>平面图underlay</h4><p>可以从ViewPlan中检索和设置顶层和底层范围。使用GetUnderlayBaseLevel（）和SetUnderlayBaseLevel（）访问对象范围的基准标高。如果基本级别ID为InvalidElementId，则不设置无效基本级别，并且没有元素显示为无效。设置参考底图范围的基准标高时，下一个最高标高的高程将用于确定参考底图范围的顶部。如果为基准标高指定的标高是最高标高，则该范围将是无边界的，并且将由指定标高以上的所有内容组成。</p>
<p>使用GetUnderlayTopLevel（）和SetUnderlayRange（）访问对象范围的顶级。如果GetUnderlayTopLevel（）返回InvalidElementId，并且XML基础级别是有效级别，则XML范围是无边界的，并且包含XML基础级别之上的所有内容。若要设置顶层，必须使用SetUnderlayRange（），该方法将ElementIds用于底层和顶层。如果顶层的高程不大于底层的高程，此方法将引发异常。</p>
<p>使用GetUnderlayOrientation（）和SetUnderlayOrientation（）方法控制如何查看视图中的元素。UnderlayOrientation可以是LookingDown（向下查看图元，就像从上面向下查看一样）或LookingUp（向上查看图元，就像从下面向上查看一样）。</p>
<p>如果当前方向为LookingDown且顶级Id与新值不同，则以下代码设置范围。然后方向更改为LookingUp。</p>
<p>代码区域：更改视图范围</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ViewUnderlay</span>(<span class="params">ViewPlan planView, ElementId topLevelId, ElementId baseLevelId</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (planView.GetUnderlayOrientation() == UnderlayOrientation.LookingDown)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (planView.GetUnderlayTopLevel() != topLevelId)</span><br><span class="line">        &#123;</span><br><span class="line">            planView.SetUnderlayRange(baseLevelId, topLevelId);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        planView.SetUnderlayOrientation(UnderlayOrientation.LookingUp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="视图图纸"><a href="#视图图纸" class="headerlink" title="视图图纸"></a>视图图纸</h3><p>视图，用于创建不属于建模设计的、不关联的视图专有详图。</p>
<p>图纸视图未与模型关联。它允许用户创建不包括在模型中的详图。</p>
<ul>
<li><p>在绘图视图中，用户可以以不同的视图比例（粗略、精细或中等）创建详图。</p>
</li>
<li><p>您可以使用2D详图工具，包括：</p>
<table>
<thead>
<tr>
<th><em>Detail lines</em> Detail regions <em>Detail components</em> Insulation <em>详图线</em>详图区域<em>详图构件</em>隔热层</th>
<th><em>Reference planes</em> Dimensions <em>Symbols</em> Text <em>参照平面</em>尺寸<em>符号</em>文字</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>这些工具与用于创建局部视图的工具相同。</p>
</li>
<li><p>图纸视图不显示模型图元。</p>
</li>
</ul>
<p>使用静态ViewDrafting.Create（）方法创建图纸视图。模型图元不显示在图纸视图中。</p>
<h4 id="图片视图"><a href="#图片视图" class="headerlink" title="图片视图"></a>图片视图</h4><p>ImageView类派生自ViewDrafting。它可用于创建包含从磁盘导入的图像的渲染视图。使用静态ImageView.Create（）方法创建新的呈现视图。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/RenderingView-76170.jpg"></p>
<h3 id="剖面视图"><a href="#剖面视图" class="headerlink" title="剖面视图"></a>剖面视图</h3><p>表示剖面视图、局部视图、俯视图和立面视图，以及参照详图索引和参照剖面。</p>
<p>ViewSection类可用于创建剖面视图、局部视图、局部视图、参照详图索引和参照剖面。它还表示立面视图。</p>
<p>剖面视图和参照剖面</p>
<p>剖面视图剖切模型以显示内部结构。ViewSection.ViewSection（）方法创建剖面视图。</p>
<p>代码区域：ViewSection. ViewSection（）</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ViewSection ViewSection.CreateSection(Document document, ElementId viewFamilyTypeId, BoundingBoxXYZ sectionBox);</span><br></pre></td></tr></table></figure>

<p>viewFamilyTypeId参数是新ViewSection将使用的ViewFamilyType的ID。类型必须是截面视图族。sectionBox参数是剖面视图裁剪框。它提供剖面视图所需的方向和范围。通常，另一个视图的裁剪框用作参数。您还可以构建自定义BoundingBoxXYZ实例来表示方向和范围。 下面的代码演示如何创建剖面视图。将在墙的中心创建剖面视图的边界框。生成的剖面视图将位于项目浏览器的“剖面（建筑剖面）”节点中。请注意，远裁剪距离将等于创建时边界框的最小值和最大值的z坐标之差。</p>
<p>代码区域：创建剖面图</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Find a section view type</span></span><br><span class="line">IEnumerable viewFamilyTypes = <span class="function"><span class="keyword">from</span> elem <span class="keyword">in</span> <span class="keyword">new</span> <span class="title">FilteredElementCollector</span>(<span class="params">document</span>).<span class="title">OfClass</span>(<span class="params"><span class="keyword">typeof</span>(ViewFamilyType</span>))</span></span><br><span class="line"><span class="function">                                                <span class="keyword">let</span> type</span> = elem <span class="keyword">as</span> ViewFamilyType</span><br><span class="line">                                                <span class="keyword">where</span> type.ViewFamily == ViewFamily.Section</span><br><span class="line">                                                <span class="keyword">select</span> type;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a BoundingBoxXYZ instance centered on wall</span></span><br><span class="line">LocationCurve lc = wall.Location <span class="keyword">as</span> LocationCurve;</span><br><span class="line">Transform curveTransform = lc.Curve.ComputeDerivatives(<span class="number">0.5</span>, <span class="literal">true</span>);</span><br><span class="line"><span class="comment">// using 0.5 and &quot;true&quot; (to specify that the parameter is normalized) </span></span><br><span class="line"><span class="comment">// places the transform&#x27;s origin at the center of the location curve)</span></span><br><span class="line"></span><br><span class="line">XYZ origin = curveTransform.Origin; <span class="comment">// mid-point of location curve</span></span><br><span class="line">XYZ viewDirection = curveTransform.BasisX.Normalize(); <span class="comment">// tangent vector along the location curve</span></span><br><span class="line">XYZ normal = viewDirection.CrossProduct(XYZ.BasisZ).Normalize(); <span class="comment">// location curve normal @ mid-point</span></span><br><span class="line"></span><br><span class="line">Transform transform = Transform.Identity;</span><br><span class="line">transform.Origin = origin;</span><br><span class="line">transform.BasisX = normal;</span><br><span class="line">transform.BasisY = XYZ.BasisZ;</span><br><span class="line"></span><br><span class="line"><span class="comment">// can use this simplification because wall&#x27;s &quot;up&quot; is vertical.</span></span><br><span class="line"><span class="comment">// For a non-vertical situation (such as section through a sloped floor the surface normal would be needed)</span></span><br><span class="line">transform.BasisZ = normal.CrossProduct(XYZ.BasisZ);</span><br><span class="line"></span><br><span class="line">BoundingBoxXYZ sectionBox = <span class="keyword">new</span> BoundingBoxXYZ();</span><br><span class="line">sectionBox.Transform = transform;</span><br><span class="line">sectionBox.Min = <span class="keyword">new</span> XYZ(<span class="number">-10</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">sectionBox.Max = <span class="keyword">new</span> XYZ(<span class="number">10</span>,<span class="number">12</span>,<span class="number">5</span>);</span><br><span class="line"><span class="comment">// Min &amp; Max X values (-10 &amp; 10) define the section line length on each side of the wall</span></span><br><span class="line"><span class="comment">// Max Y (12) is the height of the section box// Max Z (5) is the far clip offset</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a new view section.</span></span><br><span class="line">ViewSection viewSection = ViewSection.CreateSection(document, viewFamilyTypes.First().Id, sectionBox);</span><br></pre></td></tr></table></figure>

<p>参照剖面是参照现有视图的剖面。创建新参照剖面时，Revit不会添加新视图。</p>
<p>代码区域：ViewSection. ViewReferenceSection（）</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ViewSection ViewSection.CreateReferenceSection(Document document, </span><br><span class="line">                                                      ElementId parentViewId,</span><br><span class="line">                                                      ElementId viewIdToReference, </span><br><span class="line">                                                      XYZ headPoint, </span><br><span class="line">                                                      XYZ tailPoint);</span><br></pre></td></tr></table></figure>

<p>parentViewId参数是将在其中显示新引用截面标记的视图的ID。可以在“楼层平面”、“天花板平面”、“结构平面”、“剖面”、“立面”、“绘图”和“详图”视图中创建参照剖面。viewIdToReference可以是详图、绘图或剖面视图的ID。新参照截面将使用参照视图的ViewFamilyType。这两个XYZ点将确定父视图中截面标记标头的位置。 #详细视图 局部视图是模型的视图，在其他视图中显示为剖面或截面。这种类型的视图通常以比父视图中更精细的细节比例来表示模型。它用于向模型的特定部分添加更多信息。静态ViewSection. ViewDetail（）方法用于创建新的细节ViewSection。</p>
<p>代码区域：ViewSection. ViewDetail（）</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ViewSection ViewSection.CreateDetail(Document document, ElementId viewFamilyTypeId, BoundingBoxXYZ sectionBox);</span><br></pre></td></tr></table></figure>

<p>viewFamilyTypeId参数是新ViewSection将使用的ViewFamilyType的ID。类型必须是详图视图族。与标准剖面视图一样，sectionBox参数是剖面视图裁剪框。它提供剖面视图所需的方向和范围。 添加新详图ViewSection后，它将显示在项目浏览器的“详图视图（Detail）”节点中。 #立面视图 立面视图是模型的横截面，其中显示标高线。立面视图由ViewSection类表示。但是，与其他类型的横断面图不同，不能使用ViewSection类的静态方法创建立面视图。要创建立面视图，请先创建立面标记，然后使用该标记生成立面视图。新创建的立面视图将显示在项目浏览器的“立面（建筑立面）”节点中。它将被分配一个唯一的名称。 以下示例基于梁的位置创建立面视图。</p>
<p>代码区域：创建立面视图</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ViewSection <span class="title">CreateElevationView</span>(<span class="params">Document document, FamilyInstance beam</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Find an elevation view type</span></span><br><span class="line">    IEnumerable viewFamilyTypes = <span class="function"><span class="keyword">from</span> elem <span class="keyword">in</span> <span class="keyword">new</span> <span class="title">FilteredElementCollector</span>(<span class="params">document</span>).<span class="title">OfClass</span>(<span class="params"><span class="keyword">typeof</span>(ViewFamilyType</span>))</span></span><br><span class="line"><span class="function">                                                    <span class="keyword">let</span> type</span> = elem <span class="keyword">as</span> ViewFamilyType</span><br><span class="line">                                                    <span class="keyword">where</span> type.ViewFamily == ViewFamily.Elevation</span><br><span class="line">                                                    <span class="keyword">select</span> type;</span><br><span class="line"></span><br><span class="line">    LocationCurve lc = beam.Location <span class="keyword">as</span> LocationCurve;</span><br><span class="line">    XYZ xyz = lc.Curve.GetEndPoint(<span class="number">0</span>);</span><br><span class="line">    ElevationMarker marker = ElevationMarker.CreateElevationMarker(document, viewFamilyTypes.First().Id, xyz, <span class="number">1</span>);</span><br><span class="line">    ViewSection elevationView = marker.CreateElevation(document, document.ActiveView.Id, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> elevationView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ElevationMarker. Elevation（）方法将ViewPlan的id作为参数。这是ElevationMarker可见的ViewPlan。新的立面ViewSection将从ViewPlan中导出其范围并继承设置。最后一个参数是将放置新立面视图的ElevationMarker上的索引。ElevationMarker上的索引必须有效且未使用。视图的方向由索引决定。 #标注和参考标注 视图以较大比例显示另一个视图的一部分。可以使用静态方法ViewSection. callout（）创建标注视图。详图索引可以在“楼层平面”、“天花板平面”、“结构平面”、“剖面”、“立面”、“绘图”和“详图”视图中创建。生成的视图将是ViewSection、ViewPlan或ViewDetail，具体取决于所使用的ViewFamilyType，并将显示在项目浏览器的相应节点中。</p>
<p>代码区域：ViewSection. callout（）</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ViewSection ViewSection.CreateCallout(Document document, </span><br><span class="line">                                            ElementId parentViewId, </span><br><span class="line">                                            ElementId viewFamilyTypeId,</span><br><span class="line">                                            XYZ point1,</span><br><span class="line">                                            XYZ point2);</span><br></pre></td></tr></table></figure>

<p>父视图ID参数可以是可在其上创建详图索引的任何类型的视图的ID。点参数确定父视图中的图元符号的范围。参照图元是指引用现有视图的图元。添加参照视图时，Revit不会在项目中创建视图。相反，它创建一个指向指定的现有视图的指针。多个参照详图索引可以指向同一视图。</p>
<p>代码区域：ViewSection. ViewReferenceCallout（）</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ViewSection ViewSection.CreateReferenceCallout(Document document, </span><br><span class="line">                                                      ElementId parentViewId, </span><br><span class="line">                                                      ElementId viewIdToReference,</span><br><span class="line">                                                      XYZ point1,</span><br><span class="line">                                                      XYZ point2);</span><br></pre></td></tr></table></figure>

<p>创建引用对象与创建对象类似。但是，与其将视图的ViewFamilyType的Id作为参数，还不如将视图ReferenceCallout（）方法作为要引用的视图的Id。被引用视图的ViewFamilyType将由新引用对象使用。 只能参照裁剪的视图，除非参照的视图是“绘图”视图。无论父视图类型如何，始终可以参照绘图视图。立面视图可以从立面父视图和图纸父视图中参照。可以从“截面”和“绘图”父视图中参照截面视图。可以从所有父视图中参照详图视图，但在FloorPlan、CeilingPlan和StructuralPlan父视图中除外，在这些父视图中只能参照水平方向的详图视图。FloorPlan、CeilingPlan和StructuralPlan视图可以从FloorPlan、CeilingPlan和StructuralPlan父视图中引用。 下面的示例使用Detail ViewFamilyType创建新的图元，然后使用新的图元视图创建引用图元。</p>
<p>代码区域：创建对象和引用对象</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">CreateCalloutView</span>(<span class="params">Document document, View parentView</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Find a detail view type</span></span><br><span class="line">    IEnumerable viewFamilyTypes = <span class="function"><span class="keyword">from</span> elem <span class="keyword">in</span> <span class="keyword">new</span> <span class="title">FilteredElementCollector</span>(<span class="params">document</span>).<span class="title">OfClass</span>(<span class="params"><span class="keyword">typeof</span>(ViewFamilyType</span>))</span></span><br><span class="line"><span class="function">                                                    <span class="keyword">let</span> type</span> = elem <span class="keyword">as</span> ViewFamilyType</span><br><span class="line">                                                    <span class="keyword">where</span> type.ViewFamily == ViewFamily.Detail</span><br><span class="line">                                                    <span class="keyword">select</span> type;</span><br><span class="line"></span><br><span class="line">    ElementId viewFamilyTypeId = viewFamilyTypes.First().Id;    XYZ point1 = <span class="keyword">new</span> XYZ(<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">    XYZ point2 = <span class="keyword">new</span> XYZ(<span class="number">30</span>, <span class="number">30</span>, <span class="number">30</span>);</span><br><span class="line">    ElementId parentViewId = parentView.Id;  <span class="comment">// a ViewPlan</span></span><br><span class="line">    View view = ViewSection.CreateCallout(document, parentViewId, viewFamilyTypeId, point1, point2);</span><br><span class="line"></span><br><span class="line">    ViewSection.CreateReferenceCallout(document, parentViewId, view.Id, point1, point2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="图纸"><a href="#图纸" class="headerlink" title="图纸"></a>图纸</h3><p>图纸包含视图和标题栏。使用ViewSheet.Create（）方法创建图纸视图时，标题栏族符号Id是该方法的必需参数。可以使用FilteredElementCollector找到标题栏族符号。</p>
<p>代码区域：ViewSheet.Create（）</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ViewSheet ViewSheet.Create(Document document, ElementId titleBlockTypeId);</span><br></pre></td></tr></table></figure>

<p>新创建的图纸没有视图。Viewport.Create（）方法用于添加视图。Viewport类用于将常规视图添加到视图工作表，即平面、立面、绘图和三维视图。若要向视图添加明细表，请改用ScheduleSheetInstance.Create（）。</p>
<p>代码区域：添加两个在左角对齐的视图</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PlaceAlignedViewsAtLeftCorner</span>(<span class="params">Document doc</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    FilteredElementCollector fec = <span class="keyword">new</span> FilteredElementCollector(doc);</span><br><span class="line">    fec.OfClass(<span class="keyword">typeof</span>(ViewPlan));</span><br><span class="line">    <span class="keyword">var</span> viewPlans = fec.Cast().Where(vp =&gt; !vp.IsTemplate &amp;&amp; vp.ViewType == ViewType.CeilingPlan);</span><br><span class="line"></span><br><span class="line">    ViewPlan vp1 = viewPlans.ElementAt(<span class="number">0</span>);</span><br><span class="line">    ViewPlan vp2 = viewPlans.ElementAt(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> (Transaction t = <span class="keyword">new</span> Transaction(doc, <span class="string">&quot;Place on sheet&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        t.Start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Add two viewports distinct from one another</span></span><br><span class="line">        ViewSheet vs = ViewSheet.Create(doc, ElementId.InvalidElementId);</span><br><span class="line">        Viewport viewport1 = Viewport.Create(doc, vs.Id, vp1.Id, <span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">        Viewport viewport2 = Viewport.Create(doc, vs.Id, vp2.Id, <span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">5</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">        doc.Regenerate();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Calculate the necessary move vector to align the lower left corner</span></span><br><span class="line">        Outline outline1 = viewport1.GetBoxOutline();</span><br><span class="line">        Outline outline2 = viewport2.GetBoxOutline();</span><br><span class="line">        XYZ boxCenter = viewport2.GetBoxCenter();</span><br><span class="line">        XYZ vectorToCenter = boxCenter - outline2.MinimumPoint;</span><br><span class="line">        XYZ newCenter = outline1.MinimumPoint + vectorToCenter;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Move the viewport to the new location</span></span><br><span class="line">        viewport2.SetBoxCenter(newCenter);</span><br><span class="line"></span><br><span class="line">        t.Commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>XYZ位置参数标识添加的视图所在的位置。它指向添加的视图的中心坐标（以英寸为单位）。 坐标[0，0]是相对于工作表左下角的坐标。 在完整的图形集中，每张图纸都有唯一的图纸编号。该编号将显示在项目浏览器中图纸名称的前面。使用视图标题中的图纸编号可以方便地交叉参考图形集中的图纸。可以使用SheetNumber属性检索或修改编号。数字必须是唯一的;否则，当您将数字设置为重复值时，将引发异常。 下面的示例说明如何创建和打印工作表视图。开始，在文档中查找可用的标题栏（在本例中使用过滤器），然后使用它创建图纸视图。接下来，添加三维视图。视图将以其左下角位于图纸中心的方式放置。最后，通过调用View.Print（）方法打印工作表。</p>
<p>代码区域：创建图纸视图</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">CreateSheetView</span>(<span class="params">Autodesk.Revit.DB.Document document, View3D view3D</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get an available title block from document</span></span><br><span class="line">    FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">    collector.OfClass(<span class="keyword">typeof</span>(FamilySymbol));</span><br><span class="line">    collector.OfCategory(BuiltInCategory.OST_TitleBlocks);</span><br><span class="line"></span><br><span class="line">    FamilySymbol fs = collector.FirstElement() <span class="keyword">as</span> FamilySymbol;</span><br><span class="line">    <span class="keyword">if</span> (fs != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">using</span> (Transaction t = <span class="keyword">new</span> Transaction(document, <span class="string">&quot;Create a new ViewSheet&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            t.Start();</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// Create a sheet view</span></span><br><span class="line">                ViewSheet viewSheet = ViewSheet.Create(document, fs.Id);</span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">null</span> == viewSheet)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Failed to create new ViewSheet.&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Add passed in view onto the center of the sheet</span></span><br><span class="line">                UV location = <span class="keyword">new</span> UV((viewSheet.Outline.Max.U - viewSheet.Outline.Min.U) / <span class="number">2</span>,</span><br><span class="line">                                        (viewSheet.Outline.Max.V - viewSheet.Outline.Min.V) / <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//viewSheet.AddView(view3D, location);</span></span><br><span class="line">                Viewport.Create(document, viewSheet.Id, view3D.Id, <span class="keyword">new</span> XYZ(location.U, location.V, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Print the sheet out</span></span><br><span class="line">                <span class="keyword">if</span> (viewSheet.CanBePrinted)</span><br><span class="line">                &#123;</span><br><span class="line">                    TaskDialog taskDialog = <span class="keyword">new</span> TaskDialog(<span class="string">&quot;Revit&quot;</span>);</span><br><span class="line">                    taskDialog.MainContent = <span class="string">&quot;Print the sheet?&quot;</span>;</span><br><span class="line">                    TaskDialogCommonButtons buttons = TaskDialogCommonButtons.Yes | TaskDialogCommonButtons.No;</span><br><span class="line">                    taskDialog.CommonButtons = buttons;</span><br><span class="line">                    TaskDialogResult result = taskDialog.Show();</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (result == TaskDialogResult.Yes)</span><br><span class="line">                    &#123;</span><br><span class="line">                        viewSheet.Print();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                t.Commit();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span></span><br><span class="line">            &#123;</span><br><span class="line">                t.RollBack();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：不能将工作表视图添加到另一个工作表，也不能将视图添加到多个工作表;否则会发生参数异常。</p>
<p>表单修订</p>
<p>ViewSheet类有几种用于处理图纸上的修订和云线批注的方法。</p>
<ul>
<li>GetAllRevisionIds（）-获取参与图纸修订明细表的修订的有序数组。</li>
<li>GetAdditionalRevisionIds（）-获取图纸修订明细表中额外包含的修订。SetAdditionalRevisionIds（）-设置要另外包含在图纸修订明细表中的修订。</li>
<li>GetCurrentRevision（）-返回此视图表中显示的最新编号版本。</li>
<li>GetRevisionCloudNumberOnSheet（）-当项目中的编号是按图纸编号时，获取此图纸上RevisionCloud的修订号。</li>
<li>GetRevisionNumberOnSheet（）-获取特定修订的修订号，当项目中的编号是按图纸编号时，该修订号将显示在此图纸上。</li>
</ul>
<p> 根据项目中的修订顺序对修订进行排序。附加包含的修订将始终参与图纸的修订明细表。通常，修订明细表中会列出修订明细表，因为其关联的RevisionClouds之一存在于图纸中。 下面的代码示例演示如何向图纸添加与给定条件匹配的其他修订。</p>
<p>代码区域：向图纸添加其他修订</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">AddAdditionalRevisionsToSheet</span>(<span class="params">ViewSheet viewSheet, String toMatch</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Document doc = viewSheet.Document;</span><br><span class="line"></span><br><span class="line">    ICollection revisions = viewSheet.GetAdditionalRevisionIds();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find revisions whose description matches input string</span></span><br><span class="line">    FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(doc);</span><br><span class="line">    collector.OfCategory(BuiltInCategory.OST_Revisions);</span><br><span class="line">    collector.WhereElementIsNotElementType();</span><br><span class="line">    <span class="keyword">if</span> (revisions.Count &gt; <span class="number">0</span>)</span><br><span class="line">        collector.Excluding(revisions);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check if revision should be added</span></span><br><span class="line">    <span class="keyword">foreach</span> (Element revision <span class="keyword">in</span> collector)</span><br><span class="line">    &#123;</span><br><span class="line">        Parameter descriptionParam = revision.get_Parameter(BuiltInParameter.PROJECT_REVISION_REVISION_DESCRIPTION);</span><br><span class="line">        String description = descriptionParam.AsString();</span><br><span class="line">        <span class="keyword">if</span> (description.Contains(toMatch))</span><br><span class="line">            revisions.Add(revision.Id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (revisions.Count &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Apply the new list of revisions</span></span><br><span class="line">        <span class="keyword">using</span> (Transaction t = <span class="keyword">new</span> Transaction(doc, <span class="string">&quot;Add revisions to sheet&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            t.Start();</span><br><span class="line">            viewSheet.SetAdditionalRevisionIds(revisions);</span><br><span class="line">            t.Commit();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="打印机设置"><a href="#打印机设置" class="headerlink" title="打印机设置"></a>打印机设置</h4><p>在打印纸张之前，您可能需要更改打印机的设置。API使用PrintManager类和相关的Autodesk. Revit. DB类公开打印机的设置：</p>
<table>
<thead>
<tr>
<th><strong>Class 类</strong></th>
<th><strong>Functionality 功能</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Autodesk.Revit.DB.PrintManager</td>
<td>表示Revit UI中“打印”对话框（文件-&gt;Print）中的打印信息。</td>
</tr>
<tr>
<td>Autodesk.Revit.DB.PrintParameters</td>
<td>包含用于打印文档的设置的对象。</td>
</tr>
<tr>
<td>Autodesk.Revit.DB.PrintSetup</td>
<td>表示打印设置（文件-&gt;Print Setup…）在Revit UI中。</td>
</tr>
<tr>
<td>Autodesk.Revit.DB.PaperSize</td>
<td>表示Autodesk Revit项目中打印设置纸张尺寸的对象。</td>
</tr>
<tr>
<td>Autodesk.Revit.DB.PaperSizeSet</td>
<td>可以包含任意数量的纸张大小对象的集合。</td>
</tr>
<tr>
<td>Autodesk.Revit.DB.PaperSource</td>
<td>表示Autodesk Revit项目中打印设置的纸张来源的对象。</td>
</tr>
<tr>
<td>Autodesk.Revit.DB.PaperSourceSet</td>
<td>可以包含任意数量纸张源对象的集合。</td>
</tr>
<tr>
<td>Autodesk.Revit.DB.ViewSheetSetting</td>
<td>表示Revit UI中的视图&#x2F;图纸集（文件-&gt;Print）。</td>
</tr>
<tr>
<td>Autodesk.Revit.DB.PrintSetting</td>
<td>表示打印设置（文件-&gt;Print Setup…）在Revit UI中。</td>
</tr>
</tbody></table>
<p>有关使用这些对象的代码示例，请参见随Revit Platform SDK提供的ViewPrinter示例应用程序。</p>
<h3 id="图表"><a href="#图表" class="headerlink" title="图表"></a>图表</h3><p>此类表示显示数据表的视图。</p>
<p>TableView是ViewSchedule和PanelScheduleView的基类。</p>
<p>本节中的页面</p>
<ul>
<li>Schedule Classes 明细表类</li>
<li>ViewSchedule 视图明细表</li>
<li>PanelScheduleView 配电盘明细表</li>
</ul>
<h4 id="明细表类"><a href="#明细表类" class="headerlink" title="明细表类"></a>明细表类</h4><p>明细表视图使用多个支持类。</p>
<p>TableView是一个表示显示表的视图的类，它是ViewSchedule和PanelScheduleView的基类。它有一个关联的TableData类，其中包含一个或多个节。对于ViewSchedule，只有一个页眉和一个正文部分。</p>
<p>TableSectionData类表示按行和列排列的一组连续单元格。对于ViewSchedule，TableSectionData的单元格内容由ScheduleDefinition和参数生成。此外，对于ViewSchedules，虽然头部分具有读&#x2F;写权限，但主体部分是只读的。</p>
<h5 id="使用明细表中的数据"><a href="#使用明细表中的数据" class="headerlink" title="使用明细表中的数据"></a>使用明细表中的数据</h5><p>表的实际数据包含在TableData类中。虽然无法直接从TableView类获取TableData对象，但两个子类都有GetTableData（）方法。对于ViewSchedule，此方法返回一个TableData对象。对于PanelScheduleView，GetTableData（）返回PanelScheduleData对象，该对象派生自TableData基类。TableData类保存描述表中行、列和单元格样式的大部分数据。PanelScheduleData提供了专门与配电盘明细表相关的其他方法。</p>
<p>使用行、列和单元格<br>表中的数据被分解为多个部分。要使用TableData的行、列和单元格，需要获取TableSectionData对象。GetSectionData（）可以使用请求的节数据的整数或使用SectionType（即Header或Body）调用。</p>
<p>TableSectionData类可用于插入或删除行或列，格式化单元格，以及获取组成该明细表部分的单元格的详细信息，例如单元格类型（即文本或图形）或单元格的类别ID。</p>
<p>在下面的示例中，将新行添加到明细表的页眉部分，并为新创建的单元格设置文本。请注意，在使用UI创建时，页眉部分的第一行默认为标题。</p>
<p>代码区域：插入行</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">CreateSubtitle</span>(<span class="params">ViewSchedule schedule</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    TableData colTableData = schedule.GetTableData();</span><br><span class="line"></span><br><span class="line">    TableSectionData tsd = colTableData.GetSectionData(SectionType.Header);</span><br><span class="line">    tsd.InsertRow(tsd.FirstRowNumber + <span class="number">1</span>);</span><br><span class="line">    tsd.SetCellText(tsd.FirstRowNumber + <span class="number">1</span>, tsd.FirstColumnNumber, <span class="string">&quot;Schedule of column top and base levels with offsets&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另请注意，在上面的代码示例中，它使用了FirstRowNumber和FirstColumnNumber属性。在某些部分中，行或列编号可能以0开头，也可能以1开头。这些属性应始终用于代替硬编码的0或1。 在下面的示例中，将创建一个带有自定义页眉节的新单类别明细表。</p>
<p>代码区域：自定义标题部分</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CreateSingleCategoryScheduleWithSimpleHeaderSection</span>(<span class="params">Document doc</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> (Transaction t = <span class="keyword">new</span> Transaction(doc, <span class="string">&quot;Create single-category with custom headers&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Build schedule</span></span><br><span class="line">        t.Start();</span><br><span class="line">        ViewSchedule vs = ViewSchedule.CreateSchedule(doc, <span class="keyword">new</span> ElementId(BuiltInCategory.OST_Windows));</span><br><span class="line"></span><br><span class="line">        AddRegularFieldToSchedule(vs, <span class="keyword">new</span> ElementId(BuiltInParameter.WINDOW_HEIGHT));</span><br><span class="line">        AddRegularFieldToSchedule(vs, <span class="keyword">new</span> ElementId(BuiltInParameter.WINDOW_WIDTH));</span><br><span class="line">        AddRegularFieldToSchedule(vs, <span class="keyword">new</span> ElementId(BuiltInParameter.ALL_MODEL_MARK));</span><br><span class="line">        AddRegularFieldToSchedule(vs, <span class="keyword">new</span> ElementId(BuiltInParameter.ALL_MODEL_COST));</span><br><span class="line"></span><br><span class="line">        doc.Regenerate();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Get header section</span></span><br><span class="line">        TableSectionData data = vs.GetTableData().GetSectionData(SectionType.Header);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">int</span> rowNumber = data.LastRowNumber;</span><br><span class="line">        <span class="built_in">int</span> columnNumber = data.LastColumnNumber;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Get the overall width of the table so that the new columns can be resized properly</span></span><br><span class="line">        <span class="built_in">double</span> tableWidth = data.GetColumnWidth(columnNumber);</span><br><span class="line"></span><br><span class="line">        data.InsertColumn(columnNumber);</span><br><span class="line">        data.InsertColumn(columnNumber);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Refresh data to be sure that schedule is ready for text insertion</span></span><br><span class="line">        vs.RefreshData();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Set text to the first header cell</span></span><br><span class="line">        data.SetCellText(rowNumber, data.FirstColumnNumber, <span class="string">&quot;Special Window Schedule Text&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Set width of first column</span></span><br><span class="line">        data.SetColumnWidth(data.FirstColumnNumber, tableWidth / <span class="number">3.0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Set a different parameter to the second cell - the project name</span></span><br><span class="line">        data.SetCellParamIdAndCategoryId(rowNumber, data.FirstRowNumber + <span class="number">1</span>, <span class="keyword">new</span> ElementId(BuiltInParameter.PROJECT_NAME),</span><br><span class="line">                                            <span class="keyword">new</span> ElementId(BuiltInCategory.OST_ProjectInformation));</span><br><span class="line">        data.SetColumnWidth(data.FirstColumnNumber + <span class="number">1</span>, tableWidth / <span class="number">3.0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Set the third column as the schedule view name - use the special category for schedule parameters for this</span></span><br><span class="line">        data.SetCellParamIdAndCategoryId(rowNumber, data.LastColumnNumber, <span class="keyword">new</span> ElementId(BuiltInParameter.VIEW_NAME),</span><br><span class="line">                                            <span class="keyword">new</span> ElementId(BuiltInCategory.OST_ScheduleViewParamGroup));</span><br><span class="line">        data.SetColumnWidth(data.LastColumnNumber, tableWidth / <span class="number">3.0</span>);</span><br><span class="line"></span><br><span class="line">        t.Commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">AddRegularFieldToSchedule</span>(<span class="params">ViewSchedule schedule, ElementId paramId</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ScheduleDefinition definition = schedule.Definition;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find a matching SchedulableField</span></span><br><span class="line">    SchedulableField schedulableField =</span><br><span class="line">        definition.GetSchedulableFields().FirstOrDefault(sf =&gt; sf.ParameterId == paramId);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (schedulableField != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Add the found field</span></span><br><span class="line">        definition.AddField(schedulableField);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以为明细表自定义行、列或单个单元格的样式。这包括为单元格的所有四边设置边框线样式，以及单元格颜色和文本外观（即颜色，字体，大小）的能力。对于常规计划，只能在表格的标题部分执行此操作。 在下面的示例中，ViewSchedule的副标题（假定为标题部分的第二行）的字体设置为粗体，字体大小设置为10。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">FormatSubtitle</span>(<span class="params">ViewSchedule colSchedule</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    TableData colTableData = colSchedule.GetTableData();</span><br><span class="line"></span><br><span class="line">    TableSectionData tsd = colTableData.GetSectionData(SectionType.Header);</span><br><span class="line">    <span class="comment">// Subtitle is second row, first column</span></span><br><span class="line">    <span class="keyword">if</span> (tsd.AllowOverrideCellStyle(tsd.FirstRowNumber + <span class="number">1</span>, tsd.FirstColumnNumber))</span><br><span class="line">    &#123;</span><br><span class="line">        TableCellStyle tcs = <span class="keyword">new</span> TableCellStyle();</span><br><span class="line">        TableCellStyleOverrideOptions options = <span class="keyword">new</span> TableCellStyleOverrideOptions();</span><br><span class="line">        options.FontSize = <span class="literal">true</span>;</span><br><span class="line">        options.Bold = <span class="literal">true</span>;</span><br><span class="line">        tcs.SetCellStyleOverrideOptions(options);</span><br><span class="line">        tcs.IsFontBold = <span class="literal">true</span>;</span><br><span class="line">        tcs.TextSize = <span class="number">10</span>;</span><br><span class="line">        tsd.SetCellStyle(tsd.FirstRowNumber + <span class="number">1</span>, tsd.FirstColumnNumber, tcs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="视图明细表"><a href="#视图明细表" class="headerlink" title="视图明细表"></a>视图明细表</h4><p>明细表是数据的表格表示形式。典型明细表显示类别的所有图元（门、房间等）。每行表示一个元素，每列表示一个参数。</p>
<p>ViewSchedule类表示明细表和其他类似明细表的视图，包括单类别和多类别明细表、关键字明细表、材质提取、视图列表、图纸列表、注释记号图例、修订明细表和注释块。</p>
<p>ViewSchedule.Export（）方法将日程数据导出到文本文件中。</p>
<p>在图纸上放置明细表</p>
<p>静态ScheduleSheetInstance.Create（）方法在工作表上创建明细表的实例。它需要要放置明细表的图纸的ID、明细表视图的ID以及要放置明细表的图纸上的XYZ位置。ScheduleSheetInstance对象具有用于访问生成此ScheduleSheetInstance的“主”明细表的ID、明细表在图纸上的旋转、明细表在图纸上的放置位置（在图纸坐标中）以及标识ScheduleSheetInstance是否为标题栏族中的修订明细表的标志的属性。</p>
<p>本节中的页面</p>
<ul>
<li>创建明细表</li>
<li>使用视图明细表</li>
</ul>
<h5 id="创建明细表"><a href="#创建明细表" class="headerlink" title="创建明细表"></a>创建明细表</h5><p>ViewSchedule类有几种方法用于根据计划类型创建新明细表。所有这些方法都有一个Document参数，该参数是要向其中添加新明细表或类似明细表的视图的文档。新创建的明细表视图将显示在项目浏览器中的“明细表&#x2F;明细表”节点下。</p>
<p>标准的单类别或多类别明细表可以用静态ViewSchedule. fullSchedule（）方法创建。</p>
<p>代码区域：创建具有2个字段的单一类别明细表</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CreateSingleCategorySchedule</span>(<span class="params">Document doc</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> (Transaction t = <span class="keyword">new</span> Transaction(doc, <span class="string">&quot;Create single-category&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        t.Start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create schedule</span></span><br><span class="line">        ViewSchedule vs = ViewSchedule.CreateSchedule(doc, <span class="keyword">new</span> ElementId(BuiltInCategory.OST_Windows));</span><br><span class="line"></span><br><span class="line">        doc.Regenerate();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Add fields to the schedule</span></span><br><span class="line">        AddRegularFieldToSchedule(vs, <span class="keyword">new</span> ElementId(BuiltInParameter.WINDOW_HEIGHT));</span><br><span class="line">        AddRegularFieldToSchedule(vs, <span class="keyword">new</span> ElementId(BuiltInParameter.WINDOW_WIDTH));</span><br><span class="line"></span><br><span class="line">        t.Commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> </span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> Adds a single parameter field to the schedule</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">AddRegularFieldToSchedule</span>(<span class="params">ViewSchedule schedule, ElementId paramId</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ScheduleDefinition definition = schedule.Definition;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find a matching SchedulableField</span></span><br><span class="line">    SchedulableField schedulableField =</span><br><span class="line">        definition.GetSchedulableFields().FirstOrDefault(sf =&gt; sf.ParameterId == paramId);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (schedulableField != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Add the found field</span></span><br><span class="line">        definition.AddField(schedulableField);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二个参数是其图元将包含在明细表中的类别的ID，或者是多类别明细表的InvalidElementId。 第二个RISKSchedule（）方法可用于创建面积明细表，并接受一个附加参数，即明细表的面积方案ID。</p>
<p>代码区域：创建面积明细表</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(doc);</span><br><span class="line">collector.OfCategory(BuiltInCategory.OST_AreaSchemes);</span><br><span class="line"><span class="comment">//Get first ElementId of AreaScheme.</span></span><br><span class="line">ElementId areaSchemeId = collector.FirstElementId();</span><br><span class="line"><span class="keyword">if</span> (areaSchemeId != <span class="literal">null</span> &amp;&amp; areaSchemeId != ElementId.InvalidElementId)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// If you want to create an area schedule, you must use CreateSchedule method with three arguments. </span></span><br><span class="line">    <span class="comment">// The value of the second argument must be ElementId of BuiltInCategory.OST_Areas category</span></span><br><span class="line">    <span class="comment">// and the value of third argument must be ElementId of an AreaScheme.</span></span><br><span class="line">    areaSchedule = Autodesk.Revit.DB.ViewSchedule.CreateSchedule(doc, <span class="keyword">new</span> ElementId(BuiltInCategory.OST_Areas), areaSchemeId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关键字明细表显示抽象的“关键”元素，这些元素可用于填充普通模型元素的参数，并且可以使用静态ViewSchedule.CreateKeySchedule（）方法创建，该方法的第二个参数是明细表的关键字将与之关联的元素类别的ID。材料提取是一个明细表，显示有关构成模型中元素的材料的信息。与每行（分组前）表示单个元素的常规明细表不同，材料提取中的每行表示单个&lt;元素、材料&gt;对。ViewSchedule. AccessMaterialTakeoff（）方法具有与ViewSchedule. AccessSchedule（）方法相同的参数，并且允许单类别和多类别材质提取明细表。 视图列表、图纸列表和注释记号图例与指定类别相关联，因此它们的创建方法将类别ID作为参数。视图列表是项目中视图的明细表。它是视图类别的明细表，使用ViewSchedule. ViewList（）创建。 图纸列表是项目中图纸的明细表。它是“图纸”类别的明细表，使用ViewSchedule. SetSheetList（）方法创建。 注释记号图例是“注释记号标记”类别的明细表，可使用ViewSchedule.CreateKeynoteLegend（）创建。 修订明细表将添加到标题栏族中，并作为图纸上标题栏的一部分可见。如果传入的文档不是标题栏族，ViewSchedule. RevisionSchedule（）方法将引发异常。 注释块是“常规注释”类别的明细表，它显示单个族的图元，而不是类别中的所有图元。</p>
<p>代码区域：ViewSchedule. NoteBlock（）</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ViewSchedule ViewSchedule.CreateNoteBlock(Document document, ElementId familyId);</span><br></pre></td></tr></table></figure>

<p>第二个参数是其图元将包含在明细表中的族的ID。</p>
<p>代码区域：创建注释块明细表</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> (Transaction transaction = <span class="keyword">new</span> Transaction(doc, <span class="string">&quot;Creating Note BLock&quot;</span>))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//Get first ElementId of a Note Block family.</span></span><br><span class="line">    ICollection noteblockFamilies = ViewSchedule.GetValidFamiliesForNoteBlock(doc);</span><br><span class="line">    ElementId symbolId = noteblockFamilies.First();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!symbolId.Equals(ElementId.InvalidElementId))</span><br><span class="line">    &#123;</span><br><span class="line">        transaction.Start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Create a note-block view schedule.</span></span><br><span class="line">        noteBlockSchedule = ViewSchedule.CreateNoteBlock(doc, symbolId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> != areaSchedule)</span><br><span class="line">    &#123;</span><br><span class="line">        transaction.Commit();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        transaction.RollBack();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="使用ViewSchedule"><a href="#使用ViewSchedule" class="headerlink" title="使用ViewSchedule"></a>使用ViewSchedule</h5><p>ScheduleDefinition类帮助定义ViewSchedule。</p>
<p>ScheduleDefinition类包含与明细表视图内容相关的各种设置，包括：</p>
<ul>
<li>明细表的类别和其他确定明细表类型的基本属性。</li>
<li>成为明细表列的一组字段。</li>
<li>排序和分组标准。</li>
<li>限制明细表中可见图元集的过滤器。</li>
<li>控制标题和&#x2F;或页眉可见性的设置。</li>
</ul>
<p>大多数计划都包含一个通过ViewSchedule.Definition属性检索的ScheduleDefinition。在Revit中，某些类别的明细表可以包含一个“嵌入式明细表”，其中包含与主明细表中的图元相关联的图元，例如，显示每个房间内图元的房间明细表或显示与每个系统相关联的图元的风管系统明细表。嵌入的计划有自己的类别、字段、过滤器等。这些设置存储在第二个ScheduleDefinition对象中。如果存在，则从ScheduleDefinition.EmbeddedDefinition属性获取嵌入的ScheduleDefinition。</p>
<h6 id="添加字段"><a href="#添加字段" class="headerlink" title="添加字段"></a>添加字段</h6><p>创建视图明细表后，可以添加字段。ScheduleDefinition. GetControlableFields（）方法将返回一个ControlableField对象的列表，这些对象表示可能包含在计划中的非计算字段。新字段可以从可扩展字段对象或使用ScheduleFieldType添加。下表描述了可从ScheduleFieldType枚举中使用的选项。</p>
<table>
<thead>
<tr>
<th><strong>Member name 成员名称</strong></th>
<th><strong>Description 描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Instance</td>
<td>明细表图元的实例参数。所有共享参数也都使用此类型，无论它们是实例参数还是类型参数。</td>
</tr>
<tr>
<td>ElementType</td>
<td>明细表图元的类型参数。</td>
</tr>
<tr>
<td>Count</td>
<td>明细表行上显示的图元数。</td>
</tr>
<tr>
<td>ViewBased</td>
<td>用于一些参数的专用字段类型，这些参数的显示值可以根据视图的设置而更改：<em>房间明细表和空间明细表中的ROOM_AREA和ROOM_PERIMETER。</em>修订明细表中的PROJECT_REVISION_REVISION_NUM。<em>注释记号图例中按图纸编号的KEYNOTE_NUMBER。</em></td>
</tr>
<tr>
<td>Formula</td>
<td>根据明细表中其他字段的值计算的公式。</td>
</tr>
<tr>
<td>Percentage</td>
<td>一个值，指示每个元素表示的另一个字段的总和的百分比。</td>
</tr>
<tr>
<td>Room</td>
<td>明细表图元所属房间的参数。</td>
</tr>
<tr>
<td>FromRoom</td>
<td>门或窗的“从”侧房间的参数。</td>
</tr>
<tr>
<td>ToRoom</td>
<td>门或窗“向”侧的房间参数。</td>
</tr>
<tr>
<td>ProjectInfo</td>
<td>明细表图元所属项目中的“项目信息”图元的参数，可以是链接文件。仅允许在包含链接文件图元的明细表中使用。</td>
</tr>
<tr>
<td>Material</td>
<td>在材质提取中，明细表图元的一种材质的参数。</td>
</tr>
<tr>
<td>MaterialQuantity</td>
<td>在材质提取中，表示如何在明细表图元中使用特定材质的值。参数ID可以是MATERIAL_AREA、MATERIAL_VOLUME或MATERIAL_ASPAINT。</td>
</tr>
<tr>
<td>RevitLinkInstance</td>
<td>链接文件中的元素所属的RevitLinkInstance的参数。当前，RVT_LINK_RELANCE_NAME是唯一受支持的参数。仅允许在包含链接文件图元的明细表中使用。</td>
</tr>
<tr>
<td>RevitLinkType</td>
<td>链接文件中的元素所属的RevitLinkType的参数。当前，RVT_LINK_FILE_NAME_WITHOUT_EXT是唯一受支持的参数。仅允许在包含链接文件图元的明细表中使用。</td>
</tr>
<tr>
<td>StructuralMaterial</td>
<td>明细表图元的结构材质参数。</td>
</tr>
<tr>
<td>Space</td>
<td>明细表图元所属空间的参数。</td>
</tr>
</tbody></table>
<p>使用一个ScheduleDefinition.AddField（）方法将把字段添加到字段列表的末尾。若要将新字段放置在字段列表中的特定位置，请使用ScheduleDefinition.InsertField（）方法之一。还可以在事后使用ScheduleDefinition.SetFieldOrder（）对字段进行排序。 下面是一个简单的示例，显示了如何在视图明细表中没有字段的情况下向视图添加字段。</p>
<p>代码区域：向明细表添加字段</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> </span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> Add fields to view schedule.</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> </span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> List of view schedule.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddFieldToSchedule</span>(<span class="params">List schedules</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    IList schedulableFields = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">foreach</span> (ViewSchedule vs <span class="keyword">in</span> schedules)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//Get all schedulable fields from view schedule definition.</span></span><br><span class="line">        schedulableFields = vs.Definition.GetSchedulableFields();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">foreach</span> (SchedulableField sf <span class="keyword">in</span> schedulableFields)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">bool</span> fieldAlreadyAdded = <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">//Get all schedule field ids</span></span><br><span class="line">            IList ids = vs.Definition.GetFieldOrder();</span><br><span class="line">            <span class="keyword">foreach</span> (ScheduleFieldId id <span class="keyword">in</span> ids)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//If the GetSchedulableField() method of gotten schedule field returns same schedulable field,</span></span><br><span class="line">                <span class="comment">// it means the field is already added to the view schedule.</span></span><br><span class="line">                <span class="keyword">if</span> (vs.Definition.GetField(id).GetSchedulableField() == sf)</span><br><span class="line">                &#123;</span><br><span class="line">                    fieldAlreadyAdded = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//If schedulable field doesn&#x27;t exist in view schedule, add it.</span></span><br><span class="line">            <span class="keyword">if</span> (fieldAlreadyAdded == <span class="literal">false</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                vs.Definition.AddField(sf);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ScheduleField类表示ScheduleDefinition的字段列表中的单个字段。每个（非隐藏）字段都将成为明细表中的一列。 最常见的情况是，字段表示明细表中出现的图元的实例或类型参数。某些字段表示其他相关图元的参数，如明细表图元所属的房间。字段还可以表示从明细表中的其他字段（特别是公式和百分比字段）计算的数据。 ScheduleField类具有控制列标题（包括文本和方向）的属性。也可以定义列内文本的列宽和水平对齐方式。 ScheduleField.IsHidden属性可用于隐藏字段。隐藏字段不显示在明细表中，但可用于筛选、排序、分组和条件格式设置，并且可由公式和百分比字段引用。</p>
<p>DisplayType</p>
<p>ScheduleField有一个DisplayType属性，用于指示字段的显示类型。可能的值为： 标准-如果元素的值不同，则不显示任何内容，否则将显示公共值总计-计算并显示总计值最小值最大值-计算并显示最小值和最大值最小值-计算并显示最大值最大值-计算并显示最小值 方法指示此字段是否可以显示最小值和最大值。 在非分项明细表中，当多个图元显示在同一行中时，非标准显示类型的值将显示在常规行中。 #字段的样式和格式 ScheduleField.GetStyle（）和ScheduleField.SetStyle（）使用TableCellStyle类来处理明细表中字段的样式。使用SetStyle（），可以设置字段的各种属性，包括单元格边框的线条样式以及文本字体、颜色和大小。 ScheduleField. SetOptions（）和ScheduleField. GetOptions（）使用DataOptions类来处理字段数据的格式。FormatOptions类包含控制如何将数字与单位格式化为字符串的设置。它包含通常由最终用户在“格式”对话框中选择并存储在文档中的设置。 在以下示例中，ViewSchedule中的所有长度字段都设置为以英尺和小数英寸为单位显示。</p>
<p>代码区域：格式化字段</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// format length units to display in feet and inches format</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">FormatLengthFields</span>(<span class="params">ViewSchedule schedule</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> nFields = schedule.Definition.GetFieldCount();</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> n = <span class="number">0</span>; n &lt; nFields; n++)</span><br><span class="line">    &#123;</span><br><span class="line">        ScheduleField field = schedule.Definition.GetField(n);</span><br><span class="line">        <span class="keyword">if</span> (field.UnitType == UnitType.UT_Length)</span><br><span class="line">        &#123;</span><br><span class="line">            FormatOptions formatOpts = <span class="keyword">new</span> FormatOptions();</span><br><span class="line">            formatOpts.UseDefault = <span class="literal">false</span>;</span><br><span class="line">            formatOpts.DisplayUnits = DisplayUnitType.DUT_FEET_FRACTIONAL_INCHES;</span><br><span class="line">            field.SetFormatOptions(formatOpts);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面的示例将格式和样式重写应用于给定字段。</p>
<p>代码区域：对字段应用格式和样式重写</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ApplyFormattingToField</span>(<span class="params">ViewSchedule schedule, <span class="built_in">int</span> fieldIndex</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Get the field.</span></span><br><span class="line">    ScheduleDefinition definition = schedule.Definition;</span><br><span class="line">    ScheduleField field = definition.GetField(fieldIndex);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Build unit formatting for the field.</span></span><br><span class="line">    FormatOptions options = field.GetFormatOptions();</span><br><span class="line">    options.UseDefault = <span class="literal">false</span>;</span><br><span class="line">    options.DisplayUnits = DisplayUnitType.DUT_SQUARE_INCHES;</span><br><span class="line">    options.UnitSymbol = UnitSymbolType.UST_IN_SUP_2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Build style overrides for the field</span></span><br><span class="line">    <span class="comment">// Use override options to indicate fields that are overridden and apply changes</span></span><br><span class="line">    TableCellStyle style = field.GetStyle();</span><br><span class="line">    TableCellStyleOverrideOptions overrideOptions = style.GetCellStyleOverrideOptions();</span><br><span class="line">    overrideOptions.BackgroundColor = <span class="literal">true</span>;</span><br><span class="line">    style.BackgroundColor = <span class="keyword">new</span> Color(<span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xFF</span>);</span><br><span class="line">    overrideOptions.FontColor = <span class="literal">true</span>;</span><br><span class="line">    style.TextColor = <span class="keyword">new</span> Color(<span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>);</span><br><span class="line">    overrideOptions.Italics = <span class="literal">true</span>;</span><br><span class="line">    style.IsFontItalic = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    style.SetCellStyleOverrideOptions(overrideOptions);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">double</span> width = field.GridColumnWidth;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> (Transaction t = <span class="keyword">new</span> Transaction(schedule.Document, <span class="string">&quot;Set style etc&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        t.Start();</span><br><span class="line">        field.SetStyle(style);</span><br><span class="line">        field.SetFormatOptions(options);</span><br><span class="line">        <span class="comment">// Change column width (affects width in grid and on sheet) - units are in Revit length units - ft.</span></span><br><span class="line">        field.GridColumnWidth = width + <span class="number">0.5</span>;</span><br><span class="line">        t.Commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="标题和标头"><a href="#标题和标头" class="headerlink" title="标题和标头"></a>标题和标头</h6><p>明细表标题和&#x2F;或页眉的显示是可选的。是否显示标题或标头可以使用ScheduleDefinition属性ShowTitle和ShowHeaders控制。</p>
<h6 id="明细表中的查询和排序"><a href="#明细表中的查询和排序" class="headerlink" title="明细表中的查询和排序"></a>明细表中的查询和排序</h6><p>可以按计划的一个或多个字段对计划进行排序或分组。有几种方法可用于控制字段的分组和排序。ScheduleSortGroupField类表示用于对计划进行排序或分组的字段之一。排序和分组是相关的操作。无论哪种情况，明细表中出现的元素都将根据其字段值进行排序，明细表将根据该字段值进行排序&#x2F;分组，这会自动将具有相同值的元素分组在一起。通过启用额外的页眉、页脚或空白行，可以实现组之间的视觉分隔。</p>
<p>如果ScheduleDefinition.IsItemized属性为false，则用于排序&#x2F;分组的所有字段具有相同值的元素将合并到同一行中。否则，明细表将在单独的行中显示每个元素</p>
<p>通过使用ScheduleField.IsHidden属性将用于排序&#x2F;分组的字段标记为隐藏，可以按计划中未显示的数据对计划进行排序或分组。</p>
<p>代码区域：将分组&#x2F;排序添加到计划</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">AddGroupingToSchedule</span>(<span class="params">ViewSchedule schedule, BuiltInParameter paramEnum, <span class="built_in">bool</span> withTotalsAndDecoration, ScheduleSortOrder order</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Find field </span></span><br><span class="line">    ScheduleField field = FindField(schedule, paramEnum);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (field == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Unable to find field.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Build sort/group field.</span></span><br><span class="line">    ScheduleSortGroupField sortGroupField = <span class="keyword">new</span> ScheduleSortGroupField(field.FieldId, order);</span><br><span class="line">    <span class="keyword">if</span> (withTotalsAndDecoration)</span><br><span class="line">    &#123;</span><br><span class="line">        sortGroupField.ShowFooter = <span class="literal">true</span>;</span><br><span class="line">        sortGroupField.ShowFooterTitle = <span class="literal">true</span>;</span><br><span class="line">        sortGroupField.ShowFooterCount = <span class="literal">true</span>;</span><br><span class="line">        sortGroupField.ShowHeader = <span class="literal">true</span>;</span><br><span class="line">        sortGroupField.ShowBlankLine = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add the sort/group field</span></span><br><span class="line">    ScheduleDefinition definition = schedule.Definition;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> (Transaction t = <span class="keyword">new</span> Transaction(schedule.Document, <span class="string">&quot;Add sort/group field&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        t.Start();</span><br><span class="line">        definition.AddSortGroupField(sortGroupField);</span><br><span class="line">        t.Commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduleField <span class="title">FindField</span>(<span class="params">ViewSchedule schedule, BuiltInParameter paramEnum</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ScheduleDefinition definition = schedule.Definition;</span><br><span class="line">    ScheduleField foundField = <span class="literal">null</span>;</span><br><span class="line">    ElementId paramId = <span class="keyword">new</span> ElementId(paramEnum);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">foreach</span> (ScheduleFieldId fieldId <span class="keyword">in</span> definition.GetFieldOrder())</span><br><span class="line">    &#123;</span><br><span class="line">        foundField = definition.GetField(fieldId);</span><br><span class="line">        <span class="keyword">if</span> (foundField.ParameterId == paramId)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> foundField;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>标头也可以分组。GroupHeaders（）方法可用于指定在标题部分的分组中包括哪些行和列。最后一个参数是一个字符串，表示分组的行和列的标头。 在下面的示例中，将为新创建的单类别明细表对列进行分组。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CreateSingleCategoryScheduleWithGroupedColumnHeaders</span>(<span class="params">Document doc</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> (Transaction t = <span class="keyword">new</span> Transaction(doc, <span class="string">&quot;Create single-category with grouped column headers&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Build the schedule</span></span><br><span class="line">        t.Start();</span><br><span class="line">        ViewSchedule vs = ViewSchedule.CreateSchedule(doc, <span class="keyword">new</span> ElementId(BuiltInCategory.OST_Windows));</span><br><span class="line"></span><br><span class="line">        AddRegularFieldToSchedule(vs, <span class="keyword">new</span> ElementId(BuiltInParameter.WINDOW_HEIGHT));</span><br><span class="line">        AddRegularFieldToSchedule(vs, <span class="keyword">new</span> ElementId(BuiltInParameter.WINDOW_WIDTH));</span><br><span class="line">        AddRegularFieldToSchedule(vs, <span class="keyword">new</span> ElementId(BuiltInParameter.ALL_MODEL_MARK));</span><br><span class="line">        AddRegularFieldToSchedule(vs, <span class="keyword">new</span> ElementId(BuiltInParameter.ALL_MODEL_COST));</span><br><span class="line"></span><br><span class="line">        doc.Regenerate();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Group the headers in the body section using ViewSchedule methods</span></span><br><span class="line">        vs.GroupHeaders(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="string">&quot;Size&quot;</span>);</span><br><span class="line">        vs.GroupHeaders(<span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="string">&quot;Other&quot;</span>);</span><br><span class="line">        vs.GroupHeaders(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="string">&quot;All&quot;</span>);</span><br><span class="line"></span><br><span class="line">        t.Commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">AddRegularFieldToSchedule</span>(<span class="params">ViewSchedule schedule, ElementId paramId</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ScheduleDefinition definition = schedule.Definition;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find a matching SchedulableField</span></span><br><span class="line">    SchedulableField schedulableField =</span><br><span class="line">        definition.GetSchedulableFields().FirstOrDefault(sf =&gt; sf.ParameterId == paramId);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (schedulableField != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Add the found field</span></span><br><span class="line">        definition.AddField(schedulableField);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h6><p>可使用“明细表过滤器”来过滤将在明细表中显示的图元。过滤器是要使图元显示在明细表中必须满足的条件。要使图元显示在明细表中，必须满足所有筛选条件。</p>
<p>通过使用ScheduleField.IsHidden属性将用于筛选的字段标记为隐藏，可以按未显示在计划中的数据筛选计划。</p>
<p>代码区域：将筛选器添加到计划</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">AddFilterToSchedule</span>(<span class="params">ViewSchedule schedule, ElementId levelId</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Find level field</span></span><br><span class="line">    ScheduleDefinition definition = schedule.Definition;</span><br><span class="line"></span><br><span class="line">    ScheduleField levelField = FindField(schedule, BuiltInParameter.ROOM_LEVEL_ID);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add filter</span></span><br><span class="line">    <span class="keyword">using</span> (Transaction t = <span class="keyword">new</span> Transaction(schedule.Document, <span class="string">&quot;Add filter&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        t.Start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If field not present, add it</span></span><br><span class="line">        <span class="keyword">if</span> (levelField == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            levelField = definition.AddField(ScheduleFieldType.Instance, <span class="keyword">new</span> ElementId(BuiltInParameter.ROOM_LEVEL_ID));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Set field to hidden</span></span><br><span class="line">        levelField.IsHidden = <span class="literal">true</span>;</span><br><span class="line">        ScheduleFilter filter = <span class="keyword">new</span> ScheduleFilter(levelField.FieldId, ScheduleFilterType.Equal, levelId);</span><br><span class="line">        definition.AddFilter(filter);</span><br><span class="line"></span><br><span class="line">        t.Commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> </span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> Finds an existing ScheduleField matching the given parameter</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> </span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> </span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> </span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduleField <span class="title">FindField</span>(<span class="params">ViewSchedule schedule, BuiltInParameter paramEnum</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ScheduleDefinition definition = schedule.Definition;</span><br><span class="line">    ScheduleField foundField = <span class="literal">null</span>;</span><br><span class="line">    ElementId paramId = <span class="keyword">new</span> ElementId(paramEnum);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">foreach</span> (ScheduleFieldId fieldId <span class="keyword">in</span> definition.GetFieldOrder())</span><br><span class="line">    &#123;</span><br><span class="line">        foundField = definition.GetField(fieldId);</span><br><span class="line">        <span class="keyword">if</span> (foundField.ParameterId == paramId)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> foundField;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="使用明细表数据"><a href="#使用明细表数据" class="headerlink" title="使用明细表数据"></a>使用明细表数据</h6><p>下面的示例说明如何确定明细表中的图元列表。</p>
<p>代码区域：获取计划的内容</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">GetScheduleContents</span>(<span class="params">ViewSchedule viewSchedule</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Collect types displayed in the schedule</span></span><br><span class="line">    FilteredElementCollector typeCollector = <span class="keyword">new</span> FilteredElementCollector(viewSchedule.Document, viewSchedule.Id);</span><br><span class="line">    typeCollector.WhereElementIsElementType();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> numberOfTypes = typeCollector.Count();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Collect instances displayed in the schedule</span></span><br><span class="line">    FilteredElementCollector instCollector = <span class="keyword">new</span> FilteredElementCollector(viewSchedule.Document, viewSchedule.Id);</span><br><span class="line">    instCollector.WhereElementIsNotElementType();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> numberOfInstances = instCollector.Count();</span><br><span class="line"></span><br><span class="line">    TaskDialog.Show(<span class="string">&quot;Elements in schedule&quot;</span>, String.Format(<span class="string">&quot;Types &#123;0&#125; instances &#123;1&#125;&quot;</span>, numberOfTypes, numberOfInstances));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>若要使用明细表中的实际数据，ViewSchedule.GetTableData（）返回一个TableData对象，该对象包含描述表中行、列和单元格的样式和内容的大部分数据。更多信息可以在TableView中找到。</p>
<h4 id="配电盘明细表"><a href="#配电盘明细表" class="headerlink" title="配电盘明细表"></a>配电盘明细表</h4><p>PanelScheduleView表示配电盘明细表，其中显示有关配电盘、连接到配电盘的线路及其相应负荷的信息。</p>
<p>可以创建一个明细表，其中列出连接到配电盘的线路，并显示有关每个线路的信息，例如配电盘上的位置、线路名称和视在负荷。配电盘明细表显示四个主要信息部分：页眉、线路表、负荷汇总和页脚。选定配电盘的新配电盘明细表视图将显示在绘图区域中，并且配电盘明细表将添加到项目浏览器的“配电盘明细表”文件夹下。配电盘明细表显示以下数据：</p>
<ul>
<li>面板名称</li>
<li>配电盘支持的配电系统</li>
<li>面板上可用的相数</li>
<li>为分配给此配电盘的配电系统指定的导线数</li>
<li>配电盘供电电源的额定值</li>
<li>安装类型（表面或嵌入式）</li>
<li>嵌板外壳类型</li>
<li>安装面板的房间</li>
<li>分配给负载电路的名称</li>
<li>断路器的额定跳闸电流</li>
<li>断路器上的极数</li>
<li>电路号</li>
<li>Phases 阶段</li>
<li>各相视在负荷（VA）</li>
<li>所有三相的总视在负荷</li>
<li>制造商</li>
<li>对面板进行的任何更改的注释</li>
<li>均方根安培数要显示的其他回路和配电盘信息可以在配电盘明细表样板中指定，在Revit API中由PanelScheduleTemplate类表示。</li>
</ul>
<p>PanelScheduleView和ViewSchedule一样，都是从TableView类派生的。明细表和配电盘明细表之间的一些常用功能可以在“明细表类”主题中找到。</p>
<h6 id="配电盘明细表创建"><a href="#配电盘明细表创建" class="headerlink" title="配电盘明细表创建"></a>配电盘明细表创建</h6><p>有两种用于创建PanelScheduleView的静态重载。PanelScheduleView. rnInstanceView（）的一个重载只需要在其中创建配电盘明细表的文档以及与明细表关联的电气配电盘元素的ID。此方法使用默认配电盘明细表样板创建新视图。另一个重载接受要使用的特定PanelScheduleTemplate的ID。</p>
<p>以下示例使用默认样板从用户选择的配电盘创建新配电盘明细表，并将活动视图切换到新配电盘明细表视图。</p>
<p>代码区域：创建配电盘明细表</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create a new panel schedule and switch to that view</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">CreatePanelSchedule</span>(<span class="params">UIDocument uiDocument</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Document doc = uiDocument.Document;</span><br><span class="line"></span><br><span class="line">    Reference selected = uiDocument.Selection.PickObject(ObjectType.Element, <span class="string">&quot;Select an electrical panel&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Element panel = doc.GetElement(selected);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> != panel)</span><br><span class="line">    &#123;</span><br><span class="line">        PanelScheduleView psv = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">using</span> (Transaction trans = <span class="keyword">new</span> Transaction(doc, <span class="string">&quot;Create a new panel schedule&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            trans.Start();</span><br><span class="line">            psv = PanelScheduleView.CreateInstanceView(doc, panel.Id);</span><br><span class="line">            trans.Commit();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != psv)</span><br><span class="line">        &#123;</span><br><span class="line">            uiDocument.ActiveView = psv;    <span class="comment">// make new view the active view</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>, <span class="string">&quot;Please select one electrical panel.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="使用配电盘明细表"><a href="#使用配电盘明细表" class="headerlink" title="使用配电盘明细表"></a>使用配电盘明细表</h6><p>创建计划后，您可能需要对其进行修改。有几种方法有助于在计划中移动数据。若要移动数据，请使用PanelScheduleView.GetCellsBySlotNumber（）获取指定插槽号的单元格范围。PanelScheduleView.MoveSlotTo（）将源插槽中的回路移动到特定插槽。在移动回路之前，调用PanelScheduleView.CanMoveSlotTo（）以确保允许移动。</p>
<p>如果移动回路在一个组中，则该组中的所有回路都将相应地移动。IsSlotGrouped（）方法将检查插槽是否在组中。如果插槽不在组中，则此方法返回0。如果它在一个组中，则返回的值为组号（大于0的值）。</p>
<h2 id="修订"><a href="#修订" class="headerlink" title="修订"></a>修订</h2><p>Revit API提供了多个类和成员，用于访问项目修订、其设置和关联的云线批注。</p>
<h3 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h3><p>RevisionSettings类允许应用程序读取和修改影响修订和修订云线的项目范围设置。静态RevisionSettings.GetRevisionSettings（）方法返回给定项目文档的RevisionSettings对象。以下属性可用于访问项目范围的修订设置：</p>
<ul>
<li><p>RevisionCloudSpacing -确定项目中绘制的云线批注在图纸空间中的大小。</p>
</li>
<li><p>修订编号-确定项目的修订编号是按每张图纸还是按整个项目确定。AlphanumericRevisionSettings类包含应用于具有Alphanumeric RevisionNumberType的修订的设置。RevisionSettings方法GetAlphanumericRevisionSettings（）和SetAlphanumericRevisionSettings（）提供对AlphanumericRevisionSettings的读写访问。AlphanumericRevisionSettings提供以下成员：</p>
</li>
<li><p>前缀-前缀将被添加到每个版本号与字母数字类型。</p>
</li>
<li><p>后缀-要附加到每个版本号的字母数字类型的后缀。</p>
</li>
<li><p>GetSequence（）-获取字符串列表，这些字符串将用作字母数字类型的修订的编号序列。</p>
</li>
<li><p>SetSequence（）-设置此类型的修订编号的字符串列表。同样，NumericRevisionSettings类包含应用于具有Numeric</p>
</li>
</ul>
<p>RevisionNumberType的修订的设置。RevisionSettings方法GetNumericRevisionSettings（）和SetNumericRevisionSettings（）提供对这些设置的读写访问。NumericRevisionSettings提供以下成员：</p>
<ul>
<li>Prefix -每个版本号前面的数字类型前缀。</li>
<li>Suffix -要附加到每个版本号的数字类型的后缀。</li>
<li>StartNumber Property-用作数字修订序列中第一个数字的值。</li>
</ul>
<p>当修订云线显示在图纸上时，可以通过标记修订云线或通过图纸标题栏中的修订明细表来显示每个修订的修订编号。有两种方法可以确定数量：</p>
<p><strong>每个项目</strong>：版本号的值将始终对应于分配给该版本的项目范围的版本序号。例如，如果将序号为5、7和8的修订的云线批注放置在图纸上，则该图纸上的修订标记和明细表将显示5、7和8。</p>
<p><strong>每张图纸</strong>：将根据图纸上可见的修订云线为修订编号分配连续编号。例如，如果将指定了项目范围修订序号5、7和8的修订的云线批注放置在图纸上，则该图纸上的修订标记和明细表将显示1、2和3。图纸上的序列仍将遵循修订序列号的相对顺序，因此在本例中，修订5将在图纸上显示为1，修订7将显示为2，依此类推。</p>
<p>Revision类允许应用程序读取和修改项目中的现有修订以及创建新修订。Revision对象表示与项目中的单个修订相关的数据。它具有IssuedBy、IssuedTo、RevisionNumber、SequenceNumber和RevisionDate等属性。云线批注和标记可以与特定Revision对象关联，以在图纸上显示其特性。</p>
<p>项目中的修订以称为修订顺序的特定顺序存储。修订顺序表示将发布修订的概念顺序。静态方法Revision.GetAllRevisionIds（）将按此顺序返回所有Revision的ID。静态方法Revision.ReorderRevisionSequence（）可用于更改项目的修订顺序。请注意，新指定的序列必须只包含项目中的每个修订一次，并且更改修订的序列可能会更改已发布的修订的SequenceNumber和RevisionNumber。</p>
<p>静态Create（）方法将在指定的文档中创建一个新的Revision。在下面的示例中，添加了多个修订并设置了它们的属性。</p>
<p>代码区域：创建新修订</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> IList <span class="title">AddRevisions</span>(<span class="params">Document document</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    IList newRevisions = <span class="keyword">new</span> List();</span><br><span class="line">    <span class="keyword">using</span> (Transaction createRevision = <span class="keyword">new</span> Transaction(document, <span class="string">&quot;createRevision&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        createRevision.Start();</span><br><span class="line">        newRevisions.Add(AddNewRevision(document, <span class="string">&quot;Include door tags&quot;</span>, <span class="string">&quot;manager1&quot;</span>, <span class="string">&quot;employee1&quot;</span>, <span class="number">1</span>, DateTime.Now));</span><br><span class="line">        newRevisions.Add(AddNewRevision(document, <span class="string">&quot;Add a section view&quot;</span>, <span class="string">&quot;manager1&quot;</span>, <span class="string">&quot;employee1&quot;</span>, <span class="number">2</span>, DateTime.Now));</span><br><span class="line">        newRevisions.Add(AddNewRevision(document, <span class="string">&quot;Make callout view larger&quot;</span>, <span class="string">&quot;manager1&quot;</span>, <span class="string">&quot;employee1&quot;</span>, <span class="number">3</span>, DateTime.Now));</span><br><span class="line">        createRevision.Commit();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> newRevisions;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Revision <span class="title">AddNewRevision</span>(<span class="params">Document document, <span class="built_in">string</span> description, <span class="built_in">string</span> issuedBy, <span class="built_in">string</span> issuedTo, <span class="built_in">int</span> sequenceNumber, DateTime date</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Revision newRevision = Revision.Create(document);</span><br><span class="line">    newRevision.Description = description;</span><br><span class="line">    newRevision.IssuedBy = issuedBy;</span><br><span class="line">    newRevision.IssuedTo = issuedTo;</span><br><span class="line">    newRevision.NumberType = RevisionNumberType.Alphanumeric;</span><br><span class="line">    newRevision.RevisionDate = date.ToShortDateString();</span><br><span class="line">    <span class="keyword">return</span> newRevision;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CombineWithNext（）和CombineWithPrevious（）这两个方法允许应用程序将指定的Revision与模型中的下一个或上一个Revision合并。合并修订意味着与指定修订相关联的修订云和修订标签将与下一个修订重新关联，并且指定修订将从模型中删除。此方法返回重新关联的RevisionClouds的ID。但是，这些操作只能在两个修订版本都未发布的情况下实施。 下面的示例演示CombineWithNext（）方法的用法。它还使用GetAllRevisionIds（）方法查找下一个修订，以确保CombineWithNext（）方法成功。</p>
<p>代码区域：合并修订</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="built_in">bool</span> <span class="title">CombineRevision</span>(<span class="params">Document document, Revision revision</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">bool</span> combined = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// Can only combine two revisions if neither have been issued</span></span><br><span class="line">    <span class="keyword">if</span> (revision.Issued == <span class="literal">false</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ElementId revisionId = revision.Id;</span><br><span class="line">        Revision nextRevsion = GetNextRevision(document, revisionId);</span><br><span class="line">        <span class="keyword">if</span> (nextRevsion != <span class="literal">null</span> &amp;&amp; nextRevsion.Issued == <span class="literal">false</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ISet revisionCloudIds = Revision.CombineWithNext(document, revisionId);</span><br><span class="line">            combined = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">int</span> movedClouds = revisionCloudIds.Count;</span><br><span class="line">            <span class="keyword">if</span> (movedClouds &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                RevisionCloud cloud = document.GetElement(revisionCloudIds.ElementAt(<span class="number">0</span>)) <span class="keyword">as</span> RevisionCloud;</span><br><span class="line">                <span class="keyword">if</span> (cloud != <span class="literal">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">string</span> msg = <span class="built_in">string</span>.Format(<span class="string">&quot;Revision &#123;0&#125; deleted and &#123;1&#125; revision clouds were added to Revsion &#123;2&#125;&quot;</span>,</span><br><span class="line">                        revisionId.ToString(), movedClouds, cloud.RevisionId.ToString());</span><br><span class="line">                    TaskDialog.Show(<span class="string">&quot;Revision Combined&quot;</span>, msg);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> combined;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Revision <span class="title">GetNextRevision</span>(<span class="params">Document document, ElementId currentRevisionId</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Revision nextRevision = <span class="literal">null</span>;</span><br><span class="line">    IList revisionIds = Revision.GetAllRevisionIds(document);</span><br><span class="line">    <span class="built_in">int</span> currentRevisionIndex = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> n = <span class="number">0</span>; n &lt; revisionIds.Count; n++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (revisionIds[n] == currentRevisionId)</span><br><span class="line">        &#123;</span><br><span class="line">            currentRevisionIndex = n;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if the current revision id was found and is not the last index</span></span><br><span class="line">    <span class="keyword">if</span> (currentRevisionIndex &gt;= <span class="number">0</span> &amp;&amp; currentRevisionIndex &lt; revisionIds.Count - <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ElementId nextRevisionId = revisionIds[currentRevisionIndex + <span class="number">1</span>];</span><br><span class="line">        nextRevision = document.GetElement(nextRevisionId) <span class="keyword">as</span> Revision;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> nextRevision;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="修订云线"><a href="#修订云线" class="headerlink" title="修订云线"></a>修订云线</h3><p>RevisionCloud是一种图形化的“云”，可以显示在视图或图纸上，以指示模型中发生修订的位置。RevisionCloud类允许应用程序访问有关模型中存在的云线批注的信息，并创建新的云线批注。</p>
<p>RevisionCloud是特定于视图的，可以在大多数图形视图中创建，但3D视图除外。</p>
<p>另请注意，当在ViewLegend中创建RevisionCloud时，它会被视为RevisionCloud外观的图例表示，而不是模型更改的实际指示。因此，ViewLegends中的RevisionClouds不会影响修订明细表的内容。</p>
<h3 id="创建云线批注"><a href="#创建云线批注" class="headerlink" title="创建云线批注"></a>创建云线批注</h3><p>静态Create（）方法允许应用程序基于一系列直线和曲线在指定视图中创建新的RevisionCloud。只有在关联的Revision尚未发布时，才能创建RevisionClouds。</p>
<p>可以在大多数图形视图中创建RevisionClouds，但三维视图和图形柱明细表除外。与大多数其他元素不同，RevisionClouds可以直接在ViewSheet上创建。</p>
<p>RevisionCloud基于一系列草图曲线创建。不要求曲线形成闭合回路，也允许自相交。曲线将自动投影到视图的适当平面上。曲线列表不能为空，并且没有直线可以垂直于视图平面。如果视图是模型视图，则将在模型空间中解释为曲线指定的坐标。如果视图是非模型视图（例如ViewSheet），则坐标将在视图的空间中解释。</p>
<p>每条曲线都将有一系列的“云凸点”沿着它绘制沿着，形成云的外观。云图形将附加到假设每条曲线都是顺时针方向的曲线上。对于线，这意味着云的外部在视图平面内的线的法向量的方向上。因此，任何闭合的环都应该顺时针定向，以创建典型的云形状。</p>
<p>代码区域：创建修订云线</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">CreateRevisionCloudInActiveView</span>(<span class="params">Document document, Revision revision, IList curves</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> (Transaction newRevisionCloud = <span class="keyword">new</span> Transaction(document, <span class="string">&quot;Create Revision Cloud&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        newRevisionCloud.Start();</span><br><span class="line">        <span class="comment">// Can only create revision cloud for revision that is not issued</span></span><br><span class="line">        <span class="keyword">if</span> (revision.Issued == <span class="literal">false</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            RevisionCloud.Create(document, document.ActiveView, revision.Id, curves);</span><br><span class="line">            newRevisionCloud.Commit();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            newRevisionCloud.RollBack();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="修订云线几何图形"><a href="#修订云线几何图形" class="headerlink" title="修订云线几何图形"></a>修订云线几何图形</h3><p>RevisionCloud派生自Element类。云线批注的Element.Geometry属性将返回组成云线的实际曲线。另一方面，RevisionCloud.GetSketchCurves（）方法将返回定义云的基本轮廓的草图曲线，而不是Revit附着到这些曲线以创建云外观的弧。</p>
<h3 id="与RevisionCloud关联的修订版本"><a href="#与RevisionCloud关联的修订版本" class="headerlink" title="与RevisionCloud关联的修订版本"></a>与RevisionCloud关联的修订版本</h3><p>每个RevisionCloud与一个Revision相关联。关联的修订ID在调用Create（）时指定，可以从RevisionCloud.RevisionId属性中检索。如果RevisionCloud的RevisionId属性未与已发布的修订版本关联，则可以更改该属性。它只能更改为另一个尚未发布的修订版本的ID。IsRevisionIssued（）返回关联的Revision是否已发布。</p>
<h3 id="图纸-1"><a href="#图纸-1" class="headerlink" title="图纸"></a>图纸</h3><p>当RevisionCloud在ViewSheet上可见时（因为它直接放置在ViewSheet上，或者因为它在ViewSheet上放置的视图中可见），ViewSheet上显示的任何修订明细表将自动包括与RevisionCloud关联的修订。</p>
<p>RevisionCloud.GetSheetIds（）方法返回ViewSheets的ID，ViewSheets可能会出现在该ID中，并参与到图纸的修订明细表中。RevisionCloud可以出现在ViewSheet上，因为它是直接在ViewSheet上绘制的，或者因为它的所有者视图放置在ViewSheet上。如果RevisionCloud属于从属视图或具有关联从属视图的视图，则RevisionCloud也可以在放置相关从属视图或主视图的图纸上可见。</p>
<p>此RevisionCloud可能在此方法报告的所有ViewSheets中不可见。其他因素（例如视图的可见性设置或注释裁剪或关联修订的可见性设置）仍可能导致此RevisionCloud不显示在特定ViewSheet上。</p>
<p>如果此RevisionCloud归ViewLegend所有，则不会返回图纸，因为RevisionCloud不会参与修订明细表。ViewSheet类包括用于在图纸上使用Revisionsand RevisionClouds的方法。有关详细信息，请参见ViewSheet主题。</p>
<h2 id="视图过滤器"><a href="#视图过滤器" class="headerlink" title="视图过滤器"></a>视图过滤器</h2><p>过滤器是独立于视图的元素。它们可以使用ParameterFilterElement类或SelectionFilterElement类应用于视图。</p>
<h3 id="ParameterFilterElement"><a href="#ParameterFilterElement" class="headerlink" title="ParameterFilterElement"></a>ParameterFilterElement</h3><p>参数过滤元素根据其类别和一系列过滤规则过滤元素。可以指定一个或多个类别作为筛选器的允许类别。</p>
<p>定义过滤器（具有一个或多个类别和一个或多个过滤器规则）后，可以使用多种方法之一将其应用于视图。AddFilter（）方法将过滤器应用于视图，但使用默认覆盖，这意味着视图的显示不会更改。View.SetFilterOverrides（）将设置与过滤器关联的图形覆盖。而View.SetFilterVisibility（）将设置通过过滤器的元素在视图中是否可见。AddFilter（）和SetFilterVisibility（）都将过滤器应用到视图（如果它还没有应用），因此没有必要单独调用AddFilter（）。</p>
<p>下面的示例创建一个匹配多个条件的新视图筛选器，然后在视图中隐藏这些元素。</p>
<p>代码区域：将参数过滤器应用于视图</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CreateViewFilter</span>(<span class="params">Document doc, View view</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    List categories = <span class="keyword">new</span> List();</span><br><span class="line">    categories.Add(<span class="keyword">new</span> ElementId(BuiltInCategory.OST_Walls));</span><br><span class="line">    List filterRules = <span class="keyword">new</span> List();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> (Transaction t = <span class="keyword">new</span> Transaction(doc, <span class="string">&quot;Add view filter&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        t.Start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create filter element associated to the input categories</span></span><br><span class="line">        ParameterFilterElement parameterFilterElement = ParameterFilterElement.Create(doc, <span class="string">&quot;Example view filter&quot;</span>, categories);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Criterion 1 - wall type Function is &quot;Exterior&quot;</span></span><br><span class="line">        ElementId exteriorParamId = <span class="keyword">new</span> ElementId(BuiltInParameter.FUNCTION_PARAM);</span><br><span class="line">        filterRules.Add(ParameterFilterRuleFactory.CreateEqualsRule(exteriorParamId, (<span class="built_in">int</span>)WallFunction.Exterior));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Criterion 2 - wall height &gt; some number</span></span><br><span class="line">        ElementId lengthId = <span class="keyword">new</span> ElementId(BuiltInParameter.CURVE_ELEM_LENGTH);</span><br><span class="line">        filterRules.Add(ParameterFilterRuleFactory.CreateGreaterOrEqualRule(lengthId, <span class="number">28.0</span>, <span class="number">0.0001</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Criterion 3 - custom shared parameter value matches string pattern</span></span><br><span class="line">        <span class="comment">// Get the id for the shared parameter - the ElementId is not hardcoded, so we need to get an instance of this type to find it</span></span><br><span class="line">        Guid spGuid = <span class="keyword">new</span> Guid(<span class="string">&quot;96b00b61-7f5a-4f36-a828-5cd07890a02a&quot;</span>);</span><br><span class="line">        FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(doc);</span><br><span class="line">        collector.OfClass(<span class="keyword">typeof</span>(Wall));</span><br><span class="line">        Wall wall = collector.FirstElement() <span class="keyword">as</span> Wall;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (wall != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Parameter sharedParam = wall.get_Parameter(spGuid);</span><br><span class="line">            ElementId sharedParamId = sharedParam.Id;</span><br><span class="line"></span><br><span class="line">            filterRules.Add(ParameterFilterRuleFactory.CreateBeginsWithRule(sharedParamId, <span class="string">&quot;15.&quot;</span>, <span class="literal">true</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        parameterFilterElement.SetRules(filterRules);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Apply filter to view</span></span><br><span class="line">        view.AddFilter(parameterFilterElement.Id);</span><br><span class="line">        view.SetFilterVisibility(parameterFilterElement.Id, <span class="literal">false</span>);</span><br><span class="line">        t.Commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="SelectionFilterElement"><a href="#SelectionFilterElement" class="headerlink" title="SelectionFilterElement"></a>SelectionFilterElement</h3><p>SelectionFilterElement是一种特殊的视图筛选器，它不基于规则，而是基于一组可能不相关的元素。可以根据需要将特定元素添加到过滤器中，并且可以像ParameterFilterElement一样覆盖所产生的选择。</p>
<p>下面的示例创建一个新的选择筛选器并对其应用重写。</p>
<p>代码区域：将选择筛选器应用于视图</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CreateSelectionFilter</span>(<span class="params">Document doc, View view</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// find room tags in this view</span></span><br><span class="line">    FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(doc, view.Id);</span><br><span class="line">    collector.WherePasses(<span class="keyword">new</span> RoomTagFilter());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// collect tags whose room number matches criteria</span></span><br><span class="line">    List tagIds = <span class="keyword">new</span> List();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">foreach</span> (RoomTag tag <span class="keyword">in</span> collector.Cast())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> number = Int32.Parse(tag.Room.Number);</span><br><span class="line">        <span class="keyword">if</span> (number % <span class="number">3</span> == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            tagIds.Add(tag.Id);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> (Transaction t = <span class="keyword">new</span> Transaction(doc, <span class="string">&quot;Create SelectionFilterElement&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        t.Start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create selection filter and assign ids</span></span><br><span class="line">        SelectionFilterElement filterElement = SelectionFilterElement.Create(doc, <span class="string">&quot;Room tags filter&quot;</span>);</span><br><span class="line">        filterElement.SetElementIds(tagIds);</span><br><span class="line"></span><br><span class="line">        ElementId filterId = filterElement.Id;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Add the filter to the view</span></span><br><span class="line">        view.AddFilter(filterId);</span><br><span class="line"></span><br><span class="line">        doc.Regenerate();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Use the existing graphics settings, and change the color to Blue</span></span><br><span class="line">        OverrideGraphicSettings overrideSettings = view.GetFilterOverrides(filterId);</span><br><span class="line"></span><br><span class="line">        overrideSettings.SetProjectionLineColor(<span class="keyword">new</span> Color(<span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xFF</span>));</span><br><span class="line"></span><br><span class="line">        view.SetFilterOverrides(filterId, overrideSettings);</span><br><span class="line"></span><br><span class="line">        t.Commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Modifying filters</p>
<p>应用于视图的所有过滤器都可以使用View.GetFilters（）方法检索，该方法将返回过滤器ID列表。可以分别使用View.GetFilterVisibility（）和View.GetFilterOverrides（）方法检查特定筛选器的筛选器可见性和图形覆盖。RemoveFilter将从视图中删除筛选器。</p>
<p>下面的示例演示如何获取视图中的过滤器，然后修改与当前将剪切颜色设置为红色的任何过滤器关联的覆盖。</p>
<p>代码区域：修改现有筛选器</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ModifyExistingFilter</span>(<span class="params">Document doc, View view</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Find any filter with overrides setting cut color to Red</span></span><br><span class="line">    Dictionary&lt;ElementId, OverrideGraphicSettings&gt; filterIdsToChange = <span class="keyword">new</span> Dictionary&lt;ElementId, OverrideGraphicSettings&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">foreach</span> (ElementId filterId <span class="keyword">in</span> view.GetFilters())</span><br><span class="line">    &#123;</span><br><span class="line">        OverrideGraphicSettings overrideSettings = view.GetFilterOverrides(filterId);</span><br><span class="line"></span><br><span class="line">        Color lineColor = overrideSettings.CutLineColor;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (lineColor == Color.InvalidColorValue)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Save overrides setting the cut color to green</span></span><br><span class="line">        <span class="keyword">if</span> (lineColor.Red == <span class="number">0xFF</span> &amp;&amp; lineColor.Green == <span class="number">0x00</span> &amp;&amp; lineColor.Blue == <span class="number">0x00</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            overrideSettings.SetCutLineColor(<span class="keyword">new</span> Color(<span class="number">0x00</span>, <span class="number">0xFF</span>, <span class="number">0x00</span>));</span><br><span class="line">            filterIdsToChange[filterId] = overrideSettings;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make the change to all found filters</span></span><br><span class="line">    <span class="keyword">using</span> (Transaction t = <span class="keyword">new</span> Transaction(doc, <span class="string">&quot;Change override filters&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        t.Start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">foreach</span> (ElementId filterId <span class="keyword">in</span> filterIdsToChange.Keys)</span><br><span class="line">        &#123;</span><br><span class="line">            view.SetFilterOverrides(filterId, filterIdsToChange[filterId]);</span><br><span class="line">        &#125;</span><br><span class="line">        t.Commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="视图裁剪"><a href="#视图裁剪" class="headerlink" title="视图裁剪"></a>视图裁剪</h2><p>可以使用Revit API修改某些视图的裁剪区域。ViewCropRegionShapeManager.CanHaveShape属性指示是否允许视图管理裁剪区域形状，而ShapeSet属性指示是否已设置形状。下面的示例裁剪房间边界周围的视图。</p>
<p>代码区域：裁剪视图</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">CropAroundRoom</span>(<span class="params">Room room, View view</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (view != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        IList&lt;IList&lt;Autodesk.Revit.DB.BoundarySegment&gt;&gt; segments = room.GetBoundarySegments(<span class="keyword">new</span> SpatialElementBoundaryOptions());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != segments)  <span class="comment">//the room may not be bound</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">foreach</span> (IList&lt;Autodesk.Revit.DB.BoundarySegment&gt; segmentList <span class="keyword">in</span> segments)</span><br><span class="line">            &#123;</span><br><span class="line">                CurveLoop loop = <span class="keyword">new</span> CurveLoop();</span><br><span class="line">                <span class="keyword">foreach</span> (Autodesk.Revit.DB.BoundarySegment boundarySegment <span class="keyword">in</span> segmentList)</span><br><span class="line">                &#123;</span><br><span class="line">                    loop.Append(boundarySegment.GetCurve());</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                ViewCropRegionShapeManager vcrShapeMgr = view.GetCropRegionShapeManager();</span><br><span class="line">                vcrShapeMgr.SetCropShape(loop);</span><br><span class="line">                <span class="keyword">break</span>;  <span class="comment">// if more than one set of boundary segments for room, crop around the first one</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="置换视图"><a href="#置换视图" class="headerlink" title="置换视图"></a>置换视图</h2><p>使用DisplacementElement类创建置换视图。DisplacementElement是视图专有的元素，可用于使元素显示为从其实际位置偏移。置换视图对于说明模型元素与整个模型的关系非常有用。DisplacementElement实际上不会更改任何模型元素的位置;它只是使它们显示在不同的位置。</p>
<p>有关创建置换视图的详细示例，请参见Revit SDK中的DisplacementElementAnimation示例。</p>
<h3 id="创建置换视图"><a href="#创建置换视图" class="headerlink" title="创建置换视图"></a>创建置换视图</h3><p>静态DisplacementElement.Create（）方法创建一个新的DisplacementElement。如果parentDisplacementElement参数不为空，则新DisplacementElement可以是父DisplacementElement的子元素。如果指定了父代，则子DisplacementElement的转换将与父代的转换连接在一起，并且其关联元素的位移将相对于父代DisplacementElement。</p>
<p>Create（）方法还需要一个文档、一个要置换的元素列表、所有者视图以及要应用于置换元素图形的转换。在任何视图中，一个元素只能被单个DisplacementElement置换。将一个元素替换为多个DisplacementElement将导致异常。</p>
<p>可以在调用Create（）之前使用DisplaceementElement的其他静态方法来帮助防止任何异常。CanCategoryBeDisplaced（）测试属于特定类别的元素是否可以被置换，而重载的静态方法CanElementsBeDisplaced（）指示特定元素是否可以被分配给新的DisplacementElement。IsAllowedAsDisplacedElement（）测试单个元素是否有资格被置换。</p>
<p>静态GetAdditionalElementsToDisplace（）方法将返回任何其他元素，这些元素应与指定视图中的指定元素一起沿着移位。例如，当墙被置换时，所有插入对象或主体图元也应该被置换。</p>
<p>创建子DisplacementElement时，静态IsValidAsParentInView（）可用于验证特定DisplacementElement是否可用作特定View中的父代。</p>
<p>DisplacementElement的其他静态方法可用于查找包含特定元素的DisplacementElement，以获取View中所有移位元素的列表，或获取指定View所拥有的所有DisplacementElements。</p>
<h3 id="使用置换图元"><a href="#使用置换图元" class="headerlink" title="使用置换图元"></a>使用置换图元</h3><p>一旦创建了新的DisplacementElement，就可以使用方法来获取任何子DisplacementElements，以获取受DisplacementElement影响的所有元素的id，或者获取受DisplacementElement影响的所有元素以及任何子DisplacementElements的id。ParentId属性将返回父DisplacementElement的元素ID（如果存在）。</p>
<p>创建后，可以使用SetDisplacedElementIds（）或RemoveDisplacedElement（）修改受DisplacementElement影响的元素集。另外，相对位移可以改变。</p>
<p>方法ResetDisplacedElements（）将DisplacementElement的平移设置为（0，0，0）。DisplacementElement继续存在，但其元素显示在其实际位置。</p>
<h3 id="创建位移路径"><a href="#创建位移路径" class="headerlink" title="创建位移路径"></a>创建位移路径</h3><p>DisplacementPath是与DisplacementElement相关的视图特定注释。DisplacementPath类创建一个注释，该注释描述元素从其实际位置到其位移位置的移动。通过对DisplacementElement的已移位元素的边缘上的点的引用，将DisplacementPath锚定到DisplacementElement。它由一条直线或一系列折弯线表示，这些直线起源于位移元素上的指定点。</p>
<p>静态DisplacementPath.Create（）方法需要一个文档、关联DisplacementElement的ID、一个引用被DisplacementElement置换的元素之一的边或曲线的引用，以及一个在[0，1]范围内的值，该值是沿指定边的沿着参数。创建后，可以使用PathStyle属性设置DisplacementPath的路径样式。也可以使用SetAnchorPoint（）更改锚点。</p>
<p>下面的示例通过垂直和水平移动找到的第一面墙来创建新的位移，然后为其添加位移路径。</p>
<p>代码区域：创建位移和路径</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CreateDisplacementAndPath</span>(<span class="params">Document doc, View view</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Find roof</span></span><br><span class="line">    FilteredElementCollector fec = <span class="keyword">new</span> FilteredElementCollector(doc);</span><br><span class="line">    fec.OfClass(<span class="keyword">typeof</span>(RoofBase));</span><br><span class="line">    RoofBase roof = fec.FirstElement() <span class="keyword">as</span> RoofBase;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get a geometric reference for the path</span></span><br><span class="line">    Reference edgeRef = GetHorizontalEdgeReference(roof);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> (Transaction t = <span class="keyword">new</span> Transaction(doc, <span class="string">&quot;CreateDisplacementAndPath&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        t.Start();</span><br><span class="line">        <span class="comment">// Create a new top level DisplacementElement</span></span><br><span class="line">        DisplacementElement dispElem = DisplacementElement.Create(doc, <span class="keyword">new</span> ElementId[] &#123; roof.Id &#125;, <span class="keyword">new</span> XYZ(<span class="number">10</span>, <span class="number">0</span>, <span class="number">20</span>), view, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create the path associated to the element</span></span><br><span class="line">        DisplacementPath.Create(doc, dispElem, edgeRef, <span class="number">0.5</span>);</span><br><span class="line">        t.Commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Reference <span class="title">GetHorizontalEdgeReference</span>(<span class="params">Element elem</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//Find target edge from lower face of roof</span></span><br><span class="line">    Options options = <span class="keyword">new</span> Options();</span><br><span class="line">    options.ComputeReferences = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    GeometryElement geomElem = elem.get_Geometry(options);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> geomObj <span class="keyword">in</span> geomElem)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (geomObj <span class="keyword">is</span> Solid)</span><br><span class="line">        &#123;</span><br><span class="line">            Solid solid = geomObj <span class="keyword">as</span> Solid;</span><br><span class="line">            <span class="keyword">var</span> faces = solid.Faces;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">foreach</span> (Face face <span class="keyword">in</span> faces)</span><br><span class="line">            &#123;</span><br><span class="line">                BoundingBoxUV box = face.GetBoundingBox();</span><br><span class="line">                UV midpoint = (box.Min + box.Max) / <span class="number">2.0</span>;</span><br><span class="line">                <span class="keyword">if</span> (face.ComputeNormal(midpoint).Normalize().Z &lt; <span class="number">-0.1</span>) <span class="comment">// Downward facing, this is good enough</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">var</span> edgeLoops = face.EdgeLoops;</span><br><span class="line">                    <span class="keyword">foreach</span> (EdgeArray edgeArray <span class="keyword">in</span> edgeLoops)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">foreach</span> (Edge edge <span class="keyword">in</span> edgeArray)</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="comment">// horizontal?</span></span><br><span class="line">                            <span class="keyword">if</span> (Math.Abs(edge.AsCurve().ComputeDerivatives(<span class="number">0.0</span>, <span class="literal">true</span>).BasisX.DotProduct(XYZ.BasisZ)) - <span class="number">1</span> &lt;= <span class="number">0.00001</span>)</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="keyword">return</span> edge.Reference;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相关联的DisplacementElement可以具有父DisplacementElement，并且该父DisplacementElement可以具有其自己的父DisplacementElement，从而产生一系列祖先。终点可以是点的原始（未移位）位置，或者是与这些祖先DisplacementElements相对应的任何中间移位位置上的对应点。位移路径。PistorIdx属性指定路径的终点。</p>
<h2 id="UIView"><a href="#UIView" class="headerlink" title="UIView"></a>UIView</h2><p>View类是Revit中所有视图类型的基类，并跟踪视图中的图元，而UIView类则包含有关Revit用户界面中视图窗口的数据。可以使用GetOpenUIViews（）方法从UID目录中检索所有打开视图的列表。UIView类具有获取有关视图绘图区域的信息以及平移和缩放活动视图的方法。</p>
<p>GetWindowRectangle（）返回一个描述UIView窗口大小和位置的矩形。它不包括窗口边框或标题栏。</p>
<h3 id="缩放操作"><a href="#缩放操作" class="headerlink" title="缩放操作"></a>缩放操作</h3><p>UIView有几种与缩放活动视图相关的方法。UIView.GetZoomCorners（）获取模型坐标中视图矩形的角点，UIView.ZoomAndCenterRectangle（）提供缩放和平移活动视图的能力，使其以模型的输入区域为中心。</p>
<p>ZoomToFit（）和ZoomSheetSize（）方法提供了调整窗口缩放的快速方法，而Zoom（）方法可用于按指定因子放大或缩小。</p>
<h3 id="关闭视图"><a href="#关闭视图" class="headerlink" title="关闭视图"></a>关闭视图</h3><p>UIView.Close（）可以关闭可见窗口。但是，它不能用于关闭最后一个活动窗口。尝试关闭最后一个活动窗口将引发异常。</p>
<h2 id="注：翻译自Revit-API-Developers-Guide"><a href="#注：翻译自Revit-API-Developers-Guide" class="headerlink" title="注：翻译自Revit API Developers Guide"></a><em><strong>注：</strong></em>翻译自<a target="_blank" rel="noopener" href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_html">Revit API Developers Guide</a></h2></article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Revit/">Revit</a></div><div class="post-share"><div class="social-share" data-image="/images/4stars.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2024/12/06/%E4%BA%8C%E5%BC%80%E6%8C%87%E5%8D%97/16%E5%9F%BA%E5%87%86%E5%92%8C%E4%BF%A1%E6%81%AF%E5%85%83%E7%B4%A0/" title="16基准和信息元素"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">16基准和信息元素</div></div><div class="info-2"><div class="info-item-1">基准和信息元素本章介绍Revit中的基准元素和信息元素。  基准元素包括标高、轴网和模型线。 信息元素包括阶段、设计选项和EnergyDataSettings。  有关Revit图元分类的详细信息，请参见图元要素。 注：如果您需要更多信息，请参阅相关章节：  有关荷载基础、荷载工况、荷载组合、荷载性质和荷载用途，请参阅结构工程 对于模型曲线，请参阅草图 对于材质和填充图案，请参阅材质 有关能量数据设置，请参阅能量数据  本节中的页面  Levels 标高 Grids 轴网 Phase 阶段 Design Options 设计选项  标高标高是一个有限的水平面，用作以标高为主体的图元（如墙、屋顶、楼板和天花板）的参照。 在Revit Platform API中，Level类派生自DatumPlane类，而DatumPlane类派生自Element类。继承的Name属性用于检索Revit...</div></div></div></a><a class="pagination-related" href="/2024/12/05/%E4%BA%8C%E5%BC%80%E6%8C%87%E5%8D%97/09%E7%BC%96%E8%BE%91%E5%85%83%E7%B4%A0/" title="09编辑元素"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">09编辑元素</div></div><div class="info-2"><div class="info-item-1">编辑元素在Revit中，可以使用Revit Platform API移动、复制、旋转、对齐、删除、镜像、编组和排列一个元素或一组元素。在API中使用编辑功能与在Revit UI中使用命令类似。 Pages in this section 本节中的页面  Moving Elements 移动元素 Copying Elements 复制元素 Rotating elements 旋转元素 Aligning Elements 对齐元素 Mirroring Elements 镜像元素 Grouping Elements 对元素进行分组 Creating Arrays of Elements 创建元素数组 Deleting Elements 删除元素 Pinned Elements 固定元素  移动元素ElementTransformUtils类提供两个静态方法来将一个或多个元素从一个位置移动到另一个位置。 表19：移动方法    Member **Description **    MoveElement( Document, ElementId,...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2024/12/24/%E4%BA%8C%E5%BC%80%E6%8C%87%E5%8D%97/26%E7%BB%93%E6%9E%84%E5%B7%A5%E7%A8%8B/" title="26结构工程"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-24</div><div class="info-item-2">26结构工程</div></div><div class="info-2"><div class="info-item-1">结构工程以下各节介绍了仅与Revit的结构工程功能相关的API功能：  结构模型元素-讨论仅与Revit的结构工程功能相关的特定元素及其属性。  AnalyticalModel -讨论与分析模型相关的类，如AnalyticalModel、RigidLink和AnalyticalModelSupport。  AnalyticalLink -讨论在分析梁和柱之间创建新的分析链接。  荷载-讨论荷载设置和三种荷载。   您的分析链接-为希望将Revit链接到某些Structural Analysis应用程序的API用户提供建议。 本章包含一些高级主题。如果您不熟悉Revit Platform API，请先阅读基本部分，如“入门”、“元素要素”、“参数”等。  本节中的主题 结构模型元素 分析模型在结构工程中，分析模型是结构物理模型的工程描述。 荷载以下部分确定荷载设置并讨论荷载限制指南。 Analysis Link分析链接 Analytical...</div></div></div></a><a class="pagination-related" href="/2024/11/23/%E4%BA%8C%E5%BC%80%E6%8C%87%E5%8D%97/33%E5%91%BD%E4%BB%A4/" title="33命令"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-23</div><div class="info-item-2">33命令</div></div><div class="info-2"><div class="info-item-1">命令Revit API 提供对现有 Revit 命令的访问，这些命令位于选项卡、应用程序菜单或右键单击菜单中。使用 API 处理 Revit 命令的主要方法是替换现有命令实现或发布命令。 替代 Revit 命令AddInCommandBinding 类可用于替代 Revit 中的现有命令。它有三个与替换现有命令实现相关的事件。  BeforeExecuted - 此只读事件在关联命令执行之前发生。应用程序可以对此事件做出反应，但不能更改文档或影响命令的调用。 CanExecute - 当关联的命令启动检查以确定是否可以在命令目标上执行命令时出现。 Executed - 当执行关联的命令时，将发生此事件，并且应在此处执行任何覆盖实现。  要创建 commandbinding，请调用 UIApplication.CreateAddInCommandBinding（） 或 UIControlledApplication.CreateAddInCommandBinding（）。这两种方法都需要 RevitCommandId ID 来标识要替换的命令处理程序。RevitCommandId...</div></div></div></a><a class="pagination-related" href="/2024/11/29/%E4%BA%8C%E5%BC%80%E6%8C%87%E5%8D%97/32%E5%8A%A8%E6%80%81%E6%A8%A1%E5%9E%8B%E6%9B%B4%E6%96%B0/" title="32动态模型更新"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-29</div><div class="info-item-2">32动态模型更新</div></div><div class="info-2"><div class="info-item-1">动态模型更新动态模型更新为Revit API应用程序提供了修改Revit模型的能力，作为对模型中发生的更改（当这些更改即将在事务结束时提交时）的反应。Revit API应用程序可以通过实现IUpdater接口并将其注册到UpdaterRegistry类来创建更新程序。注册包括指定模型中的哪些更改应该触发更新程序。 Pages in this section 本节中的页面  实现IUpdater Execute方法 注册更新程序 Exposure to...</div></div></div></a><a class="pagination-related" href="/2024/11/29/%E4%BA%8C%E5%BC%80%E6%8C%87%E5%8D%97/31%E5%8F%AF%E5%81%9C%E9%9D%A0%E5%AF%B9%E8%AF%9D%E6%A1%86%E7%AA%97%E6%A0%BC/" title="31可停靠对话框窗格"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-29</div><div class="info-item-2">31可停靠对话框窗格</div></div><div class="info-2"><div class="info-item-1">可停靠对话框窗格自Revit 2013以来，应用程序可以通过利用Revit API中的Idling事件（用户界面事件和外部事件）类来使用无模式对话框。需要非模态对话框的加载项也可以选择使用可停靠的非模态对话框。与标准的无模式对话框类似，可停靠对话框是注册的Windows Presentation...</div></div></div></a><a class="pagination-related" href="/2024/11/29/%E4%BA%8C%E5%BC%80%E6%8C%87%E5%8D%97/30%E5%A4%96%E9%83%A8%E4%BA%8B%E4%BB%B6/" title="30外部事件"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-29</div><div class="info-item-2">30外部事件</div></div><div class="info-2"><div class="info-item-1">外部事件Revit API提供了一个外部事件框架，以适应非模态对话框的使用。它是为异步处理量身定制的，其操作类似于具有默认频率的Idling事件。 要使用外部事件框架实现无模式对话框，请执行以下步骤：  通过从IExternalEventException接口派生来实现外部事件处理程序 使用静态ExternalEvent.Create（）方法创建ExternalEvent 当需要执行Revit操作的无模式对话框中发生事件时，调用ExternalEvent.Raise（） 当存在可用的空闲时间周期时，Revit将调用IExternalEvents.Execute（）方法的实现。  IExternalEventHandler这是要为外部事件实现的接口。实现此接口的类的实例注册到Revit中，每次引发相应的外部事件时，都会调用此接口的Execute方法。 IExternalEventHandler...</div></div></div></a><a class="pagination-related" href="/2024/11/29/%E4%BA%8C%E5%BC%80%E6%8C%87%E5%8D%97/29%E4%BA%8B%E4%BB%B6/" title="29事件"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-29</div><div class="info-item-2">29事件</div></div><div class="info-2"><div class="info-item-1">...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="giscus-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/images/4stars.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">funtim41@gmail.com</div><div class="author-info-description">实践-认识-再实践-再认识</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">32</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/FunTim41"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/FunTim41" target="_blank" title="Github"><i class="fab fa-github" style="color: #FFFFFF;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%A7%86%E5%9B%BE"><span class="toc-number">1.</span> <span class="toc-text">视图</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E8%A7%86%E5%9B%BE"><span class="toc-number">1.1.</span> <span class="toc-text">关于视图</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%86%E5%9B%BE%E7%9A%84%E7%94%9F%E6%88%90"><span class="toc-number">1.1.1.</span> <span class="toc-text">视图的生成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%86%E5%9B%BE%E5%AF%BC%E8%88%AA%E5%B7%A5%E5%85%B7"><span class="toc-number">1.1.2.</span> <span class="toc-text">视图导航工具</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%92%8C%E5%88%A0%E9%99%A4%E8%A7%86%E5%9B%BE"><span class="toc-number">1.1.3.</span> <span class="toc-text">创建和删除视图</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%86%E5%9B%BE%E5%9B%BE%E5%BD%A2"><span class="toc-number">1.2.</span> <span class="toc-text">视图图形</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Thin-Lines-%E7%BB%86%E7%BA%BF"><span class="toc-number">1.2.1.</span> <span class="toc-text">Thin Lines 细线</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%B4%E6%97%B6%E8%A7%86%E5%9B%BE%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.2.2.</span> <span class="toc-text">临时视图模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%86%E5%9B%BE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.3.</span> <span class="toc-text">视图类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">1.3.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3D%E8%A7%86%E5%9B%BE"><span class="toc-number">1.3.2.</span> <span class="toc-text">3D视图</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%8F%E8%A7%86%E5%9B%BE"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">透视图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8%E7%AD%89%E8%B7%9D%E5%92%8C%E9%80%8F%E8%A7%86%E4%B9%8B%E9%97%B4%E5%88%87%E6%8D%A2"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">在等距和透视之间切换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3D%E8%A7%86%E5%9B%BE%E5%89%96%E9%9D%A2%E6%A1%86"><span class="toc-number">1.3.2.3.</span> <span class="toc-text">3D视图剖面框</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%86%E5%9B%BE%E9%94%81%E5%AE%9A"><span class="toc-number">1.3.2.4.</span> <span class="toc-text">视图锁定</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%86%E5%9B%BE%E5%B9%B3%E9%9D%A2"><span class="toc-number">1.3.3.</span> <span class="toc-text">视图平面</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%B9%B3%E9%9D%A2%E8%A7%86%E5%9B%BE"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">创建平面视图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B3%E9%9D%A2%E8%A7%86%E5%9B%BE%E5%B1%9E%E6%80%A7"><span class="toc-number">1.3.3.2.</span> <span class="toc-text">平面视图属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%86%E5%9B%BE%E8%8C%83%E5%9B%B4"><span class="toc-number">1.3.3.3.</span> <span class="toc-text">视图范围</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B3%E9%9D%A2%E5%9B%BEunderlay"><span class="toc-number">1.3.3.4.</span> <span class="toc-text">平面图underlay</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%86%E5%9B%BE%E5%9B%BE%E7%BA%B8"><span class="toc-number">1.3.4.</span> <span class="toc-text">视图图纸</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%BE%E7%89%87%E8%A7%86%E5%9B%BE"><span class="toc-number">1.3.4.1.</span> <span class="toc-text">图片视图</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%96%E9%9D%A2%E8%A7%86%E5%9B%BE"><span class="toc-number">1.3.5.</span> <span class="toc-text">剖面视图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E7%BA%B8"><span class="toc-number">1.3.6.</span> <span class="toc-text">图纸</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%93%E5%8D%B0%E6%9C%BA%E8%AE%BE%E7%BD%AE"><span class="toc-number">1.3.6.1.</span> <span class="toc-text">打印机设置</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E8%A1%A8"><span class="toc-number">1.3.7.</span> <span class="toc-text">图表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%8E%E7%BB%86%E8%A1%A8%E7%B1%BB"><span class="toc-number">1.3.7.1.</span> <span class="toc-text">明细表类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%98%8E%E7%BB%86%E8%A1%A8%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE"><span class="toc-number">1.3.7.1.1.</span> <span class="toc-text">使用明细表中的数据</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%86%E5%9B%BE%E6%98%8E%E7%BB%86%E8%A1%A8"><span class="toc-number">1.3.7.2.</span> <span class="toc-text">视图明细表</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E6%98%8E%E7%BB%86%E8%A1%A8"><span class="toc-number">1.3.7.2.1.</span> <span class="toc-text">创建明细表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8ViewSchedule"><span class="toc-number">1.3.7.2.2.</span> <span class="toc-text">使用ViewSchedule</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E5%AD%97%E6%AE%B5"><span class="toc-number">1.3.7.2.2.1.</span> <span class="toc-text">添加字段</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%A0%87%E9%A2%98%E5%92%8C%E6%A0%87%E5%A4%B4"><span class="toc-number">1.3.7.2.2.2.</span> <span class="toc-text">标题和标头</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%98%8E%E7%BB%86%E8%A1%A8%E4%B8%AD%E7%9A%84%E6%9F%A5%E8%AF%A2%E5%92%8C%E6%8E%92%E5%BA%8F"><span class="toc-number">1.3.7.2.2.3.</span> <span class="toc-text">明细表中的查询和排序</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%BF%87%E6%BB%A4"><span class="toc-number">1.3.7.2.2.4.</span> <span class="toc-text">过滤</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%98%8E%E7%BB%86%E8%A1%A8%E6%95%B0%E6%8D%AE"><span class="toc-number">1.3.7.2.2.5.</span> <span class="toc-text">使用明细表数据</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%85%8D%E7%94%B5%E7%9B%98%E6%98%8E%E7%BB%86%E8%A1%A8"><span class="toc-number">1.3.7.3.</span> <span class="toc-text">配电盘明细表</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%85%8D%E7%94%B5%E7%9B%98%E6%98%8E%E7%BB%86%E8%A1%A8%E5%88%9B%E5%BB%BA"><span class="toc-number">1.3.7.3.0.1.</span> <span class="toc-text">配电盘明细表创建</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E9%85%8D%E7%94%B5%E7%9B%98%E6%98%8E%E7%BB%86%E8%A1%A8"><span class="toc-number">1.3.7.3.0.2.</span> <span class="toc-text">使用配电盘明细表</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%AE%E8%AE%A2"><span class="toc-number">1.4.</span> <span class="toc-text">修订</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE"><span class="toc-number">1.4.1.</span> <span class="toc-text">设置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%AE%E8%AE%A2%E4%BA%91%E7%BA%BF"><span class="toc-number">1.4.2.</span> <span class="toc-text">修订云线</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E4%BA%91%E7%BA%BF%E6%89%B9%E6%B3%A8"><span class="toc-number">1.4.3.</span> <span class="toc-text">创建云线批注</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%AE%E8%AE%A2%E4%BA%91%E7%BA%BF%E5%87%A0%E4%BD%95%E5%9B%BE%E5%BD%A2"><span class="toc-number">1.4.4.</span> <span class="toc-text">修订云线几何图形</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8ERevisionCloud%E5%85%B3%E8%81%94%E7%9A%84%E4%BF%AE%E8%AE%A2%E7%89%88%E6%9C%AC"><span class="toc-number">1.4.5.</span> <span class="toc-text">与RevisionCloud关联的修订版本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E7%BA%B8-1"><span class="toc-number">1.4.6.</span> <span class="toc-text">图纸</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%86%E5%9B%BE%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="toc-number">1.5.</span> <span class="toc-text">视图过滤器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ParameterFilterElement"><span class="toc-number">1.5.1.</span> <span class="toc-text">ParameterFilterElement</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SelectionFilterElement"><span class="toc-number">1.5.2.</span> <span class="toc-text">SelectionFilterElement</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%86%E5%9B%BE%E8%A3%81%E5%89%AA"><span class="toc-number">1.6.</span> <span class="toc-text">视图裁剪</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%AE%E6%8D%A2%E8%A7%86%E5%9B%BE"><span class="toc-number">1.7.</span> <span class="toc-text">置换视图</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%BD%AE%E6%8D%A2%E8%A7%86%E5%9B%BE"><span class="toc-number">1.7.1.</span> <span class="toc-text">创建置换视图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%BD%AE%E6%8D%A2%E5%9B%BE%E5%85%83"><span class="toc-number">1.7.2.</span> <span class="toc-text">使用置换图元</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E4%BD%8D%E7%A7%BB%E8%B7%AF%E5%BE%84"><span class="toc-number">1.7.3.</span> <span class="toc-text">创建位移路径</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#UIView"><span class="toc-number">1.8.</span> <span class="toc-text">UIView</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%A9%E6%94%BE%E6%93%8D%E4%BD%9C"><span class="toc-number">1.8.1.</span> <span class="toc-text">缩放操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E9%97%AD%E8%A7%86%E5%9B%BE"><span class="toc-number">1.8.2.</span> <span class="toc-text">关闭视图</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%EF%BC%9A%E7%BF%BB%E8%AF%91%E8%87%AARevit-API-Developers-Guide"><span class="toc-number">1.9.</span> <span class="toc-text">注：翻译自Revit API Developers Guide</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/24/%E4%BA%8C%E5%BC%80%E6%8C%87%E5%8D%97/26%E7%BB%93%E6%9E%84%E5%B7%A5%E7%A8%8B/" title="26结构工程">26结构工程</a><time datetime="2024-12-29T12:52:26.154Z" title="更新于 2024-12-29 20:52:26">2024-12-29</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/23/%E4%BA%8C%E5%BC%80%E6%8C%87%E5%8D%97/33%E5%91%BD%E4%BB%A4/" title="33命令">33命令</a><time datetime="2024-12-29T07:31:06.970Z" title="更新于 2024-12-29 15:31:06">2024-12-29</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/29/%E4%BA%8C%E5%BC%80%E6%8C%87%E5%8D%97/32%E5%8A%A8%E6%80%81%E6%A8%A1%E5%9E%8B%E6%9B%B4%E6%96%B0/" title="32动态模型更新">32动态模型更新</a><time datetime="2024-12-29T07:31:06.967Z" title="更新于 2024-12-29 15:31:06">2024-12-29</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/29/%E4%BA%8C%E5%BC%80%E6%8C%87%E5%8D%97/31%E5%8F%AF%E5%81%9C%E9%9D%A0%E5%AF%B9%E8%AF%9D%E6%A1%86%E7%AA%97%E6%A0%BC/" title="31可停靠对话框窗格">31可停靠对话框窗格</a><time datetime="2024-12-29T07:31:06.962Z" title="更新于 2024-12-29 15:31:06">2024-12-29</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/29/%E4%BA%8C%E5%BC%80%E6%8C%87%E5%8D%97/30%E5%A4%96%E9%83%A8%E4%BA%8B%E4%BB%B6/" title="30外部事件">30外部事件</a><time datetime="2024-12-29T07:31:06.959Z" title="更新于 2024-12-29 15:31:06">2024-12-29</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/images/topback.jpg);"><div id="footer-wrap"><div class="copyright">&copy;2024 By funtim41@gmail.com</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">学而不思则罔，思而不学则殆。</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>(() => {
  const panguFn = () => {
    if (typeof pangu === 'object') pangu.autoSpacingPage()
    else {
      btf.getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
        .then(() => {
          pangu.autoSpacingPage()
        })
    }
  }

  const panguInit = () => {
    if (false){
      GLOBAL_CONFIG_SITE.isPost && panguFn()
    } else {
      panguFn()
    }
  }

  btf.addGlobalFn('pjaxComplete', panguInit, 'pangu')
  document.addEventListener('DOMContentLoaded', panguInit)
})()</script><div class="js-pjax"><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.isShuoshuo
  const option = null

  const getGiscusTheme = theme => theme === 'dark' ? 'dark' : 'light'

  const createScriptElement = config => {
    const ele = document.createElement('script')
    Object.entries(config).forEach(([key, value]) => {
      ele.setAttribute(key, value)
    })
    return ele
  }

  const loadGiscus = (el = document, key) => {
    const mappingConfig = isShuoshuo
      ? { 'data-mapping': 'specific', 'data-term': key }
      : { 'data-mapping': (option && option['data-mapping']) || 'pathname' }

    const giscusConfig = {
      src: 'https://giscus.app/client.js',
      'data-repo': 'FunTim41/funtim41.github.io',
      'data-repo-id': 'R_kgDONjG8ww',
      'data-category-id': 'DIC_kwDONjG8w84Cllg2',
      'data-theme': getGiscusTheme(document.documentElement.getAttribute('data-theme')),
      'data-reactions-enabled': '1',
      crossorigin: 'anonymous',
      async: true,
      ...option,
      ...mappingConfig
    }

    const scriptElement = createScriptElement(giscusConfig)

    el.querySelector('#giscus-wrap').appendChild(scriptElement)

    if (isShuoshuo) {
      window.shuoshuoComment.destroyGiscus = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }
  }

  const changeGiscusTheme = theme => {
    const iframe = document.querySelector('#giscus-wrap iframe')
    if (iframe) {
      const message = {
        giscus: {
          setConfig: {
            theme: getGiscusTheme(theme)
          }
        }
      }
      iframe.contentWindow.postMessage(message, 'https://giscus.app')
    }
  }

  btf.addGlobalFn('themeChange', changeGiscusTheme, 'giscus')

  if (isShuoshuo) {
    'Giscus' === 'Giscus'
      ? window.shuoshuoComment = { loadComment: loadGiscus }
      : window.loadOtherComment = loadGiscus
    return
  }

  if ('Giscus' === 'Giscus' || !false) {
    if (false) btf.loadComment(document.getElementById('giscus-wrap'), loadGiscus)
    else loadGiscus()
  } else {
    window.loadOtherComment = loadGiscus
  }
})()</script></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>