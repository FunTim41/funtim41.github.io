<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>18几何 | funtim的博客</title><meta name="author" content="funtim41@gmail.com"><meta name="copyright" content="funtim41@gmail.com"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="几何Autodesk.Revit.DB 命名空间包含许多与几何和图形相关类型相关的类，用于描述 API 中的图形表示。几何相关的类包括：  GeometryObject class - 包含从几何对象类派生的类。 Geometry Helper Classes - 包含从 APIObject 类派生出的类和值类型 Geometry Utility Classes - 包含创建非元素几何体和查找实体">
<meta property="og:type" content="article">
<meta property="og:title" content="18几何">
<meta property="og:url" content="https://funtim41.github.io/2024/12/14/Revit%E4%BA%8C%E5%BC%80%E6%8C%87%E5%8D%97/18%E5%87%A0%E4%BD%95/">
<meta property="og:site_name" content="funtim的博客">
<meta property="og:description" content="几何Autodesk.Revit.DB 命名空间包含许多与几何和图形相关类型相关的类，用于描述 API 中的图形表示。几何相关的类包括：  GeometryObject class - 包含从几何对象类派生的类。 Geometry Helper Classes - 包含从 APIObject 类派生出的类和值类型 Geometry Utility Classes - 包含创建非元素几何体和查找实体">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://funtim41.github.io/images/4stars.png">
<meta property="article:published_time" content="2024-12-14T13:45:11.000Z">
<meta property="article:modified_time" content="2024-12-29T07:31:06.912Z">
<meta property="article:author" content="funtim41@gmail.com">
<meta property="article:tag" content="Revit">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://funtim41.github.io/images/4stars.png"><link rel="shortcut icon" href="/images/OIP.jfif"><link rel="canonical" href="https://funtim41.github.io/2024/12/14/Revit%E4%BA%8C%E5%BC%80%E6%8C%87%E5%8D%97/18%E5%87%A0%E4%BD%95/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: funtim41@gmail.com","link":"链接: ","source":"来源: funtim的博客","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'null',
  Snackbar: {"chs_to_cht":"已切换为繁体中文","cht_to_chs":"已切换为简体中文","day_to_night":"已切换为深色模式","night_to_day":"已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: true,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '18几何',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  isShuoshuo: false
}</script><link rel="stylesheet" href="/css/bar.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background: Color(#995a82);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/images/4stars.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">55</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Timeline</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/Links/"><i class="fa-fw fas fa-link"></i><span> Links</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/images/topback.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/images/OIP.jfif" alt="Logo"><span class="site-name">funtim的博客</span></a><a class="nav-page-title" href="/"><span class="site-name">18几何</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Timeline</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/Links/"><i class="fa-fw fas fa-link"></i><span> Links</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">18几何</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-12-14T13:45:11.000Z" title="发表于 2024-12-14 21:45:11">2024-12-14</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-12-29T07:31:06.912Z" title="更新于 2024-12-29 15:31:06">2024-12-29</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Revit%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%E4%BA%BA%E5%91%98%E6%8C%87%E5%8D%97/">Revit二次开发人员指南</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="几何"><a href="#几何" class="headerlink" title="几何"></a><a target="_blank" rel="noopener" href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_Revit_Geometric_Elements_Geometry_html">几何</a></h1><p>Autodesk.Revit.DB 命名空间包含许多与几何和图形相关类型相关的类，用于描述 API 中的图形表示。几何相关的类包括：</p>
<ul>
<li>GeometryObject class - 包含从几何对象类派生的类。</li>
<li>Geometry Helper Classes - 包含从 APIObject 类派生出的类和值类型</li>
<li>Geometry Utility Classes - 包含创建非元素几何体和查找实体交点的类</li>
<li>Collection Classes - 包括从 IEnumerable 或 IEnumerator 接口派生的类。</li>
</ul>
<p>在这一节中，您将学习如何使用各种图形相关类型，如何从元素中检索几何数据，如何变换元素，以及更多内容。</p>
<p><strong>本节页面</strong></p>
<ul>
<li>从墙壁中检索几何数据</li>
<li>GeometryObject类</li>
<li>几何辅助类</li>
<li>集合类</li>
<li>从梁中检索几何数据</li>
<li>固体挤压分析</li>
<li>通过光线投影寻找几何图形</li>
<li>几何工具类</li>
<li>房间与空间几何</li>
</ul>
<h2 id="示例：从墙壁中检索几何数据"><a href="#示例：从墙壁中检索几何数据" class="headerlink" title="示例：从墙壁中检索几何数据"></a>示例：从墙壁中检索几何数据</h2><p>本教程演示了如何从墙壁获取几何数据。以下信息被涵盖：</p>
<ul>
<li>获取墙体几何边缘。</li>
<li>获取墙体几何面。</li>
</ul>
<p>注意：在本例中，由于未考虑实例，从元素中检索几何数据受到限制。例如，包含在墙中的放样在示例代码中不可用。本指南的目标是让您对如何检索几何数据有一个基本了解，但并不涵盖所有情况。有关从元素中检索几何数据的更多信息，请参阅示例：从梁中检索几何数据。</p>
<p>代码区域20-1：创建 Geometry.Options</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Autodesk.Revit.DB.Options geomOption = application.Create.NewGeometryOptions();</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">null</span> != geomOption)</span><br><span class="line">&#123;</span><br><span class="line">        geomOption.ComputeReferences = <span class="literal">true</span>;</span><br><span class="line">        geomOption.DetailLevel = Autodesk Autodesk.Revit.DB.DetailLevels.Fine;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Either the DetailLevel or the View can be set, but not both</span></span><br><span class="line">        <span class="comment">//geomOption.View = commandData.Application.ActiveUIDocument.Document.ActiveView;</span></span><br><span class="line"></span><br><span class="line">        TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>, <span class="string">&quot;Geometry Option created successfully.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：有关详细信息，请参阅几何辅助类。</p>
<p>检索面和边</p>
<p> 墙几何图形是由面和边组成的实体。完成以下步骤以获取面和边：</p>
<p>1.使用Wall类的Geometry属性创建一个Geometry.Element实例。此实例包含“对象”属性中的所有几何体对象，如实体、直线等。</p>
<p>2.迭代Object属性以获取几何体实体实例，该实例包含“面”和“边”属性中的所有几何体面和边。</p>
<p>3.迭代“面”属性以获取所有几何体面。</p>
<p>4.迭代Edges属性以获取所有几何体边。 </p>
<p>示例代码如下：</p>
<p>代码区域20-2：检索面和边</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">GetFacesAndEdges</span>(<span class="params">Wall wall</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        String faceInfo = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">        Autodesk.Revit.DB.Options opt = <span class="keyword">new</span> Options();</span><br><span class="line">        Autodesk.Revit.DB.GeometryElement geomElem = wall.get_Geometry(opt);</span><br><span class="line">        <span class="keyword">foreach</span> (GeometryObject geomObj <span class="keyword">in</span> geomElem)</span><br><span class="line">        &#123;</span><br><span class="line">                Solid geomSolid = geomObj <span class="keyword">as</span> Solid;</span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">null</span> != geomSolid)</span><br><span class="line">                &#123;</span><br><span class="line">                        <span class="built_in">int</span> faces = <span class="number">0</span>;</span><br><span class="line">                        <span class="built_in">double</span> totalArea = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">foreach</span> (Face geomFace <span class="keyword">in</span> geomSolid.Faces)</span><br><span class="line">                        &#123;</span><br><span class="line">                                faces++;</span><br><span class="line">                                faceInfo += <span class="string">&quot;Face &quot;</span> + faces + <span class="string">&quot; area: &quot;</span> + geomFace.Area.ToString() + <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">                                totalArea += geomFace.Area;</span><br><span class="line">                        &#125;</span><br><span class="line">                        faceInfo += <span class="string">&quot;Number of faces: &quot;</span> + faces + <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">                        faceInfo += <span class="string">&quot;Total area: &quot;</span> + totalArea.ToString() + <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">                        <span class="keyword">foreach</span> (Edge geomEdge <span class="keyword">in</span> geomSolid.Edges)</span><br><span class="line">                        &#123;</span><br><span class="line">                                <span class="comment">// get wall&#x27;s geometry edges</span></span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>, faceInfo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="GeometryObject类"><a href="#GeometryObject类" class="headerlink" title="GeometryObject类"></a>GeometryObject类</h2><p>索引属性Element.Geometry[]可用于提取任何模型元素（3D元素）的几何图形。这既适用于系统族实例（如墙、楼板和屋顶），也适用于许多类别的族实例（如门、窗、家具或体量）。</p>
<p>提取的几何图形将作为Autodesk. Revit. DB. GeometryElement返回给您。可以使用GetEnumerator（）方法遍历该元素的几何成员。</p>
<p>通常，在提取的几何图形的顶层返回的对象将是以下对象之一：</p>
<ul>
<li>Solids, Faces and Edges-由面和边组成的边界表示</li>
<li>Meshes-三角形的3D阵列</li>
<li>Curves-有界3D曲线</li>
<li>Points – 给定3D位置处的可见基准点</li>
<li>PolyLines – 由3D点定义的一系列线段</li>
<li>GeometryInstances-位于元素内的几何元素的实例</li>
</ul>
<p>该图说明了通过几何体提取找到的对象的层次结构。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/geometry_hierarchy.png"></p>
<p>本节中的页面</p>
<ul>
<li>Curves </li>
<li>GeometryInstances </li>
<li>Meshes </li>
<li>Points </li>
<li>PolyLines </li>
<li>Solids, Faces and Edges</li>
</ul>
<h3 id="Curves"><a href="#Curves" class="headerlink" title="Curves"></a>Curves</h3><p>曲线表示Revit模型中的二维或三维路径。曲线可以表示元素几何形状的整个范围（例如CurveElements），也可以显示为元素几何形状的一部分（例如墙或风管的中心线）。曲线和曲线集合在API的许多元素创建方法中用作输入。</p>
<p>本节中的页面</p>
<ul>
<li>曲线分析</li>
<li>曲线工作</li>
<li>曲线集合</li>
<li>曲线创建</li>
<li>曲线参数化</li>
<li>曲线类型</li>
<li>曲线类型的数学表示</li>
</ul>
<h4 id="曲线分析"><a href="#曲线分析" class="headerlink" title="曲线分析"></a>曲线分析</h4><p>有几种曲线方法是适用于几何分析的工具。</p>
<p>在某些情况下，这些API所做的事情比您通过快速查看其名称所期望的要多。</p>
<p><strong>Intersect()</strong></p>
<p>“相交”方法允许您比较两条曲线，以找出它们的不同之处或相似之处。它可以以您可能期望的方式使用，以获得两条曲线彼此相交的点，但它也可以用于识别：</p>
<ul>
<li>Collinear lines 共线的线</li>
<li>Overlapping lines 重叠线</li>
<li>Identical curves 相同曲线</li>
<li>Totally distinct curves with no intersections 完全不同的曲线，没有交叉点</li>
</ul>
<p>返回值标识这些不同的结果，输出IntersectionSetResult包含有关交点的信息。</p>
<p><strong>Project()</strong> </p>
<p>Project方法将点投影到曲线上，并返回有关曲线上最近点、其参数以及与投影点的距离的信息。</p>
<p><strong>Tessellate()</strong></p>
<p>这会将曲线分割为一系列线性段，精确度在默认公差范围内。对于Curve.Tessellate（），公差略大于1&#x2F;16”。此近似公差是Revit内部使用的公差，足以满足显示目的。</p>
<p>请注意，只有直线可以被分割成只有两个细分点的输出;非线性曲线将总是输出两个以上的点，即使曲线具有极大的半径，在数学上可能等同于直线。</p>
<h4 id="曲线工作"><a href="#曲线工作" class="headerlink" title="曲线工作"></a>曲线工作</h4><p>Curve类提供了使用曲线的有用方法。</p>
<p>除了对分析有用的方法外，Curve类还提供了用于修改曲线或获取有关曲线的基本信息的属性和方法。</p>
<p><strong>改变界限</strong></p>
<p>MakeBound（）方法可用于更改曲线的边界或为先前未绑定的曲线创建边界。MakeUnbound（）将使曲线未绑定。对于这两种方法，如果曲线标记为只读（因为它是直接从Revit图元或集合&#x2F;聚合对象中提取的），则调用此方法会导致对象更改为包含原始曲线的断开连接的副本。修改不会影响原始曲线或提供原始曲线的对象。</p>
<p><strong>图形样式</strong></p>
<p>Curve从GeometryObject继承GraphicsStyleId只读属性，GeometryObject提供指定给Curve的GraphicsStyle的ElementId。方法Curve.SetGraphicsStyleId（）可用于设置Curve的GraphicsStyle Id。Revit API中的许多方法将不使用与此曲线关联的图形样式。例如，用作图元草图一部分的曲线将不会读取此属性。新创建的曲线元素也不会使用此值，因为它们从其关联类别继承图形特性。</p>
<p><strong>曲线长度</strong></p>
<p>曲线有两个与长度相关的属性。Length属性将返回曲线的精确长度。我使用解析或数值积分计算曲线的长度。对于直线和圆弧没有性能影响。对于更快的近似，ApproximateLength属性可以快速估计曲线的长度，但在某些情况下可能会偏离2倍。此计算对于直线和圆弧是精确的。</p>
<h4 id="曲线集合"><a href="#曲线集合" class="headerlink" title="曲线集合"></a>曲线集合</h4><p>Revit API使用不同类型的曲线集合作为输入。</p>
<p>注意：较新的API方法使用Curves的.NET集合代替CurveArray和CurveArrArray。</p>
<p><strong>CurveLoop</strong></p>
<p>curveloop表示端到端连接的特定曲线链。它可以表示一个闭环或一个开环。curveloop的成员可以直接迭代，因为该类实现了IEnumerable。迭代提供了直接包含在循环中的曲线的副本；曲线的修改不会影响loop中包含的曲线。可以使用以下方法创建CurveLoops：</p>
<ul>
<li>CurveLoop.Create（）-从曲线列表创建新的CurveLoop。</li>
<li>CurveLoop.CreateViaCopy() - 创建新的CurveLoop作为现有CurveLoop的副本。</li>
<li>CurveLoop. ViaThumb（Curve，double，XYZ）-通过相对于给定平面加厚输入曲线来创建新的闭合CurveLoop。</li>
<li>CurveLoop. curveViaThrottle（CurveLoop，double，XYZ）-通过相对于给定平面加厚输入开放曲线循环来创建新的闭合曲线循环。</li>
<li>CurveLoop.CreateViaTransform() - 创建一个新的CurveLoop作为输入CurveLoop的转换副本。请注意，重载ViaThursday（）方法的thickness参数必须导致曲线超过Revit的短曲线容差（Application.ShortCurveTolerance），否则将引发异常。</li>
</ul>
<p>CurveLoop.Transform（） 的执行方式与 CreateViaTransform（） 类似，但它会变换 CurveLoop 中包含的曲线，而不是创建变换后的副本。</p>
<p><strong>CurveArray</strong></p>
<p>此集合类表示曲线的任意集合。使用其构造函数创建它。</p>
<p><strong>CurveArrArray</strong></p>
<p>此集合类是 CurveArray 的集合。当使用 this 时，此数组的子元素的组织对 this 传递给的方法有意义;例如，在 NewExtrusion（） 中，多个 CurveArrays 应该表示不同的闭合循环。</p>
<h4 id="曲线创建"><a href="#曲线创建" class="headerlink" title="曲线创建"></a>曲线创建</h4><p>通常需要将曲线作为 Revit API 方法的输入。可以通过多种方式创建它们。</p>
<p>曲线具有许多派生类型，这些类型具有用于创建曲线的静态方法。基类 Curve 还具有从现有曲线创建新曲线的方法。</p>
<p>曲线创建方法会阻止创建短于 Revit 容差的曲线。此容差通过 Application.ShortCurveTolerance 属性公开。</p>
<p><strong>Curve</strong> </p>
<p>Curve 类具有多种从现有曲线创建新曲线的方法。</p>
<ul>
<li>Clone（） - 创建此曲线的副本。</li>
<li>CreateOffset（） - 从该曲线创建一个新的曲线偏移。</li>
<li>CreateReversed（） - 创建一条与现有曲线方向相反的新曲线</li>
<li>Curve.CreateTransformed（） - 创建曲线的新实例作为该曲线的变换。</li>
</ul>
<p><strong>Line</strong></p>
<p>有两种静态方法可用于创建新 Line。</p>
<ul>
<li>CreateBound() - 在两点之间创建新的边界线性曲线。</li>
<li>CreateUnbound() - 在给定原点和方向的情况下创建新的未绑定线性曲线。</li>
</ul>
<p>Code Region：创建unbound 的线性曲线</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// define start point and direction for unbound line</span></span><br><span class="line">XYZ startPoint = <span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">XYZ directionPt = <span class="keyword">new</span> XYZ(<span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// create line</span></span><br><span class="line">Line line = Line.CreateUnbound(startPoint, directionPt);</span><br></pre></td></tr></table></figure>

<p><strong>Arc</strong> </p>
<p>重载的静态 Create（） 方法允许通过以下三种方式之一创建 Arc：</p>
<ul>
<li><p>基于 3 点</p>
</li>
<li><p>代码区域：创建具有 3 个点的圆弧</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create a new arc using two ends and a point on the curve</span></span><br><span class="line">XYZ end0 = <span class="keyword">new</span> XYZ(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);    <span class="comment">// start point of the arc</span></span><br><span class="line">XYZ end1 = <span class="keyword">new</span> XYZ(<span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>); <span class="comment">// end point of the arc</span></span><br><span class="line">XYZ pointOnCurve = <span class="keyword">new</span> XYZ(<span class="number">10</span>, <span class="number">0</span>, <span class="number">0</span>);   <span class="comment">// point along arc</span></span><br><span class="line"></span><br><span class="line">Arc arc = Arc.Create(end0, end1, pointOnCurve);</span><br></pre></td></tr></table></figure>
</li>
<li><p>基于平面、半径和角度</p>
</li>
<li><p>代码区域：使用平面创建圆弧</p>
</li>
<li><pre><code class="c#">Arc CreateArcByGivingPlane(Autodesk.Revit.ApplicationServices.Application application, Plane plane)
&#123;
    // Create an arc which is placed on the plane and whose center is the plane&#39;s origin
    double radius = 10;
    double startAngle = 0;      // The unit is radian
    double endAngle = 2 * Math.PI;        // this arc will be a circle
    return Arc.Create(plane, radius, startAngle, endAngle);
&#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">- based on center, radius, angles and two axes</span><br><span class="line">  基于圆心、半径、角度和两个轴</span><br><span class="line"></span><br><span class="line">  代码区域：使用轴创建圆弧</span><br><span class="line"></span><br><span class="line">  ```c#</span><br><span class="line">  // Create a new arc defined by its center, radios, angles and 2 axes</span><br><span class="line">  double radius = 10;</span><br><span class="line">  double startAngle = 0;      // In radian</span><br><span class="line">  double endAngle = Math.PI;        // In radian</span><br><span class="line">  XYZ center = new XYZ(5, 0, 0);</span><br><span class="line">  XYZ xAxis = new XYZ(1, 0, 0);   // The x axis to define the arc plane. Must be normalized</span><br><span class="line">  XYZ yAxis = new XYZ(0, 1, 0);   // The y axis to define the arc plane. Must be normalized</span><br><span class="line">  </span><br><span class="line">  Arc arc = Arc.Create(center, radius, startAngle, endAngle, xAxis, yAxis);</span><br></pre></td></tr></table></figure>

注意，对于后两个选项，如果角度范围等于或大于 2 * PI，则曲线将自动转换为无界圆。
</code></pre>
</li>
</ul>
<p><strong>Ellipse</strong> </p>
<p>静态 CreateCurve（） 方法创建一个椭圆，给定中心、椭圆的 x 向量和 y 向量半径、x 轴和 y 轴以定义椭圆的平面以及开始和结束参数。如果 x 半径和 y 半径几乎相等，它将返回一个圆弧，否则将返回一个椭圆。</p>
<p><strong>Cylindrical Helix</strong></p>
<p>CylindricalHelix 的静态 Create（） 方法从轴的基点、半径、x 向量、z 向量、螺距、起始角度（用于指定螺旋线的起点）和结束角度（用于指定螺旋线的终点）创建一个新的 CylindricalHelix。z 向量是轴方向，应垂直于 x 向量。正螺距产生右旋螺旋，而负螺距产生左旋螺旋。</p>
<p><strong>NURBS</strong> </p>
<p>NurbSpline 类表示 NURBS 或非均匀有理 B 样条曲线。重载的静态 CreateCurve（） 方法提供了多种创建 NURBS 曲线的方法。第一种方法是使用 Revit 在用户界面中绘制样条曲线时使用的相同计算。它需要一个控制点和权重的列表来创建新的 NurbSpline。样条的结和阶数是根据给定的控制点和权重计算的。</p>
<p>第二个选项还需要控制点和权重列表，还需要结列表以及 NurbSpline 的阶数。度数必须为 1 或更大。必须至少有 degree+1 个控制点。结的大小必须等于 degree、control points 数组的大小和 1 之和。第一度 + 1 节应该相同，最后一度 + 1 节也应相同。序列中间的结必须是非递减的。</p>
<p>第三个选项只需要控制点和权重。必须至少有 2 个控制点，并且权重的数量必须等于控制点的数量。所有权重的值都必须为正。</p>
<p>在所有情况下，创建的曲线可以是 NURBSpline 或更简单的曲线，例如直线或圆弧。这与 Revit 的期望一致，即在 Revit 图元中应使用尽可能简单的曲线表示。</p>
<p><strong>Hermite Spline</strong></p>
<p>重载的静态 HermiteSpline.Create（） 方法提供了两个用于创建 Hermite 样条的选项。最简单的方法是创建端点处具有默认切线的 Hermite 样条，并且只需要一个控制点列表和一个指示 Hermite 样条是否为周期性的标志。第二个选项将创建在其端点处具有指定切线的 Hermite 样条曲线。它有一个附加的 HermiteSplineTangents 对象参数，用于指定曲线起点和&#x2F;或终点的切线。</p>
<h4 id="曲线参数化"><a href="#曲线参数化" class="headerlink" title="曲线参数化"></a>曲线参数化</h4><p>Revit API 中的曲线可以描述为输入参数“u”的数学函数，其中曲线在 XYZ 空间中任何给定点的位置是“u”的函数。</p>
<p>曲线可以是绑定的，也可以是未绑定的。未绑定曲线没有端点，表示无限抽象（未绑定的直线）或循环曲线（圆或椭圆）。</p>
<p>在 Revit 中，参数“u”可以用两种方式表示：</p>
<ul>
<li>一个 ‘normalized’ 参数。参数的起始值为 0.0，结束值为 1.0。对于某些曲线类型，这使得沿曲线范围的曲线计算非常容易，例如，直线的中点位于参数 0.5 处。（请注意，对于更复杂的曲线方程式（如 Splines），不能总是做出此假设）。</li>
<li>一个 ‘raw’ 参数。参数的 start 和 end 值可以是任何值。对于给定的曲线，最小和最大原始参数的值可以通过 Curve.GetEndParameter（int） 获取。原始参数非常有用，因为它们的单位与 Revit 默认单位（英尺）相同。因此，要从起点沿曲线获得 5 英尺的位置，您可以在起点处获取 raw 参数，并在其上添加 5。原始参数也是计算未绑定曲线的唯一方法。</li>
</ul>
<p>方法 Curve.ComputeNormalizedParameter（） 和 Curve.ComputeRawParameter（） 会自动在两种参数类型之间缩放。方法 Curve.IsInside（） 计算原始参数，以查看它是否位于曲线的边界内。</p>
<p>您可以使用参数来计算曲线在任何给定位置的各种属性：</p>
<ul>
<li>给定曲线的 XYZ 位置。这是从 Curve.Evaluate（） 返回的。可以提供 raw 或 normalized 参数。如果您还调用 ComputeDerivatives（），则这也是 .Origin 属性。</li>
<li>给定曲线的第一个导数&#x2F;切线向量。这是 .Curve.ComputeDerivatives（） 返回的 Transform 的 BasisX 属性。</li>
<li>给定曲线的第二个导数&#x2F;法向量。这是 .BasisY 属性。</li>
<li>给定曲线的<em>次法向量</em>，定义为切线向量和法向量的叉积。这是 .Curve.ComputeDerivatives（） 返回的 Transform 的 BasisZ 属性。</li>
</ul>
<p>返回的所有向量都是非规格化的（但可以使用XYZ.Normalize（）规格化Revit API中的任何向量）。请注意，当曲线是直线时，将不会为法线和副法线向量设置值。可以使用切向量计算给定平面中直线的法向量。</p>
<p>API示例“DirectionCalculation”使用墙位置曲线的切线向量来查找朝南的外墙：</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/directioncalculation_sample.png"></p>
<p>寻找并突出显示朝南的外墙</p>
<h4 id="曲线类型"><a href="#曲线类型" class="headerlink" title="曲线类型"></a>曲线类型</h4><p>Revit使用各种曲线类型来表示文档中的曲线几何图形。</p>
<table>
<thead>
<tr>
<th><strong>Curve type 曲线类型</strong></th>
<th>Revit API类**</th>
<th><strong>Definition 定义</strong></th>
<th><strong>Notes 注意</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Bound line</td>
<td>Line</td>
<td>由端点定义的线段。</td>
<td>从Curve.GetEndpoint（）获取端点</td>
</tr>
<tr>
<td>Unbound line</td>
<td>Line</td>
<td>由位置和方向定义的无限线</td>
<td>使用Curve.IsBound标识这些。在原始参数&#x3D; 0处计算点和切向量，以找到直线方程的输入参数。</td>
</tr>
<tr>
<td>Arc</td>
<td>Arc</td>
<td>一个有界的圆弧</td>
<td>开始和结束在一定的角度。这些角度可以通过弧的每一端的原始参数值获得。</td>
</tr>
<tr>
<td>Circle</td>
<td>Arc</td>
<td>一个没有束缚的圆圈</td>
<td>使用Curve.IsBound标识。使用原始参数进行评价（从0到2π）</td>
</tr>
<tr>
<td>Cylindrical helix</td>
<td>CylindricalHelix</td>
<td>绕在圆柱体上的螺旋线，与圆柱体的轴线成恒定的角度</td>
<td>仅在楼梯和扶手中的特定应用中使用，在访问其他Revit图元和几何图形的曲线时不应使用或遇到。</td>
</tr>
<tr>
<td>Elliptical arc</td>
<td>Ellipse</td>
<td>一个约束椭圆段</td>
<td></td>
</tr>
<tr>
<td>Ellipse</td>
<td>Ellipse</td>
<td>无约束椭圆</td>
<td>使用Curve.IsBound标识。使用原始参数进行评价（从0到2π）</td>
</tr>
<tr>
<td>NURBS</td>
<td>NurbSpline</td>
<td>非均匀有理B样条曲线</td>
<td>用于在各种Revit工具中绘制的样条曲线，以及导入的几何图形</td>
</tr>
<tr>
<td>Hermite</td>
<td>HermiteSpline</td>
<td>一组点之间的样条插值</td>
<td>用于“逐点曲线”和软风管&#x2F;管道等工具，以及导入的几何图形</td>
</tr>
</tbody></table>
<p>所有Revit曲线类型的数学表示可以在曲线类型的数学表示找到。</p>
<h4 id="曲线类型的数学表示"><a href="#曲线类型的数学表示" class="headerlink" title="曲线类型的数学表示"></a>曲线类型的数学表示</h4><p>本节介绍Revit几何图形中遇到的曲线类型、其属性及其数学表示。</p>
<p><strong>Bound lines</strong></p>
<p>Bound lines由其端点定义。在Revit API中，从曲线-标高 GetEndPoint（）方法获取线的端点。</p>
<p>Bound lines上的点根据归一化参数“u”和Bound lines上点的方程为：</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/curve_bound_line.png"></p>
<p><strong>Unbound lines</strong></p>
<p>Unbound lines在Revit API中进行了专门处理。不能使用大多数曲线属性，但是，当提供原始参数时，Evaluate（）和ComputeDerivatives（）可用于获取曲线沿着的位置。</p>
<p>根据原始参数“u”以及线原点和归一化方向向量，未绑定线的点的方程为：</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/curve_unbound_line.png"></p>
<p><strong>Arcs and Circles</strong></p>
<p>圆弧和圆在Revit API中由Arc类表示。它们是根据半径、圆心和垂直于弧平面的矢量定义的，这些参数可以在Revit API中作为属性直接从Arc类访问。</p>
<p>圆的IsBound属性设置为true。这意味着它们只能通过使用原始参数（范围从0到2π）来计算，并且圆上的点的原始参数方程为：</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/curve_arcs.png"></p>
<p>其中假设圆位于XY平面内。</p>
<p>弧的开始和结束都有一定的角度。这些角度可以通过弧的每一端处的原始参数值来获得，并且这些值之间的角度值可以插入到与上述相同的等式中。</p>
<p><strong>圆柱螺旋</strong></p>
<p>圆柱螺旋线在Revit API中由ExtradricalHashion类表示。它们是根据螺旋缠绕的圆柱体的轴的基点、半径、x和y矢量、螺距以及起始角和结束角来定义的。</p>
<p><strong>椭圆和椭圆弧</strong></p>
<p>椭圆和椭圆弧段在Revit API中由Ellipse类表示。与圆弧和圆类似，它们在给定平面中根据其X和Y半径、中心和垂直于椭圆平面的向量来定义。</p>
<p>完整椭圆的IsBound属性设置为true。与圆类似，它们可以通过0和2π之间的原始参数进行评估：</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/curve_ellipse.png"></p>
<p><strong>NurbSpline</strong></p>
<p>NURBS用于用户绘制为曲线或3D对象草图的一部分的样条线段。它们还用于表示某些类型的导入几何数据。</p>
<p>NurbSpline的数据包括：</p>
<ul>
<li>长度为n+1的控制点数组</li>
<li>weights数组，长度也是n+1</li>
<li>曲线阶数，其值等于曲线阶数（k）的小一</li>
<li>长度为n + k +1的节点向量</li>
</ul>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/curve_nurb_spline.png"></p>
<p>Revit的草图绘制工具中使用的NurbSplines可以使用算法单独从控制点和阶数生成。可以在外部复制Revit算法执行的计算，请参见下面的示例：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">NurbSplinespline = curve.GeometryCurve <span class="keyword">as</span> NurbSpline;</span><br><span class="line">DoubleArrayknots = spline.Knots;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Convert to generic collection</span></span><br><span class="line">List knotList = <span class="keyword">new</span> List();</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; knots.Size; i++)</span><br><span class="line">&#123;</span><br><span class="line">    knotList.Add(knots.get_Item(i));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Preparation - get distance between each control point</span></span><br><span class="line">IList controlPoints = spline.CtrlPoints;</span><br><span class="line"><span class="built_in">int</span> numControlPoints = controlPoints.Count;</span><br><span class="line"><span class="built_in">double</span>[] chordLengths = <span class="keyword">new</span> <span class="built_in">double</span>[numControlPoints - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> iControlPoint = <span class="number">1</span>; iControlPoint &lt; numControlPoints; ++iControlPoint)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">double</span> chordLength = </span><br><span class="line">       controlPoints[iControlPoint].DistanceTo(controlPoints[iControlPoint - <span class="number">1</span>]);</span><br><span class="line">    chordLengths[iControlPoint - <span class="number">1</span>] = chordLength;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> degree = spline.Degree;</span><br><span class="line"><span class="built_in">int</span> order = degree + <span class="number">1</span>;</span><br><span class="line"><span class="built_in">int</span> numKnots = numControlPoints + order;</span><br><span class="line"><span class="built_in">double</span>[] computedKnots = <span class="keyword">new</span> <span class="built_in">double</span>[numKnots];</span><br><span class="line"><span class="built_in">int</span> iKnot = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Start knot with multiplicity degree + 1.</span></span><br><span class="line"><span class="built_in">double</span> startKnot = <span class="number">0.0</span>;</span><br><span class="line"><span class="built_in">double</span> knot = startKnot;</span><br><span class="line"><span class="keyword">for</span>(iKnot = <span class="number">0</span>; iKnot &lt; order; ++iKnot)</span><br><span class="line">&#123;</span><br><span class="line">    computedKnots[iKnot] = knot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Interior knots based on chord lengths</span></span><br><span class="line"><span class="built_in">double</span> prevKnot = knot;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="comment">/*blank*/</span>; iKnot &lt;= numControlPoints; ++iKnot) </span><br><span class="line">    <span class="comment">// Last loop computes end knot but does not set interior knot.</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">double</span> knotIncrement = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> jj = iKnot - order; jj &lt; iKnot - <span class="number">1</span>; ++jj)</span><br><span class="line">    &#123;</span><br><span class="line">        knotIncrement += chordLengths[jj];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    knotIncrement /= degree;</span><br><span class="line">    knot = prevKnot + knotIncrement;</span><br><span class="line">    <span class="keyword">if</span> (iKnot &lt; numControlPoints)</span><br><span class="line">        computedKnots[iKnot] = knot;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">break</span>;   <span class="comment">// Leave &quot;knot&quot; set to the end knot; do not increment &quot;ii&quot;.</span></span><br><span class="line"></span><br><span class="line">    prevKnot = knot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// End knot with multiplicity degree + 1.</span></span><br><span class="line"><span class="keyword">for</span>(<span class="comment">/*blank*/</span>; iKnot &lt; numKnots; ++iKnot)</span><br><span class="line">&#123;</span><br><span class="line">    computedKnots[iKnot] = knot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>HermiteSpline</strong></p>
<p>Hermite样条用于在一组控制点之间插值的曲线，如MEP中的逐点曲线和软风管和管道。它们还用于表示某些类型的导入几何数据。在Revit API中，HermiteSpline类提供了通过“控制点”、“切线”和“参数”属性访问点阵列、切线向量和参数的功能。</p>
<p>Hermite样条中两个节点之间的曲线方程为：</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/curve_hermite_1.png"></p>
<p>其中，Pk和Pk+1表示每个节点处的点，Mk和Mk+1表示切向量，并且uk和uk+1表示节点处的参数，并且基函数为：</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/curve_hermite_2.png"></p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/curve_hermite5.png"></p>
<h3 id="GeometryInstances"><a href="#GeometryInstances" class="headerlink" title="GeometryInstances"></a>GeometryInstances</h3><p>GeometryInstance表示Revit以默认配置存储的一组几何图形，然后根据图元的属性将其转换到正确的位置。最常见的遇到几何图形的情况是在族实例中。Revit使用几何图形库，允许它存储给定族的几何图形的单个副本，并在多个实例中重复使用该副本。</p>
<p>请注意，并非所有族实例都将包括几何图形。当Revit需要为给定实例制作族几何图形的唯一副本时（由于局部连接、交点以及与实例放置相关的其他因素的影响），不会遇到GeometryInstance;相反，实体几何图形将位于层次的顶层。</p>
<p>GeometryInstance提供了通过GetSymbolGeometry（）和GetInstanceGeometry（）方法读取其几何体的能力。这些方法返回另一个Autodesk.Revit.DB.GeometryElement，可以像第一级返回一样对其进行分析。</p>
<p>GetSymbolGeometry（）返回在族的坐标系中表示的几何图形。例如，当您需要“通用”表格的图片而不考虑项目中的方向和放置位置时，请使用此选项。这也是唯一一个将实际的Revit几何图形对象返回给您而不是复制的重载。这一点很重要，因为使用此几何图形作为输入来创建其他图元的操作（例如，标注尺寸或放置基于面的族）需要参照原始几何图形。</p>
<p>GetInstanceGeometry（）返回在放置实例的项目的坐标系中表示的几何图形。例如，当需要项目中实例的特定几何图形的图片时（例如，确保桌子与房间的墙壁平行放置），请使用此选项。这始终会返回图元几何图形的副本，因此，虽然它适用于实施导出器或几何分析工具，但不适合用于创建引用此几何图形的其他Revit图元。</p>
<p>GetInstanceGeometry（）和GetSymbolGeometry（）也有重载，它们可以通过任意坐标系变换几何体。这些方法始终返回类似于GetInstanceGeometry（）的副本。</p>
<p>GeometryInstance还存储了从符号坐标空间到实例坐标的变换。此转换可作为Transform属性访问。它也是通过GetInstanceGeometry（）提取几何体副本时使用的变换。有关更多详细信息，请参见几何辅助类。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/instances_transformed.png"></p>
<p>2个使用不同变换放置的族实例-将从两个族实例中获取相同的几何图形</p>
<p>对于某些族，可以嵌套多层。如果您遇到嵌套实例，则可能会以与第一级实例类似的方式对其进行解析。</p>
<p>给出了两个示例来解释如何解析实例的几何形状。</p>
<p>在此示例中，从GeometryInstance方法GetInstanceGeometry（）提取曲线。</p>
<p>代码区域：从实例获取曲线</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetAndTransformCurve</span>(<span class="params">Autodesk.Revit.ApplicationServices.Application app,</span></span></span><br><span class="line"><span class="params"><span class="function">            Autodesk.Revit.DB.Element element, Options geoOptions</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// Get geometry element of the selected element</span></span><br><span class="line">   Autodesk.Revit.DB.GeometryElement geoElement = element.get_Geometry(geoOptions);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Get geometry object</span></span><br><span class="line">   <span class="keyword">foreach</span> (GeometryObject geoObject <span class="keyword">in</span> geoElement)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="comment">// Get the geometry instance which contains the geometry information</span></span><br><span class="line">      Autodesk.Revit.DB.GeometryInstance instance =</span><br><span class="line">             geoObject <span class="keyword">as</span> Autodesk.Revit.DB.GeometryInstance;</span><br><span class="line">      <span class="keyword">if</span> (<span class="literal">null</span> != instance)</span><br><span class="line">      &#123;</span><br><span class="line">         GeometryElement instanceGeometryElement = instance.GetInstanceGeometry();</span><br><span class="line">         <span class="keyword">foreach</span> (GeometryObject o <span class="keyword">in</span> instanceGeometryElement)</span><br><span class="line">         &#123;</span><br><span class="line">            <span class="comment">// Try to find curves</span></span><br><span class="line">            Curve curve = o <span class="keyword">as</span> Curve;</span><br><span class="line">            <span class="keyword">if</span> (curve != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">               <span class="comment">// The curve is already transformed into the project coordinate system</span></span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在此示例中，使用GetSymbolGeometry（）从实例中获取实体。然后使用GeometryInstance.Transform将组成点变换到项目坐标系中。</p>
<p>代码区域：从实例获取可靠信息</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">GetAndTransformSolidInfo</span>(<span class="params">Application application, Element element, Options geoOptions</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">// Get geometry element of the selected element</span></span><br><span class="line">        Autodesk.Revit.DB.GeometryElement geoElement = element.get_Geometry(geoOptions);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Get geometry object</span></span><br><span class="line">        <span class="keyword">foreach</span> (GeometryObject geoObject <span class="keyword">in</span> geoElement)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="comment">// Get the geometry instance which contains the geometry information</span></span><br><span class="line">                Autodesk.Revit.DB.GeometryInstance instance =</span><br><span class="line">      geoObject <span class="keyword">as</span> Autodesk.Revit.DB.GeometryInstance;</span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">null</span> != instance)</span><br><span class="line">                &#123;</span><br><span class="line">                    GeometryElement instanceGeometryElement = instance.GetSymbolGeometry();</span><br><span class="line">                    <span class="keyword">foreach</span> (GeometryObject instObj <span class="keyword">in</span> instanceGeometryElement)</span><br><span class="line">                        &#123;</span><br><span class="line">                                Solid solid = instObj <span class="keyword">as</span> Solid;</span><br><span class="line">                                <span class="keyword">if</span> (<span class="literal">null</span> == solid || <span class="number">0</span> == solid.Faces.Size || <span class="number">0</span> == solid.Edges.Size)</span><br><span class="line">                                &#123;</span><br><span class="line">                                        <span class="keyword">continue</span>;</span><br><span class="line">                                &#125;</span><br><span class="line"></span><br><span class="line">                                Transform instTransform = instance.Transform;</span><br><span class="line">                                <span class="comment">// Get the faces and edges from solid, and transform the formed points</span></span><br><span class="line">                                <span class="keyword">foreach</span> (Face face <span class="keyword">in</span> solid.Faces)</span><br><span class="line">                                &#123;</span><br><span class="line">                                        Mesh mesh = face.Triangulate();</span><br><span class="line">                                        <span class="keyword">foreach</span> (XYZ ii <span class="keyword">in</span> mesh.Vertices)</span><br><span class="line">                                        &#123;</span><br><span class="line">                                                XYZ point = ii;</span><br><span class="line">                                                XYZ transformedPoint = instTransform.OfPoint(point);</span><br><span class="line">                                        &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">foreach</span> (Edge edge <span class="keyword">in</span> solid.Edges)</span><br><span class="line">                                &#123;</span><br><span class="line">                                        <span class="keyword">foreach</span> (XYZ ii <span class="keyword">in</span> edge.Tessellate())</span><br><span class="line">                                        &#123;</span><br><span class="line">                                                XYZ point = ii;</span><br><span class="line">                                                XYZ transformedPoint = instTransform.OfPoint(point);</span><br><span class="line">                                        &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：有关检索到的族实例几何图形的详细信息，请参见示例：从梁中检索几何图形数据。</p>
<h3 id="网格"><a href="#网格" class="headerlink" title="网格"></a>网格</h3><p>网格是三角形边界的集合，它们共同形成3D形状。如果Revit图元是通过某些导入操作创建的，并且还用于某些本机Revit图元（如TopographySurface），则通常会在Revit图元几何图形中遇到网格。还可以通过调用任意给定Revit面的Face.Triangulate（）来获取网格。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/mesh.png"></p>
<p>表示圆环面的网格</p>
<p>以下代码示例说明了如何将Revit面的几何体作为网格获取：</p>
<p>代码区域：提取几何体的网格</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">GetTrianglesFromFace</span>(<span class="params">Face face</span>)</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Get mesh</span></span><br><span class="line"></span><br><span class="line">        Mesh mesh = face.Triangulate();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; mesh.NumTriangles; i++)</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">               MeshTriangle triangle = mesh.get_Triangle(i);</span><br><span class="line"></span><br><span class="line">               XYZ vertex1 = triangle.get_Vertex(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">               XYZ vertex2 = triangle.get_Vertex(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">               XYZ vertex3 = triangle.get_Vertex(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：用于Revit显示目的的近似公差在构造网格时由Triangulate（）方法（上面使用的）的无参数重载使用。Triangulate（）的重载接受一个double，允许将细节级别设置在0（粗糙）和1（精细）之间。</p>
<h3 id="点"><a href="#点" class="headerlink" title="点"></a>点</h3><p>点表示3D空间中的可见坐标。</p>
<p>点通常出现在体量族图元（如ReferencePoint）中。Point类提供对其坐标的读访问，并能够获取对该点的引用，以用作其他函数的输入。</p>
<p><strong>点创建</strong></p>
<p>有两种方法可以创建点：</p>
<ul>
<li>Create(XYZ) - 在给定坐标处创建一个点。</li>
<li>Create(XYZ, ElementId) - 在给定坐标处创建一个Point，并根据GraphicsStyle元素（由ElementId指定）为其指定颜色。</li>
</ul>
<h3 id="PolyLine"><a href="#PolyLine" class="headerlink" title="PolyLine"></a>PolyLine</h3><p>PolyLine是由一组坐标点定义的线段的集合。这些通常在导入的几何体中遇到。PolyLine类提供了读取坐标的能力：</p>
<ul>
<li>PolyLine.NumberOfCoordinates – 在坐标系中的点数</li>
<li>PolyLine.GetCoordinate() – 通过索引获取坐标</li>
<li>PolyLine.GetCoordinates() – 获取对象中所有坐标的集合</li>
<li>PolyLine.Evaluate() – 给定一个规格化参数（从0到1），沿整个PolyLine范围沿着计算XYZ点</li>
</ul>
<h3 id="实体、面和边"><a href="#实体、面和边" class="headerlink" title="实体、面和边"></a>实体、面和边</h3><p>实体是一个Revit API对象，表示面和边的集合。通常，在Revit中，这些集合是完全封闭的体积，但也可能遇到壳或部分有界体积。请注意，有时Revit几何图形将包含未使用的实体，这些实体包含零个边和面。选中“边”和面成员以过滤掉这些实体。</p>
<p>Revit API提供了读取面和边的集合以及计算实体的表面积、体积和质心的功能。</p>
<p>本节中的页面</p>
<ul>
<li>边和面参数化</li>
<li>面</li>
<li>面分析</li>
<li>面分割</li>
<li>面类型</li>
<li>面类型的数学表示</li>
<li>实体分析</li>
<li>实体和面的创建</li>
</ul>
<h5 id="边和面参数化"><a href="#边和面参数化" class="headerlink" title="边和面参数化"></a>边和面参数化</h5><p>边是给定面的边界曲线。</p>
<p>使用EdgeLoops属性迭代面的边。每个循环表示面上的一个闭合边界。边始终参数化为0到1。可以使用Edge.AsCurve（）和Edge.AsCurveFollowingFace（）函数提取边缘的Curve表示。</p>
<p>边通常通过计算两个面的相交来定义。但Revit在绘制图形时不会重新计算此交点。因此，边存储一个点列表-直边的端点和曲边的细分列表。这些点是两个面上的参数坐标。这些点可以通过TessellateOnFace（）方法获得。</p>
<p>剖面产生“切割边缘”。这些是人工边-不表示模型级几何体的一部分，因此不提供参照。</p>
<p><strong>边的方向</strong></p>
<p>方向通常在第一个面上为顺时针方向（第一个面表示Revit已为特定边标识的任意面）。但是，由于两个不同的面在一个特定的边相交，并且无论您关注的是哪个面，该边都具有相同的参数化方向，因此有时需要确定特定面上的边的方向。</p>
<p>下图说明了这是如何工作的。对于面0，所有边都是顺时针参数化的（？？？）。对于面1，与面0共享的边不会重新参数化;因此，相对于面1，该边具有相反的方向，并且某些边在两条边的参数均为0（或1）的地方相交。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/face_edge_direction.png"></p>
<p>边参数化</p>
<p>API示例“PanelEdgeLengthAngle”显示了如何识别给定面的反转边。它使用边端点处的切向量来计算相邻边之间的角度，并检测是否在每个交点处翻转切向量以计算适当的角度。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/paneledgelengthangle_sample.png"></p>
<p>PanelEdgeLengthAngle结果</p>
<h5 id="面"><a href="#面" class="headerlink" title="面"></a>面</h5><p>可以将Revit API中的面描述为两个输入参数“u”和“v”的数学函数，其中面在XYZ空间中任意给定点处的位置是参数的函数。</p>
<p>U和V方向是根据给定面的形状自动确定的。恒定U或V的线可以表示为面上的网格线，如下例所示：</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/face_params.png"></p>
<p>圆柱面上的U和V网格线</p>
<p>可以使用UV参数来评估任意给定位置处的面的各种属性：</p>
<ul>
<li>参数是否在面的边界内，使用Face.IsInside（）</li>
<li>指定UV参数值处给定面的XYZ位置。这是从Face.Evaluate（）返回的。如果您还在调用ComputeDerivatives（），则这也是该方法返回的Transform的.Origin属性。</li>
<li>给定面在U方向上的切向量。这是Face.ComputeDerivatives（）返回的Transform的.BasisX属性</li>
<li>给定面在V方向上的切向量。这是Face.ComputeDerivatives（）返回的Transform的.BasisY属性。</li>
<li>给定面部的法向量。这是Face.ComputeDerivatives（）返回的Transform的.BasisZ属性。</li>
<li>关于U的二阶导数。这是Face.ComputeSecondDerivatives（）返回的FaceSecondDerivatives的. UUD派生属性。</li>
<li>相对于V的二阶导数。这是Face.ComputeSecondDerivatives（）返回的FaceSecondDerivatives的.VVDerivative。</li>
<li>给定面的混合导数。这是Face.ComputeSecondDerivatives（）返回的FaceSecondDerivatives的.MixedDerivative。</li>
</ul>
<p>返回的所有向量都是非单位化的。</p>
<h5 id="面分析"><a href="#面分析" class="headerlink" title="面分析"></a>面分析</h5><p>有几种面方法是适用于几何分析的工具。</p>
<p><strong>Intersect()</strong></p>
<p>“相交”方法计算面与曲线之间的相交。它可用于识别：</p>
<ul>
<li>两个对象之间的交点</li>
<li>如果有一条边靠近该位置，则为距离交点最近的边</li>
<li>与面完全重合的曲线</li>
<li>不相交的曲线和面</li>
</ul>
<p><strong>Project()</strong> </p>
<p>Project方法将点投影到输入面上，并返回有关投影点、到面的距离以及到投影点的最近边的信息。</p>
<p><strong>Triangulate()</strong></p>
<p>Triangulate方法获得一个近似于面的三角形网格。此方法有两个重载。无参数方法与Curve.Tessellate（）类似，因为网格的点在Revit使用的输入公差范围内（略大于1&#x2F;16”）是精确的。第二个Triangulate方法接受一个细节级别作为参数，范围从0（粗略）到1（精细）。</p>
<h5 id="面分割"><a href="#面分割" class="headerlink" title="面分割"></a>面分割</h5><p>可以通过“分割面”命令将面分割为面域。Face.HasRegions属性将报告面是否包含使用Split Face命令创建的区域，而Face.GetRegions（）方法将返回一个面列表，一个面用于承载Split Face的对象的主面（如地板的墙壁），一个面用于每个Split Face区域。</p>
<p>FaceSplitter类表示拆分面的元素。FaceSplitter.SplitElementId属性提供其面被此元素分割的元素的ID。FaceSplitter类可用于按类型过滤和查找这些面，如下所示。</p>
<p>代码区域：查找面分割元素</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Autodesk.Revit.DB.Options opt = app.Create.NewGeometryOptions();</span><br><span class="line">opt.ComputeReferences = <span class="literal">true</span>;</span><br><span class="line">opt.IncludeNonVisibleObjects = <span class="literal">true</span>;</span><br><span class="line">FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(doc);</span><br><span class="line">ICollection splitElements = collector.OfClass(<span class="keyword">typeof</span>(FaceSplitter)).Cast().ToList();</span><br><span class="line"><span class="keyword">foreach</span>(FaceSplitter faceSplitter <span class="keyword">in</span> splitElements)</span><br><span class="line">&#123;</span><br><span class="line">    Element splitElement = doc.GetElement(faceSplitter.SplitElementId);</span><br><span class="line">    Autodesk.Revit.DB.GeometryElement geomElem = faceSplitter.get_Geometry(opt);</span><br><span class="line">    <span class="keyword">foreach</span> (GeometryObject geomObj <span class="keyword">in</span> geomElem)</span><br><span class="line">    &#123;</span><br><span class="line">        Line line = geomObj <span class="keyword">as</span> Line;</span><br><span class="line">        <span class="keyword">if</span> (line != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            XYZ end1 = line.GetEndPoint(<span class="number">0</span>);</span><br><span class="line">            XYZ end2 = line.GetEndPoint(<span class="number">1</span>);</span><br><span class="line">            <span class="built_in">double</span> length = line.ApproximateLength;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="面类型"><a href="#面类型" class="headerlink" title="面类型"></a>面类型</h5><p>Revit使用各种曲线类型来表示文档中的面几何图形。其中包括：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>**Face type **</td>
<td><strong>Revit API Class</strong></td>
<td>**Definition **</td>
<td><strong>Notes 注意</strong></td>
</tr>
<tr>
<td>Plane</td>
<td>PlanarFace</td>
<td>由原点与U和V的单位向量定义的平面。</td>
<td></td>
</tr>
<tr>
<td>Cylinder</td>
<td>CylindricalFace</td>
<td>通过沿着轴拉伸圆定义的面。</td>
<td>Radius提供“半径向量”-圆的单位向量乘以半径值。</td>
</tr>
<tr>
<td>Cone</td>
<td>ConicalFace</td>
<td>一条线绕一个轴旋转而定义的面。</td>
<td>Radius提供“半径向量”-圆的单位向量乘以半径值。</td>
</tr>
<tr>
<td>Revolved face</td>
<td>RevolvedFace</td>
<td>由任意曲线绕轴旋转定义的面。</td>
<td>Radius提供旋转平面的单位矢量，不涉及“半径”。</td>
</tr>
<tr>
<td>Ruled surface</td>
<td>RuledFace</td>
<td>通过放样两条轮廓曲线或一条轮廓曲线和一个点之间的直线而定义的面。</td>
<td>曲线和点都可以作为属性获得。</td>
</tr>
<tr>
<td>Hermite face</td>
<td>HermiteFace</td>
<td>由点之间的Hermite插值定义的面。</td>
<td></td>
</tr>
</tbody></table>
<p>所有Revit面类型的数学表示可以在其中找到：面类型的数学表示。</p>
<h5 id="面类型的数学表示"><a href="#面类型的数学表示" class="headerlink" title="面类型的数学表示"></a>面类型的数学表示</h5><p>本节介绍Revit几何图形中遇到的面类型、其属性及其数学表示。</p>
<p><strong>PlanarFace</strong></p>
<p>由原点与U和V的单位向量定义的平面。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/face_planar.png"></p>
<p><strong>CylindricalFace</strong> </p>
<p>通过沿轴沿着拉伸圆而定义的面。Revit API提供以下属性：</p>
<ul>
<li>面的原点。</li>
<li>拉伸轴。</li>
<li>在X和Y中的“径向矢量”。这些向量是圆的单位向量乘以圆的半径。注意，单位向量可以表示右手或左手控制。</li>
</ul>
<p>此面的参数方程为：</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/face_cylinder.png" alt="img"></p>
<p><strong>ConicalFace</strong> </p>
<p>由一条线绕一个轴旋转而定义的面。Revit API提供以下属性：</p>
<ul>
<li>面的原点。</li>
<li>圆锥体的轴。</li>
<li>在X和Y中的“径向矢量”。这些矢量是单位矢量乘以旋转形成的圆的半径。注意，单位向量可以表示右手或左手控制。</li>
<li>The half angle of the face.<br>面的半个角。</li>
</ul>
<p>此面的参数方程为：</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/face_cone.png" alt="img"></p>
<p><strong>RevolvedFace</strong></p>
<p>由任意曲线绕轴旋转定义的面。Revit API提供以下属性：</p>
<ul>
<li>面的原点</li>
<li>面的轴线</li>
<li>轮廓曲线</li>
<li>旋转曲线的单位向量（姑且地称为“半径”）</li>
</ul>
<p>此面的参数方程为：</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/face_revolved.png" alt="img"></p>
<p><strong>RuledFace</strong> </p>
<p>RuledFace 是通过放样两条轮廓曲线之间或曲线与点之间的直线而创建的。Revit API提供曲线和点作为属性。</p>
<p>该曲面的参数方程为：</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/face_ruled1.png" alt="img"> 如果两条曲线都有效。如果其中一条曲线被替换为一个点，则方程简化为以下之一：</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/face_ruled2.png" alt="img"> <img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/face_ruled3.png" alt="img"> 没有曲线和两个点的RuledFace是不会被返回。</p>
<p><strong>HermiteFace</strong></p>
<p>立方Hermite样条曲线面。Revit API提供：</p>
<ul>
<li>样条插值点的u和v参数数组</li>
<li>每个节点上的3D点的数组（数组按u递增，然后v递增的方式组织）</li>
<li>每个节点的切向量数组</li>
<li>每个节点处的扭曲向量数组</li>
</ul>
<p>在节点（u1，v1）和（u2，v2）之间，该曲面的参数表示为：</p>
<p>其中 <img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/face_hermite2.png" alt="img"> ， <img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/face_hermite3.png" alt="img"> ，<strong>MH</strong>是Hermite矩阵：</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/face_hermite4.png" alt="img"><br>并且B是从插值点处的面属性获得的系数矩阵：</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/face_hermite5.png" alt="img"></p>
<h5 id="实体分析"><a href="#实体分析" class="headerlink" title="实体分析"></a>实体分析</h5><p><strong>实体与曲线的交线</strong></p>
<p>方法Solid.IntersectWithCurve（）计算闭合体积实体和曲线之间的交点。SolidCurveIntersectionOptions类可以指定IntersectWithCurve（）方法的结果是否将包括实体体积内部或外部的曲线段。实体内的曲线段将包括与实体的面重合的曲线段。曲线段和曲线段的参数都可以在结果中使用。</p>
<p>以下示例使用IntersectWithCurve（）方法计算柱内钢筋的长度。</p>
<p>代码区域：查找实体和曲线之间的交点</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">FindColumnRebarIntersections</span>(<span class="params">Document document, FamilyInstance column</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// We will be computing the total length of the rebar inside the column</span></span><br><span class="line">    <span class="built_in">double</span> totalRebarLengthInColumn = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find rebar hosted by this column</span></span><br><span class="line">    RebarHostData rebarHostData = RebarHostData.GetRebarHostData(column);</span><br><span class="line">    <span class="keyword">if</span> (rebarHostData == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    IList rebars = rebarHostData.GetRebarsInHost();</span><br><span class="line">    <span class="keyword">if</span> (rebars.Count == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Retrieve geometry of the column</span></span><br><span class="line">    Options geomOptions = <span class="keyword">new</span> Options();</span><br><span class="line">    geomOptions.ComputeReferences = <span class="literal">true</span>;</span><br><span class="line">    geomOptions.DetailLevel = ViewDetailLevel.Fine;</span><br><span class="line">    GeometryElement elemGeometry = column.get_Geometry(geomOptions);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Examine all geometry primitives of the column</span></span><br><span class="line">    <span class="keyword">foreach</span> (GeometryObject elemPrimitive <span class="keyword">in</span> elemGeometry)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Skip objects that are not geometry instances</span></span><br><span class="line">        GeometryInstance gInstance = elemPrimitive <span class="keyword">as</span> GeometryInstance;</span><br><span class="line">        <span class="keyword">if</span> (gInstance == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Retrieve geometry of each found geometry instance</span></span><br><span class="line">        GeometryElement instGeometry = gInstance.GetInstanceGeometry();</span><br><span class="line">        <span class="keyword">foreach</span> (GeometryObject instPrimitive <span class="keyword">in</span> instGeometry)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Skip non-solid sobject</span></span><br><span class="line">            Solid solid = instPrimitive <span class="keyword">as</span> Solid;</span><br><span class="line">            <span class="keyword">if</span> (solid == <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            SolidCurveIntersectionOptions intersectOptions = <span class="keyword">new</span> SolidCurveIntersectionOptions();</span><br><span class="line">            <span class="keyword">foreach</span> (Rebar rebar <span class="keyword">in</span> rebars)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// Get the centerlines for the rebar to find their intersection with the column</span></span><br><span class="line">                <span class="built_in">bool</span> selfIntersection = <span class="literal">false</span>;</span><br><span class="line">                <span class="built_in">bool</span> suppresHooks = <span class="literal">false</span>;</span><br><span class="line">                <span class="built_in">bool</span> suppresBends = <span class="literal">false</span>;</span><br><span class="line">                IList curves = rebar.GetCenterlineCurves(selfIntersection, suppresHooks, suppresBends, MultiplanarOption.IncludeOnlyPlanarCurves, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Examine every segment of every curve of the centerline</span></span><br><span class="line">                <span class="keyword">foreach</span> (Curve curve <span class="keyword">in</span> curves)</span><br><span class="line">                &#123;</span><br><span class="line">                    SolidCurveIntersection intersection = solid.IntersectWithCurve(curve, intersectOptions);</span><br><span class="line">                    <span class="keyword">for</span> (<span class="built_in">int</span> segment = <span class="number">0</span>; segment &lt;= intersection.SegmentCount - <span class="number">1</span>; segment++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">// Calculate length of the rebar that is inside the column</span></span><br><span class="line">                        Curve curveInside = intersection.GetCurveSegment(segment);</span><br><span class="line">                        <span class="built_in">double</span> rebarLengthInColumn = curveInside.Length;</span><br><span class="line">                        totalRebarLengthInColumn = totalRebarLengthInColumn + rebarLengthInColumn;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="实体和面的创建"><a href="#实体和面的创建" class="headerlink" title="实体和面的创建"></a>实体和面的创建</h5><p>实体和面有时用作其他实用程序的输入。Revit API提供了几个例程，可用于从头开始创建此类几何图形或从其他输入中导出此类几何图形。</p>
<p><strong>Transformed geometry</strong></p>
<p>方法</p>
<ul>
<li>GeometryElement.GetTransformed()</li>
</ul>
<p>返回应用了变换的输入几何图元的副本。由于此几何图形是副本，因此其成员不能用作其他Revit图元的输入参照，但可用于几何分析和提取。</p>
<p><strong>Geometry creation utilities</strong></p>
<p>GeometryCreationUtilities类是一个允许构造基本实体形状的实用程序类：</p>
<ul>
<li>Extrusion 拉伸</li>
<li>Loft</li>
<li>Revolution 旋转</li>
<li>Sweep 放样</li>
<li>Blend 融合</li>
<li>SweptBlend 放样融合</li>
</ul>
<p>生成的几何图形不会作为任何元素的一部分添加到文档中。然而，创建的Solid可用作其他API函数的输入，包括：</p>
<ul>
<li>作为分析可视化框架（SpatialFieldManager.AddSpatialFieldPrimitive（））中方法的输入面-这允许用户相对于文档中的其他元素可视化创建的形状</li>
<li>作为通过相交查找3D元素的输入实体</li>
<li>作为布尔运算的一个或多个输入</li>
<li>作为几何计算的一部分（例如，使用Face.Project（）、Face.Intersect（）或其他面、实体和边几何方法）</li>
</ul>
<p>下面的示例使用GeometryCreationUtilities类基于位置和高度创建圆柱形。例如，这可以用于在墙端点周围创建体积，以便查找与墙端点非常接近的其他墙：</p>
<p>代码区域：创建圆柱体</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Build cylinder centered at wall end point, extending 3&#x27; in diameter</span></span><br><span class="line">CurveLoop cylinderLoop = <span class="keyword">new</span> CurveLoop();</span><br><span class="line">XYZ arcCenter = <span class="keyword">new</span> XYZ(endPoint.X, endPoint.Y, elevation);</span><br><span class="line">Application application = wall.Document.Application;</span><br><span class="line">Arc firstArc = Arc.Create(arcCenter, <span class="number">1.5</span>, <span class="number">0</span>, Math.PI, XYZ.BasisX, XYZ.BasisY);</span><br><span class="line">Arc secondArc = Arc.Create(arcCenter, <span class="number">1.5</span>, Math.PI, <span class="number">2</span> * Math.PI, XYZ.BasisX, XYZ.BasisY);</span><br><span class="line"></span><br><span class="line">cylinderLoop.Append(firstArc);</span><br><span class="line">cylinderLoop.Append(secondArc);</span><br><span class="line"></span><br><span class="line">List singleLoop = <span class="keyword">new</span> List();</span><br><span class="line">singleLoop.Add(cylinderLoop);</span><br><span class="line"></span><br><span class="line">Solid proximityCylinder = GeometryCreationUtilities.CreateExtrusionGeometry(singleLoop, XYZ.BasisZ, height);</span><br></pre></td></tr></table></figure>

<p><strong>Boolean operations</strong> </p>
<p>BooleanOperationsUtils类提供用于组合一对实心几何体对象的方法。</p>
<p>ExecuteBooleanOperation（）方法获取输入实体的副本，并生成新实体作为结果。它的第一个参数可以是任何实体，可以直接从Revit图元获得，也可以通过其他操作（如GeometryCreationUtils）创建。</p>
<p>方法ExecuteBooleanOperationModifyingOriginalSolid（）直接对第一个输入实体执行布尔运算。第一个输入必须是不是直接从Revit图元获得的实体。属性GeometryObject.IsElementGeometry可以标识实体是否适合作为此方法的输入。</p>
<p>这两种方法的选项包括操作类型：并集、差集或交集。下面的示例演示如何获取两个实体的交点，然后查找体积。</p>
<p>代码区域：实体相交的体积</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ComputeIntersectionVolume</span>(<span class="params">Solid solidA, Solid solidB</span>)</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    Solid intersection = BooleanOperationsUtils.ExecuteBooleanOperation(solidA, solidB, BooleanOperationsType.Intersect);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">double</span> volumeOfIntersection = intersection.Volume;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法CutWithHalfSpace（）和CutWithHalfSpaceModifyingOriginalSolid（）生成一个实体，该实体是输入Solid与给定Plane正侧的半空间的交点。平面的正侧是平面。法线指向的一侧。第一种方法使用结果创建新实体，而第二种方法修改现有实体（必须是由应用程序创建的实体，而不是从Revit图元获得的实体）。</p>
<h2 id="Geometry-Helper-类"><a href="#Geometry-Helper-类" class="headerlink" title="Geometry Helper 类"></a>Geometry Helper 类</h2><p>API中有几个Geometry Helper类。Helper类用于描述某些元素的几何信息，例如使用BoundingBoxXYZ类为视图定义CropBox。</p>
<ul>
<li>BoundingBoxXYZ - 用于定义三维视图截面区域等情况的三维矩形框。</li>
<li>Transform - 变换仿射3D空间。</li>
<li>Reference -Revit模型中几何对象的稳定参照，在创建尺寸标注等图元时使用。</li>
<li>Plane - 几何中的平面。</li>
<li>Options - 用于分析几何图形的用户首选项。</li>
<li>XYZ - 表示3D空间中坐标的对象。</li>
<li>UV - 表示2D空间中坐标的对象。</li>
<li>BoundingBoxUV - 平行于坐标轴的2D矩形。</li>
</ul>
<h3 id="Transform"><a href="#Transform" class="headerlink" title="Transform"></a>Transform</h3><p>在Revit应用程序中，变换仅限于3x4变换（矩阵），即相对于模型空间的其余部分和其他对象变换对象在模型空间中的位置。变换是根据模型空间中的位置和方向构建的。三个方向矢量（BasisX、BasisY和BasisZ属性）和原点提供所有变换信息。由四个值形成的矩阵如下：</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-362AC8B3-CB53-4DB6-8606-5D90F2C8BFC4-low.png"></p>
<p>将变换应用于点如下：</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-5ABFA7C5-22F5-4A86-9878-CB0812834EB8-low.png"></p>
<p>Transform Of Point方法实现了前面的函数。</p>
<p>下面几节将介绍Geometry.Transform类的属性和方法。</p>
<h4 id="Identity"><a href="#Identity" class="headerlink" title="Identity"></a>Identity</h4><p>转换Identity </p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-4AD4178C-E897-44E0-93CD-AA8C1FD39AC4-low.png">CreateReflection()</p>
<p>反射指定的平面。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-DCA42587-9FD4-4AE3-95A8-1D45ED472D14-low.png">图112：墙反射关系</p>
<p>如上图所示，参照平面镜像了一面墙。CreateReflection（）方法需要参考平面的几何平面信息。</p>
<p>代码区域20-8：使用反射属性</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Transform <span class="title">Reflect</span>(<span class="params">ReferencePlane refPlane</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Transform mirTrans = Transform.CreateReflection(refPlane.GetPlane());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mirTrans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="CreateRotation-and-CreateRotationAtPoint"><a href="#CreateRotation-and-CreateRotationAtPoint" class="headerlink" title="CreateRotation() and CreateRotationAtPoint()"></a>CreateRotation() and CreateRotationAtPoint()</h4><p>围绕位于（0，0，0）或指定点的指定轴旋转指定角度。</p>
<h4 id="CreateTranslation"><a href="#CreateTranslation" class="headerlink" title="CreateTranslation()"></a>CreateTranslation()</h4><p>按指定的向量平移。给定一个矢量XYZ数据，如下创建一个变换：<img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-4E661E3C-0609-44C0-A7D5-52E993FEA94C-low.png"></p>
<h4 id="Determinant"><a href="#Determinant" class="headerlink" title="Determinant"></a>Determinant</h4><p>变换行列式</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-4570D0C0-0834-4A9E-AB7C-751F771AAE5B-low.png"></p>
<h4 id="HasReflection"><a href="#HasReflection" class="headerlink" title="HasReflection"></a>HasReflection</h4><p>这是一个布尔值，指示变换是否产生反射。</p>
<h4 id="Scale"><a href="#Scale" class="headerlink" title="Scale"></a>Scale</h4><p>表示变换比例的值。</p>
<h4 id="Inverse"><a href="#Inverse" class="headerlink" title="Inverse"></a>Inverse</h4><p>逆变换。如果存在变换矩阵B使得A<em>B &#x3D; B</em> A &#x3D; I（单位元），则变换矩阵A是可逆的。</p>
<h4 id="IsIdentity"><a href="#IsIdentity" class="headerlink" title="IsIdentity"></a>IsIdentity</h4><p>指示此转换是否为标识的布尔值。</p>
<h4 id="IsTranslation"><a href="#IsTranslation" class="headerlink" title="IsTranslation"></a>IsTranslation</h4><p>布尔值，指示此转变是否是转换。</p>
<h4 id="Multiply"><a href="#Multiply" class="headerlink" title="Multiply"></a>Multiply</h4><p>将转换乘以指定的变换并返回结果。</p>
<p>Operator*-将两个指定的转换相乘。</p>
<h4 id="ScaleBasis"><a href="#ScaleBasis" class="headerlink" title="ScaleBasis"></a>ScaleBasis</h4><p>缩放基向量并返回结果。</p>
<h4 id="ScaleBasisAndOrigin"><a href="#ScaleBasisAndOrigin" class="headerlink" title="ScaleBasisAndOrigin"></a>ScaleBasisAndOrigin</h4><p>缩放基向量，变换原点返回结果。</p>
<h4 id="OfPoint"><a href="#OfPoint" class="headerlink" title="OfPoint"></a>OfPoint</h4><p>将transformation到指定点。使用Origin属性。</p>
<h4 id="OfVector"><a href="#OfVector" class="headerlink" title="OfVector"></a>OfVector</h4><p>将transform转换为向量。不使用Origin属性。</p>
<h4 id="AlmostEqual"><a href="#AlmostEqual" class="headerlink" title="AlmostEqual"></a>AlmostEqual</h4><p>比较两个转换。AlmostEqual与Revit核心代码中的计算机制和精度一致。此外，在Transform类中没有实现Equal和&#x3D;&#x3D;运算符。</p>
<p>API提供了几种完成几何变换的快捷方式。几个几何体类中的Transformed属性用于执行此工作，如下表所示。</p>
<p>表48：Transformed 方法</p>
<table>
<thead>
<tr>
<th><strong>Class Name 类名</strong></th>
<th><strong>Function Description 功能描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Curve.get_Transformed(Transform transform)</td>
<td>将指定的变换转换为曲线</td>
</tr>
<tr>
<td>GeometryElement.GetTransformed(Transform transform)</td>
<td>转换原始元素中几何图形的副本。</td>
</tr>
<tr>
<td>Profile.get_Transformed(Transform transform)</td>
<td>转换轮廓并返回结果。</td>
</tr>
<tr>
<td>Mesh.get_Transformed(Transform transform) M</td>
<td>转换网格并返回结果。</td>
</tr>
</tbody></table>
<p>注意：transformed方法克隆自身，然后返回转换后的克隆结果。 除了这些方法之外，Instance类（它是族实例、链接实例和导入的CAD内容等图元的父类）还有两个方法，可以为给定的Instance提供变换。GetTransform（）方法根据实例的放置方式获得实例的基本变换，而GetTotalTransform（）方法提供使用真北变换修改的变换，例如导入实例。</p>
<p><strong>Reference</strong> </p>
<p>Reference 在元素创建中非常有用。 创建尺寸需要参照。 参考以灵活的方式标识几何表示树内的路径。 树用于查看特定的几何表达创建。API基于不同的Pick指针类型公开四种类型的引用。它们以不同的方式从API中检索：</p>
<ul>
<li>对于点-Curve.GetEndPointReference方法</li>
<li>对于曲线（直线、圆弧等）- Curve.Reference属性</li>
<li>对于面-face.Reference属性</li>
<li>对于剪切边-Edge.Reference property</li>
</ul>
<p>不能任意使用不同的参考类型。举例来说： NewLineBoundaryConditions（）方法需要Line的引用。 NewAreaBoundaryConditions（）方法需要面的引用。 NewPointBoundaryConditions（）方法需要Point的引用。 Reference. ConvertToStableRepresentation（）方法可用于将对几何体对象（例如面、边或曲线）的引用另存为字符串，然后在同一Revit任务中（甚至在存在同一文档的不同任务中）使用ParseFromStableRepresentation（）方法以字符串作为输入来获取相同的引用。</p>
<p> Options Geometry 通常从索引属性Element.Geometry中提取。梁、柱或支撑的原始几何图形在实例通过连接、剪切、复制、拉伸或其他后处理进行修改之前，可以使用FamilyInstance. GetOriginalGeometry（）方法提取。Element. Geometry和FamilyInstance. GetOriginalGeometry（）都接受必须提供的options 类。</p>
<p>options 类根据其属性自定义接收的输出类型： </p>
<ul>
<li>ComputeReferences -指示检索几何信息时是否计算几何参照。默认值为false，因此如果此属性未设置为true，则引用将不可访问。 </li>
<li>IncludeNonVisibleObjects -指示还返回在默认视图中不可见的几何对象。 </li>
<li><em>View</em> -从特定视图获取几何信息。请注意，如果指定了视图，则将使用此视图的详细程度来代替“DetailLevel”。 </li>
<li>DetailLevel -指示首选详细程度。默认值为“中”。</li>
</ul>
<p> ComputeReferences  如果将此属性设置为false，则API不计算几何参照。从几何体树检索的所有引用属性都不返回任何内容。有关引用的更多详细信息，请参阅“引用”部分。与FamilyInstance.GetOriginalGeometry（）一起使用时，此选项不能设置为true。 </p>
<p>IncludeNonVisibleObjects 大多数不可见几何图形是用户在编辑元素时看到的构造和条件几何图形（即，窗族实例的中心平面）。此属性的默认值为false。但是，某些条件可见几何图形表示真实对象（例如Revit中风管周围的隔热层），因此应将其提取。 </p>
<p>View 如果用户将“视图”特性设置为其他视图，则检索到的几何图形信息可能会有所不同。有关详细信息，请查看以下示例： 1. 在Revit中，在三维视图中绘制楼梯，然后在三维视图中选择“裁剪区域”、“裁剪区域可见”和“剖面框”属性。在“裁剪区域”中，修改三维视图中的剖面框以显示楼梯的一部分。如果使用API获取楼梯的几何图形信息，并将三维视图设置为Options.View属性，则只能检索楼梯几何图形的一部分。下图显示了Revit应用程序中的楼梯（左图）和使用API绘制的楼梯（右图）。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-F6123E3E-4B46-4502-915A-5FC399B34045-low.png"></p>
<p>图113：不同的剖面框显示不同的几何图形 </p>
<p>在Revit中绘制楼梯，然后绘制剖面，如左图所示。如果使用API获取此楼梯的信息，并将此剖面视图设置为Options.View属性，则只能检索楼梯几何图形的一部分。使用API绘制的楼梯如右图所示。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-1095389D-A7C6-4AB8-A6C6-FC8CC3C05EAB-low.png"></p>
<p>图114：检索几何剖面图 </p>
<p>DetailLevel API在Geometry.Options.DetailLevels中定义了三个枚举。这三个枚举对应于Revit应用程序中的三个详细程度，如下所示。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-81B8A84A-2F7B-4019-8CC8-4DA11B7A176A-low.png"></p>
<p>图115：三个细节层次</p>
<p>据DetailLevel特性中的不同设置检索不同的几何体信息。例如，在Revit应用程序中绘制梁，然后使用API从梁中获取几何图形进行绘制。以下图片显示了绘制结果：</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-B1C82974-A3D1-4893-9DF9-E9396C7D6352-low.png"></p>
<p>图116：梁的几何详图</p>
<p>BoundingBoxXYZ BoundingBoxXYZ定义了一个3D矩形框，它需要与任何坐标轴平行。与Instance类类似，BoundingBoxXYZ将数据存储在局部坐标空间中。它具有一个Transform属性，可将数据从框局部坐标空间转换到模型空间。换句话说，要获取模型空间中的长方体边界（与Revit中的长方体边界相同），请使用Transform属性变换每个数据成员。以下各节说明如何使用BoundingBoxXYZ。 #定义视图边界 BoundingBoxXYZ可用于通过View.CropBox属性定义视图边界。下图使用剖面视图显示了如何在Revit应用程序中使用BoundingBoxXYZ。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-C517106E-BC7F-4E89-90C4-7FFF1D6B3FD2-low.png"></p>
<p>图117：截面视图中的BoundingBoxXYZ </p>
<p>前面图片中的虚线显示了作为CropBox特性（BoundingBoxXYZ实例）显示的横断面图边界。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-22E284B3-C514-4EB4-B322-91454006173E-low.png"></p>
<p>图118：创建的截面视图 </p>
<p>上一张图片显示了相应的横断面图。视图边界外的墙将不显示。 </p>
<p>定义截面框 BoundingBoxXYZ还用于为从View3D.GetSectionBox（）方法检索的三维视图定义剖面框。在“特性”对话框中选择“剖面框”特性。剖面框如下图所示：</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-1EA1F70A-FFC5-4C58-9446-48E73E9C5606-low.png"></p>
<p>图119：三维视图剖面框#其他用途在元素的几何图形周围定义一个框。（Element.BoundingBox属性）。</p>
<p>以这种方式检索的BoundingBoxXYZ实例平行于坐标轴。在ViewSection. ViewDetail（）方法中使用。下表标识了此类的主要用途。表49：BoundingBoxXYZ属性</p>
<table>
<thead>
<tr>
<th>**Property Name **</th>
<th><strong>Usage 使用</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Max&#x2F;Min</td>
<td>最大&#x2F;最小坐标。这两个属性定义了一个平行于任何坐标轴的三维长方体。Transform属性提供了一个可以将长方体变换到适当位置的变换矩阵。</td>
</tr>
<tr>
<td>Transform</td>
<td>从长方体坐标空间转换到模型空间。</td>
</tr>
<tr>
<td>Enabled</td>
<td>指示是否打开边界框。</td>
</tr>
<tr>
<td>MaxEnabled&#x2F; MinEnabled</td>
<td>如果裁剪视图处于打开状态，<em><strong>MaxEnabled</strong></em>属性和<em><strong>MinEnabled</strong></em>属性都返回true。<img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-7050609C-8AAF-40C4-A9A8-F8920B6AD022-low.png" alt="img">如果裁剪视图处于关闭状态，<em><strong>MaxEnabled</strong></em>属性和<em><strong>MinEnabled</strong></em>属性都返回false。* 定义给定维度的最大&#x2F;最小界限是否处于活动状态。如果Enable属性为false，这两个属性也应该返回false。  此属性指示视图的裁剪框面是否可用于裁剪元素的视图。 <em>如果从View3D.GetSectionBox（)方法检索BoundingBoxXYZ，则返回值取决于是否在“三维视图属性”对话框中选择了“剖面框”属性。如果是，则所有Enabled属性都返回true。</em> 如果从Element.BoundingBox属性检索BoundingBoxXYZ，则所有Enabled属性都为true。</td>
</tr>
<tr>
<td>Bounds</td>
<td>Max&#x2F;Min属性的界限。</td>
</tr>
<tr>
<td>BoundEnabled</td>
<td>MaxEnabled&#x2F;MinEnabled属性的界限。</td>
</tr>
</tbody></table>
<p>下面的代码示例阐释如何旋转BoundingBoxXYZ以修改三维视图剖面框。</p>
<p>代码区域20-9：旋转BoundingBoxXYZ</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">RotateBoundingBox</span>(<span class="params">View3D view3d</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!view3d.IsSectionBoxActive)</span><br><span class="line">    &#123;</span><br><span class="line">        TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>,<span class="string">&quot;The section box for View3D isn&#x27;t active.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    BoundingBoxXYZ box = view3d.GetSectionBox();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create a rotation transform to apply to the section box </span></span><br><span class="line">    XYZ origin = <span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    XYZ axis = <span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Rotate 30 degrees</span></span><br><span class="line">    Transform rotate = Transform.CreateRotationAtPoint(axis, Math.PI/<span class="number">6.0</span>, origin);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Transform the View3D&#x27;s section box with the rotation transform</span></span><br><span class="line">    box.Transform = box.Transform.Multiply(rotate);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set the section box back to the view (requires an open transaction)</span></span><br><span class="line">    view3d.SetSectionBox(box);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="BoundingBoxUV"><a href="#BoundingBoxUV" class="headerlink" title="BoundingBoxUV"></a>BoundingBoxUV</h3><p>BoundingBoxUV是一个值类，它定义了一个平行于坐标轴的2D矩形。它支持最小和最大数据成员。它们一起定义BoundingBoxUV的边界。BoundingBoxUV从View.Outline属性中检索，该属性是图纸空间视图中的边界视图。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-3CDBA6D9-E139-482E-816C-640D56DE5E63-low.png"></p>
<p>图120：视图轮廓</p>
<p>两个点定义BoundingBoxUV。</p>
<ul>
<li><p>Min point - 左下角端点。</p>
</li>
<li><p>Max point - 右上端点。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-71827A01-D568-4770-9457-A279F252DBFD-low.png"></p>
</li>
</ul>
<p>图121：BoundingBoxUV最大值和最小值</p>
<p>注意：BoundingBoxUV不能像下图那样呈现倾斜矩形</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-1A52815E-11F5-4305-B68E-B0A63A06718D-low.png"></p>
<p>图122：倾斜矩形</p>
<h2 id="集合类"><a href="#集合类" class="headerlink" title="集合类"></a>集合类</h2><p>Revit API中的专用几何图形集合类。</p>
<p>API根据集合类包含的项提供以下集合类：</p>
<p>表50：几何集合类</p>
<table>
<thead>
<tr>
<th>**Class&#x2F;Type **</th>
<th>对应的集合类**</th>
<th>对应的迭代器**</th>
</tr>
</thead>
<tbody><tr>
<td>Edge</td>
<td>EdgeArray, EdgeArrayArray</td>
<td>EdgeArrayIterator, EdgeArrayArrayIterator</td>
</tr>
<tr>
<td>Face</td>
<td>FaceArray</td>
<td>FaceArrayIterator</td>
</tr>
<tr>
<td>Reference</td>
<td>ReferenceArray</td>
<td>ReferenceArrayIterator</td>
</tr>
<tr>
<td>Double value</td>
<td>DoubleArray</td>
<td>DoubleArrayIterator</td>
</tr>
</tbody></table>
<p>所有这些类都使用非常相似的方法和属性来完成类似的工作。有关更多详细信息，请参阅集合。</p>
<h2 id="示例：从梁中检索几何图形数据"><a href="#示例：从梁中检索几何图形数据" class="headerlink" title="示例：从梁中检索几何图形数据"></a>示例：从梁中检索几何图形数据</h2><p>本节说明如何从梁获取实体和曲线。可以以类似的方式检索柱和支撑几何数据。GeometryElement可以包含所需的几何体作为Solid或GeometryInstance，具体取决于梁是连接的还是独立的，本代码涵盖了这两种情况。</p>
<p>注意：如果要获取梁和支撑驱动曲线，请调用LocationCurve可用的FamilyInstance Location属性。</p>
<p>示例代码如下所示：</p>
<p>代码区域20-10：从梁获取实体和曲线</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetCurvesFromABeam</span>(<span class="params">Autodesk.Revit.DB.FamilyInstance beam,</span></span></span><br><span class="line"><span class="params"><span class="function">                                Autodesk.Revit.DB.Options options</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Autodesk.Revit.DB.GeometryElement geomElem = beam.get_Geometry(options);</span><br><span class="line"></span><br><span class="line">    Autodesk.Revit.DB.CurveArray curves = <span class="keyword">new</span> CurveArray();</span><br><span class="line">    System.Collections.Generic.List&lt;Autodesk.Revit.DB.Solid&gt; solids = <span class="keyword">new</span> System.Collections.Generic.List&lt;Autodesk.Revit.DB.Solid&gt;(); </span><br><span class="line"></span><br><span class="line">    <span class="comment">//Find all solids and insert them into solid array</span></span><br><span class="line">    AddCurvesAndSolids(geomElem, <span class="keyword">ref</span> curves, <span class="keyword">ref</span> solids);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">AddCurvesAndSolids</span>(<span class="params">Autodesk.Revit.DB.GeometryElement geomElem,</span></span></span><br><span class="line"><span class="params"><span class="function">                                <span class="keyword">ref</span> Autodesk.Revit.DB.CurveArray curves,</span></span></span><br><span class="line"><span class="params"><span class="function">                                <span class="keyword">ref</span> System.Collections.Generic.List&lt;Autodesk.Revit.DB.Solid&gt; solids</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">foreach</span> (Autodesk.Revit.DB.GeometryObject geomObj <span class="keyword">in</span> geomElem)</span><br><span class="line">    &#123;</span><br><span class="line">        Autodesk.Revit.DB.Curve curve = geomObj <span class="keyword">as</span> Autodesk.Revit.DB.Curve;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != curve)</span><br><span class="line">        &#123;</span><br><span class="line">            curves.Append(curve);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Autodesk.Revit.DB.Solid solid = geomObj <span class="keyword">as</span> Autodesk.Revit.DB.Solid;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != solid)</span><br><span class="line">        &#123;</span><br><span class="line">            solids.Add(solid);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//If this GeometryObject is Instance, call AddCurvesAndSolids</span></span><br><span class="line">        Autodesk.Revit.DB.GeometryInstance geomInst = geomObj <span class="keyword">as</span> Autodesk.Revit.DB.GeometryInstance;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != geomInst)</span><br><span class="line">        &#123;</span><br><span class="line">            Autodesk.Revit.DB.GeometryElement transformedGeomElem</span><br><span class="line">                = geomInst.GetInstanceGeometry(geomInst.Transform);</span><br><span class="line">            AddCurvesAndSolids(transformedGeomElem, <span class="keyword">ref</span> curves, <span class="keyword">ref</span> solids);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的示例使用FamilyInstance.Geometry属性访问梁的真实几何图形。若要在通过连接、剪切、复制、拉伸或其他后期处理修改族实例之前获取其原始几何图形，请使用FamilyInstance.GetOriginalGeometry（）方法。</p>
<p>注意：有关如何检索Geometry.Options类型对象的详细信息，请参阅Geometry Helper Classes。</p>
<h2 id="实体的拉伸分析"><a href="#实体的拉伸分析" class="headerlink" title="实体的拉伸分析"></a>实体的拉伸分析</h2><p>实用程序类ExtrusionAnalyzer允许您尝试将给定的几何图形“拟合”到拉伸轮廓的形状中。这个类的实例是一次性使用类，应该提供一个立体几何、一个平面和一个方向。初始化ExtrusionAnalyzer后，可以通过以下成员访问结果：</p>
<ul>
<li>GetExtrusionBase（）方法返回与输入平面对齐的拉伸实体的计算基础轮廓。</li>
<li>CalculateFaceAlignment（）方法可用于标识原始几何体中与计算拉伸的面对齐或不对齐的所有面。例如，这对于确定墙的顶部是否有倾斜连接（如果与屋顶有连接，则会出现这种情况）非常有用。如果某个面未对齐，则会将某些内容连接到影响该面的几何体。</li>
<li>若要确定生成非对齐面的元素，请将面传递给Element.GetGeneratingElementIds（）。有关此实用程序的更多详细信息，请参阅以下部分。</li>
</ul>
<p>ExtrusionAnalyzer实用程序最适用于至少有点“类似于拉伸”的几何体，例如，可能会或可能不会受到端点连接、楼板连接、屋顶连接、由门窗切割的洞口或其他修改影响的墙几何体。对于特定的形状和方向组合，分析器可能很少无法确定作为挤出基础的连贯面-在这些情况下将引发InvalidOperationException。</p>
<p>在此示例中，拉伸分析器用于计算并绘制由输入实体和太阳方向形成的阴影的轮廓。</p>
<p>代码区域：使用拉伸分析器计算并绘制阴影轮廓。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> </span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> Draw the shadow of the indicated solid with the sun direction specified.</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> </span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> The shadow will be outlined with model curves added to the document.</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> A transaction must be open in the document.</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> The document.</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> The target solid.</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> The target level where to measure and draw the shadow.</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> The direction from the sun (or light source).</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> The curves created for the shadow.</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> Thrown by ExtrusionAnalyzer when the geometry and </span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> direction combined do not permit a successful analysis.</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ICollection <span class="title">DrawShadow</span>(<span class="params">Document document, Solid solid, Level targetLevel, XYZ sunDirection</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Create target plane from level.    Plane plane = Plane.CreateByNormalAndOrigin(XYZ.BasisZ, new XYZ(0, 0, targetLevel.ProjectElevation));</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create extrusion analyzer.</span></span><br><span class="line">    ExtrusionAnalyzer analyzer = ExtrusionAnalyzer.Create(solid, plane, sunDirection);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get the resulting face at the base of the calculated extrusion.</span></span><br><span class="line">    Face result = analyzer.GetExtrusionBase();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Convert edges of the face to curves.</span></span><br><span class="line">    CurveArray curves = document.Application.Create.NewCurveArray();</span><br><span class="line">    <span class="keyword">foreach</span> (EdgeArray edgeLoop <span class="keyword">in</span> result.EdgeLoops)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">foreach</span> (Edge edge <span class="keyword">in</span> edgeLoop)</span><br><span class="line">        &#123;</span><br><span class="line">            curves.Append(edge.AsCurve());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get the model curve factory object.</span></span><br><span class="line">    Autodesk.Revit.Creation.ItemFactoryBase itemFactory;</span><br><span class="line">    <span class="keyword">if</span> (document.IsFamilyDocument)</span><br><span class="line">        itemFactory = document.FamilyCreate;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        itemFactory = document.Create;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add a sketch plane for the curves.    CurveLoop loop = new CurveLoop();</span></span><br><span class="line">    <span class="keyword">foreach</span> (Curve currentCurve <span class="keyword">in</span> curves)</span><br><span class="line">    &#123;</span><br><span class="line">        loop.Append(currentCurve);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SketchPlane sketchPlane = SketchPlane.Create(document, loop.GetPlane());</span><br><span class="line">    document.Regenerate();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add the shadow curves</span></span><br><span class="line">    ModelCurveArray curveElements = itemFactory.NewModelCurveArray(curves, sketchPlane);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Return the ids of the curves created</span></span><br><span class="line">    List curveElementIds = <span class="keyword">new</span> List();</span><br><span class="line">    <span class="keyword">foreach</span> (ModelCurve curveElement <span class="keyword">in</span> curveElements)</span><br><span class="line">    &#123;</span><br><span class="line">        curveElementIds.Add(curveElement.Id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> curveElementIds;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的实用程序可用于计算给定质量相对于视图当前日光和阴影设置的阴影：</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/shadowcalculator.png"></p>
<h2 id="通过光线投影查找几何图形"><a href="#通过光线投影查找几何图形" class="headerlink" title="通过光线投影查找几何图形"></a>通过光线投影查找几何图形</h2><p>ReferenceIntersector类可用于查找与给定射线相交的元素。</p>
<p><strong>ReferenceIntersector</strong> </p>
<p>此类允许应用程序使用Revit的拾取工具来查找图元和几何图形。这个类使用从指定方向的点发出的射线来查找射线击中的几何体。</p>
<p>该类仅与3D几何体相交，并且在创建时需要3D视图。可以使用已被剖面框剪切的三维视图，或设置了视图专有几何图元和图形选项的三维视图。输入视图上的可见性设置将确定是否返回特定图元（例如，此工具永远不会返回隐藏图元，几何图形位于视图剖面框之外的图元也不会返回）。</p>
<p>ReferenceIntersector类支持基于元素或引用类型过滤输出。输出可以根据使用的构造函数进行自定义，或者在调用方法执行光线投影之前使用类的方法和属性进行自定义。</p>
<p>有4个构造函数。</p>
<table>
<thead>
<tr>
<th><strong>Name 名称</strong></th>
<th><strong>Description 描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>ReferenceIntersector(View3D)</td>
<td>构造一个ReferenceIntersector，它被设置为返回所有元素的交集，并表示所有引用目标类型。</td>
</tr>
<tr>
<td>ReferenceIntersector(ElementFilter, FindReferenceTarget, View3D)</td>
<td>构造一个ReferenceIntersector，将其设置为返回通过过滤器的任何元素的交集。</td>
</tr>
<tr>
<td>ReferenceIntersector(ElementId, FindReferenceTarget, View3D)</td>
<td>构造一个ReferenceIntersector，它被设置为仅返回来自单个目标元素的交集。</td>
</tr>
<tr>
<td>ReferenceIntersector(ICollection, FindReferenceTarget, View3D)</td>
<td>构造一个ReferenceIntersector，它被设置为返回一组目标元素中任何一个的交集。</td>
</tr>
</tbody></table>
<p>FindReferenceTarget枚举包括以下选项：元素、网格、边、曲线、面或全部。 </p>
<p>查找元素 </p>
<p>有两种方法可以投影光线，这两种方法都将光线的原点及其方向作为输入。仅返回光线前面的元素的引用。Find（）方法返回与ReferenceIntersector的条件匹配的ReferenceWithContext对象的集合。该对象包含光线参照，它可以是与光线相交的元素和几何参照。返回的某些图元参照将具有一个相应的几何对象，该对象也是矩形的（例如，穿过墙中洞口的光线将与墙和洞口图元相交）。如果只对真正的物理交点感兴趣，则应用程序应丢弃其Reference类型为Element的所有引用。 FindNearest（）方法的行为与Find（）方法类似，但仅返回距离光线原点最近的对象引用。 返回的ReferenceWithContext包含一个接近度参数。这是光线原点与交点之间的距离。应用程序可以使用此距离来排除距离原点太远的项目，以进行特定的几何分析。应用程序还可以使用此距离来处理一些有趣的问题，包括分析模型的几何图形。</p>
<p>注意：这些方法不会返回与不在激活设计选项中的图元的交点。</p>
<p>链接文件中的元素</p>
<p> FindReferencesInRevitLinks属性提供了一个选项，用于返回在Revit链接中遇到的图元结果。如果设置为false，ReferenceIntersector将找不到对Revit链接中任何图元的参照，并且返回的所有参照将仅指向主体文档中的图元。如果设置为true，则结果可能包括对主体中元素的引用和对链接实例中元素的引用。 如果在ReferenceIntersector中设置了目标ElementId的列表，则仅当ElementId与ReferenceRevitLinkInstance的ID匹配时，才会返回引用。如果有匹配，链接中的任何相交元素都将被返回（它们的id将不会与目标id列表进行比较）。 如果应用了ElementFilter，则将根据存储的ElementFilter计算链接中的元素。请注意，如果应用的过滤器是几何过滤器（如BoundingBox过滤器或ElementIntersects过滤器），则结果可能与预期不同。这是因为将针对链接模型坐标中的链接图元计算过滤器，而链接模型坐标可能与图元在主体模型中显示的坐标不匹配。此外，在实例化期间接受Document和&#x2F;或ElementId作为输入的ElementFilters将无法正确传递链接中出现的元素，因为过滤器将无法将链接元素与过滤器的标准相匹配。 ###查找元素附近的元素 此工具的一个主要用途是查找与其他元素非常接近的元素。这允许应用程序将该工具用作其“眼睛”，并确定尚未具有内置关系的元素之间的关系。 例如，光线跟踪功能可用于查找嵌入墙中的柱。由于柱和墙不直接保持关系，因此此类允许我们通过跟踪墙范围外的光线并查找与柱的交点来查找潜在的候选对象。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/find_refs_1.png"></p>
<p>示例：查找嵌入墙中的柱</p>
<p><strong>测量距离</strong> </p>
<p>这个类也可以用来测量从天窗到最近楼层的垂直距离。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/DistanceToFloor.jpg"></p>
<p>示例：使用ReferenceIntersector.FindNearest（）进行测量</p>
<p>代码区域：使用光线投影测量距离</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">RayProjection</span> : <span class="title">IExternalCommand</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">Execute</span>(<span class="params">ExternalCommandData revit, <span class="keyword">ref</span> <span class="built_in">string</span> message, ElementSet elements</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Document doc = revit.Application.ActiveUIDocument.Document;</span><br><span class="line"></span><br><span class="line">        ICollection selectedIds = revit.Application.ActiveUIDocument.Selection.GetElementIds();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If skylight is selected, process it.</span></span><br><span class="line">        FamilyInstance skylight = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (selectedIds.Count == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">foreach</span> (ElementId id <span class="keyword">in</span> selectedIds)</span><br><span class="line">            &#123;</span><br><span class="line">                Element e = doc.GetElement(id);</span><br><span class="line">                <span class="keyword">if</span> (e <span class="keyword">is</span> FamilyInstance)</span><br><span class="line">                &#123;</span><br><span class="line">                    FamilyInstance instance = e <span class="keyword">as</span> FamilyInstance;</span><br><span class="line">                    <span class="built_in">bool</span> isWindow = (instance.Category.Id.IntegerValue == (<span class="built_in">int</span>)BuiltInCategory.OST_Windows);</span><br><span class="line">                    <span class="built_in">bool</span> isHostedByRoof = (instance.Host.Category.Id.IntegerValue == (<span class="built_in">int</span>)BuiltInCategory.OST_Roofs);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (isWindow &amp;&amp; isHostedByRoof)</span><br><span class="line">                    &#123;</span><br><span class="line">                        skylight = instance;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (skylight == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            message = <span class="string">&quot;Please select one skylight.&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span> Result.Cancelled;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Calculate the height</span></span><br><span class="line">        Line line = CalculateLineAboveFloor(doc, skylight);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create a model curve to show the distance</span></span><br><span class="line">        Plane plane = Plane.CreateByNormalAndOrigin(<span class="keyword">new</span> XYZ(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>), line.GetEndPoint(<span class="number">0</span>));</span><br><span class="line">        SketchPlane sketchPlane = SketchPlane.Create(doc, plane);</span><br><span class="line"></span><br><span class="line">        ModelCurve curve = doc.Create.NewModelCurve(line, sketchPlane);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Show a message with the length value</span></span><br><span class="line">        TaskDialog.Show(<span class="string">&quot;Distance&quot;</span>, <span class="string">&quot;Distance to floor: &quot;</span> + String.Format(<span class="string">&quot;&#123;0:f2&#125;&quot;</span>, line.Length));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Result.Succeeded;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> </span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> Determines the line segment that connects the skylight to the nearest floor.</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> </span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> The line segment.</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Line <span class="title">CalculateLineAboveFloor</span>(<span class="params">Document doc, FamilyInstance skylight</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Find a 3D view to use for the ReferenceIntersector constructor</span></span><br><span class="line">        FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(doc);</span><br><span class="line">        Func&lt;View3D, <span class="built_in">bool</span>&gt; isNotTemplate = v3 =&gt; !(v3.IsTemplate);</span><br><span class="line">        View3D view3D = collector.OfClass(<span class="keyword">typeof</span>(View3D)).Cast().First(isNotTemplate);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Use the center of the skylight bounding box as the start point.</span></span><br><span class="line">        BoundingBoxXYZ box = skylight.get_BoundingBox(view3D);</span><br><span class="line">        XYZ center = box.Min.Add(box.Max).Multiply(<span class="number">0.5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Project in the negative Z direction down to the floor.</span></span><br><span class="line">        XYZ rayDirection = <span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">        ElementClassFilter filter = <span class="keyword">new</span> ElementClassFilter(<span class="keyword">typeof</span>(Floor));</span><br><span class="line"></span><br><span class="line">        ReferenceIntersector refIntersector = <span class="keyword">new</span> ReferenceIntersector(filter, FindReferenceTarget.Face, view3D);</span><br><span class="line">        ReferenceWithContext referenceWithContext = refIntersector.FindNearest(center, rayDirection);</span><br><span class="line"></span><br><span class="line">        Reference reference = referenceWithContext.GetReference();</span><br><span class="line">        XYZ intersection = reference.GlobalPoint;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create line segment from the start point and intersection point.</span></span><br><span class="line">        Line result = Line.CreateBound(center, intersection);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>射线反弹&#x2F;分析</strong></p>
<p>ReferenceIntersector.Find（）返回的参照包括几何上的交点。知道了面上的交点、面的材质和光线方向，应用程序就可以分析建筑物内的反射和折射。下图演示了如何使用交点来反射由模型图元遮挡的光线;添加了模型曲线来表示每条光线的路径。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/find_refs_3.png"></p>
<p>示例：从曲面反弹的射线</p>
<p><strong>查找交点&#x2F;碰撞</strong></p>
<p>ReferenceIntersector类的另一个用途是检测与给定梁或管道的中心线相交&#x2F;干涉的交点（如梁或管道）。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/find_refs_4.png"></p>
<p>示例：在干涉周围重新布线元素</p>
<h2 id="几何工具类"><a href="#几何工具类" class="headerlink" title="几何工具类"></a>几何工具类</h2><p>有许多工具类可用于处理几何体对象。</p>
<p><strong>HostObjectUtils</strong></p>
<p>HostObjectUtils类提供方法作为定位复合HostObjects的某些面的快捷方式。这些实用程序检索用作对象的CompoundStructure的边界的面：</p>
<ul>
<li>HostObjectUtils.GetSideFaces() – 适用于墙壁和FaceWalls;您可以获得外部或内部饰面。</li>
<li>HostObjectUtils.GetTopFaces() and HostObjectUtils.GetBottomFaces() – 适用于屋顶、楼板和天花板。</li>
</ul>
<p><strong>SolidUtils</strong></p>
<p>SolidUtils类包含对实体执行操作的方法。</p>
<ul>
<li>SolidUtils.Clone() - 创建一个新的Solid，它是输入Solid的副本</li>
<li>SolidUtils.SplitVolumes() - 使用一个包含不相交的封闭体积的实体，并返回新创建的代表每个体积的实体对象。如果不需要分割，则返回输入实体。</li>
<li>SolidUtils.TessellateSolidOrShell() - 对给定的输入实体（可以是一个或多个完全闭合的体积，也可以是一个开放的壳）进行三角测量。返回一个TriangulatedSolidOrShell对象，该对象允许访问存储的实体的三角化边界组件或壳的三角化连接组件。</li>
<li>SolidUtils.CreateTransformed() - 创建一个新的实体，它是输入实体的变换。</li>
</ul>
<p><strong>JoinGeometryUtils</strong></p>
<p>JoinGeometryUtils类包含用于连接和取消连接元素以及管理元素连接顺序的方法。这些实用程序不适用于族文档。</p>
<ul>
<li>JoinGeometryUtils.AreElementsJoined() - 确定是否连接两个元素</li>
<li>JoinGeometryUtils.GetJoinedElements() - 返回连接到给定元素的所有元素</li>
<li>JoinGeometryUtils.JoinGeometry() - 在共享公共面的两个元素之间创建连接。将删除连接图元之间的可见边。然后，连接的元素共享相同的线宽和填充图案。</li>
<li>JoinGeometryUtils.UnjoinGeometry() - 删除两个连接元素之间的连接</li>
<li>JoinGeometryUtils.SwitchJoinOrder() - 反转两个元素连接的顺序。切割元件变成被切割元件，反之亦然。</li>
<li>JoinGeometryUtils . IsCuttingElementInJoin() - 确定两个连接的元素中的第一个元素是否剪切第二个元素，反之亦然。</li>
</ul>
<p><strong>FacetingUtils</strong></p>
<p>此类用于将三角形结构转换为其中某些三角形已合并为四边形的结构。</p>
<ul>
<li>FacetingUtils.ConvertTrianglesToQuads() - 此方法以TriangulationInterface（从TriangulatedSolidOrShell构造）作为输入，并返回表示原始三角化对象的三角形和四边形的集合。</li>
</ul>
<h2 id="房间和空间几何"><a href="#房间和空间几何" class="headerlink" title="房间和空间几何"></a>房间和空间几何</h2><p>通过Revit API可以访问空间图元（房间和空间）的三维几何图形。</p>
<p>SpatialElementGeometryCalculator类可用于计算空间元素的几何形状并获取几何形状与元素边界元素之间的关系。可以为此实用程序提供2个选项：</p>
<ul>
<li>SpatialElementBoundaryLocation – 是否使用详细面或边界元素中心线进行计算</li>
<li>StoredFreeBoundaryFaces – 是否在结果中包括不直接映射到边界元素的面。</li>
</ul>
<p>计算几何体的结果包含在SpatialElementGeometryResults类中。从SpatialElementGeometryResults类中，可以获得：</p>
<ul>
<li>表示几何的实体体积（GetGeometry（）方法）</li>
<li>边界面信息（一个集合SpatialElementBoundarySubfaces）</li>
</ul>
<p>每个子面提供：</p>
<ul>
<li>空间元素的表面</li>
<li>边界元素的匹配面</li>
<li>子面（由该特定边界元素限定的空间元素面部分）</li>
<li>底面类型（底部、顶部或侧面）</li>
</ul>
<p>关于使用此实用程序的一些注意事项：</p>
<ul>
<li>计算器为已处理的几何体维护一个内部缓存。如果要计算同一项目中多个图元的几何图形，则应使用此类的单个实例。请注意，当对文档进行任何更改时，将清除该高速缓存。</li>
<li>楼板几乎从不作为边界元素包含在内。Revit使用房间的二维轮廓来形成底面，而不将其与楼板几何图形相匹配。</li>
<li>由墙剪切特征（例如门和窗）创建的洞口不包括在返回的面中。</li>
<li>几何图形计算与Revit提供的功能相匹配。在某些情况下，如果Revit假设如何计算房间和空间边界的体积，则这些假设将显示在实用程序的输出中。</li>
</ul>
<p>以下示例计算房间的几何图形并查找其边界面</p>
<p>代码区域：使用SpatialElementGeometryCalculator的面部区域</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">SpatialElementGeometryCalculator calculator = new SpatialElementGeometryCalculator(doc);</span><br><span class="line"></span><br><span class="line"><span class="comment">// compute the room geometry</span></span><br><span class="line">SpatialElementGeometryResults results = calculator.CalculateSpatialElementGeometry(room);</span><br><span class="line"></span><br><span class="line"><span class="comment">// get the solid representing the room&#x27;s geometry</span></span><br><span class="line">Solid roomSolid = results.GetGeometry(); </span><br><span class="line"></span><br><span class="line">foreach (Face face in roomSolid.Faces)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">double</span> faceArea = face.Area;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get the sub-faces for the face of the room</span></span><br><span class="line">    IList subfaceList = results.GetBoundaryFaceInfo(face);</span><br><span class="line">    foreach (SpatialElementBoundarySubface subface in subfaceList)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (subfaceList.Count &gt; <span class="number">1</span>) <span class="comment">// there are multiple sub-faces that define the face</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// get the area of each sub-face</span></span><br><span class="line">            <span class="type">double</span> subfaceArea = subface.GetSubface().Area;</span><br><span class="line">            <span class="comment">// sub-faces exist in situations such as when a room-bounding wall has been</span></span><br><span class="line">            <span class="comment">// horizontally split and the faces of each split wall combine to create the </span></span><br><span class="line">            <span class="comment">// entire face of the room</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面的示例计算房间的几何图形，并查找属于定义房间的图元的面的材质。</p>
<p>代码区域：使用SpatialElementGeometryCalculator的面材质</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">MaterialFromFace</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="built_in">string</span> s = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    Document doc = <span class="keyword">this</span>.Document;</span><br><span class="line">        UIDocument uidoc = <span class="keyword">new</span> UIDocument(doc);</span><br><span class="line">        Room room = doc.GetElement(uidoc.Selection.PickObject(ObjectType.Element).ElementId) <span class="keyword">as</span> Room;</span><br><span class="line"></span><br><span class="line">        SpatialElementBoundaryOptions  spatialElementBoundaryOptions = <span class="keyword">new</span> SpatialElementBoundaryOptions();</span><br><span class="line">        spatialElementBoundaryOptions.SpatialElementBoundaryLocation = SpatialElementBoundaryLocation.Finish;</span><br><span class="line">        SpatialElementGeometryCalculator calculator = <span class="keyword">new</span> SpatialElementGeometryCalculator(doc, spatialElementBoundaryOptions);</span><br><span class="line">        SpatialElementGeometryResults results = calculator.CalculateSpatialElementGeometry(room);</span><br><span class="line">        Solid roomSolid = results.GetGeometry(); </span><br><span class="line"></span><br><span class="line">        <span class="keyword">foreach</span> (Face roomSolidFace <span class="keyword">in</span> roomSolid.Faces)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">foreach</span> (SpatialElementBoundarySubface subface <span class="keyword">in</span> results.GetBoundaryFaceInfo(roomSolidFace))</span><br><span class="line">            &#123;</span><br><span class="line">                Face boundingElementface = subface.GetBoundingElementFace();</span><br><span class="line">                ElementId id = boundingElementface.MaterialElementId;</span><br><span class="line">                s +=  doc.GetElement(id).Name + <span class="string">&quot;, id = &quot;</span> + id.IntegerValue.ToString() + <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    TaskDialog.Show(<span class="string">&quot;revit&quot;</span>,s);&#125;</span><br></pre></td></tr></table></figure>

<h2 id="注：翻译自Revit-API-Developers-Guide"><a href="#注：翻译自Revit-API-Developers-Guide" class="headerlink" title="注：翻译自Revit API Developers Guide"></a><em><strong>注：</strong></em>翻译自<a target="_blank" rel="noopener" href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_html">Revit API Developers Guide</a></h2></article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Revit/">Revit</a></div><div class="post-share"><div class="social-share" data-image="/images/4stars.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2024/12/15/Revit%E4%BA%8C%E5%BC%80%E6%8C%87%E5%8D%97/20%E6%9D%90%E6%96%99/" title="20材料"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">20材料</div></div><div class="info-2"><div class="info-item-1">材质在Revit Platform API中，材质数据作为图元进行存储和管理。就像在Revit UI中一样，材质可以有多个与之关联的资源，但只能使用API指定热学和结构（在Revit...</div></div></div></a><a class="pagination-related" href="/2024/12/10/RevitApi%E5%90%88%E9%9B%86/Autodesk.Revit.DB%20Opening/" title="Autodesk.Revit.DB Opening"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Autodesk.Revit.DB Opening</div></div><div class="info-2"><div class="info-item-1">Autodesk.Revit.DB OpeningAutodesk Revit项目或族文档中的洞口。 语法1public class Opening : Element  附注该对象表示各种不同类型的洞口：  墙中由修订项目中的两个边界点创建的矩形洞口。 由应用于屋顶、楼板、天花板、梁、支撑或柱的一组曲线创建的洞口。 一个垂直的竖井开口延伸到一个或多个水平。 在族文档中的墙或天花板上创建的简单洞口。  根据打开的类型，此类的某些属性将不可用。 这个对象派生自Element基对象，并且支持该对象的所有方法，例如检索该对象的参数的能力。此对象还支持访问结构分析模型，但此功能仅适用于Autodesk Revit Structure。 示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051### private void Getinfo_Opening(Opening opening)&#123;    string message =...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2024/11/18/RevitApi%E5%90%88%E9%9B%86/Autodesk.RevitAddIns%20Namespace/" title="Autodesk.RevitAddIns Namespace"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-18</div><div class="info-item-2">Autodesk.RevitAddIns Namespace</div></div><div class="info-2"><div class="info-item-1">Autodesk.RevitAddIns Namespace类AddInManifestUtility此静态类提供从 Revit .addin 文件中读取清单内容的访问。   方法  GetRevitAddInBundleManifests  GetRevitAddInManifest  GetRevitAddInManifests     RevitAddInApplication表示 Revit 外部应用程序。  构造器  RevitAddInApplication 创建 external application info 类的新实例。    属性  Name  Application name    继承关系  System.Object  Autodesk.RevitAddIns.RevitAddInItem  Autodesk.RevitAddIns.RevitAddInApplication    RevitAddInCommand表示 Revit 外部命令。  构造器  RevitAddInCommand 创建 Add-In Command info...</div></div></div></a><a class="pagination-related" href="/2024/11/18/RevitApi%E5%90%88%E9%9B%86/Autodesk.Revit.DB%20CurveArray/" title="Autodesk.Revit.DB CurveArray"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-18</div><div class="info-item-2">Autodesk.Revit.DB CurveArray</div></div><div class="info-2"><div class="info-item-1">Autodesk.Revit.DB CurveArray可以包含曲线的数组。 语法1public class CurveArray : APIObject, IEnumerable  继承层次结构System Object ​	Autodesk.Revit.DB APIObject ​		Autodesk.Revit.DB CurveArray 另见CurveArray Members Autodesk.Revit.DB Namespace 构造函数CurveArray创建CurveArray类的新实例 方法Append将曲线添加到数组的末尾。 Clear从数组中删除每条曲线，使其为空。 ForwardIterator将一个向前移动的迭代器添加到数组中。 GetEnumerator将一个向前移动的迭代器添加到数组中。 Insert将指定的曲线插入数组。 ReverseIterator返回一个向后移动的迭代器到数组。 属性IsEmpty测试数组是否为空。 Item获取或设置数组中指定索引处的曲线。 Size返回数组中的曲线数。 注：翻译自Revit Api docs 2018</div></div></div></a><a class="pagination-related" href="/2024/12/10/RevitApi%E5%90%88%E9%9B%86/Autodesk.Revit.DB%20Opening/" title="Autodesk.Revit.DB Opening"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-10</div><div class="info-item-2">Autodesk.Revit.DB Opening</div></div><div class="info-2"><div class="info-item-1">Autodesk.Revit.DB OpeningAutodesk Revit项目或族文档中的洞口。 语法1public class Opening : Element  附注该对象表示各种不同类型的洞口：  墙中由修订项目中的两个边界点创建的矩形洞口。 由应用于屋顶、楼板、天花板、梁、支撑或柱的一组曲线创建的洞口。 一个垂直的竖井开口延伸到一个或多个水平。 在族文档中的墙或天花板上创建的简单洞口。  根据打开的类型，此类的某些属性将不可用。 这个对象派生自Element基对象，并且支持该对象的所有方法，例如检索该对象的参数的能力。此对象还支持访问结构分析模型，但此功能仅适用于Autodesk Revit Structure。 示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051### private void Getinfo_Opening(Opening opening)&#123;    string message =...</div></div></div></a><a class="pagination-related" href="/2024/12/10/RevitApi%E5%90%88%E9%9B%86/Autodesk.Revit.DB%20ReferenceIntersector/" title="Autodesk.Revit.DB ReferenceIntersector"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-10</div><div class="info-item-2">Autodesk.Revit.DB ReferenceIntersector</div></div><div class="info-2"><div class="info-item-1">Autodesk.Revit.DB ReferenceIntersector用于查找和返回与从原点和方向创建的射线相交的元素的类。 语法1public class ReferenceIntersector : IDisposable    附注可以构造此类的实例，以返回与由原点和方向创建的射线，或者基于过滤和标志返回元素的子集。 调用者可以选择使用ElementFilter过滤结果，或者通过应用特定的可接受的元素。 调用方还可以指定要返回的对象的类型， 整个元素、几何体对象或其组合。 在所有情况下，要求调用者提供 用于评估的3D视图;输入视图上的视图和可见性设置将确定 返回特定元素（例如，此工具永远不会返回隐藏元素、 和几何图形位于视图剖面框之外的元素）。 该类配置为可以构建单个实例，并用于对多个不同光线进行多次评估。在同一个 ReferenceIntersector 上的调用之间，评估结果不会被保留。 该类还提供了一个选项，用于返回在Revit链接中遇到的图元结果。 当设置 FindReferencesInRevitLinks 标志...</div></div></div></a><a class="pagination-related" href="/2024/12/19/RevitApi%E5%90%88%E9%9B%86/Autodesk.Revit.UI.Selection%20Namespace/" title="Autodesk.Revit.UI.Selection"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-19</div><div class="info-item-2">Autodesk.Revit.UI.Selection</div></div><div class="info-2"><div class="info-item-1">Autodesk.Revit.UI.SelectionClassesPickedBox包含两个 XYZ 点的类，表示屏幕上的选取框。  Properties  Max 最大坐标数（拾取框的右上角）。  Min 最小坐标（拾取框的左下角）。     SelectableInViewFilter一个过滤器，用于传递在给定视图中可选的元素。  Constructors  SelectableInViewFilter  (Document, ElementId) 构造 SelectableInViewFilter 的新实例。  SelectableInViewFilter (Document, ElementId, Boolean) 构造 SelectableInViewFilter 的新实例，并可选择传递所有不可选择的元素。    Methods  PassesFilter(Element) 将筛选器应用于给定元素。  PassesFilter(Document,...</div></div></div></a><a class="pagination-related" href="/2024/12/20/RevitApi%E5%90%88%E9%9B%86/Autodesk.Revit.DB%20Transform/" title="Autodesk.Revit.DB Transform"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-20</div><div class="info-item-2">Autodesk.Revit.DB Transform</div></div><div class="info-2"><div class="info-item-1">Autodesk.Revit.DB Transform仿射三维空间的一个变换。 语法public class Transform : APIObject示例12345678910111213141516171819202122### public static XYZ TransformPoint(XYZ point, Transform transform)&#123;    double x = point.X;    double y = point.Y;    double z = point.Z;    //transform basis of the old coordinate system in the new coordinate // system    XYZ b0 = transform.get_Basis(0);    XYZ b1 = transform.get_Basis(1);    XYZ b2 = transform.get_Basis(2);    XYZ origin = transform.Origin;       ...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="giscus-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/images/4stars.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">funtim41@gmail.com</div><div class="author-info-description">实践-认识-再实践-再认识</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">55</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/FunTim41"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/FunTim41" target="_blank" title="Github"><i class="fab fa-github" style="color: #FFFFFF;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%87%A0%E4%BD%95"><span class="toc-number">1.</span> <span class="toc-text">几何</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E4%BB%8E%E5%A2%99%E5%A3%81%E4%B8%AD%E6%A3%80%E7%B4%A2%E5%87%A0%E4%BD%95%E6%95%B0%E6%8D%AE"><span class="toc-number">1.1.</span> <span class="toc-text">示例：从墙壁中检索几何数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GeometryObject%E7%B1%BB"><span class="toc-number">1.2.</span> <span class="toc-text">GeometryObject类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Curves"><span class="toc-number">1.2.1.</span> <span class="toc-text">Curves</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9B%B2%E7%BA%BF%E5%88%86%E6%9E%90"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">曲线分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9B%B2%E7%BA%BF%E5%B7%A5%E4%BD%9C"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">曲线工作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9B%B2%E7%BA%BF%E9%9B%86%E5%90%88"><span class="toc-number">1.2.1.3.</span> <span class="toc-text">曲线集合</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9B%B2%E7%BA%BF%E5%88%9B%E5%BB%BA"><span class="toc-number">1.2.1.4.</span> <span class="toc-text">曲线创建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9B%B2%E7%BA%BF%E5%8F%82%E6%95%B0%E5%8C%96"><span class="toc-number">1.2.1.5.</span> <span class="toc-text">曲线参数化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9B%B2%E7%BA%BF%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.2.1.6.</span> <span class="toc-text">曲线类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9B%B2%E7%BA%BF%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%95%B0%E5%AD%A6%E8%A1%A8%E7%A4%BA"><span class="toc-number">1.2.1.7.</span> <span class="toc-text">曲线类型的数学表示</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GeometryInstances"><span class="toc-number">1.2.2.</span> <span class="toc-text">GeometryInstances</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E6%A0%BC"><span class="toc-number">1.2.3.</span> <span class="toc-text">网格</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%82%B9"><span class="toc-number">1.2.4.</span> <span class="toc-text">点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PolyLine"><span class="toc-number">1.2.5.</span> <span class="toc-text">PolyLine</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BD%93%E3%80%81%E9%9D%A2%E5%92%8C%E8%BE%B9"><span class="toc-number">1.2.6.</span> <span class="toc-text">实体、面和边</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BE%B9%E5%92%8C%E9%9D%A2%E5%8F%82%E6%95%B0%E5%8C%96"><span class="toc-number">1.2.6.0.1.</span> <span class="toc-text">边和面参数化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9D%A2"><span class="toc-number">1.2.6.0.2.</span> <span class="toc-text">面</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9D%A2%E5%88%86%E6%9E%90"><span class="toc-number">1.2.6.0.3.</span> <span class="toc-text">面分析</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9D%A2%E5%88%86%E5%89%B2"><span class="toc-number">1.2.6.0.4.</span> <span class="toc-text">面分割</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9D%A2%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.2.6.0.5.</span> <span class="toc-text">面类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9D%A2%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%95%B0%E5%AD%A6%E8%A1%A8%E7%A4%BA"><span class="toc-number">1.2.6.0.6.</span> <span class="toc-text">面类型的数学表示</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9E%E4%BD%93%E5%88%86%E6%9E%90"><span class="toc-number">1.2.6.0.7.</span> <span class="toc-text">实体分析</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9E%E4%BD%93%E5%92%8C%E9%9D%A2%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-number">1.2.6.0.8.</span> <span class="toc-text">实体和面的创建</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Geometry-Helper-%E7%B1%BB"><span class="toc-number">1.3.</span> <span class="toc-text">Geometry Helper 类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Transform"><span class="toc-number">1.3.1.</span> <span class="toc-text">Transform</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Identity"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">Identity</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CreateRotation-and-CreateRotationAtPoint"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">CreateRotation() and CreateRotationAtPoint()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CreateTranslation"><span class="toc-number">1.3.1.3.</span> <span class="toc-text">CreateTranslation()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Determinant"><span class="toc-number">1.3.1.4.</span> <span class="toc-text">Determinant</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HasReflection"><span class="toc-number">1.3.1.5.</span> <span class="toc-text">HasReflection</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Scale"><span class="toc-number">1.3.1.6.</span> <span class="toc-text">Scale</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Inverse"><span class="toc-number">1.3.1.7.</span> <span class="toc-text">Inverse</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IsIdentity"><span class="toc-number">1.3.1.8.</span> <span class="toc-text">IsIdentity</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IsTranslation"><span class="toc-number">1.3.1.9.</span> <span class="toc-text">IsTranslation</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Multiply"><span class="toc-number">1.3.1.10.</span> <span class="toc-text">Multiply</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ScaleBasis"><span class="toc-number">1.3.1.11.</span> <span class="toc-text">ScaleBasis</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ScaleBasisAndOrigin"><span class="toc-number">1.3.1.12.</span> <span class="toc-text">ScaleBasisAndOrigin</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#OfPoint"><span class="toc-number">1.3.1.13.</span> <span class="toc-text">OfPoint</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#OfVector"><span class="toc-number">1.3.1.14.</span> <span class="toc-text">OfVector</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AlmostEqual"><span class="toc-number">1.3.1.15.</span> <span class="toc-text">AlmostEqual</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BoundingBoxUV"><span class="toc-number">1.3.2.</span> <span class="toc-text">BoundingBoxUV</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E7%B1%BB"><span class="toc-number">1.4.</span> <span class="toc-text">集合类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E4%BB%8E%E6%A2%81%E4%B8%AD%E6%A3%80%E7%B4%A2%E5%87%A0%E4%BD%95%E5%9B%BE%E5%BD%A2%E6%95%B0%E6%8D%AE"><span class="toc-number">1.5.</span> <span class="toc-text">示例：从梁中检索几何图形数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E4%BD%93%E7%9A%84%E6%8B%89%E4%BC%B8%E5%88%86%E6%9E%90"><span class="toc-number">1.6.</span> <span class="toc-text">实体的拉伸分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E5%85%89%E7%BA%BF%E6%8A%95%E5%BD%B1%E6%9F%A5%E6%89%BE%E5%87%A0%E4%BD%95%E5%9B%BE%E5%BD%A2"><span class="toc-number">1.7.</span> <span class="toc-text">通过光线投影查找几何图形</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%A0%E4%BD%95%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-number">1.8.</span> <span class="toc-text">几何工具类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%88%BF%E9%97%B4%E5%92%8C%E7%A9%BA%E9%97%B4%E5%87%A0%E4%BD%95"><span class="toc-number">1.9.</span> <span class="toc-text">房间和空间几何</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%EF%BC%9A%E7%BF%BB%E8%AF%91%E8%87%AARevit-API-Developers-Guide"><span class="toc-number">1.10.</span> <span class="toc-text">注：翻译自Revit API Developers Guide</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/30/C#/%E7%BA%BF%E7%A8%8B/" title="线程">线程</a><time datetime="2025-01-11T12:26:01.333Z" title="更新于 2025-01-11 20:26:01">2025-01-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/16/C#/LINQ/" title="Linq标准查询运算符">Linq标准查询运算符</a><time datetime="2025-01-11T12:23:21.403Z" title="更新于 2025-01-11 20:23:21">2025-01-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/01/08/CAD%E4%BA%8C%E5%BC%80/AddInManager/" title="AddInManager">AddInManager</a><time datetime="2025-01-08T13:14:43.495Z" title="更新于 2025-01-08 21:14:43">2025-01-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/01/08/%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE/Hexo+Butterfly%E4%BB%A3%E7%A0%81%E5%9D%97%E6%B0%B4%E5%B9%B3%E6%BB%9A%E5%8A%A8%E6%9D%A1/" title="Hexo+Butterfly代码块水平滚动条">Hexo+Butterfly代码块水平滚动条</a><time datetime="2025-01-08T04:24:42.742Z" title="更新于 2025-01-08 12:24:42">2025-01-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/01/05/CAD%E4%BA%8C%E5%BC%80/01%E5%9B%BE%E5%B1%82%E7%9A%84%E5%A2%9E%E5%88%A0%E6%9F%A5/" title="01图层的增删查">01图层的增删查</a><time datetime="2025-01-06T02:26:57.051Z" title="更新于 2025-01-06 10:26:57">2025-01-06</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/images/topback.jpg);"><div id="footer-wrap"><div class="copyright">&copy;2024 - 2025 By funtim41@gmail.com</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">学而不思则罔，思而不学则殆。</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>(() => {
  const panguFn = () => {
    if (typeof pangu === 'object') pangu.autoSpacingPage()
    else {
      btf.getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
        .then(() => {
          pangu.autoSpacingPage()
        })
    }
  }

  const panguInit = () => {
    if (false){
      GLOBAL_CONFIG_SITE.isPost && panguFn()
    } else {
      panguFn()
    }
  }

  btf.addGlobalFn('pjaxComplete', panguInit, 'pangu')
  document.addEventListener('DOMContentLoaded', panguInit)
})()</script><div class="js-pjax"><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.isShuoshuo
  const option = null

  const getGiscusTheme = theme => theme === 'dark' ? 'dark' : 'light'

  const createScriptElement = config => {
    const ele = document.createElement('script')
    Object.entries(config).forEach(([key, value]) => {
      ele.setAttribute(key, value)
    })
    return ele
  }

  const loadGiscus = (el = document, key) => {
    const mappingConfig = isShuoshuo
      ? { 'data-mapping': 'specific', 'data-term': key }
      : { 'data-mapping': (option && option['data-mapping']) || 'pathname' }

    const giscusConfig = {
      src: 'https://giscus.app/client.js',
      'data-repo': 'FunTim41/funtim41.github.io',
      'data-repo-id': 'R_kgDONjG8ww',
      'data-category-id': 'DIC_kwDONjG8w84Cllg2',
      'data-theme': getGiscusTheme(document.documentElement.getAttribute('data-theme')),
      'data-reactions-enabled': '1',
      crossorigin: 'anonymous',
      async: true,
      ...option,
      ...mappingConfig
    }

    const scriptElement = createScriptElement(giscusConfig)

    el.querySelector('#giscus-wrap').appendChild(scriptElement)

    if (isShuoshuo) {
      window.shuoshuoComment.destroyGiscus = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }
  }

  const changeGiscusTheme = theme => {
    const iframe = document.querySelector('#giscus-wrap iframe')
    if (iframe) {
      const message = {
        giscus: {
          setConfig: {
            theme: getGiscusTheme(theme)
          }
        }
      }
      iframe.contentWindow.postMessage(message, 'https://giscus.app')
    }
  }

  btf.addGlobalFn('themeChange', changeGiscusTheme, 'giscus')

  if (isShuoshuo) {
    'Giscus' === 'Giscus'
      ? window.shuoshuoComment = { loadComment: loadGiscus }
      : window.loadOtherComment = loadGiscus
    return
  }

  if ('Giscus' === 'Giscus' || !false) {
    if (false) btf.loadComment(document.getElementById('giscus-wrap'), loadGiscus)
    else loadGiscus()
  } else {
    window.loadOtherComment = loadGiscus
  }
})()</script></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>