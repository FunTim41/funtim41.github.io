<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>05过滤 | funtim的博客</title><meta name="author" content="funtim41@gmail.com"><meta name="copyright" content="funtim41@gmail.com"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Filtering 过滤Revit API提供了一种过滤和迭代Revit文档中图元的机制。这是获取一组相关元素（如文档中的所有墙或门）的最佳方法。过滤器也可以用来找到一个非常具体的元素集，如所有特定大小的梁。 获取通过指定过滤器的元素的基本步骤如下：  创建新的FilteredElementCollector 对它应用一个或多个过滤器 获取过滤后的元素或元素ID（使用以下几种方法之一）  下面的示">
<meta property="og:type" content="article">
<meta property="og:title" content="05过滤">
<meta property="og:url" content="https://funtim41.github.io/2024/11/26/Revit%E4%BA%8C%E5%BC%80%E6%8C%87%E5%8D%97/05%E8%BF%87%E6%BB%A4/">
<meta property="og:site_name" content="funtim的博客">
<meta property="og:description" content="Filtering 过滤Revit API提供了一种过滤和迭代Revit文档中图元的机制。这是获取一组相关元素（如文档中的所有墙或门）的最佳方法。过滤器也可以用来找到一个非常具体的元素集，如所有特定大小的梁。 获取通过指定过滤器的元素的基本步骤如下：  创建新的FilteredElementCollector 对它应用一个或多个过滤器 获取过滤后的元素或元素ID（使用以下几种方法之一）  下面的示">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://funtim41.github.io/images/4stars.png">
<meta property="article:published_time" content="2024-11-26T12:18:53.000Z">
<meta property="article:modified_time" content="2025-01-13T14:19:06.000Z">
<meta property="article:author" content="funtim41@gmail.com">
<meta property="article:tag" content="Revit">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://funtim41.github.io/images/4stars.png"><link rel="shortcut icon" href="/images/OIP.jfif"><link rel="canonical" href="https://funtim41.github.io/2024/11/26/Revit%E4%BA%8C%E5%BC%80%E6%8C%87%E5%8D%97/05%E8%BF%87%E6%BB%A4/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: funtim41@gmail.com","link":"链接: ","source":"来源: funtim的博客","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'null',
  Snackbar: {"chs_to_cht":"已切换为繁体中文","cht_to_chs":"已切换为简体中文","day_to_night":"已切换为深色模式","night_to_day":"已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: true,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '05过滤',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  isShuoshuo: false
}</script><link rel="stylesheet" href="/css/bar.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background: Color(#995a82);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/images/4stars.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">59</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Timeline</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/Links/"><i class="fa-fw fas fa-link"></i><span> Links</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/images/topback.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/images/OIP.jfif" alt="Logo"><span class="site-name">funtim的博客</span></a><a class="nav-page-title" href="/"><span class="site-name">05过滤</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Timeline</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/Links/"><i class="fa-fw fas fa-link"></i><span> Links</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">05过滤</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-11-26T12:18:53.000Z" title="发表于 2024-11-26 20:18:53">2024-11-26</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-01-13T14:19:06.000Z" title="更新于 2025-01-13 22:19:06">2025-01-13</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Revit%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%E4%BA%BA%E5%91%98%E6%8C%87%E5%8D%97/">Revit二次开发人员指南</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="Filtering-过滤"><a href="#Filtering-过滤" class="headerlink" title="Filtering 过滤"></a>Filtering 过滤</h1><p>Revit API提供了一种过滤和迭代Revit文档中图元的机制。这是获取一组相关元素（如文档中的所有墙或门）的最佳方法。过滤器也可以用来找到一个非常具体的元素集，如所有特定大小的梁。</p>
<p>获取通过指定过滤器的元素的基本步骤如下：</p>
<ol>
<li>创建新的FilteredElementCollector</li>
<li>对它应用一个或多个过滤器</li>
<li>获取过滤后的元素或元素ID（使用以下几种方法之一）</li>
</ol>
<p>下面的示例涵盖了在文档中筛选和迭代元素的基本步骤。</p>
<p><strong>代码区域6-1：使用元素过滤获取文档中的所有墙实例</strong></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Find all Wall instances in the document by using category filter</span></span><br><span class="line">ElementCategoryFilter filter = <span class="keyword">new</span> ElementCategoryFilter(BuiltInCategory.OST_Walls);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Apply the filter to the elements in the active document</span></span><br><span class="line"><span class="comment">// Use shortcut WhereElementIsNotElementType() to find wall instances only</span></span><br><span class="line">FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">IList walls = </span><br><span class="line">collector.WherePasses(filter).WhereElementIsNotElementType().ToElements();</span><br><span class="line">String prompt = <span class="string">&quot;The walls in the current document are:\n&quot;</span>;</span><br><span class="line"><span class="keyword">foreach</span> (Element e <span class="keyword">in</span> walls)</span><br><span class="line">&#123;</span><br><span class="line">        prompt += e.Name + <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>, prompt);</span><br></pre></td></tr></table></figure>

<p><strong>Pages in this section 本节中的页面</strong></p>
<ul>
<li>创建FilteredElementCollector</li>
<li>应用过滤器</li>
<li>获取筛选的元素或元素ID</li>
<li>LINQ查询</li>
<li>边界框过滤器</li>
<li>元素交叉过滤器</li>
</ul>
<h2 id="创建FilteredElementCollector"><a href="#创建FilteredElementCollector" class="headerlink" title="创建FilteredElementCollector"></a>创建FilteredElementCollector</h2><p>用于元素迭代和筛选的主类称为FilteredElementCollector。它以三种方式之一构建：</p>
<ol>
<li>从文档-将搜索和筛选文档中的元素集</li>
<li>从一个文档和一组ElementId-将搜索和筛选一组指定的元素</li>
<li>从文档和视图-将搜索和过滤视图中的可见元素</li>
</ol>
<p><em><strong>注意：</strong></em>使用静态FilteredElementCollector.IsViewValidForElementIteration()过滤指定视图中的元素时，请始终检查视图是否对元素迭代有效。</p>
<p>首次创建对象时，没有应用任何过滤器。此类要求在尝试访问元素之前至少设置一个条件，否则将引发异常。</p>
<h2 id="应用过滤器"><a href="#应用过滤器" class="headerlink" title="应用过滤器"></a>应用过滤器</h2><p>可以使用ElementFilters将筛选器应用于FilteredElementCollector。ElementFilter是一个类，它检查元素以查看它是否满足特定条件。ElementFilter基类有三个派生类，它们将元素筛选器分为三个类别。</p>
<ul>
<li><em><strong>ElementQuickFilter</strong></em>-快速过滤器仅在ElementRecord上操作，ElementRecord是一个低内存类，它具有有限的读取元素属性的接口。被快速筛选器拒绝的元素将不会在内存中展开。</li>
<li><em><strong>ElementSlowFilter</strong></em>-慢过滤器要求首先获取元素并在内存中展开。因此，最好将慢速过滤器与至少一个ElementQuickFilter耦合，这应该最小化扩展的元素数量，以便根据该过滤器设置的标准进行评估。</li>
<li><em><strong>ElementLogicalFilter</strong></em>-逻辑筛选器将联合收割机两个或多个筛选器逻辑组合。Revit可能会对构件过滤器重新排序，以使最快作用的过滤器首先被评估。</li>
</ul>
<p>大多数过滤器可以使用重载构造函数来反转，该重载构造函数接受指示反转过滤器的布尔参数，以便通常被过滤器接受的元素将被拒绝，而通常被拒绝的元素将被接受。不能反转的过滤器在下面的相应部分中注明。</p>
<p>有一组预定义的过滤器可用于常见用途。这些内置过滤器中的许多都为上面的FilteredElementCollector部分中提到的FilteredElementCollector快捷方法提供了基础。接下来的三个部分提供了有关内置过滤器的更多信息。</p>
<p>创建筛选器后，需要将其应用于FilteredElementCollector。泛型方法WherePasses()用于将单个ElementFilter应用于FilteredElementCollector。</p>
<p>还可以使用FilteredElementCollector提供的许多快捷方法应用筛选器。有些应用一个特定的过滤器而不需要进一步的输入，比如WhereElementIsCurveDriven()，而其他应用一个特定的过滤器而只需要一个简单的输入，比如OfCategory()方法，它将BuiltInCategory作为一个参数。最后，还有一些方法，如UnionWith()，可以将过滤器连接在一起。所有这些方法都返回相同的收集器，从而可以轻松地将过滤器链接在一起。</p>
<h3 id="Quick-filters-快速筛选器"><a href="#Quick-filters-快速筛选器" class="headerlink" title="Quick filters 快速筛选器"></a>Quick filters 快速筛选器</h3><p>快速过滤器只在ElementRecord上操作，ElementRecord是一个低内存类，它具有有限的读取元素属性的接口。被快速筛选器拒绝的元素将不会在内存中展开。下表总结了内置的快速过滤器，下面是一些过滤器的示例。</p>
<p><strong>Table 13: Built-in Quick Filters<br>表13：内置快速过滤器</strong></p>
<table>
<thead>
<tr>
<th><strong>Built-in Filter 内置过滤器</strong></th>
<th><strong>What it passes 它所经过的</strong></th>
<th><strong>Shortcut Method(s) 快捷方法</strong></th>
</tr>
</thead>
<tbody><tr>
<td>BoundingBoxContainsPointFilter</td>
<td>具有包含给定点的边界框的元素</td>
<td>None</td>
</tr>
<tr>
<td>BoundingBoxIntersectsFilter</td>
<td>具有与给定轮廓相交的边界框的元素</td>
<td>None</td>
</tr>
<tr>
<td>BoundingBoxIsInsideFilter</td>
<td>在给定轮廓内有边界框的元素</td>
<td>None</td>
</tr>
<tr>
<td>ElementCategoryFilter</td>
<td>id 与输入类别id匹配的元素</td>
<td>OfCategoryId()</td>
</tr>
<tr>
<td>ElementClassFilter</td>
<td>与输入运行时类（或派生类）匹配的元素</td>
<td>OfClass()</td>
</tr>
<tr>
<td>ElementDesignOptionFilter</td>
<td>特定设计选项中的图元</td>
<td>ContainedInDesignOption()</td>
</tr>
<tr>
<td>ElementIsCurveDrivenFilter</td>
<td>曲线驱动的元素</td>
<td>WhereElementIsCurveDriven()</td>
</tr>
<tr>
<td>ElementIsElementTypeFilter</td>
<td>属于“元素类型”的元素</td>
<td>WhereElementIsNotElementType()</td>
</tr>
<tr>
<td>ElementMulticategoryFilter</td>
<td>与给定类别集中的任何一个相匹配的元素</td>
<td>None</td>
</tr>
<tr>
<td>ElementMulticlassFilter</td>
<td>与给定的类（或派生类）集匹配的元素</td>
<td>None</td>
</tr>
<tr>
<td>ElementOwnerViewFilter</td>
<td>视图专有的图元</td>
<td>OwnedByView()<br />WhereElementIsViewIndependent()</td>
</tr>
<tr>
<td>ElementStructuralTypeFilter</td>
<td>与给定结构类型匹配的元素</td>
<td>None</td>
</tr>
<tr>
<td>ExclusionFilter</td>
<td>除元素id之外的所有元素都输入到过滤器</td>
<td>Excluding()</td>
</tr>
<tr>
<td>FamilySymbolFilter</td>
<td>特定族的Symbol</td>
<td></td>
</tr>
</tbody></table>
<p><strong>注意：</strong>FamilySymbolFilter不能反转。</p>
<p><strong>注意：</strong>边界框过滤器排除所有从View派生的对象和从ElementType派生的对象。 下面的示例在文档中创建一个大纲，然后使用BoundingBoxIntersectsFilter查找文档中具有与该大纲相交的边界框的元素。然后，它展示了如何使用反向过滤器来查找边界框不与给定轮廓相交的所有墙。请注意，使用OfClass()方法也会将ElementClassFilter应用于集合。</p>
<p><strong>代码区域6-2：BoundingBoxIntersectsFilter示例</strong></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Use BoundingBoxIntersects filter to find elements with a bounding box that intersects the </span></span><br><span class="line"><span class="comment">// given Outline in the document.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a Outline, uses a minimum and maximum XYZ point to initialize the outline. </span></span><br><span class="line">Outline myOutLn = <span class="keyword">new</span> Outline(<span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="keyword">new</span> XYZ(<span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a BoundingBoxIntersects filter with this Outline</span></span><br><span class="line">BoundingBoxIntersectsFilter filter = <span class="keyword">new</span> BoundingBoxIntersectsFilter(myOutLn);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Apply the filter to the elements in the active document</span></span><br><span class="line"><span class="comment">// This filter excludes all objects derived from View and objects derived from ElementType</span></span><br><span class="line">FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">IList elements = collector.WherePasses(filter).ToElements();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Find all walls which don&#x27;t intersect with BoundingBox: use an inverted filter </span></span><br><span class="line"><span class="comment">// to match elements</span></span><br><span class="line"><span class="comment">// Use shortcut command OfClass() to find walls only</span></span><br><span class="line">BoundingBoxIntersectsFilter invertFilter = <span class="keyword">new</span> BoundingBoxIntersectsFilter(myOutLn, <span class="literal">true</span>);</span><br><span class="line">collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">IList notIntersectWalls = collector.OfClass(<span class="keyword">typeof</span>(Wall)).WherePasses(invertFilter).ToElements();</span><br></pre></td></tr></table></figure>

<p>下一个示例使用排除过滤器查找文档中当前未选定的所有墙。</p>
<p>代码区域6-3：创建排除过滤器</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Find all walls that are not currently selected, </span></span><br><span class="line"><span class="comment">// Get all element ids which are current selected by users, exclude these ids when filtering</span></span><br><span class="line">ICollection selectedIds = uiDocument.Selection.GetElementIds();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Use the selection to instantiate an exclusion filter</span></span><br><span class="line">ExclusionFilter filter = <span class="keyword">new</span> ExclusionFilter(selectedIds);</span><br><span class="line"><span class="comment">// For the sake of simplicity we do not test here whether the selection is empty or not,</span></span><br><span class="line"><span class="comment">// but in production code a proper validation would have to be done to avoid an argument</span></span><br><span class="line"><span class="comment">// exception from the filter&#x27;s consructor.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Apply the filter to the elements in the active document,</span></span><br><span class="line"><span class="comment">// Use shortcut method OfClass() to find Walls only</span></span><br><span class="line">FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(uiDocument.Document);</span><br><span class="line">IList walls = collector.WherePasses(filter).OfClass(<span class="keyword">typeof</span>(Wall)).ToElements();</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>ElementClassFilter将匹配其类与输入类完全匹配的元素，或其类派生自输入类的元素。下面的示例使用ElementClassFilter获取文档中的所有加载。</p>
<p>代码区域6-4：使用ElementClassFilter获取负载</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Use ElementClassFilter to find all loads in the document</span></span><br><span class="line"><span class="comment">// Using typeof(LoadBase) will yield all AreaLoad, LineLoad and PointLoad</span></span><br><span class="line">ElementClassFilter filter = <span class="keyword">new</span> ElementClassFilter(<span class="keyword">typeof</span>(LoadBase));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Apply the filter to the elements in the active document</span></span><br><span class="line">FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">ICollection allLoads = collector.WherePasses(filter).ToElements();</span><br></pre></td></tr></table></figure>

<p>API中有一小部分元素子类不受元素类过滤器支持。这些类型存在于API中，但不存在于Revit的本机对象模型中，这意味着此过滤器不支持这些类型。为了使用类过滤器来查找这些类型的元素，需要使用更高级别的类，然后进一步处理结果以查找仅匹配子类型的元素。</p>
<p><strong>注：</strong>其中一些类型存在专用过滤器。 以下类型受此限制影响：</p>
<table>
<thead>
<tr>
<th><strong>Type 类型</strong></th>
<th><strong>Dedicated Filter 专用过滤器</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Autodesk.Revit.DB.Material的子类</td>
<td>None</td>
</tr>
<tr>
<td>Autodesk.Revit.DB.CurveElement的子类</td>
<td>CurveElementFilter</td>
</tr>
<tr>
<td>Autodesk.Revit.DB.ConnectorElement的子类</td>
<td>None</td>
</tr>
<tr>
<td>Autodesk.Revit.DB.HostedSweep的子类</td>
<td>None</td>
</tr>
<tr>
<td>Autodesk.Revit.DB.Architecture.Room</td>
<td>RoomFilter</td>
</tr>
<tr>
<td>Autodesk.Revit.DB.Mechanical.Space</td>
<td>SpaceFilter</td>
</tr>
<tr>
<td>Autodesk.Revit.DB.Area</td>
<td>AreaFilter</td>
</tr>
<tr>
<td>Autodesk.Revit.DB.Architecture.RoomTag</td>
<td>RoomTagFilter</td>
</tr>
<tr>
<td>Autodesk.Revit.DB.Mechanical.SpaceTag</td>
<td>SpaceTagFilter</td>
</tr>
<tr>
<td>Autodesk.Revit.DB.AreaTag</td>
<td>AreaTagFilter</td>
</tr>
<tr>
<td>Autodesk.Revit.DB.CombinableElement</td>
<td>None</td>
</tr>
<tr>
<td>Autodesk.Revit.DB.Mullion</td>
<td>None</td>
</tr>
<tr>
<td>Autodesk.Revit.DB.Panel</td>
<td>None</td>
</tr>
<tr>
<td>Autodesk.Revit.DB.AnnotationSymbol</td>
<td>None</td>
</tr>
<tr>
<td>Autodesk.Revit.DB.Structure.AreaReinforcementType</td>
<td>None</td>
</tr>
<tr>
<td>Autodesk.Revit.DB.Structure.PathReinforcementType</td>
<td>None</td>
</tr>
<tr>
<td>Autodesk.Revit.DB.AnnotationSymbolType</td>
<td>None</td>
</tr>
<tr>
<td>Autodesk.Revit.DB.Architecture.RoomTagType</td>
<td>None</td>
</tr>
<tr>
<td>Autodesk.Revit.DB.Mechanical.SpaceTagType</td>
<td>None</td>
</tr>
<tr>
<td>Autodesk.Revit.DB.AreaTagType</td>
<td>None</td>
</tr>
<tr>
<td>Autodesk.Revit.DB.Structure.TrussType</td>
<td>None</td>
</tr>
</tbody></table>
<h3 id="Slow-Filters-慢过滤器"><a href="#Slow-Filters-慢过滤器" class="headerlink" title="Slow Filters 慢过滤器"></a>Slow Filters 慢过滤器</h3><p>慢过滤器要求首先获得元素并在内存中展开。因此，最好将慢速过滤器与至少一个ElementQuickFilter耦合，这应该最小化扩展的元素数量，以便根据该过滤器设置的标准进行评估。下表总结了内置的慢速过滤器，下面的几个示例提供了对某些过滤器的深入了解。</p>
<p><strong>表14：内置慢速过滤器</strong></p>
<table>
<thead>
<tr>
<th><strong>Built-in Filter 内置过滤器</strong></th>
<th><strong>What it passes 它所经过的</strong></th>
<th><strong>Shortcut Method(s) 快捷方法</strong></th>
</tr>
</thead>
<tbody><tr>
<td>AreaFilter</td>
<td>Areas 区域</td>
<td>None</td>
</tr>
<tr>
<td>AreaTagFilter</td>
<td>Area tags 面积标记</td>
<td>None</td>
</tr>
<tr>
<td>CurveElementFilter</td>
<td>CurveElements 曲线元素</td>
<td>None</td>
</tr>
<tr>
<td>ElementLevelFilter</td>
<td>与给定级别ID关联的元素</td>
<td>None</td>
</tr>
<tr>
<td>ElementParameterFilter</td>
<td>元素传递一个或多个参数筛选规则</td>
<td>None</td>
</tr>
<tr>
<td>ElementPhaseStatusFilter</td>
<td>给定阶段上具有给定阶段状态的元素</td>
<td>None</td>
</tr>
<tr>
<td>FamilyInstanceFilter</td>
<td>一个特定的族实例</td>
<td>None</td>
</tr>
<tr>
<td>FamilyStructuralMaterialTypeFilter</td>
<td>给定结构材料类型的族元素</td>
<td>None</td>
</tr>
<tr>
<td>PrimaryDesignOptionMemberFilter</td>
<td>任何主设计选项所拥有的图元</td>
<td>None</td>
</tr>
<tr>
<td>RoomFilter</td>
<td>房间</td>
<td>None</td>
</tr>
<tr>
<td>RoomTagFilter</td>
<td>房间标记</td>
<td>None</td>
</tr>
<tr>
<td>SpaceFilter</td>
<td>空间</td>
<td>None</td>
</tr>
<tr>
<td>SpaceTagFilter</td>
<td>空间标签</td>
<td>None</td>
</tr>
<tr>
<td>StructuralInstanceUsageFilter</td>
<td>给定结构用途的族</td>
<td>None</td>
</tr>
<tr>
<td>StructuralMaterialTypeFilter</td>
<td>给定结构材料类型的族</td>
<td>None</td>
</tr>
<tr>
<td>StructuralWallUsageFilter</td>
<td>指定结构墙用途的墙</td>
<td>None</td>
</tr>
<tr>
<td>Element Intersection Filters</td>
<td>与给定图元的实体几何相交的图元</td>
<td>None</td>
</tr>
<tr>
<td>Element Intersection Filters</td>
<td>与给定实体几何相交的元素</td>
<td>None</td>
</tr>
</tbody></table>
<p>以下慢速过滤器不能反转： <em>RoomFilter</em> RoomTagFilter <em>AreaFilter</em> AreaTagFilter <em>SpaceFilter</em> * </p>
<p>FamilyInstanceFilter 如快速过滤器一节所述，有些类不能与ElementClassFilter一起使用。其中一些类，如Room和RoomTag有自己的专用过滤器。</p>
<p> 代码区域6-5：使用房间过滤器</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Use a RoomFilter to find all room elements in the document. It is necessary to use the </span></span><br><span class="line"><span class="comment">// RoomFilter and not an ElementClassFilter or the shortcut method OfClass() because the Room </span></span><br><span class="line"><span class="comment">// class is not supported by those methods.</span></span><br><span class="line">RoomFilter filter = <span class="keyword">new</span> RoomFilter();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Apply the filter to the elements in the active document</span></span><br><span class="line">FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">IList rooms = collector.WherePasses(filter).ToElements();</span><br></pre></td></tr></table></figure>

<p>ElementParameterFilter是一个功能强大的过滤器，可以根据元素可能具有的参数值查找元素。它可以查找参数值与特定值匹配或大于或小于某个值的元素。ElementParameterFilter还可用于查找支持特定共享参数的元素。 下面的示例使用ElementParameterFilter查找大小超过100平方英尺的房间和小于100平方英尺的房间。</p>
<p>代码区域6-6：使用参数过滤器</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Creates an ElementParameter filter to find rooms whose area is </span></span><br><span class="line"><span class="comment">// greater than specified value</span></span><br><span class="line"><span class="comment">// Create filter by provider and evaluator </span></span><br><span class="line">BuiltInParameter areaParam = BuiltInParameter.ROOM_AREA;</span><br><span class="line"><span class="comment">// provider</span></span><br><span class="line">ParameterValueProvider pvp = <span class="keyword">new</span> ParameterValueProvider(<span class="keyword">new</span> ElementId((<span class="built_in">int</span>)areaParam));</span><br><span class="line"><span class="comment">// evaluator</span></span><br><span class="line">FilterNumericRuleEvaluator fnrv = <span class="keyword">new</span> FilterNumericGreater();</span><br><span class="line"><span class="comment">// rule value </span></span><br><span class="line"><span class="built_in">double</span> ruleValue = <span class="number">100.0f</span>;      <span class="comment">// filter room whose area is greater than 100 SF</span></span><br><span class="line"><span class="comment">// rule</span></span><br><span class="line">FilterRule fRule = <span class="keyword">new</span> FilterDoubleRule(pvp, fnrv, ruleValue, <span class="number">1E-6</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create an ElementParameter filter</span></span><br><span class="line">ElementParameterFilter filter = <span class="keyword">new</span> ElementParameterFilter(fRule);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Apply the filter to the elements in the active document</span></span><br><span class="line">FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">IList rooms = collector.WherePasses(filter).ToElements();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Find rooms whose area is less than or equal to 100: </span></span><br><span class="line"><span class="comment">// Use inverted filter to match elements</span></span><br><span class="line">ElementParameterFilter lessOrEqualFilter = <span class="keyword">new</span> ElementParameterFilter(fRule, <span class="literal">true</span>); </span><br><span class="line">collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">IList lessOrEqualFounds = collector.WherePasses(lessOrEqualFilter).ToElements();</span><br></pre></td></tr></table></figure>

<p>下面的示例显示如何使用FamilyStructuralMaterialTypeFilter查找材质类型为木材的所有族。它还说明了如何使用反向过滤器来查找材质类型不是木材的所有族。</p>
<p>代码区域6-7：查找所有使用木质材料的家庭</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Use FamilyStructuralMaterialType filter to find families whose material type is Wood</span></span><br><span class="line">FamilyStructuralMaterialTypeFilter filter = <span class="keyword">new</span> FamilyStructuralMaterialTypeFilter(StructuralMaterialType.Wood);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Apply the filter to the elements in the active document</span></span><br><span class="line">FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">ICollection woodFamiles = collector.WherePasses(filter).ToElements();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Find families are not Wood: Use inverted filter to match families</span></span><br><span class="line">FamilyStructuralMaterialTypeFilter notWoodFilter = </span><br><span class="line">        <span class="keyword">new</span> FamilyStructuralMaterialTypeFilter(StructuralMaterialType.Wood, <span class="literal">true</span>);</span><br><span class="line">collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">ICollection notWoodFamilies = collector.WherePasses(notWoodFilter).ToElements();</span><br></pre></td></tr></table></figure>

<p>最后两个慢过滤器派生自ElementIntersectsFilter，后者是用于匹配与几何体相交的元素的过滤器的基类。有关此类过滤器的使用示例，请参见几何工具类一节中的代码区域：查找附近的墙。#逻辑过滤器逻辑过滤器联合收割机将两个或多个过滤器逻辑组合。下表总结了内置的逻辑筛选器。表15：内置逻辑过滤器</p>
<table>
<thead>
<tr>
<th><strong>Built-in Filter 内置过滤器</strong></th>
<th><strong>What it passes 它所经过的</strong></th>
<th><strong>Shortcut Method(s) 快捷方法</strong></th>
</tr>
</thead>
<tbody><tr>
<td>LogicalAndFilter</td>
<td>通过2个或更多过滤器的元素</td>
<td>WherePasses()-添加一个额外的过滤器IntersectWith()-连接两组独立的过滤器</td>
</tr>
<tr>
<td>LogicalOrFilter</td>
<td>至少通过2个或多个过滤器之一的元素</td>
<td>UnionWith()-连接两组独立的过滤器</td>
</tr>
</tbody></table>
<p>在下面的示例中，使用逻辑过滤器组合了两个快速过滤器，以获取文档中的所有door FamilyInstance元素。</p>
<p>代码区域6-8：使用LogicalAndFilter查找所有门实例</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Find all door instances in the project by finding all elements that both belong to the</span></span><br><span class="line"><span class="comment">// door category and are family instances.</span></span><br><span class="line">ElementClassFilter familyInstanceFilter = <span class="keyword">new</span> ElementClassFilter(<span class="keyword">typeof</span>(FamilyInstance));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a category filter for Doors</span></span><br><span class="line">ElementCategoryFilter doorsCategoryfilter = </span><br><span class="line">        <span class="keyword">new</span> ElementCategoryFilter(BuiltInCategory.OST_Doors);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a logic And filter for all Door FamilyInstances</span></span><br><span class="line">LogicalAndFilter doorInstancesFilter = <span class="keyword">new</span> LogicalAndFilter(familyInstanceFilter, </span><br><span class="line">        doorsCategoryfilter);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Apply the filter to the elements in the active document</span></span><br><span class="line">FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">IList doors = collector.WherePasses(doorInstancesFilter).ToElements();</span><br></pre></td></tr></table></figure>



<h2 id="获取筛选的元素或元素ID"><a href="#获取筛选的元素或元素ID" class="headerlink" title="获取筛选的元素或元素ID"></a>获取筛选的元素或元素ID</h2><p>将一个或多个过滤器应用于FilteredElementCollector后，可以通过以下三种方式之一来检索已过滤的元素集：</p>
<ol>
<li>获取Elements或ElementId的集合。<ul>
<li>ToElements()-返回通过所有应用的过滤器的所有元素</li>
<li>ToElementIds()-返回通过所有应用过滤器的所有元素的ElementIds</li>
</ul>
</li>
<li>获取与筛选器匹配的第一个Element或ElementId。<ul>
<li>FirstElement()-返回第一个元素以通过所有应用的过滤器</li>
<li>FirstElementId()-返回第一个元素的id，以通过所有应用的过滤器</li>
</ul>
</li>
<li>获取ElementId或Element迭代器。<ul>
<li>GetElementIdIterator()-将FilteredElementIdIterator返回到通过过滤器的元素id</li>
<li>GetElementIterator()-将FilteredElementIterator返回给通过过滤器的元素</li>
<li>GetEnumerator()-返回一个IEnumerator，它遍历传递元素的集合</li>
</ul>
</li>
</ol>
<p>一次只能使用这些组中的一个方法;如果调用另一个方法来提取元素，收集器将重置。因此，如果您之前已经获得了一个迭代器，那么当您调用另一个方法来提取元素时，它将停止并且不再遍历任何元素。</p>
<p>哪种方法最好取决于应用。如果只需要一个匹配元素，那么FirstElement()或FirstElementId()是最佳选择。如果需要所有匹配的元素，请使用ToElements()。如果需要一个变量，使用迭代器。</p>
<p>如果应用程序将删除元素或对过滤列表中的元素进行重大更改，ToElementIds()或元素id迭代器是最佳选择。这是因为删除元素或对元素进行重大更改会使元素句柄无效。对于元素id，对具有ElementId的Document.GetElement()的调用将始终返回有效的Element（如果元素已被删除，则返回空引用）。</p>
<p>使用ToElements()方法将筛选结果作为元素集合获取，允许使用foreach检查集合中的每个元素，如下所示：</p>
<p>代码区域6-9：使用ToElements()获取筛选结果</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Use ElementClassFilter to find all loads in the document</span></span><br><span class="line"><span class="comment">// Using typeof(LoadBase) will yield all AreaLoad, LineLoad and PointLoad</span></span><br><span class="line">ElementClassFilter filter = <span class="keyword">new</span> ElementClassFilter(<span class="keyword">typeof</span>(LoadBase));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Apply the filter to the elements in the active document</span></span><br><span class="line">FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">collector.WherePasses(filter);</span><br><span class="line">ICollection allLoads = collector.ToElements();</span><br><span class="line"></span><br><span class="line">String prompt = <span class="string">&quot;The loads in the current document are:\n&quot;</span>;</span><br><span class="line"><span class="keyword">foreach</span> (Element loadElem <span class="keyword">in</span> allLoads)</span><br><span class="line">&#123;</span><br><span class="line">        LoadBase load = loadElem <span class="keyword">as</span> LoadBase;</span><br><span class="line">        prompt += load.GetType().Name +  <span class="string">&quot;: &quot;</span> + </span><br><span class="line">                        load.Name + <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>, prompt);</span><br></pre></td></tr></table></figure>

<p>当只需要一个传递元素时，使用FirstElement()：</p>
<p>代码区域6-10：获取第一个通过的元素</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create a filter to find all columns</span></span><br><span class="line">StructuralInstanceUsageFilter columnFilter = </span><br><span class="line">        <span class="keyword">new</span> StructuralInstanceUsageFilter(StructuralInstanceUsage.Column);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Apply the filter to the elements in the active document</span></span><br><span class="line">FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">collector.WherePasses(columnFilter);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get the first column from the filtered results</span></span><br><span class="line"><span class="comment">// Element will be a FamilyInstance</span></span><br><span class="line">FamilyInstance column = collector.FirstElement() <span class="keyword">as</span> FamilyInstance;</span><br></pre></td></tr></table></figure>

<p>在某些情况下，FirstElement()是不够的。下一个示例显示如何使用扩展方法获取第一个非模板3D视图（这对于ReferenceIntersector构造函数的输入很有用）。</p>
<p>代码区域6-11：使用扩展方法获取第一个传递元素</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Use filter to find a non-template 3D view</span></span><br><span class="line"><span class="comment">// This example does not use FirstElement() since first filterd view3D might be a template</span></span><br><span class="line">FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">Func&lt;View3D, <span class="built_in">bool</span>&gt; isNotTemplate = v3 =&gt; !(v3.IsTemplate);</span><br><span class="line"></span><br><span class="line"><span class="comment">// apply ElementClassFilter</span></span><br><span class="line">collector.OfClass(<span class="keyword">typeof</span>(View3D));</span><br><span class="line"></span><br><span class="line"><span class="comment">// use extension methods to get first non-template View3D</span></span><br><span class="line">View3D view3D = collector.Cast().First(isNotTemplate);</span><br></pre></td></tr></table></figure>

<p>The following example demonstrates the use of the FirstElementId() method to get one passing element (a 3d view in this case) and the use of ToElementIds() to get the filter results as a collection of element ids (in order to delete a set of elements in this case).<br>下面的示例演示了使用FirstElementId()方法获取一个传递元素（本例中为3D视图），以及使用ToElementIds()获取作为元素ID集合的过滤结果（本例中为删除一组元素）。</p>
<p>代码区域6-12：使用得到过滤器结果作为元素id</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Use shortcut OfClass to get View elements</span></span><br><span class="line">collector.OfClass(<span class="keyword">typeof</span>(View3D));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get the Id of the first view</span></span><br><span class="line">ElementId viewId = collector.FirstElementId();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Test if the view is valid for element filtering</span></span><br><span class="line"><span class="keyword">if</span> (FilteredElementCollector.IsViewValidForElementIteration(document, viewId))</span><br><span class="line">&#123;</span><br><span class="line">        FilteredElementCollector viewCollector = <span class="keyword">new</span> FilteredElementCollector(document, viewId);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Get all FamilyInstance items in the view</span></span><br><span class="line">        viewCollector.OfClass(<span class="keyword">typeof</span>(FamilyInstance));</span><br><span class="line">        ICollection familyInstanceIds = viewCollector.ToElementIds();</span><br><span class="line"></span><br><span class="line">        document.Delete(familyInstanceIds);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在下面的示例中使用了GetElementIterator()方法，该方法循环访问已筛选的元素以检查某些管道的流状态。</p>
<p>代码区域6-13：以元素迭代器的形式获取结果</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Apply a filter to get all pipes in the document</span></span><br><span class="line">collector.OfClass(<span class="keyword">typeof</span>(Autodesk.Revit.DB.Plumbing.Pipe));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get results as an element iterator and look for a pipe with</span></span><br><span class="line"><span class="comment">// a specific flow state</span></span><br><span class="line">FilteredElementIterator elemItr = collector.GetElementIterator();</span><br><span class="line">elemItr.Reset();</span><br><span class="line"><span class="keyword">while</span> (elemItr.MoveNext())</span><br><span class="line">&#123;</span><br><span class="line">        Pipe pipe = elemItr.Current <span class="keyword">as</span> Pipe;</span><br><span class="line">        <span class="keyword">if</span> (pipe.FlowState == PipeFlowState.LaminarState)</span><br><span class="line">        &#123;</span><br><span class="line">                TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>, <span class="string">&quot;Model has at least one pipe with Laminar flow state.&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者，过滤结果可以作为元素id迭代器返回：</p>
<p>代码区域6-14：以元素id迭代器的形式获取结果</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Use a RoomFilter to find all room elements in the document. </span></span><br><span class="line">RoomFilter filter = <span class="keyword">new</span> RoomFilter();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Apply the filter to the elements in the active document</span></span><br><span class="line">FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">collector.WherePasses(filter);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get results as ElementId iterator</span></span><br><span class="line">FilteredElementIdIterator roomIdItr = collector.GetElementIdIterator();</span><br><span class="line">roomIdItr.Reset();</span><br><span class="line"><span class="keyword">while</span> (roomIdItr.MoveNext())</span><br><span class="line">&#123;</span><br><span class="line">        ElementId roomId = roomIdItr.Current;</span><br><span class="line">        <span class="comment">// Warn rooms smaller than 50 SF</span></span><br><span class="line">        Room room = document.GetElement(roomId) <span class="keyword">as</span> Room;</span><br><span class="line">        <span class="keyword">if</span> (room.Area &lt; <span class="number">50.0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                String prompt = <span class="string">&quot;Room is too small: id = &quot;</span> + roomId.ToString();</span><br><span class="line">                TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>, prompt);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在某些情况下，针对给定的过滤器测试单个元素，而不是获取通过过滤器的所有元素，可能会很有用。ElementFilter.PassesFilter()有两个重载，它们根据筛选器测试给定的Element或ElementId，如果元素通过筛选器，则返回true。</p>
<h2 id="LINQ查询"><a href="#LINQ查询" class="headerlink" title="LINQ查询"></a>LINQ查询</h2><p>在.NET中，FilteredElementCollector类支持Elements的IEEETM接口。您可以将此类与LINQ查询和操作一起使用来处理元素列表。请注意，由于此类提供的ElementFilters和快捷方法在生成托管包装之前处理本机代码中的元素，因此在尝试使用LINQ查询处理结果之前，在收集器上使用尽可能多的本机筛选器将获得更好的性能。</p>
<p>The following example uses an ElementClassFilter to get all FamilyInstance elements in the document, and then uses a LINQ query to narrow down the results to those FamilyInstances with a specific name.<br>下面的示例使用ElementClassFilter获取文档中的所有FamilyInstance元素，然后使用LINQ查询将结果范围缩小到具有特定名称的FamilyInstance。</p>
<p>代码区域6-15：使用LINQ查询</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Use ElementClassFilter to find family instances whose name is 60&quot; x 30&quot; Student </span></span><br><span class="line">ElementClassFilter filter = <span class="keyword">new</span> ElementClassFilter(<span class="keyword">typeof</span>(FamilyInstance));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Apply the filter to the elements in the active document</span></span><br><span class="line">FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">collector.WherePasses(filter);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Use Linq query to find family instances whose name is 60&quot; x 30&quot; Student</span></span><br><span class="line"><span class="keyword">var</span> query = <span class="keyword">from</span> element <span class="keyword">in</span> collector</span><br><span class="line">                        <span class="keyword">where</span> element.Name == <span class="string">&quot;60\&quot; x 30\&quot; Student&quot;</span></span><br><span class="line">                        <span class="keyword">select</span> element;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Cast found elements to family instances, </span></span><br><span class="line"><span class="comment">// this cast to FamilyInstance is safe because ElementClassFilter for FamilyInstance was used</span></span><br><span class="line">List familyInstances = query.Cast().ToList();</span><br></pre></td></tr></table></figure>

<h2 id="边界框过滤器"><a href="#边界框过滤器" class="headerlink" title="边界框过滤器"></a>边界框过滤器</h2><p> BoundingBox过滤器：</p>
<ul>
<li>BoundingBoxIsInsideFilter</li>
<li>BoundingBoxIntersectsFilter</li>
<li>BoundingBoxContainsPointFilter</li>
</ul>
<p>帮助您查找其边界框满足特定条件的元素。您可以检查每个元素的边界框是否在给定体积内，是否与给定体积相交，或者是否包含给定点。也可以反向执行此检查，以查找不与体积相交或不包含给定点的元素。</p>
<p>BoundingBox过滤器使用Outline作为其输入。Outline是一个表示直角棱柱的类，其轴与Revit世界坐标系对齐。</p>
<p>这些过滤器最适合于实际几何形状与其边界框的几何形状紧密匹配的形状。示例可能包括曲线与X或Y方向对齐的线性墙、由此类墙形成的矩形房间、与此类墙对齐的楼板或屋顶，或者合理的矩形族。否则，可能会出现误报，因为元素的边界框可能比实际几何形状大得多。(在这些情况下，您可以使用实际图元的几何图形来确定图元是否真正满足条件）。</p>
<h2 id="元素交叉过滤器"><a href="#元素交叉过滤器" class="headerlink" title="元素交叉过滤器"></a>元素交叉过滤器</h2><p> 元素过滤器：</p>
<ul>
<li>ElementIntersectsElementFilter</li>
<li>ElementIntersectsSolidFilter</li>
</ul>
<p>其实际三维几何体与目标对象的三维几何体相交的过程元素。</p>
<p>使用ElementIntersectsElementFilter，目标对象是另一个元素。交点的确定与Revit在生成冲突报告期间确定是否存在冲突时使用的逻辑相同。(意味着某些图元组合永远不会通过此过滤器，例如在相交处自动连接的混凝土构件，或也从干涉检查中排除的场地图元）。此外，没有实心几何图形的图元（如钢筋）也不会通过此过滤器。</p>
<p>使用ElementIntersectsSolidFilter，目标对象是任何实体。该实体可以从现有图元中获得，使用GeometryCreationUtilities中的例程从头开始创建，或者是布尔运算等二次运算的结果。与ElementIntersectsElementFilter类似，此过滤器不会传递缺少实心几何图形的元素。</p>
<p>两个过滤器都可以反转以匹配目标对象体积之外的元素。</p>
<p>这两个过滤器都是慢速过滤器，因此最好与一个或多个快速过滤器（如类或类别过滤器）组合使用。</p>
<p> 代码区域：使用ElementIntersectsSolidFilter匹配阻止禁用出口到门的元素</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> </span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> Finds any Revit physical elements which interfere with the target </span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> solid region surrounding a door.</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> This routine is useful for detecting interferences which are </span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> violations of the Americans with Disabilities Act or other local disabled </span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> access codes.</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> The door instance.</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> The accessibility region calculated</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> to surround the approach of the door.</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> Because the geometric parameters of this region are code- and </span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> door-specific, calculation of the geometry of the region is not </span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> demonstrated in this example.</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> A collection of interfering element ids.</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> ICollection <span class="title">FindElementsInterferingWithDoor</span>(<span class="params">FamilyInstance doorInstance, Solid doorAccessibilityRegion</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// Setup the filtered element collector for all document elements.</span></span><br><span class="line">   FilteredElementCollector interferingCollector = </span><br><span class="line">      <span class="keyword">new</span> FilteredElementCollector(doorInstance.Document);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Only accept element instances</span></span><br><span class="line">   interferingCollector.WhereElementIsNotElementType();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Exclude intersections with the door itself or the host wall for the door.</span></span><br><span class="line">   List excludedElements = <span class="keyword">new</span> List();</span><br><span class="line">   excludedElements.Add(doorInstance.Id);</span><br><span class="line">   excludedElements.Add(doorInstance.Host.Id);</span><br><span class="line">   ExclusionFilter exclusionFilter = <span class="keyword">new</span> ExclusionFilter(excludedElements);</span><br><span class="line">   interferingCollector.WherePasses(exclusionFilter);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Set up a filter which matches elements whose solid geometry intersects </span></span><br><span class="line">   <span class="comment">// with the accessibility region</span></span><br><span class="line">   ElementIntersectsSolidFilter intersectionFilter = </span><br><span class="line">      <span class="keyword">new</span> ElementIntersectsSolidFilter(doorAccessibilityRegion);</span><br><span class="line">   interferingCollector.WherePasses(intersectionFilter);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Return all elements passing the collector</span></span><br><span class="line">   <span class="keyword">return</span> interferingCollector.ToElementIds();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="注：翻译自Revit-API-Developers-Guide"><a href="#注：翻译自Revit-API-Developers-Guide" class="headerlink" title="注：翻译自Revit API Developers Guide"></a><em><strong>注：</strong></em>翻译自<a target="_blank" rel="noopener" href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_html">Revit API Developers Guide</a></h2></article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Revit/">Revit</a></div><div class="post-share"><div class="social-share" data-image="/images/4stars.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2024/11/29/Revit%E4%BA%8C%E5%BC%80%E6%8C%87%E5%8D%97/14%E6%97%8F%E6%96%87%E6%A1%A3/" title="14族文档"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">14族文档</div></div><div class="info-2"><div class="info-item-1">族文档本节讨论族以及如何：  创建和修改族文档 访问族类型和参数  本节中的页面  关于族文档 在族中创建图元 族元素的可见性 管理族类型和参数  关于族文档族族对象表示整个Revit族。族文档是表示族的文档(rfa)而不是Revit项目。 使用Revit API的族创建功能，可以创建和编辑族及其类型。当您有来自外部系统的现有数据并希望将其转换为Revit族库时，此功能特别有用。 对系统族编辑的API访问不可用。 类别如前一节所述，Family.FamilyCategory属性指示族的类别，如柱、家具、结构框架或窗。 以下代码可用于确定打开的Revit族文档中族的类别。 1string categoryName = familyDoc.OwnerFamily.FamilyCategory.Name;  还可以设置FamilyCategory，以允许更改正在编辑的族的类别。  参数设置 可以从族文档的OwnerFamily属性访问族参数，如下例所示。 代码区域13-2：打开的Revit族文档的类别 1234567// get the owner family of the...</div></div></div></a><a class="pagination-related" href="/2024/11/26/Revit%E4%BA%8C%E5%BC%80%E6%8C%87%E5%8D%97/04%E5%85%83%E7%B4%A0%E8%A6%81%E7%82%B9/" title="04元素要点"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">04元素要点</div></div><div class="info-2"><div class="info-item-1">元素要点元素对应于单个建筑或绘图构件，例如门、墙或尺寸标注。此外，元素可以是门类型、视图或材质定义。 元素分类Revit 图元分为六组：模型、草图、视图、组、注释和信息。每个组都包含相关的元素及其相应的符号。 模型元素模型元素表示建筑项目中存在的物理项。“模型元素”组中的元素可以细分为以下元素： 族实例 - 族实例包含族实例对象。可以将族对象载入到项目中，也可以从族样板创建族对象。有关更多信息，请参阅系列实例。 主体图元 - 主体图元包含系统族对象，这些对象可以包含其他模型图元，例如墙、屋顶、天花板和楼板。有关主体图元的更多信息，请参见墙、楼板、屋顶和洞口。 结构元素-结构图元包含仅用于 Revit 结构特征的图元。有关 Structure Elements 的更多信息，请参见 Structural Engineering。 视图元素视图图元表示在 Revit 中查看其他对象并与其他对象交互的方式。有关更多信息，请参阅视图。 组元素组图元表示辅助图元，例如 Revit...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/01/16/Revit%E4%BA%8C%E5%BC%80%E7%A4%BA%E4%BE%8B/Revit%E4%B8%8EExcel%E4%BA%A4%E4%BA%92/" title="Revit与Excel交互"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-01-16</div><div class="info-item-2">Revit与Excel交互</div></div><div class="info-2"><div class="info-item-1">  Excel检测更改自动保存，Revit自动读取数据生成元素 </div></div></div></a><a class="pagination-related" href="/2024/12/10/RevitApi%E5%90%88%E9%9B%86/Autodesk.Revit.DB%20Opening/" title="Autodesk.Revit.DB Opening"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-10</div><div class="info-item-2">Autodesk.Revit.DB Opening</div></div><div class="info-2"><div class="info-item-1">Autodesk.Revit.DB OpeningAutodesk Revit项目或族文档中的洞口。 语法1public class Opening : Element  附注该对象表示各种不同类型的洞口：  墙中由修订项目中的两个边界点创建的矩形洞口。 由应用于屋顶、楼板、天花板、梁、支撑或柱的一组曲线创建的洞口。 一个垂直的竖井开口延伸到一个或多个水平。 在族文档中的墙或天花板上创建的简单洞口。  根据打开的类型，此类的某些属性将不可用。 这个对象派生自Element基对象，并且支持该对象的所有方法，例如检索该对象的参数的能力。此对象还支持访问结构分析模型，但此功能仅适用于Autodesk Revit Structure。 示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051### private void Getinfo_Opening(Opening opening)&#123;    string message =...</div></div></div></a><a class="pagination-related" href="/2024/10/30/RevitApi%E5%90%88%E9%9B%86/Autodesk.Revit.DB%20Document/" title="Autodesk.Revit.DB Document"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-30</div><div class="info-item-2">Autodesk.Revit.DB Document</div></div><div class="info-2"><div class="info-item-1">Autodesk.Revit.DB Document表示打开的 Autodesk Revit 项目的对象。 语法1public class Document : IDisposable    附注Document 对象表示 Autodesk Revit 项目。Revit 可以打开多个项目，并打开这些项目的多个视图。活动视图或最顶层视图将是活动项目，因此是可从 Application 对象获得的活动文档。 继承层次结构 System Object Autodesk.Revit.DB Document Autodesk.Revit.DB.Macros DocumentEntryPoint  方法AcquireCoordinates 不知道是啥，API没给描述  AutoJoinElements 强制 Revit...</div></div></div></a><a class="pagination-related" href="/2024/11/18/RevitApi%E5%90%88%E9%9B%86/Autodesk.Revit.DB%20CurveArray/" title="Autodesk.Revit.DB CurveArray"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-18</div><div class="info-item-2">Autodesk.Revit.DB CurveArray</div></div><div class="info-2"><div class="info-item-1">Autodesk.Revit.DB CurveArray可以包含曲线的数组。 语法1public class CurveArray : APIObject, IEnumerable  继承层次结构System Object ​	Autodesk.Revit.DB APIObject ​		Autodesk.Revit.DB CurveArray 另见CurveArray Members Autodesk.Revit.DB Namespace 构造函数CurveArray创建CurveArray类的新实例 方法Append将曲线添加到数组的末尾。 Clear从数组中删除每条曲线，使其为空。 ForwardIterator将一个向前移动的迭代器添加到数组中。 GetEnumerator将一个向前移动的迭代器添加到数组中。 Insert将指定的曲线插入数组。 ReverseIterator返回一个向后移动的迭代器到数组。 属性IsEmpty测试数组是否为空。 Item获取或设置数组中指定索引处的曲线。 Size返回数组中的曲线数。 注：翻译自Revit Api docs 2018</div></div></div></a><a class="pagination-related" href="/2024/12/20/RevitApi%E5%90%88%E9%9B%86/Autodesk.%20Revit.DB%20ElementTransformUtils/" title="Autodesk.Revit.DB ElementTransformUtils"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-20</div><div class="info-item-2">Autodesk.Revit.DB ElementTransformUtils</div></div><div class="info-2"><div class="info-item-1">Autodesk. Revit.DB ElementTransformUtils允许元素转换的实用程序集合（例如移动，旋转，镜像和复制）。 语法1public static class ElementTransformUtils    继承层次结构 System Object Autodesk.Revit.DB ElementTransformUtils   方法CanMirrorElement确定是否可以镜像元素。 CanMirrorElements确定是否可以镜像元素。 CopyElement复制元素并将副本放置在给定转换指示的位置。 CopyElements(Document, ICollection ElementId , XYZ)复制一组元素，并将副本放置在给定指示的位置。 CopyElements(Document, ICollection ElementId , Document, Transform, CopyPasteOptions)将一组元素从源文档复制到目标文档。 CopyElements(View, ICollection ElementId ,...</div></div></div></a><a class="pagination-related" href="/2024/12/19/RevitApi%E5%90%88%E9%9B%86/Autodesk.Revit.UI.Selection%20Namespace/" title="Autodesk.Revit.UI.Selection"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-19</div><div class="info-item-2">Autodesk.Revit.UI.Selection</div></div><div class="info-2"><div class="info-item-1">Autodesk.Revit.UI.SelectionClassesPickedBox包含两个 XYZ 点的类，表示屏幕上的选取框。  Properties  Max 最大坐标数（拾取框的右上角）。  Min 最小坐标（拾取框的左下角）。     SelectableInViewFilter一个过滤器，用于传递在给定视图中可选的元素。  Constructors  SelectableInViewFilter  (Document, ElementId) 构造 SelectableInViewFilter 的新实例。  SelectableInViewFilter (Document, ElementId, Boolean) 构造 SelectableInViewFilter 的新实例，并可选择传递所有不可选择的元素。    Methods  PassesFilter(Element) 将筛选器应用于给定元素。  PassesFilter(Document,...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="giscus-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/images/4stars.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">funtim41@gmail.com</div><div class="author-info-description">实践-认识-再实践-再认识</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">59</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/FunTim41"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/FunTim41" target="_blank" title="Github"><i class="fab fa-github" style="color: #FFFFFF;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Filtering-%E8%BF%87%E6%BB%A4"><span class="toc-number">1.</span> <span class="toc-text">Filtering 过滤</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BAFilteredElementCollector"><span class="toc-number">1.1.</span> <span class="toc-text">创建FilteredElementCollector</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="toc-number">1.2.</span> <span class="toc-text">应用过滤器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Quick-filters-%E5%BF%AB%E9%80%9F%E7%AD%9B%E9%80%89%E5%99%A8"><span class="toc-number">1.2.1.</span> <span class="toc-text">Quick filters 快速筛选器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Slow-Filters-%E6%85%A2%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="toc-number">1.2.2.</span> <span class="toc-text">Slow Filters 慢过滤器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E7%AD%9B%E9%80%89%E7%9A%84%E5%85%83%E7%B4%A0%E6%88%96%E5%85%83%E7%B4%A0ID"><span class="toc-number">1.3.</span> <span class="toc-text">获取筛选的元素或元素ID</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LINQ%E6%9F%A5%E8%AF%A2"><span class="toc-number">1.4.</span> <span class="toc-text">LINQ查询</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BE%B9%E7%95%8C%E6%A1%86%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="toc-number">1.5.</span> <span class="toc-text">边界框过滤器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%83%E7%B4%A0%E4%BA%A4%E5%8F%89%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="toc-number">1.6.</span> <span class="toc-text">元素交叉过滤器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%EF%BC%9A%E7%BF%BB%E8%AF%91%E8%87%AARevit-API-Developers-Guide"><span class="toc-number">1.7.</span> <span class="toc-text">注：翻译自Revit API Developers Guide</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/02/07/ObjectARX%EF%BC%9AManaged.NET%E5%BC%80%E5%8F%91%E4%BA%BA%E5%91%98%E6%8C%87%E5%8D%97/04%E5%B0%BA%E5%AF%B8%E6%A0%87%E6%B3%A8%E5%92%8C%E5%85%AC%E5%B7%AE%EF%BC%88.NET%EF%BC%89/" title="04 尺寸标注和公差（.NET）">04 尺寸标注和公差（.NET）</a><time datetime="2025-02-07T07:32:15.924Z" title="更新于 2025-02-07 15:32:15">2025-02-07</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/01/14/ObjectARX%EF%BC%9AManaged.NET%E5%BC%80%E5%8F%91%E4%BA%BA%E5%91%98%E6%8C%87%E5%8D%97/03%E5%88%9B%E5%BB%BA%E5%92%8C%E7%BC%96%E8%BE%91AutoCAD%E5%9B%BE%E5%85%83%EF%BC%88.NET%EF%BC%89/" title="03创建和编辑AutoCAD图元（.NET）">03创建和编辑AutoCAD图元（.NET）</a><time datetime="2025-01-19T03:40:40.285Z" title="更新于 2025-01-19 11:40:40">2025-01-19</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/01/13/ObjectARX%EF%BC%9AManaged.NET%E5%BC%80%E5%8F%91%E4%BA%BA%E5%91%98%E6%8C%87%E5%8D%97/02%E6%8E%A7%E5%88%B6AutoCAD%E7%8E%AF%E5%A2%83%EF%BC%88.NET%EF%BC%89/" title="02控制AutoCAD环境（.NET）">02控制AutoCAD环境（.NET）</a><time datetime="2025-01-17T10:16:52.559Z" title="更新于 2025-01-17 18:16:52">2025-01-17</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/01/12/ObjectARX%EF%BC%9AManaged.NET%E5%BC%80%E5%8F%91%E4%BA%BA%E5%91%98%E6%8C%87%E5%8D%97/01AutoCAD.NET%20API%EF%BC%88.NET%EF%BC%89%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" title="01AutoCAD .NET API（.NET）的基础知识">01AutoCAD .NET API（.NET）的基础知识</a><time datetime="2025-01-17T10:16:40.962Z" title="更新于 2025-01-17 18:16:40">2025-01-17</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/01/16/Revit%E4%BA%8C%E5%BC%80%E7%A4%BA%E4%BE%8B/Revit%E4%B8%8EExcel%E4%BA%A4%E4%BA%92/" title="Revit与Excel交互">Revit与Excel交互</a><time datetime="2025-01-16T08:43:45.327Z" title="更新于 2025-01-16 16:43:45">2025-01-16</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/images/topback.jpg);"><div id="footer-wrap"><div class="copyright">&copy;2024 - 2025 By funtim41@gmail.com</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">学而不思则罔，思而不学则殆。</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>(() => {
  const panguFn = () => {
    if (typeof pangu === 'object') pangu.autoSpacingPage()
    else {
      btf.getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
        .then(() => {
          pangu.autoSpacingPage()
        })
    }
  }

  const panguInit = () => {
    if (false){
      GLOBAL_CONFIG_SITE.isPost && panguFn()
    } else {
      panguFn()
    }
  }

  btf.addGlobalFn('pjaxComplete', panguInit, 'pangu')
  document.addEventListener('DOMContentLoaded', panguInit)
})()</script><div class="js-pjax"><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.isShuoshuo
  const option = null

  const getGiscusTheme = theme => theme === 'dark' ? 'dark' : 'light'

  const createScriptElement = config => {
    const ele = document.createElement('script')
    Object.entries(config).forEach(([key, value]) => {
      ele.setAttribute(key, value)
    })
    return ele
  }

  const loadGiscus = (el = document, key) => {
    const mappingConfig = isShuoshuo
      ? { 'data-mapping': 'specific', 'data-term': key }
      : { 'data-mapping': (option && option['data-mapping']) || 'pathname' }

    const giscusConfig = {
      src: 'https://giscus.app/client.js',
      'data-repo': 'FunTim41/funtim41.github.io',
      'data-repo-id': 'R_kgDONjG8ww',
      'data-category-id': 'DIC_kwDONjG8w84Cllg2',
      'data-theme': getGiscusTheme(document.documentElement.getAttribute('data-theme')),
      'data-reactions-enabled': '1',
      crossorigin: 'anonymous',
      async: true,
      ...option,
      ...mappingConfig
    }

    const scriptElement = createScriptElement(giscusConfig)

    el.querySelector('#giscus-wrap').appendChild(scriptElement)

    if (isShuoshuo) {
      window.shuoshuoComment.destroyGiscus = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }
  }

  const changeGiscusTheme = theme => {
    const iframe = document.querySelector('#giscus-wrap iframe')
    if (iframe) {
      const message = {
        giscus: {
          setConfig: {
            theme: getGiscusTheme(theme)
          }
        }
      }
      iframe.contentWindow.postMessage(message, 'https://giscus.app')
    }
  }

  btf.addGlobalFn('themeChange', changeGiscusTheme, 'giscus')

  if (isShuoshuo) {
    'Giscus' === 'Giscus'
      ? window.shuoshuoComment = { loadComment: loadGiscus }
      : window.loadOtherComment = loadGiscus
    return
  }

  if ('Giscus' === 'Giscus' || !false) {
    if (false) btf.loadComment(document.getElementById('giscus-wrap'), loadGiscus)
    else loadGiscus()
  } else {
    window.loadOtherComment = loadGiscus
  }
})()</script></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>