<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>AddInManager</title>
    <url>/2025/01/08/CAD%E4%BA%8C%E5%BC%80/AddInManager/</url>
    <content><![CDATA[<h1 id="AddInManager"><a href="#AddInManager" class="headerlink" title="AddInManager"></a>AddInManager</h1><p>每次调试cad插件，老是会有占用的问题。网上找到方法就是通过反射解决，但是只找到那个要自己手动配置的，嫌麻烦。GitHub上有个<a href="https://github.com/chuongmep/CadAddinManager">CADAddInManager</a>，用了一下，好像没什么反应，不知道是不是使用方式不对，文档也不详细。索性自己整一个。</p>
<p>参照Revit SDK 里的那个AddinManager及网上给出的方法。通过反射。把dll复制到临时文件夹，然后委托调用。现在只做了CommandMethod部分的。VS2022+CAD2024。</p>
<p><img src="/iframe/image-20250108201133703.png" alt="image-20250108201133703"></p>
<p>使用方式：</p>
<p>1、先自动加载：</p>
<p>在cad根目录Support文件夹下找到acad2024.lsp。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(command&quot;netload&quot; &quot;Dll所在文件夹\\CADAddinManagerDemo.dll&quot;)</span><br></pre></td></tr></table></figure>

<p>2、把“引用文件”文件夹下的内容复制到cad根目录中，启动CAD后用“InitAddin”进行初始化，成功后菜单栏会显示“插件管理”UI及显示上图界面。</p>
<p>3、下次运行可通过菜单栏添加“插件管理”UI或者“ShowAddInManager”进入。</p>
<p>GitHub链接：<a href="https://github.com/FunTim41/CADAddInLoder">https://github.com/FunTim41/CADAddInLoder</a></p>
]]></content>
      <categories>
        <category>CAD二开学习</category>
      </categories>
      <tags>
        <tag>CAD</tag>
      </tags>
  </entry>
  <entry>
    <title>04 尺寸标注和公差（.NET）</title>
    <url>/2025/02/07/ObjectARX%EF%BC%9AManaged.NET%E5%BC%80%E5%8F%91%E4%BA%BA%E5%91%98%E6%8C%87%E5%8D%97/04%E5%B0%BA%E5%AF%B8%E6%A0%87%E6%B3%A8%E5%92%8C%E5%85%AC%E5%B7%AE%EF%BC%88.NET%EF%BC%89/</url>
    <content><![CDATA[<h1 id="尺寸标注和公差（-NET）"><a href="#尺寸标注和公差（-NET）" class="headerlink" title="尺寸标注和公差（.NET）"></a>尺寸标注和公差（.NET）</h1><p>标注将测量值添加到图形中。公差指定尺寸可以变化的程度。使用AutoCAD .NET API，可以使用标注样式和重写来管理标注。</p>
<p>本节中的主题</p>
<ul>
<li>尺寸标注概念（.NET）</li>
<li>创建标注（.NET）</li>
<li>编辑标注（.NET）</li>
<li>使用标注样式（.NET）</li>
<li>模型空间和图纸空间中的尺寸标注（.NET）</li>
<li>创建引线和注释（.NET）</li>
<li>使用几何公差（.NET）</li>
</ul>
<h2 id="尺寸标注概念（-NET）"><a href="#尺寸标注概念（-NET）" class="headerlink" title="尺寸标注概念（.NET）"></a>尺寸标注概念（.NET）</h2><p>尺寸显示对象的几何测量值、对象之间的距离或角度，或要素的<em>X</em>和<em>Y</em>坐标。AutoCAD®提供三种基本的尺寸标注类型：线性、径向和角度。线性标注包括对齐标注、旋转标注和坐标标注。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2024/ENU/OARX-DevGuide-Managed/images/GUID-8167887C-451D-47EF-BA6A-0909E43C4850.png" alt="img"></p>
<p>可以为直线、多线、圆弧、圆和圆弧段创建标注，也可以创建独立的标注。</p>
<p>AutoCAD在当前图层上绘制尺寸标注。每个标注都有一个与之关联的标注样式，无论是默认样式还是您定义的样式。样式控制诸如颜色、文字样式、箭头和标注中元素的比例等特性。尺寸标注不支持对象厚度。样式族允许对不同类型标注的基础样式进行细微修改。替代允许对特定标注进行样式修改。</p>
<p>本节中的主题</p>
<ul>
<li>标注的组成部分（.NET）</li>
<li>定义标注的系统变量（.NET）</li>
<li>设置标注文字样式（.NET）</li>
<li>理解引线（.NET）</li>
<li>了解关联标注（.NET）</li>
</ul>
<h3 id="标注的组成部分（-NET）"><a href="#标注的组成部分（-NET）" class="headerlink" title="标注的组成部分（.NET）"></a>标注的组成部分（.NET）</h3><p>尺寸标注由许多不同的对象组成，如直线、文字、实体填充和块。虽然每种尺寸类型看起来可能略有不同，但它们确实有几个共同点。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2024/ENU/OARX-DevGuide-Managed/images/GUID-54632F71-4FA8-46CE-9283-CEABB9DDC9EA.png" alt="img"></p>
<ul>
<li><strong>尺寸线。</strong>指示尺寸方向和范围的直线。对于角度标注，尺寸线为圆弧。</li>
<li><strong>延长线。</strong>从被标注的特征延伸到尺寸线的直线。延长线也称为投影线或尺寸界线。</li>
<li><strong>箭头</strong>用于指示尺寸线端点的符号。箭头也被称为终止符号或只是终止。</li>
<li><strong>尺寸文本。</strong>一个text字符串，通常表示正在测量的距离或角度的实际测量值。文本还可以包括前缀、后缀和公差。</li>
<li><strong>引线</strong>从某个注释到参照特征的实线。</li>
</ul>
<p><img src="https://help.autodesk.com/cloudhelp/2024/ENU/OARX-DevGuide-Managed/images/GUID-D9A24CCC-E495-4BB3-B8B1-11B6BE85788C.png" alt="img"></p>
<ul>
<li><strong>中间标记。</strong>十字标记圆或弧的中心的小十字</li>
<li><strong>中线。</strong>一组虚线，标记圆或弧的中心</li>
</ul>
<h3 id="定义标注的系统变量（-NET）"><a href="#定义标注的系统变量（-NET）" class="headerlink" title="定义标注的系统变量（.NET）"></a>定义标注的系统变量（.NET）</h3><p>标注系统变量控制标注的外观。尺寸标注系统变量包括DIMAUNIT、DIMUPT、DIMTOFL、DIMFIT、DIMTIH、DIMTOH、DIMJUST和DIMJUST。您可以使用 SetSystemVariable 方法设置这些变量，该方法可以从 Application 对象访问。例如，以下代码行将DIMAUNIT系统变量（角度标注的单位格式）设置为弧度（3）：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Application.SetSystemVariable(<span class="string">&quot;DIMAUNIT&quot;</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<h3 id="设置标注文字样式（-NET）"><a href="#设置标注文字样式（-NET）" class="headerlink" title="设置标注文字样式（.NET）"></a>设置标注文字样式（.NET）</h3><p>尺寸文本是指与尺寸相关的任何类型的文本，包括测量、公差（横向和几何）、前缀、后缀以及单行或段落形式的文本注释。您可以使用AutoCAD计算的默认测量值作为文本，提供自己的文本或完全隐藏文本。可以使用标注文字添加信息，如特殊制造步骤或装配说明。标注文字使用由DIMTXSTY系统变量指定的文字样式。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2024/ENU/OARX-DevGuide-Managed/images/GUID-90C330A9-8D1A-4732-8FDF-52B3B71588BD.png" alt="img"></p>
<h3 id="理解引线（-NET）"><a href="#理解引线（-NET）" class="headerlink" title="理解引线（.NET）"></a>理解引线（.NET）</h3><p>默认引线是一条带箭头的直线，指向图形中的特征。通常，引线的功能是将注释与特征连接起来。在这种情况下，注释意味着段落文本、块或特征控制框架。此类引线不同于AutoCAD为半径标注、直径标注和线性标注自动创建的简单引线，这些标注的文字不适合尺寸界线之间。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2024/ENU/OARX-DevGuide-Managed/images/GUID-BF99AD0A-D107-4C25-8C26-09B6743150F6.png" alt="img"></p>
<p>引线对象与注释相关联，因此编辑注释时，引线也会相应更新。可以复制图形中其他位置使用的注释并将其附加到引线，也可以创建新注释。也可以创建不附加注释的引线。</p>
<h3 id="了解关联标注（-NET）"><a href="#了解关联标注（-NET）" class="headerlink" title="了解关联标注（.NET）"></a>了解关联标注（.NET）</h3><p>修改关联标注关联的几何对象时，关联标注会自动调整其位置、方向和测量值。DIMASSOC系统变量控制关联标注。将DIMASSOC设置为2以启用关联标注。</p>
<h2 id="创建标注（-NET）"><a href="#创建标注（-NET）" class="headerlink" title="创建标注（.NET）"></a>创建标注（.NET）</h2><p>可以创建线性、径向、角度和纵坐标标注。</p>
<p>创建标注时，将使用激活的标注样式。创建尺寸界线后，可以修改尺寸界线原点、标注文字位置、标注文字内容及其相对于尺寸线的角度。也可以修改标注使用的标注样式。</p>
<p>本节中的主题</p>
<ul>
<li>创建线性标注（.NET）</li>
<li>创建径向标注（.NET）</li>
<li>创建角度标注（.NET）</li>
<li>创建折弯半径标注（.NET）</li>
<li>创建弧长标注（.NET）</li>
<li>创建坐标标注（.NET）</li>
</ul>
<h3 id="创建线性标注（-NET）"><a href="#创建线性标注（-NET）" class="headerlink" title="创建线性标注（.NET）"></a>创建线性标注（.NET）</h3><p>可以对齐或旋转线性标注。对齐标注的尺寸线平行于尺寸界线原点所在的线沿着。旋转尺寸的尺寸线与尺寸界线原点成一定角度放置。</p>
<p>可以通过创建 AlignedDimension 和 RotatedDimension 对象的实例来创建线性标注。创建线性标注的实例后，可以修改文字、文字的角度或尺寸线的角度。下图显示了线性标注的类型和尺寸界线原点的放置如何影响尺寸线和文字的角度。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2024/ENU/OARX-DevGuide-Managed/images/GUID-D84FF305-958E-464D-950E-7505B1A64546.png" alt="img"></p>
<p>创建 AlignedDimension 对象的实例时，可以选择指定尺寸界线原点、尺寸线位置、标注文字和要应用的标注样式。如果没有向 AlignedDimension 对象构造函数传递任何参数，则对象将被分配一组默认属性值。</p>
<p>RotatedDimension 对象构造函数提供了与 AlignedDimension 对象构造函数相同的选项，但有一个例外。 RotatedDimension 对象构造函数接受一个附加参数，该参数指定尺寸线旋转的角度。</p>
<p><strong>标注折弯线</strong></p>
<p>线性标注上的纵行不是通过一组特性添加的，而是通过扩展数据（扩展数据）添加的。负责标注折弯线的应用程序名称为ACAD_DSTYLE_DIMJAG_POSITION。下面是需要附加到线性维度的Xdata结构的示例。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Open the Registered Application table for read</span></span><br><span class="line">RegAppTable acRegAppTbl;</span><br><span class="line">acRegAppTbl = &lt;transaction&gt;.GetObject(&lt;current_database&gt;.RegAppTableId,</span><br><span class="line">                                      OpenMode.ForRead) <span class="keyword">as</span> RegAppTable;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Check to see if the app &quot;ACAD_DSTYLE_DIMJAG_POSITION&quot; is</span></span><br><span class="line"><span class="comment">// registered and if not add it to the RegApp table</span></span><br><span class="line"><span class="keyword">if</span> (acRegAppTbl.Has(<span class="string">&quot;ACAD_DSTYLE_DIMJAG_POSITION&quot;</span>) == <span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> (RegAppTableRecord acRegAppTblRec = <span class="keyword">new</span> RegAppTableRecord())</span><br><span class="line">    &#123;</span><br><span class="line">        acRegAppTblRec.Name = <span class="string">&quot;ACAD_DSTYLE_DIMJAG_POSITION&quot;</span>;</span><br><span class="line"> </span><br><span class="line">        &lt;transaction&gt;.GetObject(&lt;current_database&gt;.RegAppTableId, OpenMode.ForWrite);</span><br><span class="line"> </span><br><span class="line">        acRegAppTbl.Add(acRegAppTblRec);</span><br><span class="line">        &lt;transaction&gt;.AddNewlyCreatedDBObject(acRegAppTblRec, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Create a result buffer to define the Xdata</span></span><br><span class="line">ResultBuffer acResBuf = <span class="keyword">new</span> ResultBuffer();</span><br><span class="line">acResBuf.Add(<span class="keyword">new</span> TypedValue((<span class="built_in">int</span>)DxfCode.ExtendedDataRegAppName,</span><br><span class="line">                                         <span class="string">&quot;ACAD_DSTYLE_DIMJAG_POSITION&quot;</span>));</span><br><span class="line">acResBuf.Add(<span class="keyword">new</span> TypedValue((<span class="built_in">int</span>)DxfCode.ExtendedDataInteger16, <span class="number">387</span>));</span><br><span class="line">acResBuf.Add(<span class="keyword">new</span> TypedValue((<span class="built_in">int</span>)DxfCode.ExtendedDataInteger16, <span class="number">3</span>));</span><br><span class="line">acResBuf.Add(<span class="keyword">new</span> TypedValue((<span class="built_in">int</span>)DxfCode.ExtendedDataInteger16, <span class="number">389</span>));</span><br><span class="line">acResBuf.Add(<span class="keyword">new</span> TypedValue((<span class="built_in">int</span>)DxfCode.ExtendedDataXCoordinate,</span><br><span class="line">                                         <span class="keyword">new</span> Point3d(<span class="number">-1.26985</span>, <span class="number">3.91514</span>, <span class="number">0</span>)));</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Attach the Xdata to the dimension</span></span><br><span class="line">&lt;dimension_object&gt;.XData = acResBuf;</span><br></pre></td></tr></table></figure>

<p><strong>创建旋转线性标注</strong></p>
<p>本示例在模型空间中创建旋转标注。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">CommandMethod(<span class="string">&quot;CreateRotatedDimension&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CreateRotatedDimension</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Get the current database</span></span><br><span class="line">    Document acDoc = Application.DocumentManager.MdiActiveDocument;</span><br><span class="line">    Database acCurDb = acDoc.Database;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start a transaction</span></span><br><span class="line">    <span class="keyword">using</span> (Transaction acTrans = acCurDb.TransactionManager.StartTransaction())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Open the Block table for read</span></span><br><span class="line">        BlockTable acBlkTbl;</span><br><span class="line">        acBlkTbl = acTrans.GetObject(acCurDb.BlockTableId,</span><br><span class="line">                                        OpenMode.ForRead) <span class="keyword">as</span> BlockTable;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Open the Block table record Model space for write</span></span><br><span class="line">        BlockTableRecord acBlkTblRec;</span><br><span class="line">        acBlkTblRec = acTrans.GetObject(acBlkTbl[BlockTableRecord.ModelSpace],</span><br><span class="line">                                        OpenMode.ForWrite) <span class="keyword">as</span> BlockTableRecord;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create the rotated dimension</span></span><br><span class="line">        <span class="keyword">using</span> (RotatedDimension acRotDim = <span class="keyword">new</span> RotatedDimension())</span><br><span class="line">        &#123;</span><br><span class="line">            acRotDim.XLine1Point = <span class="keyword">new</span> Point3d(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            acRotDim.XLine2Point = <span class="keyword">new</span> Point3d(<span class="number">6</span>, <span class="number">3</span>, <span class="number">0</span>);</span><br><span class="line">            acRotDim.Rotation = <span class="number">0.707</span>;</span><br><span class="line">            acRotDim.DimLinePoint = <span class="keyword">new</span> Point3d(<span class="number">0</span>, <span class="number">5</span>, <span class="number">0</span>);</span><br><span class="line">            acRotDim.DimensionStyle = acCurDb.Dimstyle;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Add the new object to Model space and the transaction</span></span><br><span class="line">            acBlkTblRec.AppendEntity(acRotDim);</span><br><span class="line">            acTrans.AddNewlyCreatedDBObject(acRotDim, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Commit the changes and dispose of the transaction</span></span><br><span class="line">        acTrans.Commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="创建径向标注（-NET）"><a href="#创建径向标注（-NET）" class="headerlink" title="创建径向标注（.NET）"></a>创建径向标注（.NET）</h3><p>径向尺寸测量圆弧和圆的半径和直径。通过创建 RadialDimension 和 DiametricDimension 对象的实例来创建径向和直径尺寸。</p>
<p>根据圆或圆弧的大小、标注文字的位置以及DIMUPT、DIMTOFL、DIMFIT、DIMTIH、DIMTOH、DIMJUST和DIMJUST标注系统变量中的值，可以创建不同类型的径向标注。（可以使用 GetSystemVariable 和 SetSystemVariable 方法查询或设置系统变量。）</p>
<p>对于水平标注文字，如果尺寸线与水平线的角度大于15度，并且位于圆或圆弧之外，则AutoCAD将绘制一条弯钩线，也称为基线或折线。钩线放置在标注文字的旁边或下方，如下图所示：</p>
<p><img src="https://help.autodesk.com/cloudhelp/2024/ENU/OARX-DevGuide-Managed/images/GUID-D09B48A1-80E1-4D97-A78D-324EFF2341EA.png" alt="img"></p>
<p><img src="https://help.autodesk.com/cloudhelp/2024/ENU/OARX-DevGuide-Managed/images/GUID-4118F66E-ECB4-4E94-A8E7-9BF431D14F0D.png" alt="img"></p>
<p>创建 RadialDimension 对象的实例时，可以选择指定中心点和弦点、引线长度、标注文字和要应用的标注样式。创建 DiametricDimension 对象与创建 RadialDimension 对象类似，不同之处在于指定弦和远弦点，而不是中心和弦点。</p>
<p>LeaderLength 属性指定从 ChordPoint 到注释文字的距离（如果不需要钩线，则为停止）。</p>
<p><strong>创建径向尺寸标注</strong></p>
<p>本示例在模型空间中创建径向标注。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">CommandMethod(<span class="string">&quot;CreateRadialDimension&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CreateRadialDimension</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Get the current database</span></span><br><span class="line">    Document acDoc = Application.DocumentManager.MdiActiveDocument;</span><br><span class="line">    Database acCurDb = acDoc.Database;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start a transaction</span></span><br><span class="line">    <span class="keyword">using</span> (Transaction acTrans = acCurDb.TransactionManager.StartTransaction())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Open the Block table for read</span></span><br><span class="line">        BlockTable acBlkTbl;</span><br><span class="line">        acBlkTbl = acTrans.GetObject(acCurDb.BlockTableId,</span><br><span class="line">                                        OpenMode.ForRead) <span class="keyword">as</span> BlockTable;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Open the Block table record Model space for write</span></span><br><span class="line">        BlockTableRecord acBlkTblRec;</span><br><span class="line">        acBlkTblRec = acTrans.GetObject(acBlkTbl[BlockTableRecord.ModelSpace],</span><br><span class="line">                                        OpenMode.ForWrite) <span class="keyword">as</span> BlockTableRecord;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create the radial dimension</span></span><br><span class="line">        <span class="keyword">using</span> (RadialDimension acRadDim = <span class="keyword">new</span> RadialDimension())</span><br><span class="line">        &#123;</span><br><span class="line">            acRadDim.Center = <span class="keyword">new</span> Point3d(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            acRadDim.ChordPoint = <span class="keyword">new</span> Point3d(<span class="number">5</span>, <span class="number">5</span>, <span class="number">0</span>);</span><br><span class="line">            acRadDim.LeaderLength = <span class="number">5</span>;</span><br><span class="line">            acRadDim.DimensionStyle = acCurDb.Dimstyle;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Add the new object to Model space and the transaction</span></span><br><span class="line">            acBlkTblRec.AppendEntity(acRadDim);</span><br><span class="line">            acTrans.AddNewlyCreatedDBObject(acRadDim, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Commit the changes and dispose of the transaction</span></span><br><span class="line">        acTrans.Commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="创建角度标注（-NET）"><a href="#创建角度标注（-NET）" class="headerlink" title="创建角度标注（.NET）"></a>创建角度标注（.NET）</h3><p>角度标注测量两条线或三点之间的角度。例如，您可以使用它们来测量圆的两个半径之间的角度。尺寸线形成圆弧。角度尺寸是通过创建 LineAngularDimension2 或 Point3AngularDimension 对象的实例来创建的。</p>
<ul>
<li><strong>LineAngularDimension2.</strong> 表示由两条直线定义的角度标注。</li>
<li><strong>Point3AngularDimension.</strong> 表示由三个点定义的角度标注。</li>
</ul>
<p>当您创建 LineAngularDimension2 或 Point3AngularDimension 对象的实例时，构造函数可以选择接受一组参数。创建新的 LineAngularDimension2 对象时，可以提供以下参数：</p>
<ul>
<li>延长线1起点（ XLine1Start 属性）</li>
<li>延长线1终点（ XLine1End 属性）</li>
<li>延长线2起点（ XLine2Start 属性）</li>
<li>延长线1终点（ XLine2End 属性）</li>
<li>弧点（ ArcPoint 属性）</li>
<li>标注文字（ DimensionText 属性）</li>
<li>标注样式（ DimensionStyleName 或 DimensionStyle 属性）</li>
</ul>
<p>创建新的 Point3AngularDimension 对象时，可以提供以下参数：</p>
<ul>
<li>中心点（ CenterPoint 属性）</li>
<li>延长线1点（ XLine1Point 属性）</li>
<li>延长线2点（ XLine2Point 属性）</li>
<li>弧点（ ArcPoint 属性）</li>
<li>标注文字（ DimensionText 属性）</li>
<li>标注样式（ DimensionStyleName 或 DimensionStyle 属性）</li>
</ul>
<p><strong>创建角度标注</strong></p>
<p>本示例在模型空间中创建角度标注。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">CommandMethod(<span class="string">&quot;CreateAngularDimension&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CreateAngularDimension</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Get the current database</span></span><br><span class="line">    Document acDoc = Application.DocumentManager.MdiActiveDocument;</span><br><span class="line">    Database acCurDb = acDoc.Database;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start a transaction</span></span><br><span class="line">    <span class="keyword">using</span> (Transaction acTrans = acCurDb.TransactionManager.StartTransaction())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Open the Block table for read</span></span><br><span class="line">        BlockTable acBlkTbl;</span><br><span class="line">        acBlkTbl = acTrans.GetObject(acCurDb.BlockTableId,</span><br><span class="line">                                        OpenMode.ForRead) <span class="keyword">as</span> BlockTable;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Open the Block table record Model space for write</span></span><br><span class="line">        BlockTableRecord acBlkTblRec;</span><br><span class="line">        acBlkTblRec = acTrans.GetObject(acBlkTbl[BlockTableRecord.ModelSpace],</span><br><span class="line">                                        OpenMode.ForWrite) <span class="keyword">as</span> BlockTableRecord;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create an angular dimension</span></span><br><span class="line">        <span class="keyword">using</span> (LineAngularDimension2 acLinAngDim = <span class="keyword">new</span> LineAngularDimension2())</span><br><span class="line">        &#123;</span><br><span class="line">            acLinAngDim.XLine1Start = <span class="keyword">new</span> Point3d(<span class="number">0</span>, <span class="number">5</span>, <span class="number">0</span>);</span><br><span class="line">            acLinAngDim.XLine1End = <span class="keyword">new</span> Point3d(<span class="number">1</span>, <span class="number">7</span>, <span class="number">0</span>);</span><br><span class="line">            acLinAngDim.XLine2Start = <span class="keyword">new</span> Point3d(<span class="number">0</span>, <span class="number">5</span>, <span class="number">0</span>);</span><br><span class="line">            acLinAngDim.XLine2End = <span class="keyword">new</span> Point3d(<span class="number">1</span>, <span class="number">3</span>, <span class="number">0</span>);</span><br><span class="line">            acLinAngDim.ArcPoint = <span class="keyword">new</span> Point3d(<span class="number">3</span>, <span class="number">5</span>, <span class="number">0</span>);</span><br><span class="line">            acLinAngDim.DimensionStyle = acCurDb.Dimstyle;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Add the new object to Model space and the transaction</span></span><br><span class="line">            acBlkTblRec.AppendEntity(acLinAngDim);</span><br><span class="line">            acTrans.AddNewlyCreatedDBObject(acLinAngDim, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Commit the changes and dispose of the transaction</span></span><br><span class="line">        acTrans.Commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="创建折弯半径标注（-NET）"><a href="#创建折弯半径标注（-NET）" class="headerlink" title="创建折弯半径标注（.NET）"></a>创建折弯半径标注（.NET）</h3><p>折弯半径尺寸测量对象的半径，并显示前面带有半径符号的尺寸文本。在以下情况下，您可能会在径向尺寸对象上使用折弯尺寸：</p>
<ul>
<li>对象的中心点位于布局之外，或者位于模型中没有足够空间放置径向尺寸标注的区域上</li>
<li>物体的半径很大</li>
</ul>
<p>通过创建 RadialDimensionLarge 对象的实例来创建慢跑半径尺寸。当你创建一个 RadialDimensionLarge 对象的实例时，它的构造函数可以有选择地接受一组参数。创建新的 RadialDimensionLarge 对象时，可以提供以下参数：</p>
<ul>
<li>中心点（ Center 属性）</li>
<li>弦点（ ChordPoint 属性）</li>
<li>覆写中间点（ OverrideCenter 属性）</li>
<li>折弯线的位置（ JogPoint 属性）</li>
<li>折弯线的角度（ JogAngle 属性）</li>
<li>标注文字（ DimensionText 属性）</li>
<li>标注样式（ DimensionStyleName 或 DimensionStyle 属性）</li>
</ul>
<p><strong>创建折弯半径标注</strong></p>
<p>本示例在模型空间中创建折弯半径标注。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">CommandMethod(<span class="string">&quot;CreateJoggedDimension&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CreateJoggedDimension</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Get the current database</span></span><br><span class="line">    Document acDoc = Application.DocumentManager.MdiActiveDocument;</span><br><span class="line">    Database acCurDb = acDoc.Database;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start a transaction</span></span><br><span class="line">    <span class="keyword">using</span> (Transaction acTrans = acCurDb.TransactionManager.StartTransaction())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Open the Block table for read</span></span><br><span class="line">        BlockTable acBlkTbl;</span><br><span class="line">        acBlkTbl = acTrans.GetObject(acCurDb.BlockTableId,</span><br><span class="line">                                        OpenMode.ForRead) <span class="keyword">as</span> BlockTable;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Open the Block table record Model space for write</span></span><br><span class="line">        BlockTableRecord acBlkTblRec;</span><br><span class="line">        acBlkTblRec = acTrans.GetObject(acBlkTbl[BlockTableRecord.ModelSpace],</span><br><span class="line">                                        OpenMode.ForWrite) <span class="keyword">as</span> BlockTableRecord;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create a large radius dimension</span></span><br><span class="line">        <span class="keyword">using</span> (RadialDimensionLarge acRadDimLrg = <span class="keyword">new</span> RadialDimensionLarge())</span><br><span class="line">        &#123;</span><br><span class="line">            acRadDimLrg.Center = <span class="keyword">new</span> Point3d(<span class="number">-3</span>, <span class="number">-4</span>, <span class="number">0</span>);</span><br><span class="line">            acRadDimLrg.ChordPoint = <span class="keyword">new</span> Point3d(<span class="number">2</span>, <span class="number">7</span>, <span class="number">0</span>);</span><br><span class="line">            acRadDimLrg.OverrideCenter = <span class="keyword">new</span> Point3d(<span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">            acRadDimLrg.JogPoint = <span class="keyword">new</span> Point3d(<span class="number">1</span>, <span class="number">4.5</span>, <span class="number">0</span>);</span><br><span class="line">            acRadDimLrg.JogAngle = <span class="number">0.707</span>;</span><br><span class="line">            acRadDimLrg.DimensionStyle = acCurDb.Dimstyle;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Add the new object to Model space and the transaction</span></span><br><span class="line">            acBlkTblRec.AppendEntity(acRadDimLrg);</span><br><span class="line">            acTrans.AddNewlyCreatedDBObject(acRadDimLrg, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Commit the changes and dispose of the transaction</span></span><br><span class="line">        acTrans.Commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="创建弧长标注（-NET）"><a href="#创建弧长标注（-NET）" class="headerlink" title="创建弧长标注（.NET）"></a>创建弧长标注（.NET）</h3><p>弧长标注测量沿弧的沿着长度，并显示标注文字，标注文字带有位于弧上方或弧前方的弧符号。当需要标注弧的实际长度而不仅仅是其起点和终点之间的距离时，可以使用弧长标注。</p>
<p>可以通过创建 ArcDimension 对象的实例来创建弧长半径标注。创建 ArcDimension 对象的实例时，需要一组定义尺寸的参数。创建新的 ArcDimension 对象时，必须提供以下参数：</p>
<ul>
<li>中心点（ Center 属性）</li>
<li>延长线1点（ XLine1Point 物业）</li>
<li>延长线2点（ XLine2Point 属性）</li>
<li>弧点（ ArcPoint 属性）</li>
<li>标注文字（ DimensionText 属性）</li>
<li>标注样式（ DimensionStyleName 或 DimensionStyle 属性）</li>
</ul>
<p><strong>注意：</strong>DIMARCSYM系统变量控制是否显示圆弧符号以及该符号相对于标注文字的显示位置。</p>
<p><strong>创建弧长标注</strong></p>
<p>本示例在模型空间中创建弧长标注。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">CommandMethod(<span class="string">&quot;CreateArcLengthDimension&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CreateArcLengthDimension</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Get the current database</span></span><br><span class="line">    Document acDoc = Application.DocumentManager.MdiActiveDocument;</span><br><span class="line">    Database acCurDb = acDoc.Database;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start a transaction</span></span><br><span class="line">    <span class="keyword">using</span> (Transaction acTrans = acCurDb.TransactionManager.StartTransaction())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Open the Block table for read</span></span><br><span class="line">        BlockTable acBlkTbl;</span><br><span class="line">        acBlkTbl = acTrans.GetObject(acCurDb.BlockTableId,</span><br><span class="line">                                        OpenMode.ForRead) <span class="keyword">as</span> BlockTable;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Open the Block table record Model space for write</span></span><br><span class="line">        BlockTableRecord acBlkTblRec;</span><br><span class="line">        acBlkTblRec = acTrans.GetObject(acBlkTbl[BlockTableRecord.ModelSpace],</span><br><span class="line">                                        OpenMode.ForWrite) <span class="keyword">as</span> BlockTableRecord;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create an arc length dimension</span></span><br><span class="line">        <span class="keyword">using</span> (ArcDimension acArcDim = <span class="keyword">new</span> ArcDimension(<span class="keyword">new</span> Point3d(<span class="number">4.5</span>, <span class="number">1.5</span>, <span class="number">0</span>),</span><br><span class="line">                                                        <span class="keyword">new</span> Point3d(<span class="number">8</span>, <span class="number">4.25</span>, <span class="number">0</span>),</span><br><span class="line">                                                        <span class="keyword">new</span> Point3d(<span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>),</span><br><span class="line">                                                        <span class="keyword">new</span> Point3d(<span class="number">5</span>, <span class="number">7</span>, <span class="number">0</span>),</span><br><span class="line">                                                        <span class="string">&quot;&lt;&gt;&quot;</span>,</span><br><span class="line">                                                        acCurDb.Dimstyle))</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Add the new object to Model space and the transaction</span></span><br><span class="line">            acBlkTblRec.AppendEntity(acArcDim);</span><br><span class="line">            acTrans.AddNewlyCreatedDBObject(acArcDim, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Commit the changes and dispose of the transaction</span></span><br><span class="line">        acTrans.Commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="创建坐标尺寸（-NET）"><a href="#创建坐标尺寸（-NET）" class="headerlink" title="创建坐标尺寸（.NET）"></a>创建坐标尺寸（.NET）</h3><p>坐标或基准尺寸测量从原点（称为基准）到标注特征（如零件中的孔）的垂直距离。这些尺寸通过保持特征与基准的精确偏移来防止误差的增加。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2024/ENU/OARX-DevGuide-Managed/images/GUID-B0D74148-4C3E-46DC-8B4E-5EC58AD23D88.png" alt="img"></p>
<p>坐标尺寸由带有引线的<em>X</em>或<em>Y</em>纵坐标组成。<em>X</em>基准坐标尺寸测量特征沿<em>X</em>轴沿着距基准的距离。<em>Y</em>基准坐标尺寸沿<em>Y</em>轴沿着测量相同的距离。AutoCAD使用当前用户坐标系（UCS）的原点来确定测量坐标。使用坐标的绝对值。</p>
<p>无论当前尺寸样式定义的方向如何，尺寸文本都会与坐标引线对齐。您可以接受默认文本或使用自己的文本覆盖它。</p>
<p>通过创建 OrdinateDimension 对象的实例来创建同基准尺寸。当你创建一个 OrdinateDimension 对象的实例时，它的构造函数可以接受一组可选的参数。创建新的 OrdinateDimension 对象时，可以提供以下参数：</p>
<ul>
<li>使用X轴（ UsingXAxis 属性）</li>
<li>定义点（ DefiningPoint 属性）</li>
<li>引线端点（ LeaderEndPoint 属性）</li>
<li>标注文字（ DimensionText 属性）</li>
<li>标注样式（ DimensionStyleName 或 DimensionStyle 属性）</li>
</ul>
<p>当将值传递到 OrdinateDimension 对象构造器时，第一个值是布尔标志，它指定尺寸是<em>X</em>基准还是<em>Y</em>基准坐标尺寸。如果输入 TRUE ，将创建<em>X</em>基准坐标尺寸。如果输入 FALSE ，将创建<em>Y</em>基准坐标尺寸。 UsingXAxis 特性也可用于指定坐标尺寸是<em>X</em>基准还是<em>Y</em>基准。</p>
<p><strong>创建坐标尺寸</strong></p>
<p>本示例在“模型”空间中创建纵坐标标注。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">CommandMethod(<span class="string">&quot;CreateOrdinateDimension&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CreateOrdinateDimension</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Get the current database</span></span><br><span class="line">    Document acDoc = Application.DocumentManager.MdiActiveDocument;</span><br><span class="line">    Database acCurDb = acDoc.Database;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start a transaction</span></span><br><span class="line">    <span class="keyword">using</span> (Transaction acTrans = acCurDb.TransactionManager.StartTransaction())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Open the Block table for read</span></span><br><span class="line">        BlockTable acBlkTbl;</span><br><span class="line">        acBlkTbl = acTrans.GetObject(acCurDb.BlockTableId,</span><br><span class="line">                                        OpenMode.ForRead) <span class="keyword">as</span> BlockTable;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Open the Block table record Model space for write</span></span><br><span class="line">        BlockTableRecord acBlkTblRec;</span><br><span class="line">        acBlkTblRec = acTrans.GetObject(acBlkTbl[BlockTableRecord.ModelSpace],</span><br><span class="line">                                        OpenMode.ForWrite) <span class="keyword">as</span> BlockTableRecord;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create an ordinate dimension</span></span><br><span class="line">        <span class="keyword">using</span> (OrdinateDimension acOrdDim = <span class="keyword">new</span> OrdinateDimension())</span><br><span class="line">        &#123;</span><br><span class="line">            acOrdDim.UsingXAxis = <span class="literal">true</span>;</span><br><span class="line">            acOrdDim.DefiningPoint = <span class="keyword">new</span> Point3d(<span class="number">5</span>, <span class="number">5</span>, <span class="number">0</span>);</span><br><span class="line">            acOrdDim.LeaderEndPoint = <span class="keyword">new</span> Point3d(<span class="number">10</span>, <span class="number">5</span>, <span class="number">0</span>);</span><br><span class="line">            acOrdDim.DimensionStyle = acCurDb.Dimstyle;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Add the new object to Model space and the transaction</span></span><br><span class="line">            acBlkTblRec.AppendEntity(acOrdDim);</span><br><span class="line">            acTrans.AddNewlyCreatedDBObject(acOrdDim, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Commit the changes and dispose of the transaction</span></span><br><span class="line">        acTrans.Commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="编辑标注（-NET）"><a href="#编辑标注（-NET）" class="headerlink" title="编辑标注（.NET）"></a>编辑标注（.NET）</h2><p>与AutoCAD中的其他图形对象一样，可以使用为对象提供的方法和属性编辑标注。</p>
<p>以下属性可用于大多数标注对象：</p>
<ul>
<li><p>DimensionStyle </p>
<p>指定尺寸样式的对象ID。</p>
</li>
<li><p>DimensionStyleName </p>
<p>指定标注样式的名称。</p>
</li>
<li><p>DimensionText </p>
<p>指定用户定义的标注文字字符串。</p>
</li>
<li><p>HorizontalRotation </p>
<p>以弧度为单位指定尺寸的旋转角度。</p>
</li>
<li><p>Measurement </p>
<p>指定标注的实际测量值。</p>
</li>
<li><p>TextPosition </p>
<p>指定标注文字位置。</p>
</li>
<li><p>TextRotation</p>
<p>指定标注文字的旋转角度。</p>
</li>
</ul>
<p>此外，要使用标注对象的特定属性和方法修改标注对象，还可以复制和变换标注对象。</p>
<p>本节中的主题</p>
<ul>
<li>重写标注文字（.NET）</li>
</ul>
<h3 id="重写标注文字（-NET）"><a href="#重写标注文字（-NET）" class="headerlink" title="重写标注文字（.NET）"></a>重写标注文字（.NET）</h3><p>可以使用 DimensionText 特性替换显示的尺寸值。使用此属性可以完全替换尺寸的显示值，也可以将文本附加到值。要在重写尺寸文本中表示测量值，请在文本中使用字符串“&lt;&gt;”。</p>
<p><strong>修改标注文字</strong></p>
<p>此示例将一些文本附加到值，以便同时显示字符串和尺寸值。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">CommandMethod(<span class="string">&quot;OverrideDimensionText&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">OverrideDimensionText</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Get the current database</span></span><br><span class="line">    Document acDoc = Application.DocumentManager.MdiActiveDocument;</span><br><span class="line">    Database acCurDb = acDoc.Database;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start a transaction</span></span><br><span class="line">    <span class="keyword">using</span> (Transaction acTrans = acCurDb.TransactionManager.StartTransaction())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Open the Block table for read</span></span><br><span class="line">        BlockTable acBlkTbl;</span><br><span class="line">        acBlkTbl = acTrans.GetObject(acCurDb.BlockTableId,</span><br><span class="line">                                        OpenMode.ForRead) <span class="keyword">as</span> BlockTable;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Open the Block table record Model space for write</span></span><br><span class="line">        BlockTableRecord acBlkTblRec;</span><br><span class="line">        acBlkTblRec = acTrans.GetObject(acBlkTbl[BlockTableRecord.ModelSpace],</span><br><span class="line">                                        OpenMode.ForWrite) <span class="keyword">as</span> BlockTableRecord;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create the aligned dimension</span></span><br><span class="line">        <span class="keyword">using</span> (AlignedDimension acAliDim = <span class="keyword">new</span> AlignedDimension())</span><br><span class="line">        &#123;</span><br><span class="line">            acAliDim.XLine1Point = <span class="keyword">new</span> Point3d(<span class="number">5</span>, <span class="number">3</span>, <span class="number">0</span>);</span><br><span class="line">            acAliDim.XLine2Point = <span class="keyword">new</span> Point3d(<span class="number">10</span>, <span class="number">3</span>, <span class="number">0</span>);</span><br><span class="line">            acAliDim.DimLinePoint = <span class="keyword">new</span> Point3d(<span class="number">7.5</span>, <span class="number">5</span>, <span class="number">0</span>);</span><br><span class="line">            acAliDim.DimensionStyle = acCurDb.Dimstyle;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Override the dimension text</span></span><br><span class="line">            acAliDim.DimensionText = <span class="string">&quot;The value is &lt;&gt;&quot;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Add the new object to Model space and the transaction</span></span><br><span class="line">            acBlkTblRec.AppendEntity(acAliDim);</span><br><span class="line">            acTrans.AddNewlyCreatedDBObject(acAliDim, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Commit the changes and dispose of the transaction</span></span><br><span class="line">        acTrans.Commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用标注样式（-NET）"><a href="#使用标注样式（-NET）" class="headerlink" title="使用标注样式（.NET）"></a>使用标注样式（.NET）</h2><p>命名标注样式是确定标注外观的一组设置。使用命名标注样式，可以为工程图中的标注建立和实施绘图标准。</p>
<p>所有标注都使用激活的标注样式创建。如果在创建标注之前未定义或应用样式，AutoCAD将应用默认样式STANDARD。要设置活动维度样式，请使用当前数据库的 Dimstyle 属性。</p>
<p>若要设置标注样式，请开始命名并保存样式。新样式以当前样式为基础，并包括定义尺寸部分、文字定位和注释外观的所有设置。在这种情况下，注释意味着主单位和换算单位、公差和文本。</p>
<p>本节中的主题</p>
<ul>
<li>创建、修改和复制标注样式（.NET）</li>
<li>更改标注样式（.NET）</li>
</ul>
<h3 id="创建、修改和复制标注样式（-NET）"><a href="#创建、修改和复制标注样式（-NET）" class="headerlink" title="创建、修改和复制标注样式（.NET）"></a>创建、修改和复制标注样式（.NET）</h3><p>通过创建 DimStyleTableRecord 对象的实例，然后使用 Add 方法将其添加到 DimStyleTable 中，可以创建新的标注样式。在将标注样式添加到表中之前，请使用 Name 特性设置新样式的名称。</p>
<p>也可以复制现有样式或具有重载的样式。使用 CopyFrom 方法将尺寸样式从源对象复制到尺寸样式。源对象可以是另一个 DimStyleTableRecord 对象、 Dimension 、 Tolerance 或 Leader 对象，甚至是 Database 对象。如果从其他标注样式复制样式设置，则当前样式将完全复制。如果从 Dimension 、 Tolerance 或 Leader 对象复制样式设置，则当前设置（包括任何对象替代）将复制到样式中。如果复制 Database 对象的当前样式，则标注样式和任何图形重载都将复制到新样式中。</p>
<p><strong>复制标注样式和重载</strong></p>
<p>本示例创建三个新标注样式，并将当前设置从当前 Database 、给定标注样式和给定标注分别复制到每个新标注样式。通过在运行此示例之前执行相应的设置，您将发现已创建了不同的标注样式。</p>
<ol>
<li>创建新图形并使其成为活动图形。</li>
<li>在新图形中创建线性尺寸标注。此尺寸应是图形中的唯一对象。</li>
<li>将尺寸线的颜色更改为黄色。</li>
<li>将DIMCLRD系统变量更改为5（蓝色）。</li>
<li>运行以下示例：</li>
</ol>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">CommandMethod(<span class="string">&quot;CopyDimStyles&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CopyDimStyles</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Get the current database</span></span><br><span class="line">    Document acDoc = Application.DocumentManager.MdiActiveDocument;</span><br><span class="line">    Database acCurDb = acDoc.Database;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start a transaction</span></span><br><span class="line">    <span class="keyword">using</span> (Transaction acTrans = acCurDb.TransactionManager.StartTransaction())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Open the Block table for read</span></span><br><span class="line">        BlockTable acBlkTbl;</span><br><span class="line">        acBlkTbl = acTrans.GetObject(acCurDb.BlockTableId,</span><br><span class="line">                                        OpenMode.ForRead) <span class="keyword">as</span> BlockTable;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Open the Block table record Model space for read</span></span><br><span class="line">        BlockTableRecord acBlkTblRec;</span><br><span class="line">        acBlkTblRec = acTrans.GetObject(acBlkTbl[BlockTableRecord.ModelSpace],</span><br><span class="line">                                        OpenMode.ForRead) <span class="keyword">as</span> BlockTableRecord;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">object</span> acObj = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">foreach</span> (ObjectId acObjId <span class="keyword">in</span> acBlkTblRec)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Get the first object in Model space</span></span><br><span class="line">            acObj = acTrans.GetObject(acObjId,</span><br><span class="line">                                        OpenMode.ForRead);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Open the DimStyle table for read</span></span><br><span class="line">        DimStyleTable acDimStyleTbl;</span><br><span class="line">        acDimStyleTbl = acTrans.GetObject(acCurDb.DimStyleTableId,</span><br><span class="line">                                            OpenMode.ForRead) <span class="keyword">as</span> DimStyleTable;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">string</span>[] strDimStyleNames = <span class="keyword">new</span> <span class="built_in">string</span>[<span class="number">3</span>];</span><br><span class="line">        strDimStyleNames[<span class="number">0</span>] = <span class="string">&quot;Style 1 copied from a dim&quot;</span>;</span><br><span class="line">        strDimStyleNames[<span class="number">1</span>] = <span class="string">&quot;Style 2 copied from Style 1&quot;</span>;</span><br><span class="line">        strDimStyleNames[<span class="number">2</span>] = <span class="string">&quot;Style 3 copied from the running drawing values&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">int</span> nCnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Keep a reference of the first dimension style for later</span></span><br><span class="line">        DimStyleTableRecord acDimStyleTblRec1 = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Iterate the array of dimension style names</span></span><br><span class="line">        <span class="keyword">foreach</span> (<span class="built_in">string</span> strDimStyleName <span class="keyword">in</span> strDimStyleNames)</span><br><span class="line">        &#123;</span><br><span class="line">            DimStyleTableRecord acDimStyleTblRec;</span><br><span class="line">            DimStyleTableRecord acDimStyleTblRecCopy = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Check to see if the dimension style exists or not</span></span><br><span class="line">            <span class="keyword">if</span> (acDimStyleTbl.Has(strDimStyleName) == <span class="literal">false</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (acDimStyleTbl.IsWriteEnabled == <span class="literal">false</span>) acTrans.GetObject(acCurDb.DimStyleTableId, OpenMode.ForWrite);</span><br><span class="line"></span><br><span class="line">                acDimStyleTblRec = <span class="keyword">new</span> DimStyleTableRecord();</span><br><span class="line">                acDimStyleTblRec.Name = strDimStyleName;</span><br><span class="line"></span><br><span class="line">                acDimStyleTbl.Add(acDimStyleTblRec);</span><br><span class="line">                acTrans.AddNewlyCreatedDBObject(acDimStyleTblRec, <span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                acDimStyleTblRec = acTrans.GetObject(acDimStyleTbl[strDimStyleName],</span><br><span class="line">                                                        OpenMode.ForWrite) <span class="keyword">as</span> DimStyleTableRecord;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Determine how the new dimension style is populated</span></span><br><span class="line">            <span class="keyword">switch</span> ((<span class="built_in">int</span>)nCnt)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// Assign the values of the dimension object to the new dimension style</span></span><br><span class="line">                <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">try</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">// Cast the object to a Dimension</span></span><br><span class="line">                        Dimension acDim = acObj <span class="keyword">as</span> Dimension;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// Copy the dimension style data from the dimension and</span></span><br><span class="line">                        <span class="comment">// set the name of the dimension style as the copied settings</span></span><br><span class="line">                        <span class="comment">// are unnamed.</span></span><br><span class="line">                        acDimStyleTblRecCopy = acDim.GetDimstyleData();</span><br><span class="line">                        acDimStyleTblRec1 = acDimStyleTblRec;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">catch</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">// Object was not a dimension</span></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Assign the values of the dimension style to the new dimension style</span></span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                    acDimStyleTblRecCopy = acDimStyleTblRec1;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// Assign the values of the current drawing to the dimension style</span></span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                    acDimStyleTblRecCopy = acCurDb.GetDimstyleData();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Copy the dimension settings and set the name of the dimension style</span></span><br><span class="line">            acDimStyleTblRec.CopyFrom(acDimStyleTblRecCopy);</span><br><span class="line">            acDimStyleTblRec.Name = strDimStyleName;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Dispose of the copied dimension style</span></span><br><span class="line">            acDimStyleTblRecCopy.Dispose();</span><br><span class="line"></span><br><span class="line">            nCnt = nCnt + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Commit the changes and dispose of the transaction</span></span><br><span class="line">        acTrans.Commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用DIMSTYLE命令打开标注样式管理器。现在应该列出了三种标注样式。样式1应具有黄色尺寸线。样式2应该与样式1相同。样式3应具有蓝色尺寸线。</p>
<h3 id="重写标注样式（-NET）"><a href="#重写标注样式（-NET）" class="headerlink" title="重写标注样式（.NET）"></a>重写标注样式（.NET）</h3><p>每个标注都可以重写由标注样式指定给它的设置。以下属性可用于大多数标注对象：</p>
<ul>
<li><p>Dimatfit</p>
<p>指定尺寸线仅显示在尺寸界线内，并强制尺寸文字和箭头显示在尺寸界线内或外。</p>
</li>
<li><p>Dimaltrnd </p>
<p>指定换算单位的舍入。</p>
</li>
<li><p>Dimasz</p>
<p>指定尺寸线箭头、引线箭头和钩线的大小。</p>
</li>
<li><p>Dimaunit</p>
<p>指定角度标注的单位格式。</p>
</li>
<li><p>Dimblk1, Dimblk2 ，</p>
<p>指定用于尺寸线箭头的块。</p>
</li>
<li><p>Dimcen </p>
<p> 指定径向和直径标注的中心标记的类型和大小。</p>
</li>
<li><p>Dimclrd</p>
<p>指定尺寸、引线或公差对象的尺寸线颜色。</p>
</li>
<li><p>Dimclre</p>
<p>指定尺寸界线的颜色。</p>
</li>
<li><p>Dimclrt </p>
<p>指定尺寸和公差对象的文字颜色。</p>
</li>
<li><p>Dimdec</p>
<p>指定为尺寸或公差的基本单位显示的小数位数。</p>
</li>
<li><p>Dimdsep Dimdsep的</p>
<p>指定在小数尺寸和公差值中用作小数分隔符的字符。</p>
</li>
<li><p>Dimexe</p>
<p>指定尺寸界线超出尺寸线的距离。</p>
</li>
<li><p>Dimexo </p>
<p>指定尺寸界线距原点的偏移距离。</p>
</li>
<li><p>Dimfrac </p>
<p>指定尺寸和公差中分数值的格式。</p>
</li>
<li><p>Dimgap</p>
<p>指定打断尺寸线以容纳标注文字时标注文字与尺寸线之间的距离。</p>
</li>
<li><p>Dimlfac </p>
<p>指定线性标注测量的全局比例因子。</p>
</li>
<li><p>Dimltex1, Dimltex2 </p>
<p>指定尺寸界线的线型。</p>
</li>
<li><p>Dimlwd </p>
<p>指定尺寸线的线宽。</p>
</li>
<li><p>Dimlwe</p>
<p>指定尺寸界线的线宽。</p>
</li>
<li><p>Dimjust</p>
<p>指定标注文字的水平对齐方式。</p>
</li>
<li><p>Dimrnd </p>
<p>指定尺寸测量的距离舍入。</p>
</li>
<li><p>Dimsd1, Dimsd2 </p>
<p>指定尺寸线的抑制。</p>
</li>
<li><p>Dimse1, Dimse2 </p>
<p>指定尺寸界线的抑制。</p>
</li>
<li><p>Dimtad</p>
<p>指定文字相对于尺寸线的垂直位置。</p>
</li>
<li><p>Dimtdec </p>
<p>指定主尺寸中公差值的精度。</p>
</li>
<li><p>Dimtfac </p>
<p>指定公差值的文字高度相对于标注文字高度的比例因子。</p>
</li>
<li><p>Dimlunit </p>
<p>指定除角度标注外的所有标注的单位格式。</p>
</li>
<li><p>Dimtih </p>
<p>指定是否在尺寸界线内绘制标注文字。</p>
</li>
<li><p>Dimtm</p>
<p>指定标注文字的最小公差限制。</p>
</li>
<li><p>Dimtmove</p>
<p>指定移动文字时如何绘制标注文字。</p>
</li>
<li><p>Dimtofl </p>
<p>指定是否在尺寸界线之间绘制尺寸线（即使文字放置在尺寸界线之外）。</p>
</li>
<li><p>Dimtoh </p>
<p>为除纵坐标外的所有标注类型指定尺寸标注文字在尺寸界线外的位置。</p>
</li>
<li><p>Dimtol</p>
<p>指定公差是否与标注文字一起显示。</p>
</li>
<li><p>Dimtolj </p>
<p>指定公差值相对于公称尺寸文字的垂直对正。</p>
</li>
<li><p>Dimtp </p>
<p>指定标注文字的最大公差限制。</p>
</li>
<li><p>Dimtxt </p>
<p>指定尺寸或公差文字的高度。</p>
</li>
<li><p>Dimzin </p>
<p>指定尺寸值中是否隐藏前导零和尾随零以及零英尺和零英寸测量值。</p>
</li>
<li><p>Prefix </p>
<p>指定标注值前缀。</p>
</li>
<li><p>Suffix </p>
<p>指定标注值后缀。</p>
</li>
<li><p>TextPrecision </p>
<p>指定角度标注文字的精度。</p>
</li>
<li><p>TextPosition </p>
<p>指定标注文字位置。</p>
</li>
<li><p>TextRotation</p>
<p>指定标注文字的旋转角度。</p>
</li>
</ul>
<p><strong>为对齐的标注输入用户定义的后缀</strong></p>
<p>此示例在模型空间中创建对齐尺寸，并使用Suffix属性允许用户更改尺寸的文本后缀。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">CommandMethod(<span class="string">&quot;AddDimensionTextSuffix&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">AddDimensionTextSuffix</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Get the current database</span></span><br><span class="line">    Document acDoc = Application.DocumentManager.MdiActiveDocument;</span><br><span class="line">    Database acCurDb = acDoc.Database;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start a transaction</span></span><br><span class="line">    <span class="keyword">using</span> (Transaction acTrans = acCurDb.TransactionManager.StartTransaction())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Open the Block table for read</span></span><br><span class="line">        BlockTable acBlkTbl;</span><br><span class="line">        acBlkTbl = acTrans.GetObject(acCurDb.BlockTableId,</span><br><span class="line">                                        OpenMode.ForRead) <span class="keyword">as</span> BlockTable;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Open the Block table record Model space for write</span></span><br><span class="line">        BlockTableRecord acBlkTblRec;</span><br><span class="line">        acBlkTblRec = acTrans.GetObject(acBlkTbl[BlockTableRecord.ModelSpace],</span><br><span class="line">                                        OpenMode.ForWrite) <span class="keyword">as</span> BlockTableRecord;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create the aligned dimension</span></span><br><span class="line">        <span class="keyword">using</span> (AlignedDimension acAliDim = <span class="keyword">new</span> AlignedDimension())</span><br><span class="line">        &#123;</span><br><span class="line">            acAliDim.XLine1Point = <span class="keyword">new</span> Point3d(<span class="number">0</span>, <span class="number">5</span>, <span class="number">0</span>);</span><br><span class="line">            acAliDim.XLine2Point = <span class="keyword">new</span> Point3d(<span class="number">5</span>, <span class="number">5</span>, <span class="number">0</span>);</span><br><span class="line">            acAliDim.DimLinePoint = <span class="keyword">new</span> Point3d(<span class="number">5</span>, <span class="number">7</span>, <span class="number">0</span>);</span><br><span class="line">            acAliDim.DimensionStyle = acCurDb.Dimstyle;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Add the new object to Model space and the transaction</span></span><br><span class="line">            acBlkTblRec.AppendEntity(acAliDim);</span><br><span class="line">            acTrans.AddNewlyCreatedDBObject(acAliDim, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Append a suffix to the dimension text</span></span><br><span class="line">            PromptStringOptions pStrOpts = <span class="keyword">new</span> PromptStringOptions(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">            pStrOpts.Message = <span class="string">&quot;\nEnter a new text suffix for the dimension: &quot;</span>;</span><br><span class="line">            pStrOpts.AllowSpaces = <span class="literal">true</span>;</span><br><span class="line">            PromptResult pStrRes = acDoc.Editor.GetString(pStrOpts);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (pStrRes.Status == PromptStatus.OK)</span><br><span class="line">            &#123;</span><br><span class="line">                acAliDim.Suffix = pStrRes.StringResult;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Commit the changes and dispose of the transaction</span></span><br><span class="line">        acTrans.Commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="模型空间和图纸空间中的尺寸标注（-NET）"><a href="#模型空间和图纸空间中的尺寸标注（-NET）" class="headerlink" title="模型空间和图纸空间中的尺寸标注（.NET）"></a>模型空间和图纸空间中的尺寸标注（.NET）</h2><p>可以在模型空间和图纸空间中绘制尺寸。但是，如果要标注尺寸的几何图形位于模型空间中，则最好在模型空间中绘制尺寸，因为AutoCAD会将定义点放置在绘制几何图形的空间中。</p>
<p>如果在图纸空间中绘制描述模型中几何图形的尺寸，则在使用编辑命令或更改“模型空间”视口中显示的放大率时，图纸空间尺寸不会更改。将视图从图纸空间更改为模型空间时，图纸空间尺寸的位置也保持不变。</p>
<p>如果在图纸空间中标注尺寸，并且线性标注的全局比例因子（DIMLFAC系统变量）设置为小于0，则测量的距离将乘以DIMLFAC的绝对值。如果在“模型”空间中标注尺寸，则即使DIMLFAC小于0，也将使用值1.0。如果在“尺寸”提示下更改变量并选择“视口”选项，AutoCAD将计算DIMLFAC的值。AutoCAD计算模型空间与图纸空间的比例，并将该值的负值指定给DIMLFAC。</p>
<h2 id="创建引线和注释（-NET）"><a href="#创建引线和注释（-NET）" class="headerlink" title="创建引线和注释（.NET）"></a>创建引线和注释（.NET）</h2><p>引线是将某个注释连接到图形中某个要素的线。引线及其注释是关联的，这意味着如果修改注释，引线将相应更新。不要将引线对象与AutoCAD自动生成为尺寸线一部分的引线混淆。</p>
<p>本节中的主题</p>
<ul>
<li>创建引线（.NET）</li>
<li>向引线添加注释（.NET）</li>
<li>引线关联性（.NET）</li>
<li>编辑引线关联性（.NET）</li>
<li>编辑引线（.NET）</li>
</ul>
<h3 id="创建引线（-NET）"><a href="#创建引线（-NET）" class="headerlink" title="创建引线（.NET）"></a>创建引线（.NET）</h3><p>可以从图形中的任何点或特征创建引线并控制其外观。引线可以是直线段或平滑的样条曲线。引线颜色由当前尺寸线颜色控制。引线比例由活动标注样式中设置的总体标注比例控制。如果存在箭头，则其类型和大小由活动样式中定义的箭头控制。</p>
<p>一条称为钩线的细线通常将注释连接到引线。如果最后一条引线线段与水平线的夹角大于15度，则勾线将与多行文字和几何公差框一起显示。钩线是单个箭头的长度。如果引线没有注释，则它没有钩线。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2024/ENU/OARX-DevGuide-Managed/images/GUID-9FCA8620-3D1E-4847-86C7-34FB341059DA.png" alt="img"></p>
<p>可以通过创建引线对象的实例来创建引线。创建Leader对象的实例时，其构造函数不接受任何参数。 AppendVertex 方法用于定义所创建引线的位置和长度。</p>
<p><strong>创建引线</strong></p>
<p>本示例在模型空间中创建引线。没有与引线关联的注释。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">CommandMethod(<span class="string">&quot;CreateLeader&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CreateLeader</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Get the current database</span></span><br><span class="line">    Document acDoc = Application.DocumentManager.MdiActiveDocument;</span><br><span class="line">    Database acCurDb = acDoc.Database;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start a transaction</span></span><br><span class="line">    <span class="keyword">using</span> (Transaction acTrans = acCurDb.TransactionManager.StartTransaction())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Open the Block table for read</span></span><br><span class="line">        BlockTable acBlkTbl;</span><br><span class="line">        acBlkTbl = acTrans.GetObject(acCurDb.BlockTableId,</span><br><span class="line">                                        OpenMode.ForRead) <span class="keyword">as</span> BlockTable;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Open the Block table record Model space for write</span></span><br><span class="line">        BlockTableRecord acBlkTblRec;</span><br><span class="line">        acBlkTblRec = acTrans.GetObject(acBlkTbl[BlockTableRecord.ModelSpace],</span><br><span class="line">                                        OpenMode.ForWrite) <span class="keyword">as</span> BlockTableRecord;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create the leader</span></span><br><span class="line">        <span class="keyword">using</span> (Leader acLdr = <span class="keyword">new</span> Leader())</span><br><span class="line">        &#123;</span><br><span class="line">            acLdr.AppendVertex(<span class="keyword">new</span> Point3d(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">            acLdr.AppendVertex(<span class="keyword">new</span> Point3d(<span class="number">4</span>, <span class="number">4</span>, <span class="number">0</span>));</span><br><span class="line">            acLdr.AppendVertex(<span class="keyword">new</span> Point3d(<span class="number">4</span>, <span class="number">5</span>, <span class="number">0</span>));</span><br><span class="line">            acLdr.HasArrowHead = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Add the new object to Model space and the transaction</span></span><br><span class="line">            acBlkTblRec.AppendEntity(acLdr);</span><br><span class="line">            acTrans.AddNewlyCreatedDBObject(acLdr, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Commit the changes and dispose of the transaction</span></span><br><span class="line">        acTrans.Commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="向引线添加注释（-NET）"><a href="#向引线添加注释（-NET）" class="headerlink" title="向引线添加注释（.NET）"></a>向引线添加注释（.NET）</h3><p>Leader 对象的注释可以是 Tolerance 、 MText 或 BlockReference 对象。可以创建新注释对象，也可以附加现有注释对象的副本。通过将注释对象的对象ID分配给 Annotation 属性，可以将注释添加到引线。</p>
<h3 id="引线关联性（-NET）"><a href="#引线关联性（-NET）" class="headerlink" title="引线关联性（.NET）"></a>引线关联性（.NET）</h3><p>引线与其注释相关联，因此当注释移动时，引线的端点也随之移动。当您移动文字和几何公差符号注释时，最终引线线段根据注释与引线倒数第二点（倒数第二点）的关系，在附着到注释的左侧和右侧之间交替。如果注释的中点位于倒数第二个引线点的右侧，则引线将附着到右侧;否则，它将附着到左侧。</p>
<p>使用 Erase 、 Add （添加块）或 WBlock 方法从图形中删除任何一个对象都会破坏关联性。如果引线及其注释在单个操作中一起复制，则新副本是关联的。如果单独复制它们，它们将是非关联的。如果由于任何原因（例如，仅复制引线对象或删除注释）而破坏了关联性，则将从引线中删除钩线。</p>
<p><strong>将引线与注记关联</strong></p>
<p>这个例子创建了一个 MText 对象。然后使用 MText 对象作为其注释创建引线。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">CommandMethod(<span class="string">&quot;AddLeaderAnnotation&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">AddLeaderAnnotation</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Get the current database</span></span><br><span class="line">    Document acDoc = Application.DocumentManager.MdiActiveDocument;</span><br><span class="line">    Database acCurDb = acDoc.Database;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start a transaction</span></span><br><span class="line">    <span class="keyword">using</span> (Transaction acTrans = acCurDb.TransactionManager.StartTransaction())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Open the Block table for read</span></span><br><span class="line">        BlockTable acBlkTbl;</span><br><span class="line">        acBlkTbl = acTrans.GetObject(acCurDb.BlockTableId,</span><br><span class="line">                                        OpenMode.ForRead) <span class="keyword">as</span> BlockTable;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Open the Block table record Model space for write</span></span><br><span class="line">        BlockTableRecord acBlkTblRec;</span><br><span class="line">        acBlkTblRec = acTrans.GetObject(acBlkTbl[BlockTableRecord.ModelSpace],</span><br><span class="line">                                        OpenMode.ForWrite) <span class="keyword">as</span> BlockTableRecord;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create the MText annotation</span></span><br><span class="line">        <span class="keyword">using</span> (MText acMText = <span class="keyword">new</span> MText())</span><br><span class="line">        &#123;</span><br><span class="line">            acMText.Contents = <span class="string">&quot;Hello, World.&quot;</span>;</span><br><span class="line">            acMText.Location = <span class="keyword">new</span> Point3d(<span class="number">5</span>, <span class="number">5</span>, <span class="number">0</span>);</span><br><span class="line">            acMText.Width = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Add the new object to Model space and the transaction</span></span><br><span class="line">            acBlkTblRec.AppendEntity(acMText);</span><br><span class="line">            acTrans.AddNewlyCreatedDBObject(acMText, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Create the leader with annotation</span></span><br><span class="line">            <span class="keyword">using</span> (Leader acLdr = <span class="keyword">new</span> Leader())</span><br><span class="line">            &#123;</span><br><span class="line">                acLdr.AppendVertex(<span class="keyword">new</span> Point3d(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">                acLdr.AppendVertex(<span class="keyword">new</span> Point3d(<span class="number">4</span>, <span class="number">4</span>, <span class="number">0</span>));</span><br><span class="line">                acLdr.AppendVertex(<span class="keyword">new</span> Point3d(<span class="number">4</span>, <span class="number">5</span>, <span class="number">0</span>));</span><br><span class="line">                acLdr.HasArrowHead = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Add the new object to Model space and the transaction</span></span><br><span class="line">                acBlkTblRec.AppendEntity(acLdr);</span><br><span class="line">                acTrans.AddNewlyCreatedDBObject(acLdr, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Attach the annotation after the leader object is added</span></span><br><span class="line">                acLdr.Annotation = acMText.ObjectId;</span><br><span class="line">                acLdr.EvaluateLeader();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Commit the changes and dispose of the transaction</span></span><br><span class="line">        acTrans.Commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="编辑引线关联性（-NET）"><a href="#编辑引线关联性（-NET）" class="headerlink" title="编辑引线关联性（.NET）"></a>编辑引线关联性（.NET）</h3><p>除了引线和注释之间的关联关系之外，引线及其注释在图形中是完全独立的对象。编辑引线不会影响注释，编辑注释也不会影响引线。</p>
<p>虽然文字注释是使用DIMCLRT、DIMTXT和DIMTXSTY系统变量创建的，以定义其颜色、高度和样式，但不能通过这些系统变量进行更改，因为它不是真正的标注对象。文本注释的编辑方式必须与任何其他 MText 对象相同。</p>
<p>使用 Evaluate 方法计算引线与其关联注释的关系。如果需要，此方法将更新引线几何图形。</p>
<h3 id="编辑引线（-NET）"><a href="#编辑引线（-NET）" class="headerlink" title="编辑引线（.NET）"></a>编辑引线（.NET）</h3><p>对引线注释所做的任何更改其位置的修改都会影响关联引线端点的位置。此外，旋转注释会导致引线钩线（如果有）旋转。</p>
<p>通过缩放引线来调整引线的大小。如果缩放引线，注释将保持在相对于引线端点的相同位置，但不会缩放。除了缩放之外，还可以移动、镜像和旋转引线。使用 TransformBy 方法编辑引线。使用其成员属性和方法修改关联的批注</p>
<h2 id="使用几何公差（-NET）"><a href="#使用几何公差（-NET）" class="headerlink" title="使用几何公差（.NET）"></a>使用几何公差（.NET）</h2><p>几何公差显示了特征的形状、轮廓、方向、位置和跳动的偏差。在几何公差符号中添加几何公差。这些框包含单个尺寸的所有公差信息。</p>
<p>本节中的主题</p>
<ul>
<li>创建几何公差（.NET）</li>
<li>编辑几何公差（.NET）</li>
</ul>
<h3 id="创建几何公差（-NET）"><a href="#创建几何公差（-NET）" class="headerlink" title="创建几何公差（.NET）"></a>创建几何公差（.NET）</h3><p>通过创建 FeatureControlFrame 对象的实例来创建几何公差。当你创建一个 FeatureControlFrame 对象的实例时，它的构造函数可以接受一组可选的参数。创建新的 FeatureControlFrame 对象时，可以提供以下参数：</p>
<ul>
<li>包含公差符号的文本字符串（ Text 属性）</li>
<li>插入点（ Location 属性）</li>
<li>法向量（ Normal 属性）</li>
<li>方向矢量（ Direction 属性）</li>
</ul>
<p><strong>创建几何公差</strong></p>
<p>此示例在模型空间中创建简单的几何公差。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">CommandMethod(<span class="string">&quot;CreateGeometricTolerance&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CreateGeometricTolerance</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Get the current database</span></span><br><span class="line">    Document acDoc = Application.DocumentManager.MdiActiveDocument;</span><br><span class="line">    Database acCurDb = acDoc.Database;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start a transaction</span></span><br><span class="line">    <span class="keyword">using</span> (Transaction acTrans = acCurDb.TransactionManager.StartTransaction())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Open the Block table for read</span></span><br><span class="line">        BlockTable acBlkTbl;</span><br><span class="line">        acBlkTbl = acTrans.GetObject(acCurDb.BlockTableId,</span><br><span class="line">                                        OpenMode.ForRead) <span class="keyword">as</span> BlockTable;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Open the Block table record Model space for write</span></span><br><span class="line">        BlockTableRecord acBlkTblRec;</span><br><span class="line">        acBlkTblRec = acTrans.GetObject(acBlkTbl[BlockTableRecord.ModelSpace],</span><br><span class="line">                                        OpenMode.ForWrite) <span class="keyword">as</span> BlockTableRecord;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create the Geometric Tolerance (Feature Control Frame)</span></span><br><span class="line">        <span class="keyword">using</span> (FeatureControlFrame acFcf = <span class="keyword">new</span> FeatureControlFrame())</span><br><span class="line">        &#123;</span><br><span class="line">            acFcf.Text = <span class="string">&quot;&#123;\\Fgdt;j&#125;%%v&#123;\\Fgdt;n&#125;0.001%%v%%v%%v%%v&quot;</span>;</span><br><span class="line">            acFcf.Location = <span class="keyword">new</span> Point3d(<span class="number">5</span>, <span class="number">5</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Add the new object to Model space and the transaction</span></span><br><span class="line">            acBlkTblRec.AppendEntity(acFcf);</span><br><span class="line">            acTrans.AddNewlyCreatedDBObject(acFcf, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Commit the changes and dispose of the transaction</span></span><br><span class="line">        acTrans.Commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="编辑几何公差（-NET）"><a href="#编辑几何公差（-NET）" class="headerlink" title="编辑几何公差（.NET）"></a>编辑几何公差（.NET）</h3><p>几何公差受多个系统变量和特性的影响。下列系统变量和特性会影响几何公差的外观：</p>
<p>DIMCLRD</p>
<p>控制几何公差符号的颜色。</p>
<p>DIMCLRT</p>
<p>控制公差文字的颜色。</p>
<p>DIMGAP</p>
<p>控制几何公差符号和文字之间的差距。</p>
<p>DIMTXT</p>
<p>控制公差文字的大小。</p>
<p>DIMTXTSTY</p>
<p>控制公差文字的样式。</p>
<h2 id="注：翻译自ObjectARX-Managed-NET-Developer’s-Guide，且只保留了C-部分的代码"><a href="#注：翻译自ObjectARX-Managed-NET-Developer’s-Guide，且只保留了C-部分的代码" class="headerlink" title="注：翻译自ObjectARX: Managed .NET Developer’s Guide，且只保留了C#部分的代码"></a><em><strong>注：</strong></em>翻译自<a href="https://help.autodesk.com/view/OARX/2024/ENU/?guid=GUID-C3F3C736-40CF-44A0-9210-55F6A939B6F2">ObjectARX: Managed .NET Developer’s Guide</a>，且只保留了C#部分的代码</h2>]]></content>
      <categories>
        <category>ObjectARX：Managed.NET开发人员指南</category>
      </categories>
      <tags>
        <tag>CAD</tag>
      </tags>
  </entry>
  <entry>
    <title>02控制AutoCAD环境（.NET）</title>
    <url>/2025/01/13/ObjectARX%EF%BC%9AManaged.NET%E5%BC%80%E5%8F%91%E4%BA%BA%E5%91%98%E6%8C%87%E5%8D%97/02%E6%8E%A7%E5%88%B6AutoCAD%E7%8E%AF%E5%A2%83%EF%BC%88.NET%EF%BC%89/</url>
    <content><![CDATA[<h1 id="控制AutoCAD环境（-NET）"><a href="#控制AutoCAD环境（-NET）" class="headerlink" title="控制AutoCAD环境（.NET）"></a>控制AutoCAD环境（.NET）</h1><p>本章介绍开发与AutoCAD一起运行的进程内应用程序的基础知识。它解释了许多概念，以控制和有效地使用AutoCAD环境。</p>
<p>本节中的主题</p>
<ul>
<li>控制应用程序窗口（.NET）</li>
<li>控制绘图窗口（.NET）</li>
<li>创建、打开、保存和关闭图形（.NET）</li>
<li>锁定和删除文档（.NET）</li>
<li>AutoCAD的首选项（.NET）</li>
<li>设置和返回系统变量（.NET）</li>
<li>精确绘图（.NET）</li>
<li>提示用户输入（.NET）</li>
<li>访问命令行（.NET）</li>
<li>扩展AutoCAD用户界面（.NET）</li>
<li>自定义对话框可用于获取用户输入并扩展AutoCAD用户界面的功能。</li>
</ul>
<h2 id="控制应用程序窗口（-NET）"><a href="#控制应用程序窗口（-NET）" class="headerlink" title="控制应用程序窗口（.NET）"></a>控制应用程序窗口（.NET）</h2><p>控制应用程序窗口的能力使开发人员能够灵活地创建有效和智能的应用程序。有时，您的应用程序最小化AutoCAD窗口是合适的，可能是在您的代码在另一个应用程序（如Microsoft® Excel®）中执行工作时。此外，在执行提示用户输入等任务之前，通常需要验证AutoCAD窗口的状态。</p>
<p>使用Application对象上的方法和属性，可以更改Application窗口的位置、大小和可见性。您还可以使用 WindowState 属性来最小化、最大化和检查“应用程序”窗口的当前状态。</p>
<p><strong>应用程序窗口的位置和大小</strong></p>
<p>此示例使用 Location 和 Size 特性将AutoCAD应用程序窗口定位在屏幕的左上角，并将其大小调整为400像素宽x 400像素高。</p>
<p>注意：以下示例要求项目引用PresentationCore（PresentationCore.dll）库。使用”添加引用”对话框并从”. NET”选项卡中选择”PresentationCore”。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Drawing;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.Runtime;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.ApplicationServices;</span><br><span class="line"> </span><br><span class="line">[<span class="meta">CommandMethod(<span class="string">&quot;PositionApplicationWindow&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PositionApplicationWindow</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//设置cad窗口的位置，左上角为原点</span></span><br><span class="line">	Point ptApp = <span class="keyword">new</span> Point(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	Application.MainWindow.SetLocation(ptApp);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置尺寸</span></span><br><span class="line">	Size szApp = <span class="keyword">new</span> Size(<span class="number">400</span>, <span class="number">400</span>);</span><br><span class="line">	Application.MainWindow.SetSize(szApp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（注：上面代码与原CAD给出的略有不同，用原来的跑不起来）</p>
<p><strong>最小化和最大化应用程序窗口</strong></p>
<p><strong>注意：以下示例要求项目引用PresentationCore（PresentationCore.dll）库。</strong>使用”添加引用”对话框并从”. NET”选项卡中选择”PresentationCore”。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Drawing;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.Runtime;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.ApplicationServices;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.Windows;</span><br><span class="line"> </span><br><span class="line">[<span class="meta">CommandMethod(<span class="string">&quot;MinMaxApplicationWindow&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MinMaxApplicationWindow</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//Minimize the Application window</span></span><br><span class="line">    Application.MainWindow.WindowState = Window.State.Minimized;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    System.Windows.Forms.MessageBox.Show(<span class="string">&quot;Minimized&quot;</span>, <span class="string">&quot;MinMax&quot;</span>,</span><br><span class="line">                System.Windows.Forms.MessageBoxButtons.OK,</span><br><span class="line">                System.Windows.Forms.MessageBoxIcon.None,</span><br><span class="line">                System.Windows.Forms.MessageBoxDefaultButton.Button1,</span><br><span class="line">                System.Windows.Forms.MessageBoxOptions.ServiceNotification);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Maximize the Application window</span></span><br><span class="line">    Application.MainWindow.WindowState = Window.State.Maximized;</span><br><span class="line">    System.Windows.Forms.MessageBox.Show(<span class="string">&quot;Maximized&quot;</span>, <span class="string">&quot;MinMax&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>查找应用程序窗口的当前状态</strong></p>
<p>示例查询“应用程序”窗口的状态，并在消息框中向用户显示该状态。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.Runtime;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.ApplicationServices;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.Windows;</span><br><span class="line"> </span><br><span class="line">[<span class="meta">CommandMethod(<span class="string">&quot;CurrentWindowState&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CurrentWindowState</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    System.Windows.Forms.MessageBox.Show(<span class="string">&quot;The application window is &quot;</span> +</span><br><span class="line">                                            Application.MainWindow.WindowState.ToString(), </span><br><span class="line">                                            <span class="string">&quot;Window State&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使应用程序窗口不可见和可见</strong></p>
<p>下面的代码使用 Visible 属性使AutoCAD应用程序窗口不可见，然后再次可见。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.Runtime;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.ApplicationServices;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.Windows;</span><br><span class="line"> </span><br><span class="line">[<span class="meta">CommandMethod(<span class="string">&quot;HideWindowState&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">HideWindowState</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//Hide the Application window</span></span><br><span class="line">    Application.MainWindow.Visible = <span class="literal">false</span>;</span><br><span class="line">    System.Windows.Forms.MessageBox.Show(<span class="string">&quot;Invisible&quot;</span>, <span class="string">&quot;Show/Hide&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Show the Application window</span></span><br><span class="line">    Application.MainWindow.Visible = <span class="literal">true</span>;</span><br><span class="line">    System.Windows.Forms.MessageBox.Show(<span class="string">&quot;Visible&quot;</span>, <span class="string">&quot;Show/Hide&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="控制绘图窗口（-NET）"><a href="#控制绘图窗口（-NET）" class="headerlink" title="控制绘图窗口（.NET）"></a>控制绘图窗口（.NET）</h2><p>与“AutoCAD应用程序”窗口一样，您可以最小化、最大化、重新定位、调整大小和检查任何“Document”窗口的状态。也可以使用视图、视口和缩放方法更改图形在窗口中的显示方式。</p>
<p>AutoCAD .NET API提供了多种显示图形的方法。在跟踪更改的总体效果时，可以控制图形显示快速移动到图形的不同区域。您可以缩放以更改放大率，或平移以在图形区域中重新定位视图，保存命名视图，然后在需要打印或参考特定细节时将其恢复，或通过将屏幕拆分为多个平铺视口来同时显示多个视图。</p>
<p>本节中的主题</p>
<ul>
<li>文档窗口的位置和大小（.NET）</li>
<li>缩放和平移当前视图（.NET）</li>
<li>使用命名视图（.NET）</li>
<li>使用平铺视口（.NET）</li>
<li>更新文档窗口中的几何图形（.NET）</li>
</ul>
<h3 id="文档窗口的位置和大小（-NET）"><a href="#文档窗口的位置和大小（-NET）" class="headerlink" title="文档窗口的位置和大小（.NET）"></a>文档窗口的位置和大小（.NET）</h3><p>使用 Document 对象修改任何文档窗口的位置和大小。可以使用 WindowState 属性最小化或最大化“文档”窗口，并且可以使用 WindowState 属性查找“文档”窗口的当前状态。</p>
<p><strong>调整活动文档窗口的大小</strong></p>
<p>此示例使用Location和 Size 属性将“文档”窗口的位置和大小设置为400像素宽x 400像素高。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.Runtime;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.ApplicationServices;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.Windows;</span><br><span class="line"> </span><br><span class="line">[<span class="meta">CommandMethod(<span class="string">&quot;SizeDocumentWindow&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SizeDocumentWindow</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//Size the Document window</span></span><br><span class="line">	Document acDoc = Application.DocumentManager.MdiActiveDocument;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Works around what looks to be a refresh problem with the Application window</span></span><br><span class="line">	acDoc.Window.WindowState = Window.State.Normal;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Set the position of the Document window</span></span><br><span class="line">	System.Drawing.Point ptDoc = <span class="keyword">new</span> System.Drawing.Point(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	acDoc.Window.SetLocation(ptDoc);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Set the size of the Document window</span></span><br><span class="line">	System.Drawing.Size szDoc = <span class="keyword">new</span> System.Drawing.Size(<span class="number">400</span>, <span class="number">400</span>);</span><br><span class="line">	acDoc.Window.SetSize(szDoc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>最小化和最大化活动文档窗口</strong></p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.Runtime;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.ApplicationServices;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.Windows;</span><br><span class="line"> </span><br><span class="line">[<span class="meta">CommandMethod(<span class="string">&quot;MinMaxDocumentWindow&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MinMaxDocumentWindow</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    Document acDoc = Application.DocumentManager.MdiActiveDocument;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Minimize the Document window</span></span><br><span class="line">    acDoc.Window.WindowState = Window.State.Minimized;</span><br><span class="line">    System.Windows.Forms.MessageBox.Show(<span class="string">&quot;Minimized&quot;</span> , <span class="string">&quot;MinMax&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Maximize the Document window</span></span><br><span class="line">    acDoc.Window.WindowState = Window.State.Maximized;</span><br><span class="line">    System.Windows.Forms.MessageBox.Show(<span class="string">&quot;Maximized&quot;</span> , <span class="string">&quot;MinMax&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>查找活动文档窗口的当前状态</strong></p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.Runtime;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.ApplicationServices;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.Windows;</span><br><span class="line"> </span><br><span class="line">[<span class="meta">CommandMethod(<span class="string">&quot;CurrentDocWindowState&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CurrentDocWindowState</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    Document acDoc = Application.DocumentManager.MdiActiveDocument;</span><br><span class="line"></span><br><span class="line">    System.Windows.Forms.MessageBox.Show(<span class="string">&quot;The document window is &quot;</span> +</span><br><span class="line">    acDoc.Window.WindowState.ToString(), <span class="string">&quot;Window State&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="缩放和平移当前视图（-NET）"><a href="#缩放和平移当前视图（-NET）" class="headerlink" title="缩放和平移当前视图（.NET）"></a>缩放和平移当前视图（.NET）</h3><p>视图是图形窗口中图形的特定放大率、位置和方向。通过更改当前视图的高度、宽度和中心点，可以更改图形的视图。增加或减少视图的宽度或高度会影响图形的显示大小。平移视图是通过调整当前视图的中心来完成的。</p>
<p>本节中的主题</p>
<ul>
<li>操作当前视图（.NET）</li>
<li>定义到窗口（.NET）</li>
<li>缩放视图（.NET）</li>
<li>中心对象（.NET）</li>
<li>显示图形范围和限制（.NET）</li>
</ul>
<h4 id="操作当前视图（-NET）"><a href="#操作当前视图（-NET）" class="headerlink" title="操作当前视图（.NET）"></a>操作当前视图（.NET）</h4><p>通过使用 Editor 对象的 GetCurrentView 方法，可以访问模型或图纸空间中视口的当前视图。 GetCurrentView 方法返回 ViewTableRecord 对象。使用 ViewTableRecord 对象可以操纵活动视口中视图的放大率、位置和方向。更改 ViewTableRecord 对象后，使用 SetCurrentView 方法更新活动视口的当前视图。</p>
<p>您将用于操作当前视图的一些常见属性包括：</p>
<ul>
<li><strong>CenterPoint</strong>-DCS坐标中视图的中心点。</li>
<li><strong>Height</strong>-DCS坐标中视图的高度。增加高度以缩小;减少高度以放大。</li>
<li><strong>目标</strong>-WCS坐标中视图的目标。</li>
<li><strong>ViewDirection</strong>-在WCS坐标中从目标到视图相机的向量。</li>
<li><strong>ViewTwist</strong>-以弧度表示的视图扭曲角度。</li>
<li><strong>宽度</strong>-DCS坐标中视图的宽度。增加宽度以缩小;减小宽度以放大。</li>
</ul>
<p><strong>VBA代码交叉引用</strong></p>
<p>AutoCAD .NET API不提供直接操作图形当前视图的方法，如ActiveX Automation库中的方法。例如，如果要缩放到图形中对象的范围或图形的界限，则必须操作当前视图的 Width 、 Height 和 CenterPoint 特性。若要获取图形的限制范围，请使用Database对象的 Extmin 、 Extmax 、 Limmin 和 Limmax 特性。</p>
<p><strong>用于操作当前视图的函数</strong></p>
<p>此示例代码是后面的示例使用的通用过程。“缩放”过程接受四个参数来完成缩放到边界、平移或居中绘图视图以及按给定因子缩放绘图视图。缩放过程要求以WCS坐标提供所有坐标值。</p>
<p>Zoom过程的参数为：</p>
<ul>
<li><strong>最小点</strong>-用于定义要显示区域左下角的三维点。</li>
<li><strong>最大点</strong>-用于定义要显示区域的右上角的三维点。</li>
<li><strong>中心点</strong>-用于定义视图中心的三维点。</li>
<li><strong>比例因子</strong>-用于指定增加或减少视图大小的比例的真实的数字。</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.ApplicationServices;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.DatabaseServices;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.Runtime;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.Geometry;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Zoom</span>(<span class="params">Point3d pMin, Point3d pMax, Point3d pCenter, <span class="built_in">double</span> dFactor</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Get the current document and database</span></span><br><span class="line">    Document acDoc = Application.DocumentManager.MdiActiveDocument;</span><br><span class="line">    Database acCurDb = acDoc.Database;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> nCurVport = System.Convert.ToInt32(Application.GetSystemVariable(<span class="string">&quot;CVPORT&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get the extents of the current space when no points </span></span><br><span class="line">    <span class="comment">// or only a center point is provided</span></span><br><span class="line">    <span class="comment">// Check to see if Model space is current</span></span><br><span class="line">    <span class="keyword">if</span> (acCurDb.TileMode == <span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (pMin.Equals(<span class="keyword">new</span> Point3d()) == <span class="literal">true</span> &amp;&amp; </span><br><span class="line">            pMax.Equals(<span class="keyword">new</span> Point3d()) == <span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            pMin = acCurDb.Extmin;</span><br><span class="line">            pMax = acCurDb.Extmax;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Check to see if Paper space is current</span></span><br><span class="line">        <span class="keyword">if</span> (nCurVport == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Get the extents of Paper space</span></span><br><span class="line">            <span class="keyword">if</span> (pMin.Equals(<span class="keyword">new</span> Point3d()) == <span class="literal">true</span> &amp;&amp; </span><br><span class="line">                pMax.Equals(<span class="keyword">new</span> Point3d()) == <span class="literal">true</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                pMin = acCurDb.Pextmin;</span><br><span class="line">                pMax = acCurDb.Pextmax;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Get the extents of Model space</span></span><br><span class="line">            <span class="keyword">if</span> (pMin.Equals(<span class="keyword">new</span> Point3d()) == <span class="literal">true</span> &amp;&amp; </span><br><span class="line">                pMax.Equals(<span class="keyword">new</span> Point3d()) == <span class="literal">true</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                pMin = acCurDb.Extmin;</span><br><span class="line">                pMax = acCurDb.Extmax;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start a transaction</span></span><br><span class="line">    <span class="keyword">using</span> (Transaction acTrans = acCurDb.TransactionManager.StartTransaction())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Get the current view</span></span><br><span class="line">        <span class="keyword">using</span> (ViewTableRecord acView = acDoc.Editor.GetCurrentView())</span><br><span class="line">        &#123;</span><br><span class="line">            Extents3d eExtents;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Translate WCS coordinates to DCS</span></span><br><span class="line">            Matrix3d matWCS2DCS;</span><br><span class="line">            matWCS2DCS = Matrix3d.PlaneToWorld(acView.ViewDirection);</span><br><span class="line">            matWCS2DCS = Matrix3d.Displacement(acView.Target - Point3d.Origin) * matWCS2DCS;</span><br><span class="line">            matWCS2DCS = Matrix3d.Rotation(-acView.ViewTwist, </span><br><span class="line">                                            acView.ViewDirection, </span><br><span class="line">                                            acView.Target) * matWCS2DCS;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If a center point is specified, define the min and max </span></span><br><span class="line">            <span class="comment">// point of the extents</span></span><br><span class="line">            <span class="comment">// for Center and Scale modes</span></span><br><span class="line">            <span class="keyword">if</span> (pCenter.DistanceTo(Point3d.Origin) != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                pMin = <span class="keyword">new</span> Point3d(pCenter.X - (acView.Width / <span class="number">2</span>),</span><br><span class="line">                                    pCenter.Y - (acView.Height / <span class="number">2</span>), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">                pMax = <span class="keyword">new</span> Point3d((acView.Width / <span class="number">2</span>) + pCenter.X,</span><br><span class="line">                                    (acView.Height / <span class="number">2</span>) + pCenter.Y, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Create an extents object using a line</span></span><br><span class="line">            <span class="keyword">using</span> (Line acLine = <span class="keyword">new</span> Line(pMin, pMax))</span><br><span class="line">            &#123;</span><br><span class="line">                eExtents = <span class="keyword">new</span> Extents3d(acLine.Bounds.Value.MinPoint,</span><br><span class="line">                                            acLine.Bounds.Value.MaxPoint);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Calculate the ratio between the width and height of the current view</span></span><br><span class="line">            <span class="built_in">double</span> dViewRatio;</span><br><span class="line">            dViewRatio = (acView.Width / acView.Height);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Tranform the extents of the view</span></span><br><span class="line">            matWCS2DCS = matWCS2DCS.Inverse();</span><br><span class="line">            eExtents.TransformBy(matWCS2DCS);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">double</span> dWidth;</span><br><span class="line">            <span class="built_in">double</span> dHeight;</span><br><span class="line">            Point2d pNewCentPt;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Check to see if a center point was provided (Center and Scale modes)</span></span><br><span class="line">            <span class="keyword">if</span> (pCenter.DistanceTo(Point3d.Origin) != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                dWidth = acView.Width;</span><br><span class="line">                dHeight = acView.Height;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (dFactor == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    pCenter = pCenter.TransformBy(matWCS2DCS);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                pNewCentPt = <span class="keyword">new</span> Point2d(pCenter.X, pCenter.Y);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">// Working in Window, Extents and Limits mode</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// Calculate the new width and height of the current view</span></span><br><span class="line">                dWidth = eExtents.MaxPoint.X - eExtents.MinPoint.X;</span><br><span class="line">                dHeight = eExtents.MaxPoint.Y - eExtents.MinPoint.Y;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Get the center of the view</span></span><br><span class="line">                pNewCentPt = <span class="keyword">new</span> Point2d(((eExtents.MaxPoint.X + eExtents.MinPoint.X) * <span class="number">0.5</span>),</span><br><span class="line">                                            ((eExtents.MaxPoint.Y + eExtents.MinPoint.Y) * <span class="number">0.5</span>));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Check to see if the new width fits in current window</span></span><br><span class="line">            <span class="keyword">if</span> (dWidth &gt; (dHeight * dViewRatio)) dHeight = dWidth / dViewRatio;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Resize and scale the view</span></span><br><span class="line">            <span class="keyword">if</span> (dFactor != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                acView.Height = dHeight * dFactor;</span><br><span class="line">                acView.Width = dWidth * dFactor;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Set the center of the view</span></span><br><span class="line">            acView.CenterPoint = pNewCentPt;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Set the current view</span></span><br><span class="line">            acDoc.Editor.SetCurrentView(acView);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Commit the changes</span></span><br><span class="line">        acTrans.Commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="定义到窗口（-NET）"><a href="#定义到窗口（-NET）" class="headerlink" title="定义到窗口（.NET）"></a>定义到窗口（.NET）</h4><p>在AutoCAD中，可以使用ZOOM命令的“窗口”选项定义应显示在图形窗口中的图形区域。定义要显示的区域时，将调整当前视图的 Width 和 Height 属性，以匹配由指定的两个点定义的区域。基于指定的点，视图的 CenterPoint 属性也会移动。</p>
<p><strong>缩放到由两点定义的区域</strong></p>
<p>此示例代码演示如何使用“操作当前视图”主题中定义的Zoom过程缩放到定义的区域。Zoom过程传递坐标（1.3，7.8，0）和（13.7，-2.6，0）作为前两个参数，以定义要显示的区域。</p>
<p>不需要新的中心点，因此新的Point 3d对象被传递给该过程。最后一个参数用于缩放新视图。缩放视图可用于在显示区域和图形窗口边缘之间创建间隙。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">CommandMethod(<span class="string">&quot;ZoomWindow&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ZoomWindow</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Zoom to a window boundary defined by 1.3,7.8 and 13.7,-2.6</span></span><br><span class="line">    Point3d pMin = <span class="keyword">new</span> Point3d(<span class="number">1.3</span>, <span class="number">7.8</span>, <span class="number">0</span>);</span><br><span class="line">    Point3d pMax = <span class="keyword">new</span> Point3d(<span class="number">13.7</span>, <span class="number">-2.6</span>, <span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line">    Zoom(pMin, pMax, <span class="keyword">new</span> Point3d(), <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>缩放视图（.NET）</strong></p>
<p>如果需要增大或减小图形窗口中图像的放大率，则可以更改当前视图的 Width 和 Height 属性。当重新创建视图时，请确保以相同的因子更改 Width 和 Height 属性。缩放当前视图时计算的比例因子通常基于以下情况之一：</p>
<ul>
<li>相对于图形界限</li>
<li>相对于当前视图</li>
<li>相对于图纸空间单位</li>
</ul>
<p><strong>使用指定比例放大活动图形</strong></p>
<p>此示例代码演示如何使用“操作当前视图”主题中定义的Zoom过程将当前视图缩小50%。</p>
<p>当缩放过程总共传递四个值时，前两个是未使用的新3D点。传递的第三个值是用于缩放视图的中心点，传递的最后一个值是用于缩放视图的比例因子。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">CommandMethod(<span class="string">&quot;ZoomScale&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ZoomScale</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Get the current document</span></span><br><span class="line">    Document acDoc = Application.DocumentManager.MdiActiveDocument;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Get the current view</span></span><br><span class="line">    <span class="keyword">using</span> (ViewTableRecord acView = acDoc.Editor.GetCurrentView())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Get the center of the current view</span></span><br><span class="line">        Point3d pCenter = <span class="keyword">new</span> Point3d(acView.CenterPoint.X,</span><br><span class="line">                                      acView.CenterPoint.Y, <span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// Set the scale factor to use</span></span><br><span class="line">        <span class="built_in">double</span> dScale = <span class="number">0.5</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// Scale the view using the center of the current view</span></span><br><span class="line">        Zoom(<span class="keyword">new</span> Point3d(), <span class="keyword">new</span> Point3d(), pCenter, <span class="number">1</span> / dScale);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="中心对象（-NET）"><a href="#中心对象（-NET）" class="headerlink" title="中心对象（.NET）"></a>中心对象（.NET）</h4><p>通过使用 CenterPoint 特性更改视图的中心点，可以在图形窗口中重新定位图像。当视图的中心点更改而视图的大小未更改时，视图将平行于屏幕平移。</p>
<p><strong>将活动图形放大到指定中心</strong></p>
<p>此示例代码演示了如何使用在“操作当前视图”主题下定义的Zoom过程更改当前视图的中心点。</p>
<p>当“缩放”过程总共传递四个值时，前两个值被定义为新的3D点，并被该过程忽略。第三个值是定义视图新中心点的点（5，5，0），最后一个值为1，以保持当前视图的大小。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">CommandMethod(<span class="string">&quot;ZoomCenter&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ZoomCenter</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// Center the view at 5,5,0</span></span><br><span class="line">  Zoom(<span class="keyword">new</span> Point3d(), <span class="keyword">new</span> Point3d(), <span class="keyword">new</span> Point3d(<span class="number">5</span>, <span class="number">5</span>, <span class="number">0</span>), <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="显示图形范围和限制（-NET）"><a href="#显示图形范围和限制（-NET）" class="headerlink" title="显示图形范围和限制（.NET）"></a>显示图形范围和限制（.NET）</h4><p>图形的范围或界限用于定义最外面的对象出现的边界或由当前空间的界限定义的区域。</p>
<p><strong>计算当前空间的范围</strong></p>
<p>可以使用以下属性从 Database 对象访问当前空间的范围：</p>
<ul>
<li>Extmin和Extmax-返回模型空间的范围。</li>
<li>Pextmin和Pextmax-返回当前图纸空间布局的范围。</li>
</ul>
<p>获得当前空间的范围后，可以计算当前视图的 Width 和 Height 属性的新值。使用以下公式计算视图的新宽度：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">dWidth = MaxPoint.X - MinPoint.X</span><br></pre></td></tr></table></figure>

<p>使用以下公式计算视图的新高度：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">dHeight = MaxPoint.Y - MinPoint.Y</span><br></pre></td></tr></table></figure>

<p>在计算出视图的宽度和高度之后，就可以计算出视图的中心点。可以使用以下公式获得视图的中心点：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">dCenterX = (MaxPoint.X + MinPoint.X) * <span class="number">0.5</span></span><br><span class="line">dCenterY = (MaxPoint.Y + MinPoint.Y) * <span class="number">0.5</span></span><br></pre></td></tr></table></figure>

<p><strong>计算当前空间的界限</strong></p>
<p>要根据当前空间的限制更改图形的显示，请使用 Database 对象的 Limmin 和 Limmax 以及 Plimmin 和 Plimmax 特性。返回定义当前空间界限的点后，可以使用前面提到的公式计算新视图的宽度、高度和中心点。</p>
<p><strong>放大到当前空间的范围和界限</strong></p>
<p>此示例代码演示如何使用“操作当前视图”主题中定义的Zoom过程显示当前空间的限制范围。</p>
<p>当缩放过程总共传递四个值时，传递的前两个值应该是定义要显示区域的最小点和最大点的点。第三个值定义为新的三维点，程序将忽略它，而最后一个值用于调整图形图像的大小，使其不会完全填充整个图形窗口。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">CommandMethod(<span class="string">&quot;ZoomExtents&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ZoomExtents</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Zoom to the extents of the current space</span></span><br><span class="line">    Zoom(<span class="keyword">new</span> Point3d(), <span class="keyword">new</span> Point3d(), <span class="keyword">new</span> Point3d(), <span class="number">1.01075</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">[<span class="meta">CommandMethod(<span class="string">&quot;ZoomLimits&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ZoomLimits</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    Document acDoc = Application.DocumentManager.MdiActiveDocument;</span><br><span class="line">    Database acCurDb = acDoc.Database;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Zoom to the limits of Model space</span></span><br><span class="line">    Zoom(<span class="keyword">new</span> Point3d(acCurDb.Limmin.X, acCurDb.Limmin.Y, <span class="number">0</span>),</span><br><span class="line">         <span class="keyword">new</span> Point3d(acCurDb.Limmax.X, acCurDb.Limmax.Y, <span class="number">0</span>),</span><br><span class="line">         <span class="keyword">new</span> Point3d(), <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用命名视图（-NET）"><a href="#使用命名视图（-NET）" class="headerlink" title="使用命名视图（.NET）"></a>使用命名视图（.NET）</h3><p>您可以命名并保存要重用的视图。当您不再需要该视图时，可以将其删除。</p>
<p>命名视图存储在视图表中，该表是图形数据库中的命名符号表之一。使用 Add 方法创建命名视图，以向View表添加新视图。将新命名视图添加到“视图”（View）表格中时，将创建默认的模型空间视图。</p>
<p>在创建视图时为视图命名。视图的名称最多可包含255个字符，并包含字母、数字和特殊字符美元符号（$）、连字符（-）和下划线（_）。</p>
<p>一个命名视图可以从View表中删除，只需使用您想要删除的 ViewTableRecord 对象的 Erase 方法。</p>
<p><strong>添加命名视图并将其设置为当前视图</strong></p>
<p>下面的示例将命名视图添加到图形中并将其置为当前视图。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.ApplicationServices;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.DatabaseServices;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.Runtime;</span><br><span class="line"> </span><br><span class="line">[<span class="meta">CommandMethod(<span class="string">&quot;CreateNamedView&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CreateNamedView</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Get the current database</span></span><br><span class="line">    Document acDoc = Application.DocumentManager.MdiActiveDocument;</span><br><span class="line">    Database acCurDb = acDoc.Database;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start a transaction</span></span><br><span class="line">    <span class="keyword">using</span> (Transaction acTrans = acCurDb.TransactionManager.StartTransaction())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Open the View table for read</span></span><br><span class="line">        ViewTable acViewTbl;</span><br><span class="line">        acViewTbl = acTrans.GetObject(acCurDb.ViewTableId,</span><br><span class="line">                                        OpenMode.ForRead) <span class="keyword">as</span> ViewTable;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check to see if the named view &#x27;View1&#x27; exists</span></span><br><span class="line">        <span class="keyword">if</span> (acViewTbl.Has(<span class="string">&quot;View1&quot;</span>) == <span class="literal">false</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Open the View table for write</span></span><br><span class="line">            acTrans.GetObject(acCurDb.ViewTableId, OpenMode.ForWrite);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Create a new View table record and name the view &#x27;View1&#x27;</span></span><br><span class="line">            <span class="keyword">using</span> (ViewTableRecord acViewTblRec = <span class="keyword">new</span> ViewTableRecord())</span><br><span class="line">            &#123;</span><br><span class="line">                acViewTblRec.Name = <span class="string">&quot;View1&quot;</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Add the new View table record to the View table and the transaction</span></span><br><span class="line">                acViewTbl.Add(acViewTblRec);</span><br><span class="line">                acTrans.AddNewlyCreatedDBObject(acViewTblRec, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Set &#x27;View1&#x27; current</span></span><br><span class="line">                acDoc.Editor.SetCurrentView(acViewTblRec);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Commit the changes</span></span><br><span class="line">            acTrans.Commit();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Dispose of the transaction</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>命名视图</strong></p>
<p>下面的示例从图形中删除命名视图。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.ApplicationServices;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.DatabaseServices;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.Runtime;</span><br><span class="line"> </span><br><span class="line">[<span class="meta">CommandMethod(<span class="string">&quot;EraseNamedView&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">EraseNamedView</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Get the current database</span></span><br><span class="line">    Document acDoc = Application.DocumentManager.MdiActiveDocument;</span><br><span class="line">    Database acCurDb = acDoc.Database;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start a transaction</span></span><br><span class="line">    <span class="keyword">using</span> (Transaction acTrans = acCurDb.TransactionManager.StartTransaction())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Open the View table for read</span></span><br><span class="line">        ViewTable acViewTbl;</span><br><span class="line">        acViewTbl = acTrans.GetObject(acCurDb.ViewTableId,</span><br><span class="line">                                        OpenMode.ForRead) <span class="keyword">as</span> ViewTable;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check to see if the named view &#x27;View1&#x27; exists</span></span><br><span class="line">        <span class="keyword">if</span> (acViewTbl.Has(<span class="string">&quot;View1&quot;</span>) == <span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Open the View table for write</span></span><br><span class="line">            acTrans.GetObject(acCurDb.ViewTableId, OpenMode.ForWrite);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Get the named view</span></span><br><span class="line">            ViewTableRecord acViewTblRec;</span><br><span class="line">            acViewTblRec = acTrans.GetObject(acViewTbl[<span class="string">&quot;View1&quot;</span>],</span><br><span class="line">                                                OpenMode.ForWrite) <span class="keyword">as</span> ViewTableRecord;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Remove the named view from the View table</span></span><br><span class="line">            acViewTblRec.Erase();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Commit the changes</span></span><br><span class="line">            acTrans.Commit();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Dispose of the transaction</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用平铺视口（-NET）"><a href="#使用平铺视口（-NET）" class="headerlink" title="使用平铺视口（.NET）"></a>使用平铺视口（.NET）</h3><p>AutoCAD通常使用填充整个图形区域的单个平铺视口开始新图形。可以拆分“模型”选项卡的绘图区域，以同时显示多个视口。例如，如果使完整视图和局部视图都保持可见，则可以看到局部修改对整个图形的影响。在每个平铺视口中，可以执行以下操作：</p>
<ul>
<li>缩放、设置捕捉、栅格和UCS图标模式，以及恢复各个视口中的命名视图</li>
<li>执行命令时从一个视口绘制到另一个视口</li>
<li>命名视口配置，以便可以重复使用</li>
</ul>
<p>可以在各种配置中显示平铺视口。视口的显示方式取决于需要查看的视图的数量和大小。模型空间中的平铺视口存储在Viewport表中</p>
<p>平铺视口存储在“视口”表中。Viewports表中的每条记录都表示一个视口，与其他表记录不同，可能有多个同名的Viewport表记录。具有相同名称的每个记录用于控制显示哪些视口。</p>
<p>例如，名为“Active”的视口表记录表示当前显示在“模型”选项卡上的平铺视口。</p>
<p>本节中的主题</p>
<ul>
<li>识别和操纵活动视口（.NET）</li>
<li>使平铺视口成为当前视口（.NET）</li>
</ul>
<h4 id="识别和操纵活动视口（-NET）"><a href="#识别和操纵活动视口（-NET）" class="headerlink" title="识别和操纵活动视口（.NET）"></a>识别和操纵活动视口（.NET）</h4><p>活动视口在“视口”（Viewports）表格中由名为“*Active”的记录表示，这不是唯一的名称，因为“模型”（Model）选项卡上当前显示的所有平铺视口都名为“**Active”。显示的每个平铺视口都指定了一个编号。活动视口的编号可以通过以下方式获得：</p>
<ul>
<li>检索CVPORT系统变量的值</li>
<li>使用编辑器对象的 ActiveViewportId 属性获取活动视口的对象ID，然后打开Viewport对象以访问其Number属性</li>
</ul>
<p>拥有活动视口后，可以控制其显示属性，启用视口的绘图辅助工具（如栅格和捕捉）以及视口本身的大小。平铺视口由两个角点定义：左下角和右上角。 LowerLeftCorner 和 UpperRightCorner 属性表示视口在显示器上的图形位置。</p>
<p>单个平铺视口配置的左下角为（0，0），右上角为（1，1）。无论“模型”选项卡上平铺视口的数量如何，绘图窗口的左下角始终由点（0，0）表示，右上角由（1，1）表示。当显示多个平铺视口时，左下角和右上角将有所不同，但一个视口的左下角为（0，0），另一个视口的右上角为（1，1）</p>
<p>这些属性定义如下（以四向拆分为例）：</p>
<p><img src="https://help.autodesk.com/cloudhelp/2024/ENU/OARX-DevGuide-Managed/images/GUID-9202183A-77ED-4929-A2CE-46D262C71597.png" alt="img"></p>
<p>在本例中：</p>
<ul>
<li>视口1-LowerLeftCorner &#x3D;（0，.5），UpperRightCorner &#x3D;（.5，1）</li>
<li>视口2-LowerLeftCorner &#x3D;（.5，.5），UpperRightCorner &#x3D;（1，1）</li>
<li>视口3-LowerLeftCorner &#x3D;（0，0），UpperRightCorner &#x3D;（.5，.5）</li>
<li>视口4-LowerLeftCorner &#x3D;（.5，0），UpperRightCorner &#x3D;（1，.5）</li>
</ul>
<p><strong>创建具有两个水平窗口的新平铺视口配置</strong></p>
<p>以下示例创建两个水平视口作为命名视口配置，并重新定义活动显示。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.ApplicationServices;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.DatabaseServices;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.Runtime;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.Geometry;</span><br><span class="line"> </span><br><span class="line">[<span class="meta">CommandMethod(<span class="string">&quot;CreateModelViewport&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CreateModelViewport</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Get the current database</span></span><br><span class="line">    Document acDoc = Application.DocumentManager.MdiActiveDocument;</span><br><span class="line">    Database acCurDb = acDoc.Database;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start a transaction</span></span><br><span class="line">    <span class="keyword">using</span> (Transaction acTrans = acCurDb.TransactionManager.StartTransaction())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Open the Viewport table for read</span></span><br><span class="line">        ViewportTable acVportTbl;</span><br><span class="line">        acVportTbl = acTrans.GetObject(acCurDb.ViewportTableId,</span><br><span class="line">                                        OpenMode.ForRead) <span class="keyword">as</span> ViewportTable;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check to see if the named view &#x27;TEST_VIEWPORT&#x27; exists</span></span><br><span class="line">        <span class="keyword">if</span> (acVportTbl.Has(<span class="string">&quot;TEST_VIEWPORT&quot;</span>) == <span class="literal">false</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Open the View table for write</span></span><br><span class="line">            acTrans.GetObject(acCurDb.ViewportTableId, OpenMode.ForWrite);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Add the new viewport to the Viewport table and the transaction</span></span><br><span class="line">            <span class="keyword">using</span> (ViewportTableRecord acVportTblRecLwr = <span class="keyword">new</span> ViewportTableRecord())</span><br><span class="line">            &#123;</span><br><span class="line">                acVportTbl.Add(acVportTblRecLwr);</span><br><span class="line">                acTrans.AddNewlyCreatedDBObject(acVportTblRecLwr, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Name the new viewport &#x27;TEST_VIEWPORT&#x27; and assign it to be</span></span><br><span class="line">                <span class="comment">// the lower half of the drawing window</span></span><br><span class="line">                acVportTblRecLwr.Name = <span class="string">&quot;TEST_VIEWPORT&quot;</span>;</span><br><span class="line">                acVportTblRecLwr.LowerLeftCorner = <span class="keyword">new</span> Point2d(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">                acVportTblRecLwr.UpperRightCorner = <span class="keyword">new</span> Point2d(<span class="number">1</span>, <span class="number">0.5</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Add the new viewport to the Viewport table and the transaction</span></span><br><span class="line">                <span class="keyword">using</span> (ViewportTableRecord acVportTblRecUpr = <span class="keyword">new</span> ViewportTableRecord())</span><br><span class="line">                &#123;</span><br><span class="line">                    acVportTbl.Add(acVportTblRecUpr);</span><br><span class="line">                    acTrans.AddNewlyCreatedDBObject(acVportTblRecUpr, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// Name the new viewport &#x27;TEST_VIEWPORT&#x27; and assign it to be</span></span><br><span class="line">                    <span class="comment">// the upper half of the drawing window</span></span><br><span class="line">                    acVportTblRecUpr.Name = <span class="string">&quot;TEST_VIEWPORT&quot;</span>;</span><br><span class="line">                    acVportTblRecUpr.LowerLeftCorner = <span class="keyword">new</span> Point2d(<span class="number">0</span>, <span class="number">0.5</span>);</span><br><span class="line">                    acVportTblRecUpr.UpperRightCorner = <span class="keyword">new</span> Point2d(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// To assign the new viewports as the active viewports, the </span></span><br><span class="line">                    <span class="comment">// viewports named &#x27;*Active&#x27; need to be removed and recreated</span></span><br><span class="line">                    <span class="comment">// based on &#x27;TEST_VIEWPORT&#x27;.</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">// Step through each object in the symbol table</span></span><br><span class="line">                    <span class="keyword">foreach</span> (ObjectId acObjId <span class="keyword">in</span> acVportTbl)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">// Open the object for read</span></span><br><span class="line">                        ViewportTableRecord acVportTblRec;</span><br><span class="line">                        acVportTblRec = acTrans.GetObject(acObjId,</span><br><span class="line">                                                            OpenMode.ForRead) <span class="keyword">as</span> ViewportTableRecord;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// See if it is one of the active viewports, and if so erase it</span></span><br><span class="line">                        <span class="keyword">if</span> (acVportTblRec.Name == <span class="string">&quot;*Active&quot;</span>)</span><br><span class="line">                        &#123;</span><br><span class="line">                            acTrans.GetObject(acObjId, OpenMode.ForWrite);</span><br><span class="line">                            acVportTblRec.Erase();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// Clone the new viewports as the active viewports</span></span><br><span class="line">                    <span class="keyword">foreach</span> (ObjectId acObjId <span class="keyword">in</span> acVportTbl)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">// Open the object for read</span></span><br><span class="line">                        ViewportTableRecord acVportTblRec;</span><br><span class="line">                        acVportTblRec = acTrans.GetObject(acObjId,</span><br><span class="line">                                                            OpenMode.ForRead) <span class="keyword">as</span> ViewportTableRecord;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// See if it is one of the active viewports, and if so erase it</span></span><br><span class="line">                        <span class="keyword">if</span> (acVportTblRec.Name == <span class="string">&quot;TEST_VIEWPORT&quot;</span>)</span><br><span class="line">                        &#123;</span><br><span class="line">                            ViewportTableRecord acVportTblRecClone;</span><br><span class="line">                            acVportTblRecClone = acVportTblRec.Clone() <span class="keyword">as</span> ViewportTableRecord;</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// Add the new viewport to the Viewport table and the transaction</span></span><br><span class="line">                            acVportTbl.Add(acVportTblRecClone);</span><br><span class="line">                            acVportTblRecClone.Name = <span class="string">&quot;*Active&quot;</span>;</span><br><span class="line">                            acTrans.AddNewlyCreatedDBObject(acVportTblRecClone, <span class="literal">true</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// Update the display with the new tiled viewports arrangement</span></span><br><span class="line">                    acDoc.Editor.UpdateTiledViewportsFromDatabase();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Commit the changes</span></span><br><span class="line">            acTrans.Commit();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Dispose of the transaction</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="使平铺视口成为当前视口（-NET）"><a href="#使平铺视口成为当前视口（-NET）" class="headerlink" title="使平铺视口成为当前视口（.NET）"></a>使平铺视口成为当前视口（.NET）</h4><p>在当前视口中输入点并选择对象。若要将视口置为当前视口，请使用CVPORT系统变量，并按要置为当前视口的编号指定视口。</p>
<p>可以在现有视口中搜索以查找特定视口。为此，请使用 Name 属性标识名称为“*Active”的视口表记录。</p>
<p><strong>拆分视口，然后在窗口中缩放</strong></p>
<p>此示例将活动视口拆分为两个水平窗口。然后循环访问图形中的所有平铺视口，并显示每个视口的视口名称以及左下角和右上角。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.ApplicationServices;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.DatabaseServices;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.Runtime;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.Geometry;</span><br><span class="line"> </span><br><span class="line">[<span class="meta">CommandMethod(<span class="string">&quot;SplitAndIterateModelViewports&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SplitAndIterateModelViewports</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Get the current database</span></span><br><span class="line">    Document acDoc = Application.DocumentManager.MdiActiveDocument;</span><br><span class="line">    Database acCurDb = acDoc.Database;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start a transaction</span></span><br><span class="line">    <span class="keyword">using</span> (Transaction acTrans = acCurDb.TransactionManager.StartTransaction())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Open the Viewport table for write</span></span><br><span class="line">        ViewportTable acVportTbl;</span><br><span class="line">        acVportTbl = acTrans.GetObject(acCurDb.ViewportTableId,</span><br><span class="line">                                        OpenMode.ForWrite) <span class="keyword">as</span> ViewportTable;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Open the active viewport for write</span></span><br><span class="line">        ViewportTableRecord acVportTblRec;</span><br><span class="line">        acVportTblRec = acTrans.GetObject(acDoc.Editor.ActiveViewportId,</span><br><span class="line">                                            OpenMode.ForWrite) <span class="keyword">as</span> ViewportTableRecord;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">using</span> (ViewportTableRecord acVportTblRecNew = <span class="keyword">new</span> ViewportTableRecord())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Add the new viewport to the Viewport table and the transaction</span></span><br><span class="line">            acVportTbl.Add(acVportTblRecNew);</span><br><span class="line">            acTrans.AddNewlyCreatedDBObject(acVportTblRecNew, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Assign the name &#x27;*Active&#x27; to the new Viewport</span></span><br><span class="line">            acVportTblRecNew.Name = <span class="string">&quot;*Active&quot;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Use the existing lower left corner for the new viewport</span></span><br><span class="line">            acVportTblRecNew.LowerLeftCorner = acVportTblRec.LowerLeftCorner;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Get half the X of the existing upper corner</span></span><br><span class="line">            acVportTblRecNew.UpperRightCorner = <span class="keyword">new</span> Point2d(acVportTblRec.UpperRightCorner.X,</span><br><span class="line">                                                            acVportTblRec.LowerLeftCorner.Y +</span><br><span class="line">                                                            ((acVportTblRec.UpperRightCorner.Y -</span><br><span class="line">                                                                acVportTblRec.LowerLeftCorner.Y) / <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Recalculate the corner of the active viewport</span></span><br><span class="line">            acVportTblRec.LowerLeftCorner = <span class="keyword">new</span> Point2d(acVportTblRec.LowerLeftCorner.X,</span><br><span class="line">                                                        acVportTblRecNew.UpperRightCorner.Y);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Update the display with the new tiled viewports arrangement</span></span><br><span class="line">            acDoc.Editor.UpdateTiledViewportsFromDatabase();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Step through each object in the symbol table</span></span><br><span class="line">            <span class="keyword">foreach</span> (ObjectId acObjId <span class="keyword">in</span> acVportTbl)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// Open the object for read</span></span><br><span class="line">                ViewportTableRecord acVportTblRecCur;</span><br><span class="line">                acVportTblRecCur = acTrans.GetObject(acObjId,</span><br><span class="line">                                                        OpenMode.ForRead) <span class="keyword">as</span> ViewportTableRecord;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (acVportTblRecCur.Name == <span class="string">&quot;*Active&quot;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    Application.SetSystemVariable(<span class="string">&quot;CVPORT&quot;</span>, acVportTblRecCur.Number);</span><br><span class="line"></span><br><span class="line">                    Application.ShowAlertDialog(<span class="string">&quot;Viewport: &quot;</span> + acVportTblRecCur.Number +</span><br><span class="line">                                                <span class="string">&quot; is now active.&quot;</span> +</span><br><span class="line">                                                <span class="string">&quot;\nLower left corner: &quot;</span> +</span><br><span class="line">                                                acVportTblRecCur.LowerLeftCorner.X + <span class="string">&quot;, &quot;</span> +</span><br><span class="line">                                                acVportTblRecCur.LowerLeftCorner.Y +</span><br><span class="line">                                                <span class="string">&quot;\nUpper right corner: &quot;</span> +</span><br><span class="line">                                                acVportTblRecCur.UpperRightCorner.X + <span class="string">&quot;, &quot;</span> +</span><br><span class="line">                                                acVportTblRecCur.UpperRightCorner.Y);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Commit the changes and dispose of the transaction</span></span><br><span class="line">        acTrans.Commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="更新文档窗口中的几何图形（-NET）"><a href="#更新文档窗口中的几何图形（-NET）" class="headerlink" title="更新文档窗口中的几何图形（.NET）"></a>更新文档窗口中的几何图形（.NET）</h3><p>通过AutoCAD .NET API执行的许多操作都会修改绘图区域中显示的内容。并非所有这些操作都会立即更新图形的显示。这是为了让您可以对图形进行多次更改，而无需等待在每次操作后更新显示。相反，您可以将您的操作捆绑在一起，并在完成后进行一次调用来更新显示。</p>
<p>更新显示的方法是 UpdateScreen （ Application 和 Editor 对象）和 Regen （ Editor 对象）。</p>
<p>UpdateScreen 方法重绘应用程序或文档窗口。 Regen 方法在绘图窗口中重新生成图形对象，并重新计算所有对象的屏幕坐标和视图分辨率。它还可以重新索引图形数据库，以获得最佳显示和对象选择性能。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Redraw the drawing</span></span><br><span class="line">Application.UpdateScreen();</span><br><span class="line">Application.DocumentManager.MdiActiveDocument.Editor.UpdateScreen();</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Regenerate the drawing</span></span><br><span class="line">Application.DocumentManager.MdiActiveDocument.Editor.Regen();</span><br></pre></td></tr></table></figure>

<h2 id="创建、打开、保存和关闭图形（-NET）"><a href="#创建、打开、保存和关闭图形（-NET）" class="headerlink" title="创建、打开、保存和关闭图形（.NET）"></a>创建、打开、保存和关闭图形（.NET）</h2><p>DocumentCollection 、 DocumentCollectionExtension 、 Document 和 Database 对象提供对AutoCAD®文件方法的访问。</p>
<p><strong>VBA&#x2F;ActiveX 交叉引用</strong></p>
<table>
<thead>
<tr>
<th align="left">VBA&#x2F;ActiveX 类</th>
<th align="left">.NET API类</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Documents collection</td>
<td align="left">DocumentCollection 和 DocumentCollectionExtension</td>
</tr>
<tr>
<td align="left">Document</td>
<td align="left">Document 和 Database</td>
</tr>
<tr>
<td align="left">Document.Saved</td>
<td align="left">System.Convert.ToInt16（Application.GetSystemVariable（“DBMOD”））</td>
</tr>
</tbody></table>
<p>本节中的主题</p>
<ul>
<li>创建和打开图形（.NET）</li>
<li>保存并关闭图形（.NET）</li>
<li>未打开文档时工作（.NET）</li>
</ul>
<h3 id="创建和打开图形（-NET）"><a href="#创建和打开图形（-NET）" class="headerlink" title="创建和打开图形（.NET）"></a>创建和打开图形（.NET）</h3><p>要创建新图形或打开现有图形，请使用 DocumentCollectionExtension 对象的方法。 Add 方法基于图形模板创建新的图形文件，并将该图形添加到 DocumentCollectionExtension 。 Open 方法打开现有的图形文件。</p>
<p><strong>创建新图形</strong></p>
<p>此示例使用 Add 方法基于acad.dwt图形样板文件创建新图形。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.ApplicationServices;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.DatabaseServices;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.Runtime;</span><br><span class="line"> </span><br><span class="line">[<span class="meta">CommandMethod(<span class="string">&quot;NewDrawing&quot;</span>, CommandFlags.Session)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">NewDrawing</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Specify the template to use, if the template is not found</span></span><br><span class="line">    <span class="comment">// the default settings are used.</span></span><br><span class="line">    <span class="built_in">string</span> strTemplatePath = <span class="string">&quot;acad.dwt&quot;</span>;</span><br><span class="line"></span><br><span class="line">    DocumentCollection acDocMgr = Application.DocumentManager;</span><br><span class="line">    Document acDoc = acDocMgr.Add(strTemplatePath);</span><br><span class="line"></span><br><span class="line">    acDocMgr.MdiActiveDocument = acDoc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>打开现有图形</strong></p>
<p>此示例使用 Open 方法打开现有图形。在打开图形之前，代码会先检查文件是否存在，然后再尝试打开它。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.IO;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.ApplicationServices;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.DatabaseServices;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.Runtime;</span><br><span class="line"> </span><br><span class="line">[<span class="meta">CommandMethod(<span class="string">&quot;OpenDrawing&quot;</span>, CommandFlags.Session)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">OpenDrawing</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> strFileName = <span class="string">&quot;C:\\campus.dwg&quot;</span>;</span><br><span class="line">    DocumentCollection acDocMgr = Application.DocumentManager;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (File.Exists(strFileName))</span><br><span class="line">    &#123;</span><br><span class="line">        acDocMgr.Open(strFileName, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        acDocMgr.MdiActiveDocument.Editor.WriteMessage(<span class="string">&quot;File &quot;</span> + strFileName +</span><br><span class="line">                                                        <span class="string">&quot; does not exist.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="保存并关闭图形（-NET）"><a href="#保存并关闭图形（-NET）" class="headerlink" title="保存并关闭图形（.NET）"></a>保存并关闭图形（.NET）</h3><p>使用 Database 对象的 SaveAs 方法保存 Database 对象的内容。使用 SaveAs 方法时，通过为 bBakAndRename 参数提供 True ，可以指定是否应重命名数据库以及是否应将磁盘上图形的备份重命名为备份文件。通过检查DWGTITLED系统变量的值，可以确定数据库是否使用默认名称Drawing1、Drawing2等。如果DWGTITLED为0，则图形尚未重命名。</p>
<p>有时，您需要检查活动图形是否有任何未保存的更改。最好在退出AutoCAD任务或开始新图形之前执行此操作。若要检查图形文件是否已更改，需要检查DBMOD系统变量的值。</p>
<p><strong>关闭图形</strong></p>
<p>Document 对象的 CloseAndDiscard 或 CloseAndSave 方法用于关闭打开的图形并放弃或保存所做的任何更改。可以使用 DocumentCollectionExtension 的 CloseAll 方法关闭AutoCAD中所有打开的图形。</p>
<p><strong>保存活动图形</strong></p>
<p>如果当前未保存激活图形或使用其当前名称，则本示例将激活图形保存到“c：\MyDrawing.dwg“。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.ApplicationServices;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.Runtime;</span><br><span class="line"> </span><br><span class="line">[<span class="meta">CommandMethod(<span class="string">&quot;SaveActiveDrawing&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SaveActiveDrawing</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    Document acDoc = Application.DocumentManager.MdiActiveDocument;</span><br><span class="line">    <span class="built_in">string</span> strDWGName = acDoc.Name;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">object</span> obj = Application.GetSystemVariable(<span class="string">&quot;DWGTITLED&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Check to see if the drawing has been named</span></span><br><span class="line">    <span class="keyword">if</span> (System.Convert.ToInt16(obj) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// If the drawing is using a default name (Drawing1, Drawing2, etc)</span></span><br><span class="line">        <span class="comment">// then provide a new name</span></span><br><span class="line">        strDWGName = <span class="string">&quot;c:\\MyDrawing.dwg&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Save the active drawing</span></span><br><span class="line">    acDoc.Database.SaveAs(strDWGName, <span class="literal">true</span>, DwgVersion.Current,</span><br><span class="line">                          acDoc.Database.SecurityParameters);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>确定图形是否有未保存的更改</strong></p>
<p>此示例检查是否有未保存的更改，并与用户确认是否可以保存图形（如果不可以，则跳到结尾）。如果确定，请使用 SaveAs 方法保存当前图形，如下所示：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.ApplicationServices;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.DatabaseServices;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.Runtime;</span><br><span class="line"> </span><br><span class="line">[<span class="meta">CommandMethod(<span class="string">&quot;DrawingSaved&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DrawingSaved</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">object</span> obj = Application.GetSystemVariable(<span class="string">&quot;DBMOD&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Check the value of DBMOD, if 0 then the drawing has no unsaved changes</span></span><br><span class="line">    <span class="keyword">if</span> (System.Convert.ToInt16(obj) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (System.Windows.Forms.MessageBox.Show(<span class="string">&quot;Do you wish to save this drawing?&quot;</span>,</span><br><span class="line">                                  <span class="string">&quot;Save Drawing&quot;</span>,</span><br><span class="line">                                  System.Windows.Forms.MessageBoxButtons.YesNo,</span><br><span class="line">                                  System.Windows.Forms.MessageBoxIcon.Question)</span><br><span class="line">                                  == System.Windows.Forms.DialogResult.Yes)</span><br><span class="line">        &#123;</span><br><span class="line">            Document acDoc = Application.DocumentManager.MdiActiveDocument;</span><br><span class="line">            acDoc.Database.SaveAs(acDoc.Name, <span class="literal">true</span>, DwgVersion.Current,</span><br><span class="line">                                  acDoc.Database.SecurityParameters);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="未打开文档时工作（-NET）"><a href="#未打开文档时工作（-NET）" class="headerlink" title="未打开文档时工作（.NET）"></a>未打开文档时工作（.NET）</h3><p>AutoCAD总是在打开新文档或现有文档的情况下启动。但是，在当前运行期间可以关闭所有文件。</p>
<p>如果关闭AutoCAD用户界面中的所有文档，您会注意到应用程序窗口发生了一些变化。快速访问工具栏和应用程序菜单提供有限的选项。这些有限的选项与创建和打开图形、显示图纸集管理器以及恢复图形有关。如果显示菜单栏，则还会显示简化的“文件”、“视图”、“窗口”和“帮助”菜单。你也会注意到没有命令行。</p>
<p>在零文档状态下工作时，您可以执行以下操作：</p>
<ul>
<li>您可以创建新文档或打开现有文档</li>
<li>您可以自定义应用程序菜单和菜单栏的零文档状态</li>
<li>您可以关闭AutoCAD</li>
</ul>
<p>若要在AutoCAD进入零文档状态时对其作出反应，应使用 DocumentDestroyed 事件。 DocumentDestroyed 事件在打开的文档关闭时触发。最后一张单据关闭时的单据计数为1。使用 DocumentManager 的 Count 属性确定触发 DocumentDestroyed 事件时打开的文档数。</p>
<p><strong>自定义应用程序菜单</strong></p>
<p>此示例代码使用 DocumentDestroyed 事件监视最后一个图形何时关闭以及何时进入零文档状态。进入零文档状态后， Opening 事件将在应用程序菜单中注册。单击应用程序菜单时，会触发 Opening 事件。在 Opening 事件期间，一个新的菜单项被添加到应用程序菜单中。新菜单项显示一个消息框。</p>
<p><strong>注意：</strong>您必须将<em>AdWindows.dll</em>引用到项目中，才能使用以下示例代码。<em>AdWindows.dll</em>包含用于自定义应用程序菜单的命名空间，可以在AutoCAD的安装文件夹或ObjectARX SDK的一部分中找到。还需要引用 WindowsBase ，该引用位于“添加引用”对话框的“AutoCAD .NET”选项卡上。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Autodesk.Windows;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.Runtime;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.ApplicationServices;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Create the command handler for the custom  application menu item</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyCommandHandler</span> : <span class="title">System.Windows.Input.ICommand</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">CanExecute</span>(<span class="params"><span class="built_in">object</span> parameter</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> EventHandler CanExecuteChanged;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Execute</span>(<span class="params"><span class="built_in">object</span> parameter</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Application.ShowAlertDialog(<span class="string">&quot;MyMenuItem has been clicked&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title">Chapter4</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//Global var for ZeroDocState</span></span><br><span class="line">    ApplicationMenuItem acApMenuItem = <span class="literal">null</span>;</span><br><span class="line"> </span><br><span class="line">    [<span class="meta">CommandMethod(<span class="string">&quot;AddZeroDocEvent&quot;</span>)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddZeroDocEvent</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Get the DocumentCollection and register the DocumentDestroyed event</span></span><br><span class="line">        DocumentCollection acDocMgr = Application.DocumentManager;</span><br><span class="line">        acDocMgr.DocumentDestroyed += </span><br><span class="line">            <span class="keyword">new</span> DocumentDestroyedEventHandler(docDestroyed);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">docDestroyed</span>(<span class="params"><span class="built_in">object</span> obj, </span></span></span><br><span class="line"><span class="params"><span class="function">                             DocumentDestroyedEventArgs acDocDesEvtArgs</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Determine if the menu item already exists and the number of documents open</span></span><br><span class="line">        <span class="keyword">if</span> (Application.DocumentManager.Count == <span class="number">1</span> &amp;&amp; acApMenuItem == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Add the event handler to watch for when the application menu is opened</span></span><br><span class="line">            <span class="comment">// AdWindows.dll must be referenced to the project</span></span><br><span class="line">            ComponentManager.ApplicationMenu.Opening += </span><br><span class="line">                <span class="keyword">new</span> EventHandler&lt;EventArgs&gt;(ApplicationMenu_Opening);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ApplicationMenu_Opening</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Check to see if the custom menu item was added previously</span></span><br><span class="line">        <span class="keyword">if</span> (acApMenuItem == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Get the application menu component</span></span><br><span class="line">            ApplicationMenu acApMenu = ComponentManager.ApplicationMenu;</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// Create a new application menu item</span></span><br><span class="line">            acApMenuItem = <span class="keyword">new</span> ApplicationMenuItem();</span><br><span class="line">            acApMenuItem.Text = <span class="string">&quot;MyMenuItem&quot;</span>;</span><br><span class="line">            acApMenuItem.CommandHandler = <span class="keyword">new</span> MyCommandHandler();</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// Append the new menu item</span></span><br><span class="line">            acApMenu.MenuContent.Items.Add(acApMenuItem);</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// Remove the application menu Opening event handler</span></span><br><span class="line">            ComponentManager.ApplicationMenu.Opening -= </span><br><span class="line">                <span class="keyword">new</span> EventHandler&lt;EventArgs&gt;(ApplicationMenu_Opening);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="锁定和删除文档（-NET）"><a href="#锁定和删除文档（-NET）" class="headerlink" title="锁定和删除文档（.NET）"></a>锁定和删除文档（.NET）</h2><p>修改对象或访问AutoCAD的请求可以在任何上下文中发生，也可以来自任何数量的应用程序。为了防止与其他请求发生冲突，您有责任在修改文档之前锁定文档。在某些上下文中未能锁定文档将导致修改数据库期间发生锁定冲突。您希望在应用程序出现以下情况时锁定文档：</p>
<ul>
<li>从无模式对话框与AutoCAD交互</li>
<li>访问当前文档以外的加载文档</li>
<li>用作COM服务器</li>
<li>使用会话命令标志注册命令</li>
</ul>
<p>例如，当将实体添加到当前文档以外的文档中的模型或图纸空间时，需要锁定该文档。您使用要锁定的 Database 对象的 LockDocument 方法。当调用 LockDocument 方法时，返回一个 DocumentLock 对象。</p>
<p>修改锁定的数据库后，需要解锁数据库。要解锁数据库，请调用 DocumentLock 对象的 Dispose 方法。您还可以将Using语句与 DocumentLock 对象一起使用，一旦Using语句结束，数据库将被解锁。</p>
<p>注意：在不使用会话命令标志的命令上下文中工作时，在修改当前文档之前，不需要锁定该文档的数据库。</p>
<p><strong>在修改对象之前锁定数据库</strong></p>
<p>此示例创建一个新文档，然后在其中绘制一个圆。创建文档后，将锁定新文档的数据库，然后向其中添加一个圆。添加圆后，将解锁数据库，并将关联的文档窗口设置为当前。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.ApplicationServices;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.DatabaseServices;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.Runtime;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.Geometry;</span><br><span class="line"> </span><br><span class="line">[<span class="meta">CommandMethod(<span class="string">&quot;LockDoc&quot;</span>, CommandFlags.Session)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">LockDoc</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Create a new drawing</span></span><br><span class="line">    DocumentCollection acDocMgr = Application.DocumentManager;</span><br><span class="line">    Document acNewDoc = acDocMgr.Add(<span class="string">&quot;acad.dwt&quot;</span>);</span><br><span class="line">    Database acDbNewDoc = acNewDoc.Database;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Lock the new document</span></span><br><span class="line">    <span class="keyword">using</span> (DocumentLock acLckDoc = acNewDoc.LockDocument())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Start a transaction in the new database</span></span><br><span class="line">        <span class="keyword">using</span> (Transaction acTrans = acDbNewDoc.TransactionManager.StartTransaction())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Open the Block table for read</span></span><br><span class="line">            BlockTable acBlkTbl;</span><br><span class="line">            acBlkTbl = acTrans.GetObject(acDbNewDoc.BlockTableId,</span><br><span class="line">                                            OpenMode.ForRead) <span class="keyword">as</span> BlockTable;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Open the Block table record Model space for write</span></span><br><span class="line">            BlockTableRecord acBlkTblRec;</span><br><span class="line">            acBlkTblRec = acTrans.GetObject(acBlkTbl[BlockTableRecord.ModelSpace],</span><br><span class="line">                                            OpenMode.ForWrite) <span class="keyword">as</span> BlockTableRecord;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Create a circle with a radius of 3 at 5,5</span></span><br><span class="line">            <span class="keyword">using</span> (Circle acCirc = <span class="keyword">new</span> Circle())</span><br><span class="line">            &#123;</span><br><span class="line">                acCirc.Center = <span class="keyword">new</span> Point3d(<span class="number">5</span>, <span class="number">5</span>, <span class="number">0</span>);</span><br><span class="line">                acCirc.Radius = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Add the new object to Model space and the transaction</span></span><br><span class="line">                acBlkTblRec.AppendEntity(acCirc);</span><br><span class="line">                acTrans.AddNewlyCreatedDBObject(acCirc, <span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Save the new object to the database</span></span><br><span class="line">            acTrans.Commit();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Unlock the document</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set the new document current</span></span><br><span class="line">    acDocMgr.MdiActiveDocument = acNewDoc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="AutoCAD的首选项（-NET）"><a href="#AutoCAD的首选项（-NET）" class="headerlink" title="AutoCAD的首选项（.NET）"></a>AutoCAD的首选项（.NET）</h2><p>AutoCAD .NET API不包含任何类或方法来访问通过“AutoCAD选项”对话框访问的选项。通过ActiveX® Automation库可以访问这些选项。使用从Application对象的 Preferences 属性返回的COM对象。</p>
<p>拥有Preferences COM对象后，就可以访问与选项相关的九个对象，每个对象代表“选项”对话框中的一个选项卡。通过这些对象可以访问“选项”对话框中存储在注册表中的所有选项。通过使用这些对象上的特性，可以自定义许多AutoCAD设置。这些对象是</p>
<ul>
<li>PreferencesDisplay  </li>
<li>PreferencesDrafting  </li>
<li>PreferencesFiles </li>
<li>PreferencesOpenSave  </li>
<li>PreferencesOutput</li>
<li>PreferencesProfiles </li>
<li>PreferencesSelection  </li>
<li>PreferencesSystem </li>
<li>PreferencesUser</li>
</ul>
<p><strong>访问首选项对象</strong></p>
<p>下面的示例演示如何通过COM互操作访问Preferences对象。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">AcadPreferences acPrefComObj = (AcadPreferences)Application.Preferences;</span><br></pre></td></tr></table></figure>

<p>引用首选项对象后，可以使用“显示”、“绘图”、“文件”、“打开保存”、“输出”、“配置”、“选择”、“系统”和“用户”属性访问任何特定的首选项对象。</p>
<p><strong>把十字准线设置为全屏</strong></p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.ApplicationServices;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.Runtime;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.Interop;</span><br><span class="line"> </span><br><span class="line">[<span class="meta">CommandMethod(<span class="string">&quot;PrefsSetCursor&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PrefsSetCursor</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// This example sets the crosshairs for the drawing window</span></span><br><span class="line">    <span class="comment">// to full screen.</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Access the Preferences object</span></span><br><span class="line">    AcadPreferences acPrefComObj = (AcadPreferences)Application.Preferences;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Use the CursorSize property to set the size of the crosshairs</span></span><br><span class="line">    acPrefComObj.Display.CursorSize = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>隐藏滚动条</strong></p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.ApplicationServices;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.Runtime;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.Interop;</span><br><span class="line"> </span><br><span class="line">[<span class="meta">CommandMethod(<span class="string">&quot;PrefsSetDisplay&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PrefsSetDisplay</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// This example disables the scroll bars</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Access the Preferences object</span></span><br><span class="line">    AcadPreferences acPrefComObj = (AcadPreferences)Application.Preferences;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Disable the scroll bars</span></span><br><span class="line">    acPrefComObj.Display.DisplayScrollBars = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本节中的主题</p>
<ul>
<li>数据库首选项（.NET）</li>
</ul>
<h4 id="数据库首选项（-NET）"><a href="#数据库首选项（-NET）" class="headerlink" title="数据库首选项（.NET）"></a>数据库首选项（.NET）</h4><p>沿着应用程序级首选项，还有一些基于图形的首选项，可通过存储在图形文件中的“选项”对话框访问。要访问这些存储的设置，请使用 Database 对象的相应属性或使用 Application 对象的 GetSystemVariable 和 SetSystemVariable 方法。</p>
<p><strong>VBA&#x2F;ActiveX 交叉引用</strong></p>
<table>
<thead>
<tr>
<th align="left">VBA&#x2F;ActiveX 类</th>
<th align="left">.NET API类</th>
</tr>
</thead>
<tbody><tr>
<td align="left">DatabasePreferences</td>
<td align="left">Database and drawing based system variables 基于数据库和图形的系统变量</td>
</tr>
</tbody></table>
<h2 id="设置和返回系统变量（-NET）"><a href="#设置和返回系统变量（-NET）" class="headerlink" title="设置和返回系统变量（.NET）"></a>设置和返回系统变量（.NET）</h2><p>Application对象提供了用于设置和检索AutoCAD系统变量的 SetSystemVariable 和 GetSystemVariable 方法。例如，要将整数指定给MAXSORT系统变量，请使用以下代码：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Get the current value from a system variable</span></span><br><span class="line"><span class="built_in">int</span> nMaxSort = System.Convert.ToInt32(Application.GetSystemVariable(<span class="string">&quot;MAXSORT&quot;</span>));</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Set system variable to new value</span></span><br><span class="line">Application.SetSystemVariable(<span class="string">&quot;MAXSORT&quot;</span>, <span class="number">100</span>);</span><br></pre></td></tr></table></figure>

<h2 id="精确绘图（-NET）"><a href="#精确绘图（-NET）" class="headerlink" title="精确绘图（.NET）"></a>精确绘图（.NET）</h2><p>使用AutoCAD，您可以创建具有精确几何图形的图形，而无需执行繁琐的计算。通常，您可以在不知道坐标的情况下指定精确的点。无需离开图形屏幕，即可对图形执行计算并显示各种类型的状态信息。</p>
<p>本节中的主题</p>
<ul>
<li>调整捕捉和网格对齐（.NET）</li>
<li>使用正交模式（.NET）</li>
<li>计算点和值（.NET）</li>
<li>计算面积（.NET）</li>
</ul>
<h3 id="调整捕捉和网格对齐（-NET）"><a href="#调整捕捉和网格对齐（-NET）" class="headerlink" title="调整捕捉和网格对齐（.NET）"></a>调整捕捉和网格对齐（.NET）</h3><p>网格是测量距离的视觉指导，而捕捉模式用于限制光标移动。除了设置栅格和捕捉模式的间距外，还可以调整旋转和使用的捕捉类型。</p>
<p>如果需要沿特定路线或角度沿着绘制，可以旋转捕捉角度。捕捉角度旋转的中心点是捕捉基点。</p>
<p>注意：更改活动视口的捕捉和栅格设置后，应使用Editor对象的 UpdateTiledViewportsFromDatabase 方法更新绘图区域的显示。</p>
<p>捕捉和栅格不会影响通过AutoCAD .NET API指定的点，但会影响用户在绘图区域中指定的点（如果请求用户使用 GetPoint 或 GetEntity 等方法输入输入）。</p>
<p><strong>更改网格和捕捉设置</strong></p>
<p>此示例将捕捉基点更改为（1，1），捕捉旋转角度更改为30度。打开网格并调整间距，以便更改可见。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.ApplicationServices;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.DatabaseServices;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.Runtime;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.Geometry;</span><br><span class="line"> </span><br><span class="line">[<span class="meta">CommandMethod(<span class="string">&quot;ChangeGridAndSnap&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ChangeGridAndSnap</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// Get the current database</span></span><br><span class="line">  Document acDoc = Application.DocumentManager.MdiActiveDocument;</span><br><span class="line">  Database acCurDb = acDoc.Database;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// Start a transaction</span></span><br><span class="line">  <span class="keyword">using</span> (Transaction acTrans = acCurDb.TransactionManager.StartTransaction())</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="comment">// Open the active viewport</span></span><br><span class="line">      ViewportTableRecord acVportTblRec;</span><br><span class="line">      acVportTblRec = acTrans.GetObject(acDoc.Editor.ActiveViewportId,</span><br><span class="line">                                        OpenMode.ForWrite) <span class="keyword">as</span> ViewportTableRecord;</span><br><span class="line"> </span><br><span class="line">      <span class="comment">// Turn on the grid for the active viewport</span></span><br><span class="line">      acVportTblRec.GridEnabled = <span class="literal">true</span>;</span><br><span class="line"> </span><br><span class="line">      <span class="comment">// Adjust the spacing of the grid to 1, 1</span></span><br><span class="line">      acVportTblRec.GridIncrements = <span class="keyword">new</span> Point2d(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"> </span><br><span class="line">      <span class="comment">// Turn on the snap mode for the active viewport</span></span><br><span class="line">      acVportTblRec.SnapEnabled = <span class="literal">true</span>;</span><br><span class="line"> </span><br><span class="line">      <span class="comment">// Adjust the snap spacing to 0.5, 0.5</span></span><br><span class="line">      acVportTblRec.SnapIncrements = <span class="keyword">new</span> Point2d(<span class="number">0.5</span>, <span class="number">0.5</span>);</span><br><span class="line"> </span><br><span class="line">      <span class="comment">// Change the snap base point to 1, 1</span></span><br><span class="line">      acVportTblRec.SnapBase = <span class="keyword">new</span> Point2d(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"> </span><br><span class="line">      <span class="comment">// Change the snap rotation angle to 30 degrees (0.524 radians)</span></span><br><span class="line">      acVportTblRec.SnapAngle = <span class="number">0.524</span>;</span><br><span class="line"> </span><br><span class="line">      <span class="comment">// Update the display of the tiled viewport</span></span><br><span class="line">      acDoc.Editor.UpdateTiledViewportsFromDatabase();</span><br><span class="line"> </span><br><span class="line">      <span class="comment">// Commit the changes and dispose of the transaction</span></span><br><span class="line">      acTrans.Commit();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用正交模式（-NET）"><a href="#使用正交模式（-NET）" class="headerlink" title="使用正交模式（.NET）"></a>使用正交模式（.NET）</h3><p>绘制直线或移动对象时，可以使用“正交”模式将光标限制在水平轴或垂直轴上。正交对齐取决于当前捕捉角度和UCS。正交模式适用于需要指定第二个点的活动，例如使用 GetDistance 或 GetAngle 方法时。使用“正交”不仅可以建立垂直或水平对齐，还可以强制平行或创建规则偏移。</p>
<p>通过允许AutoCAD施加正交约束，可以更快地绘制。例如，可以在开始绘制之前通过启用“正交”模式来创建一系列垂直线。由于直线被约束到水平轴和垂直轴，因此您可以更快地绘制，因为知道直线是垂直的。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2024/ENU/OARX-DevGuide-Managed/images/GUID-2FE8A50F-06B9-460C-8EE3-1492C05B0659.png" alt="img"></p>
<p>以下语句打开“正交”模式。与网格和捕捉设置不同，“正交”模式在 Database 对象中而不是活动视口中维护。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Application.DocumentManager.MdiActiveDocument.Database.Orthomode = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>

<h3 id="计算点和值（-NET）"><a href="#计算点和值（-NET）" class="headerlink" title="计算点和值（.NET）"></a>计算点和值（.NET）</h3><p>通过使用编辑器对象以及几何和几何图形命名空间提供的方法，可以快速解决数学问题或在图形中定位点。一些可用的方法是：</p>
<ul>
<li>使用 GetDistanceTo 和 DistanceTo 方法获取两个二维或三维点之间的距离</li>
<li>使用带有返回值的 Angle 属性的 GetVectorTo 方法，使用两个2D点获取与X轴的角度</li>
<li>使用 StringToAngle 方法将字符串形式的角度转换为真实的（双精度）值</li>
<li>使用 AngleToString 方法将角度从真实的（双精度）值转换为字符串</li>
<li>使用 StringToDistance 方法将距离从字符串转换为真实的（双精度）值</li>
<li>使用 GetDistance 方法查找用户输入的两点之间的距离</li>
</ul>
<p>注意：AutoCAD .NET API不包含基于距离和角度（极坐标点）计算点的方法以及在不同坐标系之间转换坐标的方法。如果您需要这些实用程序，则需要利用ActiveX Automation库中的 PolarPoint 和 TranslateCoordinates 方法。</p>
<p><strong>从X轴获取角度</strong><br>此示例计算两点之间的向量并确定与X轴的角度。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.ApplicationServices;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.Runtime;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.Geometry;</span><br><span class="line"> </span><br><span class="line">[<span class="meta">CommandMethod(<span class="string">&quot;AngleFromXAxis&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">AngleFromXAxis</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">  Point2d pt1 = <span class="keyword">new</span> Point2d(<span class="number">2</span>, <span class="number">5</span>);</span><br><span class="line">  Point2d pt2 = <span class="keyword">new</span> Point2d(<span class="number">5</span>, <span class="number">2</span>);</span><br><span class="line"> </span><br><span class="line">  Application.ShowAlertDialog(<span class="string">&quot;Angle from XAxis: &quot;</span> +</span><br><span class="line">                              pt1.GetVectorTo(pt2).Angle.ToString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>计算极点</strong><br>此示例基于基点、角度和距离计算点。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.ApplicationServices;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.Runtime;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.Geometry;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">static</span> Point2d <span class="title">PolarPoints</span>(<span class="params">Point2d pPt, <span class="built_in">double</span> dAng, <span class="built_in">double</span> dDist</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Point2d(pPt.X + dDist * Math.Cos(dAng),</span><br><span class="line">                     pPt.Y + dDist * Math.Sin(dAng));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">static</span> Point3d <span class="title">PolarPoints</span>(<span class="params">Point3d pPt, <span class="built_in">double</span> dAng, <span class="built_in">double</span> dDist</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Point3d(pPt.X + dDist * Math.Cos(dAng),</span><br><span class="line">                     pPt.Y + dDist * Math.Sin(dAng),</span><br><span class="line">                     pPt.Z);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">[<span class="meta">CommandMethod(<span class="string">&quot;PolarPoints&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PolarPoints</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">  Point2d pt1 = PolarPoints(<span class="keyword">new</span> Point2d(<span class="number">5</span>, <span class="number">2</span>), <span class="number">0.785398</span>, <span class="number">12</span>);</span><br><span class="line"> </span><br><span class="line">  Application.ShowAlertDialog(<span class="string">&quot;\nPolarPoint: &quot;</span> +</span><br><span class="line">                              <span class="string">&quot;\nX = &quot;</span> + pt1.X +</span><br><span class="line">                              <span class="string">&quot;\nY = &quot;</span> + pt1.Y);</span><br><span class="line"> </span><br><span class="line">  Point3d pt2 = PolarPoints(<span class="keyword">new</span> Point3d(<span class="number">5</span>, <span class="number">2</span>, <span class="number">0</span>), <span class="number">0.785398</span>, <span class="number">12</span>);</span><br><span class="line"> </span><br><span class="line">  Application.ShowAlertDialog(<span class="string">&quot;\nPolarPoint: &quot;</span> +</span><br><span class="line">                              <span class="string">&quot;\nX = &quot;</span> + pt2.X +</span><br><span class="line">                              <span class="string">&quot;\nY = &quot;</span> + pt2.Y +</span><br><span class="line">                              <span class="string">&quot;\nZ = &quot;</span> + pt2.Z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用GetDistance方法查找两点之间的距离</strong></p>
<p>此示例使用 GetDistance 方法获取两个点并显示计算的距离。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.ApplicationServices;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.EditorInput;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.Runtime;</span><br><span class="line"> </span><br><span class="line">[<span class="meta">CommandMethod(<span class="string">&quot;GetDistanceBetweenTwoPoints&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">GetDistanceBetweenTwoPoints</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">  Document acDoc = Application.DocumentManager.MdiActiveDocument;</span><br><span class="line"> </span><br><span class="line">  PromptDoubleResult pDblRes;</span><br><span class="line">  pDblRes = acDoc.Editor.GetDistance(<span class="string">&quot;\nPick two points: &quot;</span>);</span><br><span class="line"> </span><br><span class="line">  Application.ShowAlertDialog(<span class="string">&quot;\nDistance between points: &quot;</span> +</span><br><span class="line">                              pDblRes.Value.ToString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="计算面积（-NET）"><a href="#计算面积（-NET）" class="headerlink" title="计算面积（.NET）"></a>计算面积（.NET）</h3><p>您可以使用 Area 属性查找弧、圆、椭圆、轻量曲面、多边形、面域、图案填充、平面闭合样条或任何其他从基本类型Curve派生的图元的面积。</p>
<p>如果需要计算多个对象的组合面积，则可以在添加一系列面域时保留累计面积，或对一系列面域使用布尔方法以获得表示所需面积的单个面域。从这个区域中，您可以使用 Area 属性来获取其面积。计算的面积根据查询的对象类型而不同。</p>
<p>本节中的主题</p>
<ul>
<li>计算定义的区域（.NET）</li>
</ul>
<h4 id="计算定义的区域（-NET）"><a href="#计算定义的区域（-NET）" class="headerlink" title="计算定义的区域（.NET）"></a>计算定义的区域（.NET）</h4><p>如果要计算的面积是基于用户指定的点，则可以考虑在内存中创建一个对象（如轻量级对象），然后在丢弃对象之前查询该对象的面积。以下步骤说明了如何实现此操作：</p>
<ol>
<li>在一个循环中使用 GetPoint 方法从用户那里获得点数。</li>
<li>从用户提供的点创建一个轻量级的图形。创建新的多段线对象。指定顶点的数量以及它们应该位于的点。</li>
<li>使用 Area 属性获取新创建的曲面的面积。</li>
<li>使用其 Dispose 方法处置该多段线。</li>
</ol>
<p><strong>计算由用户输入的点定义的面积</strong></p>
<p>此示例提示用户输入五个点。然后，将根据输入的点创建一个顶点。此时将关闭按钮，按钮的区域将显示在消息框中。由于未向块中添加缓存，因此需要在命令结束前将其释放。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.ApplicationServices;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.DatabaseServices;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.Geometry;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.EditorInput;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.Runtime;</span><br><span class="line"> </span><br><span class="line">[<span class="meta">CommandMethod(<span class="string">&quot;CalculateDefinedArea&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CalculateDefinedArea</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Prompt the user for 5 points</span></span><br><span class="line">    Document acDoc = Application.DocumentManager.MdiActiveDocument;</span><br><span class="line"> </span><br><span class="line">    PromptPointResult pPtRes;</span><br><span class="line">    Point2dCollection colPt = <span class="keyword">new</span> Point2dCollection();</span><br><span class="line">    PromptPointOptions pPtOpts = <span class="keyword">new</span> PromptPointOptions(<span class="string">&quot;&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Prompt for the first point</span></span><br><span class="line">    pPtOpts.Message = <span class="string">&quot;\nSpecify first point: &quot;</span>;</span><br><span class="line">    pPtRes = acDoc.Editor.GetPoint(pPtOpts);</span><br><span class="line">    colPt.Add(<span class="keyword">new</span> Point2d(pPtRes.Value.X, pPtRes.Value.Y));</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Exit if the user presses ESC or cancels the command</span></span><br><span class="line">    <span class="keyword">if</span> (pPtRes.Status == PromptStatus.Cancel) <span class="keyword">return</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">int</span> nCounter = <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span> (nCounter &lt;= <span class="number">4</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Prompt for the next points</span></span><br><span class="line">        <span class="keyword">switch</span>(nCounter)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                pPtOpts.Message = <span class="string">&quot;\nSpecify second point: &quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                pPtOpts.Message = <span class="string">&quot;\nSpecify third point: &quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                pPtOpts.Message = <span class="string">&quot;\nSpecify fourth point: &quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                pPtOpts.Message = <span class="string">&quot;\nSpecify fifth point: &quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// Use the previous point as the base point</span></span><br><span class="line">        pPtOpts.UseBasePoint = <span class="literal">true</span>;</span><br><span class="line">        pPtOpts.BasePoint = pPtRes.Value;</span><br><span class="line"> </span><br><span class="line">        pPtRes = acDoc.Editor.GetPoint(pPtOpts);</span><br><span class="line">        colPt.Add(<span class="keyword">new</span> Point2d(pPtRes.Value.X, pPtRes.Value.Y));</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (pPtRes.Status == PromptStatus.Cancel) <span class="keyword">return</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// Increment the counter</span></span><br><span class="line">        nCounter = nCounter + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Create a polyline with 5 points</span></span><br><span class="line">    <span class="keyword">using</span> (Polyline acPoly = <span class="keyword">new</span> Polyline())</span><br><span class="line">    &#123;</span><br><span class="line">        acPoly.AddVertexAt(<span class="number">0</span>, colPt[<span class="number">0</span>], <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        acPoly.AddVertexAt(<span class="number">1</span>, colPt[<span class="number">1</span>], <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        acPoly.AddVertexAt(<span class="number">2</span>, colPt[<span class="number">2</span>], <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        acPoly.AddVertexAt(<span class="number">3</span>, colPt[<span class="number">3</span>], <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        acPoly.AddVertexAt(<span class="number">4</span>, colPt[<span class="number">4</span>], <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// Close the polyline</span></span><br><span class="line">        acPoly.Closed = <span class="literal">true</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// Query the area of the polyline</span></span><br><span class="line">        Application.ShowAlertDialog(<span class="string">&quot;Area of polyline: &quot;</span> +</span><br><span class="line">                                    acPoly.Area.ToString());</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// Dispose of the polyline</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="提示用户输入（-NET）"><a href="#提示用户输入（-NET）" class="headerlink" title="提示用户输入（.NET）"></a>提示用户输入（.NET）</h2><p>作为 Document 对象的子对象的 Editor 对象定义用户输入方法。用户输入方法在AutoCAD命令行或动态输入工具提示中显示提示，并请求各种类型的输入。这种类型的用户输入对于屏幕坐标、实体选择和短字符串或数值的交互式输入最有用。如果应用程序需要输入大量选项或值，则Windows窗体可能比单个提示更合适。</p>
<p>每个用户输入法都在命令行上显示一个可选提示，并返回一个特定于所请求输入类型的值。例如， GetString 返回一个 PromptResult ，它允许您确定 GetString 方法的状态并检索用户输入的字符串。每个用户输入方法都有一个特定的返回值。</p>
<p>输入方法接受一个字符串作为显示的提示信息或一个控制用户输入的特定对象类型。这些对象类型允许您控制诸如 NULL 输入（按Enter键）、基点、零或负数的输入以及任意文本值的输入等操作。</p>
<p>若要强制提示符单独显示在一行中，请在使用VB.NET时在提示符字符串的开头使用回车&#x2F;换行常量 (vbCrLf) 或换行常量（vbLf），或在C#中使用字符串“\n”。</p>
<p>本节中的主题</p>
<ul>
<li>GetString方法（.NET）</li>
<li>GetPoint方法（.NET）</li>
<li>GetKeywords方法（.NET）</li>
<li>控制用户输入（.NET）</li>
</ul>
<h3 id="GetString方法（-NET）"><a href="#GetString方法（-NET）" class="headerlink" title="GetString方法（.NET）"></a>GetString方法（.NET）</h3><p>GetString 方法在命令提示符下提示用户输入字符串。 PromptStringOptions 对象允许您控制输入的内容以及提示消息的显示方式。 PromptStringOptions 对象的 AllowSpaces 属性控制在提示符下是否允许空格。如果设置为false，按空格键将终止输入。</p>
<p><strong>在命令行中从用户处获取字符串值</strong></p>
<p>下面的示例显示Enter Your Name提示，并要求通过按Enter键终止用户的输入（输入字符串中允许有空格）。输入的字符串将显示在消息框中。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.ApplicationServices;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.EditorInput;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.Runtime;</span><br><span class="line"> </span><br><span class="line">[<span class="meta">CommandMethod(<span class="string">&quot;GetStringFromUser&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">GetStringFromUser</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    Document acDoc = Application.DocumentManager.MdiActiveDocument;</span><br><span class="line"> </span><br><span class="line">    PromptStringOptions pStrOpts = <span class="keyword">new</span> PromptStringOptions(<span class="string">&quot;\nEnter your name: &quot;</span>);</span><br><span class="line">    pStrOpts.AllowSpaces = <span class="literal">true</span>;</span><br><span class="line">    PromptResult pStrRes = acDoc.Editor.GetString(pStrOpts);</span><br><span class="line"> </span><br><span class="line">    Application.ShowAlertDialog(<span class="string">&quot;The name entered was: &quot;</span> +</span><br><span class="line">                                pStrRes.StringResult);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="GetPoint方法（-NET）"><a href="#GetPoint方法（-NET）" class="headerlink" title="GetPoint方法（.NET）"></a>GetPoint方法（.NET）</h3><p>GetPoint 方法提示用户在命令提示下指定点。 PromptPointOptions 对象允许您控制输入的内容以及提示消息的显示方式。 PromptPointOptions 对象的 UseBasePoint 和 BasePoint 属性控制是否从基点绘制rubber-band线。除了指定点之外，还可以使用 PromptPointOptions 对象的 Keywords 特性定义可以在命令提示下输入的关键字。</p>
<p><strong>获取用户选择的点</strong></p>
<p>下面的示例提示用户输入两个点，然后使用这两个点作为起点和终点绘制一条直线。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.ApplicationServices;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.DatabaseServices;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.EditorInput;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.Geometry;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.Runtime;</span><br><span class="line"> </span><br><span class="line">[<span class="meta">CommandMethod(<span class="string">&quot;GetPointsFromUser&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">GetPointsFromUser</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Get the current database and start the Transaction Manager</span></span><br><span class="line">    Document acDoc = Application.DocumentManager.MdiActiveDocument;</span><br><span class="line">    Database acCurDb = acDoc.Database;</span><br><span class="line"></span><br><span class="line">    PromptPointResult pPtRes;</span><br><span class="line">    PromptPointOptions pPtOpts = <span class="keyword">new</span> PromptPointOptions(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Prompt for the start point</span></span><br><span class="line">    pPtOpts.Message = <span class="string">&quot;\nEnter the start point of the line: &quot;</span>;</span><br><span class="line">    pPtRes = acDoc.Editor.GetPoint(pPtOpts);</span><br><span class="line">    Point3d ptStart = pPtRes.Value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Exit if the user presses ESC or cancels the command</span></span><br><span class="line">    <span class="keyword">if</span> (pPtRes.Status == PromptStatus.Cancel) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Prompt for the end point</span></span><br><span class="line">    pPtOpts.Message = <span class="string">&quot;\nEnter the end point of the line: &quot;</span>;</span><br><span class="line">    pPtOpts.UseBasePoint = <span class="literal">true</span>;</span><br><span class="line">    pPtOpts.BasePoint = ptStart;</span><br><span class="line">    pPtRes = acDoc.Editor.GetPoint(pPtOpts);</span><br><span class="line">    Point3d ptEnd = pPtRes.Value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pPtRes.Status == PromptStatus.Cancel) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start a transaction</span></span><br><span class="line">    <span class="keyword">using</span> (Transaction acTrans = acCurDb.TransactionManager.StartTransaction())</span><br><span class="line">    &#123;</span><br><span class="line">        BlockTable acBlkTbl;</span><br><span class="line">        BlockTableRecord acBlkTblRec;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Open Model space for write</span></span><br><span class="line">        acBlkTbl = acTrans.GetObject(acCurDb.BlockTableId,</span><br><span class="line">                                        OpenMode.ForRead) <span class="keyword">as</span> BlockTable;</span><br><span class="line"></span><br><span class="line">        acBlkTblRec = acTrans.GetObject(acBlkTbl[BlockTableRecord.ModelSpace],</span><br><span class="line">                                        OpenMode.ForWrite) <span class="keyword">as</span> BlockTableRecord;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Define the new line</span></span><br><span class="line">        <span class="keyword">using</span> (Line acLine = <span class="keyword">new</span> Line(ptStart, ptEnd))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Add the line to the drawing</span></span><br><span class="line">            acBlkTblRec.AppendEntity(acLine);</span><br><span class="line">            acTrans.AddNewlyCreatedDBObject(acLine, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Zoom to the extents or limits of the drawing</span></span><br><span class="line">        acDoc.SendStringToExecute(<span class="string">&quot;._zoom _all &quot;</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Commit the changes and dispose of the transaction</span></span><br><span class="line">        acTrans.Commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="GetKeywords方法（-NET）"><a href="#GetKeywords方法（-NET）" class="headerlink" title="GetKeywords方法（.NET）"></a>GetKeywords方法（.NET）</h3><p>GetKeywords 方法在命令提示符下提示用户输入关键字。 PromptKeywordOptions 对象允许您控制输入的内容以及提示消息的显示方式。 PromptKeywordOptions 对象的 Keywords 属性允许您定义可以在命令提示符下输入的关键字。</p>
<p><strong>注意：</strong>下划线字符（“_”）具有特殊含义，不能用作关键字或关键字的一部分。</p>
<p><strong>在命令行中从用户处获取关键字</strong></p>
<p>下面的示例通过将属性 AllowNone 设置为false来强制用户输入关键字，这将禁止 NULL 输入（按Enter键）。 Keywords 属性用于添加允许的有效关键字。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.ApplicationServices;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.EditorInput;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.Runtime;</span><br><span class="line"> </span><br><span class="line">[<span class="meta">CommandMethod(<span class="string">&quot;GetKeywordFromUser&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">GetKeywordFromUser</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    Document acDoc = Application.DocumentManager.MdiActiveDocument;</span><br><span class="line"></span><br><span class="line">    PromptKeywordOptions pKeyOpts = <span class="keyword">new</span> PromptKeywordOptions(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    pKeyOpts.Message = <span class="string">&quot;\nEnter an option &quot;</span>;</span><br><span class="line">    pKeyOpts.Keywords.Add(<span class="string">&quot;Line&quot;</span>);</span><br><span class="line">    pKeyOpts.Keywords.Add(<span class="string">&quot;Circle&quot;</span>);</span><br><span class="line">    pKeyOpts.Keywords.Add(<span class="string">&quot;Arc&quot;</span>);</span><br><span class="line">    pKeyOpts.AllowNone = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    PromptResult pKeyRes = acDoc.Editor.GetKeywords(pKeyOpts);</span><br><span class="line"></span><br><span class="line">    Application.ShowAlertDialog(<span class="string">&quot;Entered keyword: &quot;</span> +</span><br><span class="line">                                pKeyRes.StringResult);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更用户友好的关键字提示符是在用户按Enter（ NULL input）时提供默认值的提示符。请注意对以下示例的微小修改。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.ApplicationServices;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.EditorInput;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.Runtime;</span><br><span class="line"> </span><br><span class="line">[<span class="meta">CommandMethod(<span class="string">&quot;GetKeywordFromUser2&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">GetKeywordFromUser2</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    Document acDoc = Application.DocumentManager.MdiActiveDocument;</span><br><span class="line"></span><br><span class="line">    PromptKeywordOptions pKeyOpts = <span class="keyword">new</span> PromptKeywordOptions(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    pKeyOpts.Message = <span class="string">&quot;\nEnter an option &quot;</span>;</span><br><span class="line">    pKeyOpts.Keywords.Add(<span class="string">&quot;Line&quot;</span>);</span><br><span class="line">    pKeyOpts.Keywords.Add(<span class="string">&quot;Circle&quot;</span>);</span><br><span class="line">    pKeyOpts.Keywords.Add(<span class="string">&quot;Arc&quot;</span>);</span><br><span class="line">    pKeyOpts.Keywords.Default = <span class="string">&quot;Arc&quot;</span>;</span><br><span class="line">    pKeyOpts.AllowNone = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    PromptResult pKeyRes = acDoc.Editor.GetKeywords(pKeyOpts);</span><br><span class="line"></span><br><span class="line">    Application.ShowAlertDialog(<span class="string">&quot;Entered keyword: &quot;</span> +</span><br><span class="line">                                pKeyRes.StringResult);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="控制用户输入（-NET）"><a href="#控制用户输入（-NET）" class="headerlink" title="控制用户输入（.NET）"></a>控制用户输入（.NET）</h3><p>在收集用户的输入时，您需要确保限制他们可以输入的信息类型，以便获得所需的响应。各种提示选项对象不仅用于定义在命令提示下显示的提示，还用于限制用户可以提供的输入。使用某些输入法，您不仅可以根据所使用的方法类型获得返回值，还可以获得关键字。</p>
<p>例如，您可以使用 GetPoint 方法让用户指定一个点或使用关键字进行响应。这就是LINE、CIRCLE和PLINE等命令的工作方式。</p>
<p><strong>获取整数值或关键字</strong></p>
<p>下面的示例提示用户输入正的非零整数值或关键字。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.ApplicationServices;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.EditorInput;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.Runtime;</span><br><span class="line"> </span><br><span class="line">[<span class="meta">CommandMethod(<span class="string">&quot;GetIntegerOrKeywordFromUser&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">GetIntegerOrKeywordFromUser</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    Document acDoc = Application.DocumentManager.MdiActiveDocument;</span><br><span class="line"></span><br><span class="line">    PromptIntegerOptions pIntOpts = <span class="keyword">new</span> PromptIntegerOptions(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    pIntOpts.Message = <span class="string">&quot;\nEnter the size or &quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Restrict input to positive and non-negative values</span></span><br><span class="line">    pIntOpts.AllowZero = <span class="literal">false</span>;</span><br><span class="line">    pIntOpts.AllowNegative = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Define the valid keywords and allow Enter</span></span><br><span class="line">    pIntOpts.Keywords.Add(<span class="string">&quot;Big&quot;</span>);</span><br><span class="line">    pIntOpts.Keywords.Add(<span class="string">&quot;Small&quot;</span>);</span><br><span class="line">    pIntOpts.Keywords.Add(<span class="string">&quot;Regular&quot;</span>);</span><br><span class="line">    pIntOpts.Keywords.Default = <span class="string">&quot;Regular&quot;</span>;</span><br><span class="line">    pIntOpts.AllowNone = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get the value entered by the user</span></span><br><span class="line">    PromptIntegerResult pIntRes = acDoc.Editor.GetInteger(pIntOpts);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pIntRes.Status == PromptStatus.Keyword)</span><br><span class="line">    &#123;</span><br><span class="line">        Application.ShowAlertDialog(<span class="string">&quot;Entered keyword: &quot;</span> +</span><br><span class="line">                                    pIntRes.StringResult);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        Application.ShowAlertDialog(<span class="string">&quot;Entered value: &quot;</span> +</span><br><span class="line">                                    pIntRes.Value.ToString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="访问命令行（-NET）"><a href="#访问命令行（-NET）" class="headerlink" title="访问命令行（.NET）"></a>访问命令行（.NET）</h2><p>您可以使用 SendStringToExecute 方法将命令直接发送到命令行。 SendStringToExecute 方法向命令行发送一个字符串。该字符串必须包含命令的参数，这些参数按照所执行命令的提示序列的预期顺序列出。</p>
<p>字符串中的空格或相当于回车的ASCII等效项相当于按键盘上的Enter键。与AutoLISP环境不同，调用不带参数的 SendStringToExecute 方法是无效的。</p>
<p>使用 SendStringToExecute 执行的命令是异步的，并且在.NET命令结束之前不会调用。如果你需要立即（同步）执行一个命令，你应该：</p>
<ul>
<li>使用COM自动化库的 SendCommand 方法，可以使用.NET COM Interop访问该库</li>
<li>P&#x2F;Invoke为本地AutoCAD命令和使用ObjectARX或.NET API定义的命令调用非托管 acedCommand 或 acedCmd 方法</li>
<li>P&#x2F;Invoke为通过AutoLISP定义的命令启用非托管 acedInvoke 方法</li>
</ul>
<p><strong>向命令行发送命令</strong></p>
<p>下面的示例创建一个圆心为（2，2，0）、半径为4的圆。然后将图形缩放到图形中的所有几何图形。请注意，字符串末尾有一个空格，表示最后一次按Enter键以开始执行命令。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.ApplicationServices;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.Runtime;</span><br><span class="line"> </span><br><span class="line">[<span class="meta">CommandMethod(<span class="string">&quot;SendACommandToAutoCAD&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SendACommandToAutoCAD</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">  Document acDoc = Application.DocumentManager.MdiActiveDocument;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// Draws a circle and zooms to the extents or </span></span><br><span class="line">  <span class="comment">// limits of the drawing</span></span><br><span class="line">  acDoc.SendStringToExecute(<span class="string">&quot;._circle 2,2,0 4 &quot;</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">  acDoc.SendStringToExecute(<span class="string">&quot;._zoom _all &quot;</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="扩展AutoCAD用户界面（-NET）"><a href="#扩展AutoCAD用户界面（-NET）" class="headerlink" title="扩展AutoCAD用户界面（.NET）"></a><strong>扩展AutoCAD用户界面（.NET）</strong></h2><p>自定义对话框可用于获取用户输入并扩展AutoCAD用户界面的功能。</p>
<p>AutoCAD托管.NET类允许应用程序访问许多AutoCAD UI资源，并合并新的对话框或表单。 Autodesk.AutoCAD.Windows 命名空间中的某些类提供对AutoCAD要素对话框（如线型和颜色）的访问。这些类提供了一个显示表单的 ShowDialog 方法。当使用这些类时，应用程序自动获得对话框大小和位置设置的持久性。</p>
<p>Autodesk.AutoCAD.Windows 命名空间还公开了用于访问AutoCAD用户界面的某些可扩展元素（包括选项板和选项板集、托盘项目和状态栏）的界面。与工具选项板相关的类和接口位于 Autodesk.AutoCAD.Windows.ToolPalette 命名空间中。可以通过 Autodesk.AutoCAD.Windows.Visuals 类访问AutoCAD图标以及拾取点和拾取集位图。</p>
<p>AutoCAD托管的.NET API中的自定义对话框或表单直接从 System.Windows.Forms 命名空间扩展类。但是，这样的应用程序不应该调用 Form.ShowDialog 方法，而是使用 Autodesk.AutoCAD.ApplicationServices.Application.ShowModalDialog 和 ShowModelessDialog 方法来显示它们的自定义表单。在AutoCAD扩展应用程序中使用 Form.ShowDialog 可能会导致意外行为。</p>
<h2 id="注：翻译自ObjectARX-Managed-NET-Developer’s-Guide，且只保留了C-部分的代码"><a href="#注：翻译自ObjectARX-Managed-NET-Developer’s-Guide，且只保留了C-部分的代码" class="headerlink" title="注：翻译自ObjectARX: Managed .NET Developer’s Guide，且只保留了C#部分的代码"></a><em><strong>注：</strong></em>翻译自<a href="https://help.autodesk.com/view/OARX/2024/ENU/?guid=GUID-C3F3C736-40CF-44A0-9210-55F6A939B6F2">ObjectARX: Managed .NET Developer’s Guide</a>，且只保留了C#部分的代码</h2>]]></content>
      <categories>
        <category>ObjectARX：Managed.NET开发人员指南</category>
      </categories>
      <tags>
        <tag>CAD</tag>
      </tags>
  </entry>
  <entry>
    <title>Revit与Excel交互</title>
    <url>/2025/01/16/Revit%E4%BA%8C%E5%BC%80%E7%A4%BA%E4%BE%8B/Revit%E4%B8%8EExcel%E4%BA%A4%E4%BA%92/</url>
    <content><![CDATA[<iframe src="/iframe/Revit%E4%B8%8EExcel%E4%BA%A4%E4%BA%92.gif" width="700" height="850" frameborder="0" loading="lazy" allowfullscreen></iframe>

<p>Excel检测更改自动保存，Revit自动读取数据生成元素</p>
]]></content>
      <categories>
        <category>Revit二开示例</category>
      </categories>
      <tags>
        <tag>Revit</tag>
      </tags>
  </entry>
  <entry>
    <title>线程</title>
    <url>/2024/12/30/CSharp/%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><p><img src="C:\Users\funtim\AppData\Roaming\Typora\typora-user-images\image-20241130220945830.png" alt="image-20241130220945830"></p>
<h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Thread thread1 = <span class="keyword">new</span> Thread(Methode);</span><br></pre></td></tr></table></figure>

<h4 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">thread1.Start();</span><br></pre></td></tr></table></figure>

<h4 id="等待完成"><a href="#等待完成" class="headerlink" title="等待完成"></a>等待完成</h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">thread1.Join();</span><br></pre></td></tr></table></figure>

<h4 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">thread1.Priority=ThreadPriority.Highest;<span class="comment">//优先级和线程调度器时间片都会影响顺序</span></span><br></pre></td></tr></table></figure>

<h4 id="名字"><a href="#名字" class="headerlink" title="名字"></a>名字</h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">thread1.Name=<span class="string">&quot;001&quot;</span>;</span><br></pre></td></tr></table></figure>

<h4 id="当前线程优先级"><a href="#当前线程优先级" class="headerlink" title="当前线程优先级"></a>当前线程优先级</h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Thread.CurrentThread.Priority=ThreadPriority.Normal;</span><br></pre></td></tr></table></figure>

<h4 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">lock</span> (counterLock) &#123; counter += <span class="number">1</span>; &#125;</span><br></pre></td></tr></table></figure>

<h4 id="监视器"><a href="#监视器" class="headerlink" title="监视器"></a>监视器</h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//尝试进入临界区</span></span><br><span class="line"><span class="keyword">if</span> (Monitor.TryEnter(ticketslock, <span class="number">2000</span>))    </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">try</span></span><br><span class="line">		&#123;</span><br><span class="line">            ......</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">finally</span></span><br><span class="line">		&#123;</span><br><span class="line">			Monitor.Exit(ticketslock);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	&#123;<span class="comment">//超时，未进入临界区</span></span><br><span class="line">	   ......</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h4 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//可在进程内，也跨进程，filePath：共享的互斥体</span></span><br><span class="line"><span class="keyword">using</span> (<span class="keyword">var</span> mutex = <span class="keyword">new</span> Mutex(<span class="literal">false</span>, <span class="string">$&quot;GlobalFileMutex:<span class="subst">&#123;filePath&#125;</span>&quot;</span>))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        mutex.WaitOne();<span class="comment">//获取互斥体</span></span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">           ......</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> </span><br><span class="line">        &#123;</span><br><span class="line">          mutex.ReleaseMutex();</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">bool</span> lockAcquired = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    _lock.EnterWriteLock();<span class="comment">//读</span></span><br><span class="line">    lockAcquired = <span class="literal">true</span>;<span class="comment">//确保获取了锁</span></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (lockAcquired)</span><br><span class="line"></span><br><span class="line">        _lock.ExitWriteLock();</span><br><span class="line">&#125;</span><br><span class="line">-------------------------------------------------------------------------------------------------------------------</span><br><span class="line">  <span class="built_in">bool</span> lockAcquired = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">try</span></span><br><span class="line">  &#123;</span><br><span class="line">      _lock.EnterReadLock();<span class="comment">//写</span></span><br><span class="line">      lockAcquired = <span class="literal">true</span>;      </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">finally</span></span><br><span class="line">  &#123;</span><br><span class="line">      <span class="keyword">if</span> (lockAcquired)</span><br><span class="line">          _lock.ExitReadLock();</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h4 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> SemaphoreSlim semaphore = <span class="keyword">new</span> SemaphoreSlim(initialCount: <span class="number">3</span>, maxCount: <span class="number">3</span>);<span class="comment">//设置线程数量</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">semaphore.Wait();<span class="comment">//等待信号量,数量-1,等待和释放不必在同一个线程中</span></span><br><span class="line">Thread thread = <span class="keyword">new</span> Thread(() =&gt; ProcessBooking(input));</span><br><span class="line">thread.Start();	</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ProcessBooking</span>(<span class="params"><span class="built_in">string</span>? input</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">	&#123;</span><br><span class="line">       ......</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">finally</span></span><br><span class="line">	&#123;</span><br><span class="line">		semaphore.Release();<span class="comment">//释放信号量</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="自动重置事件"><a href="#自动重置事件" class="headerlink" title="自动重置事件"></a>自动重置事件</h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> AutoResetEvent autoResetEvent = <span class="keyword">new</span> AutoResetEvent(<span class="literal">false</span>);<span class="comment">//初始信号false</span></span><br><span class="line"><span class="comment">//消费者线程</span></span><br><span class="line"><span class="comment">//autoResetEvent.WaitOne();</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//生产者线程</span></span><br><span class="line"><span class="comment">//autoResetEvent.Set();</span></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">	userInput = Console.ReadLine()??<span class="string">&quot;&quot;</span>;</span><br><span class="line">	<span class="keyword">if</span> (userInput==<span class="string">&quot;go&quot;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		autoResetEvent.Set();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Worker</span>()</span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		Console.WriteLine(<span class="string">$&quot;worker<span class="subst">&#123;Thread.CurrentThread.Name&#125;</span> thread is waiting for the signal&quot;</span>);</span><br><span class="line">		autoResetEvent.WaitOne();</span><br><span class="line">		Console.WriteLine(<span class="string">$&quot;worker<span class="subst">&#123;Thread.CurrentThread.Name&#125;</span>  thread proceeds&quot;</span>);</span><br><span class="line">		Thread.Sleep(<span class="number">2000</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="手动重置事件"><a href="#手动重置事件" class="headerlink" title="手动重置事件"></a>手动重置事件</h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> ManualResetEventSlim manualResetEvent = <span class="keyword">new</span> ManualResetEventSlim(<span class="literal">false</span>);</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">	userInput = Console.ReadLine() ?? <span class="string">&quot;&quot;</span>;</span><br><span class="line">	<span class="keyword">if</span> (userInput == <span class="string">&quot;wt&quot;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		manualResetEvent.Reset();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (userInput == <span class="string">&quot;go&quot;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		manualResetEvent.Set();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Work</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (userInput == <span class="string">&quot;wt&quot;</span>)</span><br><span class="line">			Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;Thread.CurrentThread.Name&#125;</span> is waiting for the signal...&quot;</span>);</span><br><span class="line">		manualResetEvent.Wait();</span><br><span class="line">		Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;Thread.CurrentThread.Name&#125;</span> has Working.&quot;</span>);</span><br><span class="line">		Thread.Sleep(<span class="number">1000</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="双向信号传递"><a href="#双向信号传递" class="headerlink" title="双向信号传递"></a>双向信号传递</h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Queue&lt;<span class="built_in">int</span>&gt; queue = <span class="keyword">new</span> Queue&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line"></span><br><span class="line">ManualResetEventSlim consumeEvent = <span class="keyword">new</span> ManualResetEventSlim(<span class="literal">false</span>);</span><br><span class="line">ManualResetEventSlim prodeceEvent = <span class="keyword">new</span> ManualResetEventSlim(<span class="literal">true</span>);</span><br><span class="line"><span class="built_in">int</span> consumeCounter = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">object</span> lockConsumerCounter = <span class="keyword">new</span> <span class="built_in">object</span>();</span><br><span class="line">Thread[] consumerThreads = <span class="keyword">new</span> Thread[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">	consumerThreads[i] = <span class="keyword">new</span> Thread(Consume);</span><br><span class="line">	consumerThreads[i].Name = <span class="string">$&quot;Consumer<span class="subst">&#123;i + <span class="number">1</span>&#125;</span>&quot;</span>;</span><br><span class="line">	consumerThreads[i].Start();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//生产者</span></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">	prodeceEvent.Wait();</span><br><span class="line">	prodeceEvent.Reset();</span><br><span class="line">	Console.WriteLine(<span class="string">&quot;To produce , enter &#x27;p&#x27;&quot;</span>);</span><br><span class="line">	<span class="keyword">var</span> input = Console.ReadLine() ?? <span class="string">&quot;&quot;</span>;</span><br><span class="line">	<span class="keyword">if</span> (input.ToLower() == <span class="string">&quot;p&quot;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			queue.Enqueue(i);</span><br><span class="line">			Console.WriteLine(<span class="string">$&quot;Produced:<span class="subst">&#123;i&#125;</span>&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		consumeEvent.Set();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//消费者行为</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Consume</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="built_in">int</span> i = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">int</span> j = <span class="number">0</span>;</span><br><span class="line">		consumeEvent.Wait();</span><br><span class="line">		<span class="keyword">while</span> (queue.TryDequeue(<span class="keyword">out</span> <span class="built_in">int</span> item))</span><br><span class="line">		&#123;</span><br><span class="line">			i++;<span class="comment">//当前消费者消耗产品的总数</span></span><br><span class="line">			Thread.Sleep(<span class="number">500</span>);</span><br><span class="line">			Console.WriteLine(<span class="string">$&quot;Consume:<span class="subst">&#123;item&#125;</span> product, from thead:<span class="subst">&#123;Thread.CurrentThread.Name&#125;</span>&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		j++;</span><br><span class="line">		<span class="keyword">lock</span> (lockConsumerCounter)</span><br><span class="line">		&#123;<span class="comment">//当前消费者在第一次消费完所有产品时，进入</span></span><br><span class="line">			<span class="keyword">if</span> (j == <span class="number">1</span> &amp;&amp; i != <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;Thread.CurrentThread.Name&#125;</span>  +<span class="subst">&#123;i&#125;</span>&quot;</span>);</span><br><span class="line">				consumeCounter++;</span><br><span class="line">				<span class="comment">//如果三个消费者把所有产品消耗完了</span></span><br><span class="line">				<span class="keyword">if</span> (consumeCounter == <span class="number">3</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					consumeEvent.Reset();</span><br><span class="line">					prodeceEvent.Set();</span><br><span class="line">					consumeCounter = <span class="number">0</span>;</span><br><span class="line">					Console.WriteLine(<span class="string">&quot;----------------------------&quot;</span>);</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">object</span> userLock=<span class="keyword">new</span> <span class="built_in">object</span>();</span><br><span class="line"><span class="built_in">object</span> orderLock=<span class="keyword">new</span> <span class="built_in">object</span>();</span><br><span class="line"></span><br><span class="line">Thread thread=<span class="keyword">new</span> Thread(ManageOrder);</span><br><span class="line">thread.Start();</span><br><span class="line"></span><br><span class="line">ManageUesr();</span><br><span class="line"></span><br><span class="line">thread.Join();</span><br><span class="line"></span><br><span class="line">Console.WriteLine(<span class="string">&quot;Program finished. press any key to exit.&quot;</span>);</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ManageUesr</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">lock</span> (userLock)</span><br><span class="line">	&#123;</span><br><span class="line">		Console.WriteLine(<span class="string">&quot;User Management acuired the user lock&quot;</span>);</span><br><span class="line">		Thread.Sleep(<span class="number">2000</span>);</span><br><span class="line">		<span class="keyword">lock</span> (orderLock)</span><br><span class="line">		&#123;</span><br><span class="line">			Console.WriteLine(<span class="string">&quot;User Management acquired the order lock&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ManageOrder</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">lock</span> (orderLock)</span><br><span class="line">	&#123;</span><br><span class="line">		Console.WriteLine(<span class="string">&quot;Order Management acuired the order lock&quot;</span>);</span><br><span class="line">		Thread.Sleep(<span class="number">1000</span>);</span><br><span class="line">		<span class="keyword">lock</span> (userLock)</span><br><span class="line">		&#123;</span><br><span class="line">			Console.WriteLine(<span class="string">&quot;Order Management acquired the user lock&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">thread1.ThreadState</span><br></pre></td></tr></table></figure>

<h4 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">ThreadPool.QueueUserWorkItem(ProcessBooking,input);</span><br><span class="line">Thread.CurrentThread.IsThreadPoolThread;<span class="comment">//是否是线程池线程</span></span><br></pre></td></tr></table></figure>

<h4 id="线程中的异常处理"><a href="#线程中的异常处理" class="headerlink" title="线程中的异常处理"></a>线程中的异常处理</h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> exceptions = <span class="keyword">new</span> List&lt;Exception&gt;();</span><br><span class="line"></span><br><span class="line"><span class="built_in">object</span> lockexceptions = <span class="keyword">new</span> <span class="built_in">object</span>(); </span><br><span class="line">Thread thread1 = <span class="keyword">new</span> Thread(Work);</span><br><span class="line">Thread thread2 = <span class="keyword">new</span> Thread(Work);</span><br><span class="line">thread1.Start();</span><br><span class="line">thread2.Start();</span><br><span class="line"></span><br><span class="line">thread1.Join();</span><br><span class="line">thread2.Join();</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> exceptions)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(  item.Message);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Work</span>(<span class="params"><span class="built_in">object</span>? obj</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">try</span></span><br><span class="line">	&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InvalidOperationException(<span class="string">&quot;An error occurred in this worker thread. This is expected.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception ex)</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="keyword">lock</span> (lockexceptions)</span><br><span class="line">        exceptions.Add(ex);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">await</span> Task.Run(() =&gt; Console.WriteLine(<span class="string">&quot;888&quot;</span>));</span><br><span class="line"><span class="keyword">var</span> tesk = Task.Run(() =&gt; Console.WriteLine(<span class="string">&quot;666&quot;</span>));</span><br><span class="line">Console.WriteLine(<span class="string">&quot;777&quot;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="从任务返回结果"><a href="#从任务返回结果" class="headerlink" title="从任务返回结果"></a>从任务返回结果</h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> tasks = Task.Run(() =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> ......</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="Wait-WaitAll-Result"><a href="#Wait-WaitAll-Result" class="headerlink" title="Wait,WaitAll,Result"></a>Wait,WaitAll,Result</h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">task.Wait();<span class="comment">//等待任务完成</span></span><br><span class="line"><span class="comment">//Task.WaitAll(task,task1);//等待多个任务完成</span></span><br><span class="line"><span class="comment">//var result=task.Result;//阻塞线程,返回结果</span></span><br></pre></td></tr></table></figure>

<h4 id="ContinueWith"><a href="#ContinueWith" class="headerlink" title="ContinueWith"></a>ContinueWith</h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Text.Json;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">var</span> client = <span class="keyword">new</span> HttpClient();</span><br><span class="line"><span class="keyword">var</span> task = client.GetStringAsync(<span class="string">&quot;https://pokeapi.co/api/v2/pokemon&quot;</span>);</span><br><span class="line">task.ContinueWith(t =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> result = t.Result;</span><br><span class="line">   <span class="keyword">var</span> doc=JsonDocument.Parse(result);</span><br><span class="line">    JsonElement root=doc.RootElement;</span><br><span class="line">    JsonElement results = root.GetProperty(<span class="string">&quot;results&quot;</span>);</span><br><span class="line">    JsonElement firstPokemon = results[<span class="number">0</span>];</span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;firstPokemon.GetProperty(<span class="string">&quot;name&quot;</span>)&#125;</span>,<span class="subst">&#123;firstPokemon.GetProperty(<span class="string">&quot;url&quot;</span>)&#125;</span>&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">Console.WriteLine(<span class="string">&quot;666&quot;</span>);</span><br><span class="line">Console.ReadLine();</span><br></pre></td></tr></table></figure>

<h4 id="WhenAll、Any"><a href="#WhenAll、Any" class="headerlink" title="WhenAll、Any"></a>WhenAll、Any</h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Console.WriteLine((tasks.Sum(t =&gt; t.Result)));//会阻塞主线程</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//全部任务完成时</span></span><br><span class="line">Task.WhenAll(tasks)</span><br><span class="line">    .ContinueWith(t =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">       Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;t.Result.Sum()&#125;</span>&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="comment">//当有任务完成时</span></span><br><span class="line"><span class="comment">//Task.WhenAny(tasks)</span></span><br><span class="line"><span class="comment">//    .ContinueWith(t =&gt;</span></span><br><span class="line"><span class="comment">//    &#123;</span></span><br><span class="line"><span class="comment">//       Console.WriteLine($&quot;&#123;t.Result.Result&#125;&quot;);</span></span><br><span class="line"><span class="comment">//    &#125;);</span></span><br></pre></td></tr></table></figure>

<h4 id="延续链与解包"><a href="#延续链与解包" class="headerlink" title="延续链与解包"></a>延续链与解包</h4><p><img src="C:\Users\funtim\AppData\Roaming\Typora\typora-user-images\image-20241202105506144.png" alt="image-20241202105506144"></p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Text.Json;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">var</span> client = <span class="keyword">new</span> System.Net.Http.HttpClient();</span><br><span class="line"><span class="keyword">var</span> taskListJson = client.GetStringAsync(<span class="string">&quot;https://pokeapi.co/api/v2/pokemon&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> taskGetfirstUrl = taskListJson.ContinueWith(t =&gt;</span><br><span class="line">&#123;<span class="comment">//得到上一个task的结果</span></span><br><span class="line">    <span class="keyword">var</span> result = t.Result;</span><br><span class="line">    <span class="keyword">var</span> doc = JsonDocument.Parse(result);</span><br><span class="line">    JsonElement root = doc.RootElement;</span><br><span class="line">    JsonElement results = root.GetProperty(<span class="string">&quot;results&quot;</span>);</span><br><span class="line">    JsonElement firstPokemon = results[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">return</span> firstPokemon.GetProperty(<span class="string">&quot;url&quot;</span>).ToString();</span><br><span class="line">&#125;); </span><br><span class="line"><span class="keyword">var</span> taskGetDetail = taskGetfirstUrl.ContinueWith(t =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> result = t.Result;</span><br><span class="line">    <span class="keyword">return</span> client.GetStringAsync(result);</span><br><span class="line">&#125;).Unwrap();<span class="comment">//解包</span></span><br><span class="line">taskGetDetail.ContinueWith(t =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> result = t.Result;</span><br><span class="line">    <span class="keyword">var</span> doc = JsonDocument.Parse(result);</span><br><span class="line">    JsonElement root = doc.RootElement;</span><br><span class="line">    <span class="keyword">var</span> results1 = root.GetProperty(<span class="string">&quot;name&quot;</span>).ToString();</span><br><span class="line">    <span class="keyword">var</span> results2 = root.GetProperty(<span class="string">&quot;weight&quot;</span>).ToString();</span><br><span class="line">    <span class="keyword">var</span> results3 = root.GetProperty(<span class="string">&quot;height&quot;</span>).ToString();</span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;name:<span class="subst">&#123;results1&#125;</span>\nweight:<span class="subst">&#123;results2&#125;</span>\nheight:<span class="subst">&#123;results3&#125;</span>&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">Console.WriteLine(<span class="string">&quot;666&quot;</span>);</span><br><span class="line">Console.ReadLine();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="任务中的异常处理"><a href="#任务中的异常处理" class="headerlink" title="任务中的异常处理"></a>任务中的异常处理</h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> task1 = client.GetStringAsync(<span class="string">&quot;https://pokeapi123.co/api/v2/pokemon&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (task1.IsFaulted &amp;&amp; task1.Exception != <span class="literal">null</span>) <span class="comment">//抛出异常</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> task1.Exception.InnerExceptions)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(item.Message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> tasks = <span class="keyword">new</span>[]</span><br><span class="line">&#123;</span><br><span class="line">    Task.Run(() =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InvalidOperationException(<span class="string">&quot;Invalid Operation&quot;</span>);</span><br><span class="line">    &#125;),</span><br><span class="line">    Task.Run(() =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentNullException(<span class="string">&quot;Argument null&quot;</span>);</span><br><span class="line">    &#125;),</span><br><span class="line">    Task.Run(() =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;General exception&quot;</span>);</span><br><span class="line">    &#125;),</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//var t=Task.WhenAll(tasks);</span></span><br><span class="line"><span class="comment">//t.Wait();</span></span><br><span class="line"><span class="comment">//var tesult=t.Result;//用result和wait都可以抛出异常</span></span><br><span class="line"></span><br><span class="line">Task.WhenAll(tasks)</span><br><span class="line">    .ContinueWith(t =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (t.IsFaulted&amp;&amp;t.Exception!=<span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> t.Exception.InnerExceptions)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(item.Message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">Console.WriteLine(<span class="string">&quot;Press enter key to exit&quot;</span>);</span><br><span class="line">Console.ReadLine();</span><br></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Text.Json;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">var</span> client = <span class="keyword">new</span> System.Net.Http.HttpClient();</span><br><span class="line">    <span class="keyword">var</span> task1 = client.GetStringAsync(<span class="string">&quot;https://pokeapi123.co/api/v2/pokemon&quot;</span>);</span><br><span class="line">    <span class="keyword">var</span> task2 = task1.ContinueWith(</span><br><span class="line">        t =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> result = t.Result;</span><br><span class="line">            <span class="keyword">var</span> doc = JsonDocument.Parse(result);</span><br><span class="line">            JsonElement root = doc.RootElement;</span><br><span class="line">            JsonElement results = root.GetProperty(<span class="string">&quot;results&quot;</span>);</span><br><span class="line">            JsonElement firstPokemon = results[<span class="number">0</span>];</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;firstPokemon.GetProperty(<span class="string">&quot;name&quot;</span>)&#125;</span>,<span class="subst">&#123;firstPokemon.GetProperty(<span class="string">&quot;url&quot;</span>)&#125;</span>&quot;</span>);</span><br><span class="line">        &#125;,</span><br><span class="line">        TaskContinuationOptions.NotOnFaulted<span class="comment">//添加执行条件,当前一个任务无异常时执行</span></span><br><span class="line">    ); </span><br><span class="line"></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;666&quot;</span>);</span><br><span class="line">    Console.ReadLine();</span><br></pre></td></tr></table></figure>

<h4 id="任务取消"><a href="#任务取消" class="headerlink" title="任务取消"></a>任务取消</h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">var</span> cts=<span class="keyword">new</span> CancellationTokenSource();</span><br><span class="line"><span class="comment">//cts.CancelAfter(1000);//超时，1秒后自动取消</span></span><br><span class="line"><span class="keyword">var</span> token=cts.Token;</span><br><span class="line"><span class="keyword">var</span> task=Task.Run (Work,token);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Console.WriteLine(<span class="string">&quot;To cancel,press &#x27;c&#x27;&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> input = Console.ReadLine();</span><br><span class="line"><span class="keyword">if</span> (input == <span class="string">&quot;c&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">	cts.Cancel();</span><br><span class="line">&#125;</span><br><span class="line">task.Wait();</span><br><span class="line">Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;task.Status&#125;</span>&quot;</span>);</span><br><span class="line">Console.ReadLine();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Work</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">	Console.WriteLine(<span class="string">&quot;Started dong the work&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (token.IsCancellationRequested)</span><br><span class="line">		&#123;</span><br><span class="line">			Console.WriteLine(<span class="string">$&quot;User requested cancellation at iteration:<span class="subst">&#123;i&#125;</span>&quot;</span>);</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//throw new OperationCanceledException();</span></span><br><span class="line">			<span class="comment">//token.ThrowIfCancellationRequested();</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		Thread.SpinWait(<span class="number">300000</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	Console.WriteLine(<span class="string">&quot;Work is done.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><h4 id="异步与Await概述"><a href="#异步与Await概述" class="headerlink" title="异步与Await概述"></a>异步与Await概述</h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Text.Json;</span><br><span class="line"></span><br><span class="line">output();</span><br><span class="line"></span><br><span class="line">Console.WriteLine(<span class="string">&quot;666&quot;</span>);</span><br><span class="line">Console.ReadLine();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">async</span> <span class="keyword">void</span> <span class="title">output</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">var</span> client = <span class="keyword">new</span> System.Net.Http.HttpClient();</span><br><span class="line">    <span class="keyword">var</span> taskGetPokemonList = client.GetStringAsync(<span class="string">&quot;https://pokeapi.co/api/v2/pokemon&quot;</span>);</span><br><span class="line">    <span class="keyword">var</span> response = <span class="keyword">await</span> taskGetPokemonList;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> doc = JsonDocument.Parse(response);</span><br><span class="line">    JsonElement root = doc.RootElement;</span><br><span class="line">    JsonElement results = root.GetProperty(<span class="string">&quot;results&quot;</span>);</span><br><span class="line">    JsonElement firstPokemon = results[<span class="number">0</span>];</span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;firstPokemon.GetProperty(<span class="string">&quot;name&quot;</span>)&#125;</span>,<span class="subst">&#123;firstPokemon.GetProperty(<span class="string">&quot;url&quot;</span>)&#125;</span>&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> 异步与<span class="title">Await</span>基本语法</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">async</span> Task <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;starting to do work&quot;</span>);</span><br><span class="line">            <span class="keyword">var</span> data= <span class="keyword">await</span> WorkAsync();</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;data&#125;</span>&quot;</span>);</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;press enter to exit&quot;</span>);</span><br><span class="line">            Console.ReadLine();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">async</span> Task&lt;<span class="built_in">string</span>&gt; <span class="title">WorkAsync</span>()</span> </span><br><span class="line">        &#123;</span><br><span class="line">           <span class="keyword">await</span> Task.Delay(<span class="number">2000</span>);</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Work is done&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;666&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Await前后使用的是哪个线程"><a href="#Await前后使用的是哪个线程" class="headerlink" title="Await前后使用的是哪个线程"></a>Await前后使用的是哪个线程</h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> 异步与<span class="title">Await</span>基本语法</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">async</span> Task <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)<span class="comment">//main函数使用了await，要把void main 改为task main</span></span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;Main thread id:<span class="subst">&#123;Thread.CurrentThread.ManagedThreadId&#125;</span>&quot;</span>);<span class="comment">//1</span></span><br><span class="line">            Console.WriteLine(<span class="string">&quot;starting to do work&quot;</span>);</span><br><span class="line">           <span class="comment">// var data = await WorkAsync();</span></span><br><span class="line">             <span class="keyword">await</span> WorkAsync();</span><br><span class="line">         </span><br><span class="line">            <span class="comment">//Console.WriteLine($&quot;&#123;data&#125;&quot;);</span></span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;data thread id:<span class="subst">&#123;Thread.CurrentThread.ManagedThreadId&#125;</span>&quot;</span>);<span class="comment">//x</span></span><br><span class="line">            Console.WriteLine(<span class="string">&quot;press enter to exit&quot;</span>);</span><br><span class="line">            Console.ReadLine();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">async</span> Task&lt;<span class="built_in">string</span>&gt; <span class="title">WorkAsync</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;task before thread id:<span class="subst">&#123;Thread.CurrentThread.ManagedThreadId&#125;</span>&quot;</span>);<span class="comment">//1</span></span><br><span class="line">            <span class="keyword">await</span> Task.Delay(<span class="number">2000</span>);</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Work is done&quot;</span>);</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;task after id:<span class="subst">&#123;Thread.CurrentThread.ManagedThreadId&#125;</span>&quot;</span>);<span class="comment">//x</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;666&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="返回值后的延续，改自“延续链解包”"><a href="#返回值后的延续，改自“延续链解包”" class="headerlink" title="返回值后的延续，改自“延续链解包”"></a>返回值后的延续，改自“延续链解包”</h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Text.Json;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">var</span> client = <span class="keyword">new</span> System.Net.Http.HttpClient();</span><br><span class="line"> getInfoAsync();</span><br><span class="line">Console.WriteLine(<span class="string">&quot;666&quot;</span>);</span><br><span class="line">Console.ReadLine();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">async</span> Task <span class="title">getInfoAsync</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Working...&quot;</span>);</span><br><span class="line">    <span class="keyword">var</span> taskListJson = <span class="keyword">await</span> client.GetStringAsync(<span class="string">&quot;https://pokeapi.co/api/v2/pokemon&quot;</span>);</span><br><span class="line">    <span class="comment">//得到第一个pokemon的url</span></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Working...&quot;</span>);</span><br><span class="line">    <span class="keyword">var</span> doc = JsonDocument.Parse(taskListJson);</span><br><span class="line">    JsonElement root = doc.RootElement;</span><br><span class="line">    JsonElement results = root.GetProperty(<span class="string">&quot;results&quot;</span>);</span><br><span class="line">    JsonElement firstPokemon = results[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">var</span> url = firstPokemon.GetProperty(<span class="string">&quot;url&quot;</span>).ToString();</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Working...&quot;</span>);</span><br><span class="line">    <span class="keyword">var</span> GetDetail = <span class="keyword">await</span> client.GetStringAsync(url);</span><br><span class="line">    doc = JsonDocument.Parse(GetDetail);</span><br><span class="line">    root = doc.RootElement;</span><br><span class="line">    <span class="keyword">var</span> results1 = root.GetProperty(<span class="string">&quot;name&quot;</span>).ToString();</span><br><span class="line">    <span class="keyword">var</span> results2 = root.GetProperty(<span class="string">&quot;weight&quot;</span>).ToString();</span><br><span class="line">    <span class="keyword">var</span> results3 = root.GetProperty(<span class="string">&quot;height&quot;</span>).ToString();</span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;name:<span class="subst">&#123;results1&#125;</span>\nweight:<span class="subst">&#123;results2&#125;</span>\nheight:<span class="subst">&#123;results3&#125;</span>&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="异步方法中的异常处理"><a href="#异步方法中的异常处理" class="headerlink" title="异步方法中的异常处理"></a>异步方法中的异常处理</h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> tasks = <span class="keyword">new</span>[]</span><br><span class="line">&#123;</span><br><span class="line">    Task.Run(() =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InvalidOperationException(<span class="string">&quot;Invalid Operation&quot;</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;),</span><br><span class="line">    Task.Run(() =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentNullException(<span class="string">&quot;Argument null&quot;</span>); </span><br><span class="line">    &#125;),</span><br><span class="line">    Task.Run(() =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;General exception&quot;</span>); </span><br><span class="line">    &#125;),</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> Task.WhenAll(tasks);<span class="comment">//抛出一个</span></span><br><span class="line"></span><br><span class="line">Console.WriteLine(<span class="string">&quot;Press enter key to exit&quot;</span>);</span><br><span class="line">Console.ReadLine();</span><br></pre></td></tr></table></figure>

<p>Await和同步上下文</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">async</span> <span class="keyword">void</span> <span class="title">button1_Click</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="comment">//ShowMessage(2, 3000);//这个会阻塞ui线程，会在一瞬间显示最终结果</span></span><br><span class="line">    <span class="keyword">await</span> ShowMessage(<span class="number">2</span>, <span class="number">3000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">async</span> <span class="keyword">void</span> <span class="title">button2_Click</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ShowMessage(2, 2000);</span></span><br><span class="line">    <span class="keyword">await</span> ShowMessage(<span class="number">2</span>, <span class="number">2000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">async</span> Task <span class="title">ShowMessage</span>(<span class="params"><span class="built_in">int</span> v1, <span class="built_in">int</span> v2</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">object</span> lk = <span class="keyword">new</span> <span class="built_in">object</span>();</span><br><span class="line">    <span class="comment">//Thread.Sleep(v2);</span></span><br><span class="line">    <span class="keyword">await</span> Task.Delay(v2);</span><br><span class="line">    <span class="keyword">lock</span> (lk)</span><br><span class="line">        i *= v1;</span><br><span class="line">    label1.Text = i.ToString();</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h3 id="并行循环"><a href="#并行循环" class="headerlink" title="并行循环"></a>并行循环</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">int</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">int</span>[] array = <span class="keyword">new</span> <span class="built_in">int</span>[num];</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; num; i++)</span><br><span class="line">&#123;</span><br><span class="line">	array[i] = i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">object</span> locksum = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="keyword">var</span> st = DateTime.Now;</span><br><span class="line"></span><br><span class="line"><span class="comment">//并行循环for、foreach、invoke都会阻塞线程</span></span><br><span class="line">Parallel.For(<span class="number">0</span>, array.Length, i =&gt;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">lock</span> (locksum)</span><br><span class="line">	&#123;</span><br><span class="line">		sum += array[i];</span><br><span class="line">		Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;Task.CurrentId&#125;</span>\t<span class="subst">&#123;Thread.CurrentThread.IsThreadPoolThread&#125;</span>&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> et = DateTime.Now;</span><br><span class="line">Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;sum&#125;</span>\r\n<span class="subst">&#123;(et - st).TotalMilliseconds&#125;</span>&quot;</span>);</span><br><span class="line">Console.ReadLine();</span><br><span class="line">Parallel.Invoke(() =&gt;</span><br><span class="line">&#123;</span><br><span class="line">	Console.WriteLine(<span class="string">&quot;I am one&quot;</span>);</span><br><span class="line">&#125;,</span><br><span class="line">() =&gt;</span><br><span class="line">&#123;</span><br><span class="line">	Console.WriteLine(<span class="string">&quot;I am two&quot;</span>);</span><br><span class="line">&#125;,</span><br><span class="line">() =&gt;</span><br><span class="line">&#123;</span><br><span class="line">	Console.WriteLine(<span class="string">&quot;I am three&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Console.ReadLine();</span><br></pre></td></tr></table></figure>

<h4 id="并行循环异常处理"><a href="#并行循环异常处理" class="headerlink" title="并行循环异常处理"></a>并行循环异常处理</h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">int</span> num = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">int</span>[] array = <span class="keyword">new</span> <span class="built_in">int</span>[num];</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; num; i++)</span><br><span class="line">&#123;</span><br><span class="line">	array[i] = i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">object</span> locksum = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="keyword">var</span> st = DateTime.Now;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//添加state参数</span></span><br><span class="line">	Parallel.For(<span class="number">0</span>, array.Length, (i, state) =&gt;</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">lock</span> (locksum)</span><br><span class="line">		&#123;<span class="comment">//无异常，则执行</span></span><br><span class="line">			<span class="keyword">if</span> (!state.IsExceptional)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (i == <span class="number">65</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">throw</span> <span class="keyword">new</span> InvalidOperationException(<span class="string">&quot;666&quot;</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				sum += array[i];</span><br><span class="line">				Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;Task.CurrentId&#125;</span><span class="subst">&#123;Thread.CurrentThread.IsThreadPoolThread&#125;</span>&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception ex)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//捕获聚合异常</span></span><br><span class="line">	ex.Dump();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> et = DateTime.Now;</span><br><span class="line">Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;sum&#125;</span>\r\n<span class="subst">&#123;(et - st).TotalMilliseconds&#125;</span>&quot;</span>);</span><br><span class="line">Console.ReadLine();</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="并行循环Stop"><a href="#并行循环Stop" class="headerlink" title="并行循环Stop"></a>并行循环Stop</h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//添加state参数</span></span><br><span class="line">	Parallel.For(<span class="number">0</span>, array.Length, (i, state) =&gt;</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">lock</span> (locksum)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (!state.IsStopped)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (i == <span class="number">65</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					state.Stop();</span><br><span class="line">				&#125;</span><br><span class="line">				sum += array[i];</span><br><span class="line">				Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;Task.CurrentId&#125;</span><span class="subst">&#123;Thread.CurrentThread.IsThreadPoolThread&#125;</span>&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="并行循环Break"><a href="#并行循环Break" class="headerlink" title="并行循环Break"></a>并行循环Break</h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Parallel.For(<span class="number">0</span>, array.Length, (i, state) =&gt;</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">lock</span> (locksum)</span><br><span class="line">		&#123;<span class="comment">//</span></span><br><span class="line">			<span class="keyword">if</span> (state.ShouldExitCurrentIteration &amp;&amp; state.LowestBreakIteration &lt; i)</span><br><span class="line"></span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (i == <span class="number">65</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				state.Break();</span><br><span class="line">			&#125;</span><br><span class="line">			sum += array[i];</span><br><span class="line">			Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;Task.CurrentId&#125;</span><span class="subst">&#123;Thread.CurrentThread.IsThreadPoolThread&#125;</span>&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="并行循环Result"><a href="#并行循环Result" class="headerlink" title="并行循环Result"></a>并行循环Result</h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">int</span> num = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">int</span>[] array = <span class="keyword">new</span> <span class="built_in">int</span>[num];</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; num; i++)</span><br><span class="line">&#123;</span><br><span class="line">	array[i] = i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">object</span> locksum = <span class="keyword">new</span> Object();</span><br><span class="line">ParallelLoopResult result;</span><br><span class="line"><span class="keyword">var</span> st = DateTime.Now;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">	result = Parallel.For(<span class="number">0</span>, array.Length, (i, state) =&gt;</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">lock</span> (locksum)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (state.ShouldExitCurrentIteration &amp;&amp; state.LowestBreakIteration &lt; i)</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (i == <span class="number">65</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				state.Break();</span><br><span class="line">				<span class="comment">//throw new InvalidOperationException();</span></span><br><span class="line">			&#125;</span><br><span class="line">			sum += array[i];</span><br><span class="line">			Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;Task.CurrentId&#125;</span><span class="subst">&#123;Thread.CurrentThread.IsThreadPoolThread&#125;</span>&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);result.Dump();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception ex)</span><br><span class="line">&#123;</span><br><span class="line">	ex.Dump();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> et = DateTime.Now;</span><br><span class="line">Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;sum&#125;</span>\r\n<span class="subst">&#123;(et - st).TotalMilliseconds&#125;</span>&quot;</span>);</span><br><span class="line">Console.ReadLine();</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="并行循环取消"><a href="#并行循环取消" class="headerlink" title="并行循环取消"></a>并行循环取消</h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">var</span> cts = <span class="keyword">new</span> CancellationTokenSource();</span><br><span class="line"><span class="comment">//cts.CancelAfter(1000);//超时，1秒后自动取消</span></span><br><span class="line"><span class="keyword">var</span> token = cts.Token;</span><br><span class="line"><span class="keyword">var</span> task = Task.Run(Work, token);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Console.WriteLine(<span class="string">&quot;To cancel,press &#x27;c&#x27;&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> input = Console.ReadLine();</span><br><span class="line"><span class="keyword">if</span> (input == <span class="string">&quot;c&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">	cts.Cancel();</span><br><span class="line">&#125;</span><br><span class="line">task.Wait();</span><br><span class="line">Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;task.Status&#125;</span>&quot;</span>);</span><br><span class="line">Console.ReadLine();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Work</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">try</span></span><br><span class="line">	&#123;</span><br><span class="line">		Console.WriteLine(<span class="string">&quot;Started dong the work&quot;</span>);</span><br><span class="line">		<span class="keyword">var</span> options = <span class="keyword">new</span> ParallelOptions &#123; CancellationToken = cts.Token &#125;;</span><br><span class="line">		<span class="comment">//添加并行配置 </span></span><br><span class="line">		Parallel.For(<span class="number">0</span>, <span class="number">1000</span>, options, i</span><br><span class="line">		=&gt;</span><br><span class="line">		&#123;</span><br><span class="line">			Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;DateTime.Now&#125;</span>&quot;</span>);</span><br><span class="line">			Thread.SpinWait(<span class="number">300000000</span>);</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (Exception ex)</span><br><span class="line">	&#123;</span><br><span class="line">		ex.Dump();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="并行循环线程存储变量"><a href="#并行循环线程存储变量" class="headerlink" title="并行循环线程存储变量"></a>并行循环线程存储变量</h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> startTime = DateTime.Now;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span>[] array = System.Linq.Enumerable.Range(<span class="number">0</span>, <span class="number">1000000000</span>).ToArray();</span><br><span class="line"><span class="built_in">object</span> lockSum = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="built_in">long</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// () =&gt; 0,初始为0，tls局部存储变量</span></span><br><span class="line">Parallel.For(</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    array.Length,</span><br><span class="line">    () =&gt; <span class="number">0</span>,</span><br><span class="line">    (i, state, tls) =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        tls += array[i] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> tls;</span><br><span class="line">    &#125;,</span><br><span class="line">    tls =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">lock</span> (lockSum)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += tls;</span><br><span class="line">            <span class="comment">//Console.WriteLine($&quot;&#123;Task.CurrentId&#125;&quot;);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br><span class="line"><span class="keyword">var</span> endTime = DateTime.Now;</span><br><span class="line">Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;sum&#125;</span>\r\n<span class="subst">&#123;(endTime - startTime).TotalMilliseconds&#125;</span>&quot;</span>);</span><br><span class="line">Console.ReadLine();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="PLINQ"><a href="#PLINQ" class="headerlink" title="PLINQ"></a>PLINQ</h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> items = System.Linq.Enumerable.Range(<span class="number">0</span>, <span class="number">200</span>);</span><br><span class="line"><span class="comment">//并行查询</span></span><br><span class="line"><span class="keyword">var</span> eventnumber = items.AsParallel().AsOrdered().Where(i =&gt;</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	Console.WriteLine(<span class="string">$&quot;当前数字\t<span class="subst">&#123;i&#125;</span>\t的线程id：<span class="subst">&#123;Thread.CurrentThread.ManagedThreadId&#125;</span>&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> i % <span class="number">2</span> == <span class="number">0</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Console.WriteLine(<span class="string">&quot;test......&quot;</span>);</span><br><span class="line">eventnumber.ForAll(e =&gt; Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;e&#125;</span>:threadID:<span class="subst">&#123;Thread.CurrentThread.ManagedThreadId&#125;</span>&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//foreach (var element in eventnumber)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//	Console.WriteLine($&quot;消费&#123;element&#125;:threadID:&#123;Thread.CurrentThread.ManagedThreadId&#125;&quot;);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line">Console.ReadLine();</span><br></pre></td></tr></table></figure>

<h4 id="PLINQ缓冲模式"><a href="#PLINQ缓冲模式" class="headerlink" title="PLINQ缓冲模式"></a>PLINQ缓冲模式</h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> items = System.Linq.Enumerable.Range(<span class="number">0</span>, <span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//并行查询，添加缓冲模式</span></span><br><span class="line"><span class="keyword">var</span> eventnumber = items</span><br><span class="line">    .AsParallel()</span><br><span class="line">    .WithMergeOptions(ParallelMergeOptions.NotBuffered)</span><br><span class="line">    .Where(i =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;当前数字\t<span class="subst">&#123;i&#125;</span>\t的线程id：<span class="subst">&#123;Thread.CurrentThread.ManagedThreadId&#125;</span>&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> i % <span class="number">2</span> == <span class="number">0</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">Console.WriteLine(<span class="string">&quot;test......&quot;</span>);</span><br><span class="line"><span class="comment">//eventnumber延迟执行，foreach有合并行为，forall没有</span></span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> element <span class="keyword">in</span> eventnumber)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;消费<span class="subst">&#123;element&#125;</span>:threadID:<span class="subst">&#123;Thread.CurrentThread.ManagedThreadId&#125;</span>&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">Console.ReadLine();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="PLINQ异常处理"><a href="#PLINQ异常处理" class="headerlink" title="PLINQ异常处理"></a>PLINQ异常处理</h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> items = System.Linq.Enumerable.Range(<span class="number">0</span>, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//并行查询</span></span><br><span class="line"><span class="keyword">var</span> eventnumber = items.AsParallel().WithMergeOptions(ParallelMergeOptions.Default).Where(i =&gt;</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	Console.WriteLine(<span class="string">$&quot;当前数字<span class="subst">&#123;i&#125;</span>的线程id：<span class="subst">&#123;Thread.CurrentThread.ManagedThreadId&#125;</span>&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (i == <span class="number">5</span>) <span class="keyword">throw</span> <span class="keyword">new</span> InvalidOperationException(<span class="string">&quot;has exception&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (i == <span class="number">19</span>) <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentNullException();</span><br><span class="line">	<span class="keyword">return</span> i % <span class="number">2</span> == <span class="number">0</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Console.WriteLine(<span class="string">&quot;test......&quot;</span>);</span><br><span class="line"><span class="comment">//只能在这里捕获，前面的是延迟执行的。。。</span></span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	eventnumber.ForAll(e =&gt; Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;e&#125;</span>:threadID:<span class="subst">&#123;Thread.CurrentThread.ManagedThreadId&#125;</span>&quot;</span>));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (AggregateException ex)</span><br><span class="line">&#123;<span class="comment">//捕获聚合异常中的所有异常</span></span><br><span class="line">	ex.Handle(e =&gt; &#123; Console.WriteLine(e.Message); <span class="keyword">return</span> <span class="literal">true</span>; &#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="PLINQ取消"><a href="#PLINQ取消" class="headerlink" title="PLINQ取消"></a>PLINQ取消</h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> items = System.Linq.Enumerable.Range(<span class="number">0</span>, <span class="number">20</span>);</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">var</span> cts = <span class="keyword">new</span> CancellationTokenSource();<span class="comment">//创建资源</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//并行查询，使用令牌</span></span><br><span class="line"><span class="keyword">var</span> eventnumber = items</span><br><span class="line">.AsParallel()</span><br><span class="line">.WithCancellation(cts.Token)</span><br><span class="line">.Where(i =&gt;</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	Console.WriteLine(<span class="string">$&quot;当前数字<span class="subst">&#123;i&#125;</span>的线程id：<span class="subst">&#123;Thread.CurrentThread.ManagedThreadId&#125;</span>&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> i % <span class="number">2</span> == <span class="number">0</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Console.WriteLine(<span class="string">&quot;test......&quot;</span>);</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	eventnumber.ForAll(e =&gt;</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (e &gt; <span class="number">8</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			cts.Cancel();<span class="comment">//取消操作</span></span><br><span class="line">		&#125;</span><br><span class="line">		Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;e&#125;</span>:threadID:<span class="subst">&#123;Thread.CurrentThread.ManagedThreadId&#125;</span>&quot;</span>);</span><br><span class="line">	&#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (OperationCanceledException ex)</span><br><span class="line">&#123;</span><br><span class="line">	ex.Dump();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="并发栈"><a href="#并发栈" class="headerlink" title="并发栈"></a>并发栈</h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> stack=<span class="keyword">new</span> ConcurrentStack&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line">stack.Push(<span class="number">1</span>);</span><br><span class="line">stack.Push(<span class="number">2</span>);</span><br><span class="line">stack.Push(<span class="number">3</span>);</span><br><span class="line">stack.TryPop(<span class="keyword">out</span> <span class="keyword">var</span> result);</span><br><span class="line">stack.TryPop(<span class="keyword">out</span> <span class="keyword">var</span> result1);</span><br><span class="line">stack.TryPop(<span class="keyword">out</span> <span class="keyword">var</span> result2);</span><br><span class="line">result.Dump();</span><br><span class="line">result1.Dump();</span><br><span class="line">result2.Dump();</span><br></pre></td></tr></table></figure>

<h4 id="并发队列、阻塞集合"><a href="#并发队列、阻塞集合" class="headerlink" title="并发队列、阻塞集合"></a>并发队列、阻塞集合</h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="meta">#nullable enable</span></span><br><span class="line">ConcurrentQueue&lt;<span class="built_in">string</span>?&gt; requestQueue = <span class="keyword">new</span> ConcurrentQueue&lt;<span class="built_in">string</span>?&gt;();</span><br><span class="line"><span class="comment">//一个包装器，对ConcurrentQueue进行包装</span></span><br><span class="line">BlockingCollection&lt;<span class="built_in">string</span>?&gt; collection = <span class="keyword">new</span> BlockingCollection&lt;<span class="built_in">string</span>?&gt;(requestQueue, <span class="number">3</span>);<span class="comment">//设置限制3</span></span><br><span class="line"></span><br><span class="line">Thread monitoringThread = <span class="keyword">new</span> Thread(MonitorQueue);</span><br><span class="line">monitoringThread.Start();</span><br><span class="line"></span><br><span class="line">Console.WriteLine(<span class="string">&quot;Server is running ,type &#x27;exit&#x27; to stop&quot;</span>);</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">string</span>? input = Console.ReadLine();</span><br><span class="line">	<span class="keyword">if</span> (input?.ToLower() == <span class="string">&quot;exit&quot;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		collection.CompleteAdding();<span class="comment">//停止添加</span></span><br><span class="line">		input.Dump();</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	collection.Add(input);</span><br><span class="line">	Console.WriteLine(<span class="string">$&quot;Enqueued:<span class="subst">&#123;input&#125;</span>;queue size:<span class="subst">&#123;collection.Count&#125;</span>&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MonitorQueue</span>()</span></span><br><span class="line">&#123;   <span class="comment">//这个foreach不会自己结束</span></span><br><span class="line">	<span class="keyword">foreach</span> (<span class="keyword">var</span> request <span class="keyword">in</span> collection.GetConsumingEnumerable())</span><br><span class="line">	&#123;<span class="comment">//检查是否完成</span></span><br><span class="line">	  <span class="keyword">if</span> (collection.IsCompleted)</span><br><span class="line">	  &#123;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	  &#125;</span><br><span class="line">		Thread processingThread = <span class="keyword">new</span> Thread(() =&gt; ProcessInput(request));</span><br><span class="line">		processingThread.Start();</span><br><span class="line">		Thread.Sleep(<span class="number">2000</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ProcessInput</span>(<span class="params"><span class="built_in">string</span>? input</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	Thread.Sleep(<span class="number">2000</span>);</span><br><span class="line">	(Convert.ToInt32(input)*<span class="number">10</span>).Dump();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title>01AutoCAD .NET API（.NET）的基础知识</title>
    <url>/2025/01/12/ObjectARX%EF%BC%9AManaged.NET%E5%BC%80%E5%8F%91%E4%BA%BA%E5%91%98%E6%8C%87%E5%8D%97/01AutoCAD.NET%20API%EF%BC%88.NET%EF%BC%89%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h1 id="AutoCAD-NET-API（-NET）的基础知识"><a href="#AutoCAD-NET-API（-NET）的基础知识" class="headerlink" title="AutoCAD .NET API（.NET）的基础知识"></a>AutoCAD .NET API（.NET）的基础知识</h1><p>要有效地使用AutoCAD®.NET API，您应该熟悉与要自动执行的任务相关的AutoCAD图元、对象和功能。对对象的图形和非图形特性了解得越多，就越容易通过AutoCAD .NET API对其进行操作。</p>
<p>本节中的主题</p>
<ul>
<li>了解AutoCAD对象层次（.NET）</li>
<li>访问对象层次结构（.NET）</li>
<li>集合对象（.NET）</li>
<li>了解属性和方法（.NET）</li>
<li>进程外与进程内（.NET）</li>
<li>定义命令和AutoLISP函数（.NET）</li>
</ul>
<h2 id="了解AutoCAD对象层次（-NET）"><a href="#了解AutoCAD对象层次（-NET）" class="headerlink" title="了解AutoCAD对象层次（.NET）"></a>了解AutoCAD对象层次（.NET）</h2><p>对象是AutoCAD .NET API的主要构造块。每个暴露的对象都代表AutoCAD的一个精确部分。AutoCAD .NET API中有许多不同类型的对象。AutoCAD .NET API中表示的某些对象包括：</p>
<ul>
<li>图形对象，如直线、圆弧、文本和尺寸</li>
<li>样式设置，如图层、线型和标注样式</li>
<li>组织结构，如层、组和块</li>
<li>图形显示，如视图和视口</li>
<li>甚至绘图和AutoCAD应用程序</li>
</ul>
<p>这些对象以分层方式进行结构化，AutoCAD应用程序对象位于根。这种层次结构通常被称为对象模型。下图显示了 Application 对象与 BlockTableRecord （如模型空间）中的图元之间的基本关系。AutoCAD .NET API中还有许多对象未在此处表示。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2024/ENU/OARX-DevGuide-Managed/images/GUID-1AA8F78F-DF90-4AA4-A975-A06FBF65231C.png"></p>
<p>本节中的主题</p>
<ul>
<li>应用程序对象（.NET）</li>
<li>文档对象（.NET）</li>
<li>数据库对象（.NET）</li>
<li>图形和非图形对象（.NET）</li>
<li>集合对象（.NET）</li>
<li>非原生图形和非图形对象（.NET）</li>
</ul>
<h3 id="应用程序对象（-NET）"><a href="#应用程序对象（-NET）" class="headerlink" title="应用程序对象（.NET）"></a>应用程序对象（.NET）</h3><p>Application 对象是AutoCAD .NET API的根对象。从Application对象中，可以访问主窗口以及任何打开的图形。一旦有了图形，就可以访问图形中的对象。</p>
<p>例如， Application 对象有一个返回 DocumentCollection 对象的 DocumentManager 属性。此对象提供对当前在AutoCAD中打开的图形的访问，并允许用户创建、保存和打开图形文件。Application对象的其他属性提供对应用程序特定数据（如信息中心、主窗口和状态栏）的访问。 MainWindow 属性允许访问应用程序名称、大小、位置和可见性。</p>
<p>虽然Application对象的大多数特性允许访问AutoCAD .NET API中的对象，但也有一些特性引用AutoCAD ActiveX® Automation中的对象。这些属性包括应用程序对象的COM版本（ AcadApplication ）、菜单栏（ MenuBar ）、加载的菜单组（ MenuGroups ）和首选项（ Preferences ）。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2024/ENU/OARX-DevGuide-Managed/images/GUID-577A2AFF-CBE6-4FED-9F28-B2DCA9064A5D.png"></p>
<p>DocumentManager<br>所有文档对象的容器（每个打开的图形都有一个文档对象)。</p>
<p>DocumentWindowCollection<br>所有文档窗口对象的容器（DocumentManager中的每个文档对象都有一个文档窗口对象）。</p>
<p>InfoCenter  InfoCenter信息<br>包含对信息中心工具栏的引用。</p>
<p>MainWindow  MainWindow的<br>包含对AutoCAD的应用程序窗口对象的引用。</p>
<p>MenuBar<br>包含对AutoCAD中菜单栏的MenuBar COM对象的引用。</p>
<p>MenuGroups<br>包含对MenuGroups COM对象的引用，该对象包含每个加载的CUIx文件的自定义组名称。</p>
<p>Preferences<br>包含对首选项COM对象的引用，该对象允许您修改“选项”对话框中的许多设置。</p>
<p>Publisher<br>包含对用于发布图形的Publisher对象的引用。</p>
<p>StatusBar<br>包含对应用程序窗口的StatusBar对象的引用。</p>
<p>UserConfigurationManager<br>包含一个对UserconfigureationManager对象的引用，该对象允许您使用用户保存的配置文件。</p>
<h3 id="文档对象（-NET）"><a href="#文档对象（-NET）" class="headerlink" title="文档对象（.NET）"></a>文档对象（.NET）</h3><p>实际上是AutoCAD图形的 Document 对象是 DocumentCollection 对象的一部分。使用 DocumentExtension 和 DocumentCollectionExtention 对象可以创建、打开和关闭图形文件。 Document 对象提供对 Database 对象的访问，该对象包含所有图形和大多数非图形AutoCAD对象。</p>
<p>沿着 Database 对象， Document 对象提供对状态栏、打开文档的窗口、 Editor 和 TransactionManager 对象的访问。 Editor 对象提供对用于从用户获取输入的函数的访问，输入的形式为点、输入的字符串或数值。</p>
<p>TransactionManager 对象用于在称为事务的单个操作下访问多个数据库对象。事务可以嵌套，当您完成事务时，您可以提交或中止所做的更改。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2024/ENU/OARX-DevGuide-Managed/images/GUID-E8265C60-AD9F-4C53-97B3-AD4CA4474DFA.png"></p>
<h3 id="数据库对象（-NET）"><a href="#数据库对象（-NET）" class="headerlink" title="数据库对象（.NET）"></a>数据库对象（.NET）</h3><p>Database 对象包含所有图形和大多数非图形AutoCAD对象。数据库中包含的一些对象是实体、符号表和命名字典。数据库中的图元表示图形中的图形对象。直线、圆、圆弧、文字、图案填充和多段线都是图元的示例。用户可以看到屏幕上的实体，并可以操纵它。</p>
<p>通过 Document 对象的 Database 成员属性访问当前文档的 Database 对象。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Application.DocumentManager.MdiActiveDocument.Database</span><br></pre></td></tr></table></figure>

<p>符号表和字典</p>
<p>符号表和字典对象提供对非图形对象（块、图层、线型、布局等）的访问。每个图形都包含一组九个固定的符号表，而图形中的字典数量可以根据AutoCAD中使用的应用程序的功能和类型而有所不同。无法将新符号表添加到数据库中。</p>
<p>符号表的示例包括图层表（LayerTable）和块表（BlockTable），前者包含图层表记录，后者包含块表记录。所有图形实体（线、圆、弧等）都属于块表记录。默认情况下，每个图形都包含模型空间和图纸空间的预定义块表记录。每个图纸空间布局都有自己的块表记录。</p>
<p>字典是一个容器对象，可以包含任何AutoCAD对象或 XRecord 。字典存储在数据库中的命名对象字典下，或者作为表记录或图形实体的扩展字典。命名对象字典是与数据库关联的所有字典的主表。与符号表不同，可以创建新字典并将其添加到命名对象字典中。</p>
<p>注意：字典对象不能包含图形图元。</p>
<p>VBA&#x2F;ActiveX交叉引用</p>
<p>AutoCAD .NET API中的 Database 对象类似于ActiveX Automation库中的 Document 对象。要访问ActiveX Automation库的 Document 对象中可用的大多数特性，您需要使用AutoCAD .NET API的Document和Database对象。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2024/ENU/OARX-DevGuide-Managed/images/GUID-6D966F16-4E60-4C89-BA86-9F25D67E1AF0.png" alt="img"></p>
<h3 id="图形和非图形对象（-NET）"><a href="#图形和非图形对象（-NET）" class="headerlink" title="图形和非图形对象（.NET）"></a>图形和非图形对象（.NET）</h3><p>图形对象（也称为实体）是构成图形的可见对象（直线、圆、光栅图像等）。将图形对象添加到图形的方法是：参照正确的块表记录，然后使用带有新对象的 AppendEntity 方法将其追加到图形。</p>
<p>若要修改或查询对象，请从相应的块表记录中获取对象的引用，然后使用对象本身的方法或特性。每个图形对象都具有执行与AutoCAD编辑命令（如“复制”、“缩放”、“移动”、“镜像”等）相同功能的方法。</p>
<p>这些对象还具有检索扩展数据（扩展数据）、高亮显示和取消高亮显示以及设置其他图元的属性的方法。大多数图形对象都有一些共同的属性，例如 LayerId 、 LinetypeId 、 Color 和 Handle 。每个图形对象还具有特定的属性，例如 Center 、 StartPoint 、 Radius 和 FitTolerance 。</p>
<p>非图形对象是图形中不可见的（信息性）对象，例如图层、线型、标注样式、表格样式等。要创建新的符号表记录，请使用所有者表上的 Add 方法或使用 SetAt 方法将字典添加到命名对象字典。若要修改或查询这些对象，请使用对象本身的方法或属性。每个非图形对象都具有特定于其用途的方法和属性;所有对象都具有检索扩展数据（扩展数据）和擦除自身的方法。</p>
<h3 id="集合对象（-NET）"><a href="#集合对象（-NET）" class="headerlink" title="集合对象（.NET）"></a>集合对象（.NET）</h3><p>AutoCAD将大多数图形和非图形对象分组到集合或容器对象中。虽然集合包含不同类型的数据，但可以使用类似的技术处理它们。每个集合都有一个向集合中添加对象或从集合中获取项的方法。大多数集合使用 Add 或 SetAt 方法将对象添加到集合中。</p>
<p>大多数集合都提供类似的方法和属性，使它们易于使用和学习。 Count 属性返回集合中对象的计数，从零开始，而Item函数返回集合中的对象。AutoCAD .NET API中集合成员的示例包括：</p>
<ul>
<li>图层符号表中的图层表记录</li>
<li>ACAD_LAYOUT字典中的布局</li>
<li>DocumentCollection中的文档</li>
<li>块参照中的属性</li>
</ul>
<h3 id="非原生图形和非图形对象（-NET）"><a href="#非原生图形和非图形对象（-NET）" class="headerlink" title="非原生图形和非图形对象（.NET）"></a>非原生图形和非图形对象（.NET）</h3><p>AutoCAD .NET API是ObjectARX和ActiveX Automation的交叉实现。虽然可以从ObjectARX应用程序使用ActiveX Automation，但AutoCAD .NET API提供对ActiveX Automation库对象的直接访问。使用本机AutoCAD .NET API处理对象时，还可以从特性访问等效的COM对象。在某些情况下，COM对象是以编程方式访问AutoCAD要素的唯一方法。通过AutoCAD .NET API显示COM对象的特性的一些示例包括 Preferences 、 Menubar 、 MenuGroups 、 AcadObject 和 AcadApplication 。</p>
<p>注意：使用COM对象时，您需要确保引用AutoCAD类型库。</p>
<p>应用程序对象的 Preferences 属性提供对一组COM对象的访问，每个对象对应于“选项”对话框中的一个选项卡。这些对象一起提供了对“选项”对话框中所有注册表存储的设置的访问。还可以使用 Application 对象的 SetSystemVariable 和 GetSystemVariable 方法设置和修改选项（以及不属于“选项”对话框的系统变量）。</p>
<p>如果您正在使用可能最初为VB或VBA开发的现有代码，或者甚至在使用可能与AutoCAD ActiveX Automation库和AutoCAD .NET API一起使用的第三方库时，COM对象非常有用。与 Preferences 对象一样，您还可以使用 Utility 对象访问转换坐标或基于角度和距离定义新点的实用程序，该对象可以从 AcadApplication COM对象访问，该对象相当于AutoCAD中的 Application 对象。NET API。</p>
<p>注意：同时使用AutoCAD .NET API和ActiveX Automation时，如果您创建了可能需要返回对象的自定义函数，建议返回 ObjectId 而不是对象本身。</p>
<h2 id="访问对象层次结构（-NET）"><a href="#访问对象层次结构（-NET）" class="headerlink" title="访问对象层次结构（.NET）"></a>访问对象层次结构（.NET）</h2><p>虽然Application是AutoCAD .NET API中的根对象，但您通常将使用当前图形的数据库。 Application 对象的 DocumentManager 属性允许您使用 MdiActiveDocument 属性访问当前文档。从由 MdiActiveDocument 属性返回的 Document 对象，您可以使用 Database 属性访问其数据库。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Application.DocumentManager.MdiActiveDocument.Database.Clayer;</span><br></pre></td></tr></table></figure>

<p> 本节中的主题</p>
<ul>
<li>引用对象层次结构（.NET）中的对象</li>
<li>访问应用程序对象（.NET）</li>
</ul>
<h3 id="引用对象层次结构（-NET）中的对象"><a href="#引用对象层次结构（-NET）中的对象" class="headerlink" title="引用对象层次结构（.NET）中的对象"></a>引用对象层次结构（.NET）中的对象</h3><p>在AutoCAD .NET API中使用对象时，可以直接引用某些对象，也可以通过基于所使用对象的用户定义变量来引用某些对象。若要直接引用对象，请将该对象包含在调用层次结构中。例如，以下语句将图形文件附加到当前图形的数据库。请注意，层次结构从Application开始，然后转到 Database 对象。从 Database 对象中调用 方法：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> strFName, strBlkName;</span><br><span class="line">Autodesk.AutoCAD.DatabaseServices.ObjectId objId;</span><br><span class="line"> </span><br><span class="line">strFName = <span class="string">&quot;c:/clients/Proj 123/grid.dwg&quot;</span>;</span><br><span class="line">strBlkName = System.IO.Path.GetFileNameWithoutExtension(strFName);</span><br><span class="line"> </span><br><span class="line">objId = Application.DocumentManager.MdiActiveDocument.Database.AttachXref(strFName, strBlkName);</span><br></pre></td></tr></table></figure>

<p>要通过用户定义的变量引用对象，请将变量定义为所需的类型，然后将变量设置为适当的对象。例如，以下代码定义了一个类型为 Autodesk.AutoCAD.DatabaseServices.Database 的变量（ acCurDb ），并将该变量设置为等于当前数据库：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Autodesk.AutoCAD.DatabaseServices.Database acCurDb;</span><br><span class="line">acCurDb = Application.DocumentManager.MdiActiveDocument.Database;</span><br></pre></td></tr></table></figure>

<p>然后，以下语句使用 acCurDb 用户定义变量将图形文件附着到数据库：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> strFName, strBlkName;</span><br><span class="line">Autodesk.AutoCAD.DatabaseServices.ObjectId objId;</span><br><span class="line"> </span><br><span class="line">strFName = <span class="string">&quot;c:/clients/Proj 123/grid.dwg&quot;</span>;</span><br><span class="line">strBlkName = System.IO.Path.GetFileNameWithoutExtension(strFName);</span><br><span class="line"> </span><br><span class="line">objId = acCurDb.AttachXref(strFName, strBlkName);</span><br></pre></td></tr></table></figure>

<p><strong>从模型空间中检索图元</strong></p>
<p>下面的示例返回模型空间中的第一个实体对象。类似的代码可以对图纸空间图元执行相同的操作。请注意，所有图形对象都定义为 Entity 对象：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.Runtime;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.ApplicationServices;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.DatabaseServices;</span><br><span class="line"> </span><br><span class="line">[<span class="meta">CommandMethod(<span class="string">&quot;ListEntities&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ListEntities</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// Get the current document and database, and start a transaction</span></span><br><span class="line">  Document acDoc = Application.DocumentManager.MdiActiveDocument;</span><br><span class="line">  Database acCurDb = acDoc.Database;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">using</span> (Transaction acTrans = acCurDb.TransactionManager.StartTransaction())</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="comment">// Open the Block table record for read</span></span><br><span class="line">      BlockTable acBlkTbl;</span><br><span class="line">      acBlkTbl = acTrans.GetObject(acCurDb.BlockTableId,</span><br><span class="line">                                   OpenMode.ForRead) <span class="keyword">as</span> BlockTable;</span><br><span class="line"> </span><br><span class="line">      <span class="comment">// Open the Block table record Model space for read</span></span><br><span class="line">      BlockTableRecord acBlkTblRec;</span><br><span class="line">      acBlkTblRec = acTrans.GetObject(acBlkTbl[BlockTableRecord.ModelSpace],</span><br><span class="line">                                      OpenMode.ForRead) <span class="keyword">as</span> BlockTableRecord;</span><br><span class="line"> </span><br><span class="line">      <span class="built_in">int</span> nCnt = <span class="number">0</span>;</span><br><span class="line">      acDoc.Editor.WriteMessage(<span class="string">&quot;\nModel space objects: &quot;</span>);</span><br><span class="line"> </span><br><span class="line">      <span class="comment">// Step through each object in Model space and</span></span><br><span class="line">      <span class="comment">// display the type of object found</span></span><br><span class="line">      <span class="keyword">foreach</span> (ObjectId acObjId <span class="keyword">in</span> acBlkTblRec)</span><br><span class="line">      &#123;</span><br><span class="line">          acDoc.Editor.WriteMessage(<span class="string">&quot;\n&quot;</span> + acObjId.ObjectClass.DxfName);</span><br><span class="line"> </span><br><span class="line">          nCnt = nCnt + <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line"> </span><br><span class="line">      <span class="comment">// If no objects are found then display a message</span></span><br><span class="line">      <span class="keyword">if</span> (nCnt == <span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">          acDoc.Editor.WriteMessage(<span class="string">&quot;\n  No objects found&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line"> </span><br><span class="line">      <span class="comment">// Dispose of the transaction</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="访问Application对象（-NET）"><a href="#访问Application对象（-NET）" class="headerlink" title="访问Application对象（.NET）"></a>访问Application对象（.NET）</h3><p>Application对象位于对象层次的根，它提供对AutoCAD主窗口的访问。例如，下面的代码行更新应用程序：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Autodesk.AutoCAD.ApplicationServices.Application.UpdateScreen();</span><br></pre></td></tr></table></figure>

<h2 id="集合对象（-NET）-1"><a href="#集合对象（-NET）-1" class="headerlink" title="集合对象（.NET）"></a>集合对象（.NET）</h2><p>集合是一种包含许多类似对象实例的对象类型。以下列表包含AutoCAD .NET API中的一些集合对象：</p>
<p>Block Table Record<br>包含特定块定义中的所有图元。</p>
<p>Block Table<br>包含图形中的所有块。</p>
<p>Named Objects Dictionary<br>包含图形中的所有词典。</p>
<p>Dimension Style Table<br>包含图形中的所有标注样式。</p>
<p>Document Collection<br>包含当前任务中所有打开的图形。</p>
<p>Group Dictionary<br>包含图形中的所有编组。</p>
<p>Hyperlink Collection<br>包含给定实体的所有超链接。</p>
<p>Layer Table<br>包含图形中的所有图层。</p>
<p>Layout Dictionary<br>包含图形中的所有布局。</p>
<p>Linetype Table<br>包含图形中的所有线型。</p>
<p>MenuBar Collection<br>包含当前在AutoCAD中显示的所有菜单。</p>
<p>MenuGroup Collection<br>包含AutoCAD中当前加载的所有自定义组。自定义组表示加载的CUIx文件，该文件可以包含菜单、菜单和功能区选项卡以及定义用户界面的其他元素。</p>
<p>Plot Configuration Dictionary<br>包含图形中的命名打印设置。</p>
<p>Registered Application Table<br>包含图形中所有注册的应用程序。</p>
<p>Text Style Table<br>包含图形中的所有文字样式。</p>
<p>UCS Table<br>包含图形中的所有用户坐标系（UCS）。</p>
<p>View Table<br>包含图形中的所有视图。</p>
<p>Viewport Table<br>包含图形中的所有视口。</p>
<p>本节中的主题</p>
<ul>
<li>访问集合（.NET）</li>
<li>向集合对象添加新成员（.NET）</li>
<li>遍历集合对象（.NET）</li>
<li>创建集合对象的成员（.NET）</li>
</ul>
<h3 id="访问集合（-NET）"><a href="#访问集合（-NET）" class="headerlink" title="访问集合（.NET）"></a>访问集合（.NET）</h3><p>大多数集合和容器对象都是通过 Document 或 Database 对象访问的。 Document 和 Database 对象包含一个属性，用于访问大多数可用Collection对象的对象或对象ID。例如，以下代码定义变量并检索表示当前图形中 Layers 集合的 LayersTable 对象：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Get the current document and start the Transaction Manager</span></span><br><span class="line">Database acCurDb = Application.DocumentManager.MdiActiveDocument.Database;</span><br><span class="line"><span class="keyword">using</span> (Transaction acTrans = acCurDb.TransactionManager.StartTransaction())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// This example returns the layer table for the current database</span></span><br><span class="line">    LayerTable acLyrTbl;</span><br><span class="line">    acLyrTbl = acTrans.GetObject(acCurDb.LayerTableId,</span><br><span class="line">                                 OpenMode.ForRead) <span class="keyword">as</span> LayerTable;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">// Dispose of the transaction</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="向集合对象添加新成员（-NET）"><a href="#向集合对象添加新成员（-NET）" class="headerlink" title="向集合对象添加新成员（.NET）"></a>向集合对象添加新成员（.NET）</h3><p>要向集合中添加新成员，请使用 Add 方法。例如，以下代码创建一个新层并将其添加到“层”（Layer）表中：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.Runtime;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.ApplicationServices;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.DatabaseServices;</span><br><span class="line"> </span><br><span class="line">[<span class="meta">CommandMethod(<span class="string">&quot;AddMyLayer&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">AddMyLayer</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// Get the current document and database, and start a transaction</span></span><br><span class="line">  Document acDoc = Application.DocumentManager.MdiActiveDocument;</span><br><span class="line">  Database acCurDb = acDoc.Database;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">using</span> (Transaction acTrans = acCurDb.TransactionManager.StartTransaction())</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="comment">// Returns the layer table for the current database</span></span><br><span class="line">      LayerTable acLyrTbl;</span><br><span class="line">      acLyrTbl = acTrans.GetObject(acCurDb.LayerTableId,</span><br><span class="line">                                   OpenMode.ForRead) <span class="keyword">as</span> LayerTable;</span><br><span class="line"> </span><br><span class="line">      <span class="comment">// Check to see if MyLayer exists in the Layer table</span></span><br><span class="line">      <span class="keyword">if</span> (acLyrTbl.Has(<span class="string">&quot;MyLayer&quot;</span>) != <span class="literal">true</span>)</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="comment">// Open the Layer Table for write</span></span><br><span class="line">          acTrans.GetObject(acCurDb.LayerTableId, OpenMode.ForWrite);</span><br><span class="line"> </span><br><span class="line">          <span class="comment">// Create a new layer table record and name the layer &quot;MyLayer&quot;</span></span><br><span class="line">          <span class="keyword">using</span> (LayerTableRecord acLyrTblRec = <span class="keyword">new</span> LayerTableRecord())</span><br><span class="line">          &#123;</span><br><span class="line">              acLyrTblRec.Name = <span class="string">&quot;MyLayer&quot;</span>;</span><br><span class="line"> </span><br><span class="line">              <span class="comment">// Add the new layer table record to the layer table and the transaction</span></span><br><span class="line">              acLyrTbl.Add(acLyrTblRec);</span><br><span class="line">              acTrans.AddNewlyCreatedDBObject(acLyrTblRec, <span class="literal">true</span>);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// Commit the changes</span></span><br><span class="line">          acTrans.Commit();</span><br><span class="line">      &#125;</span><br><span class="line"> </span><br><span class="line">      <span class="comment">// Dispose of the transaction</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="遍历集合对象（-NET）"><a href="#遍历集合对象（-NET）" class="headerlink" title="遍历集合对象（.NET）"></a>遍历集合对象（.NET）</h3><p>要选择Collection对象的特定成员，请使用 Item 或 GetAt 方法。 Item 和 GetAt 方法需要一个字符串形式的键，其中表示项的名称。对于大多数集合，Item方法是隐含的，这意味着您实际上不需要使用方法。</p>
<p>对于某些Collection对象，您还可以使用索引号来指定要检索的项在集合中的位置。您可以使用的方法根据您使用的语言以及使用符号表或字典而有所不同。</p>
<p>以下语句显示如何访问图层符号表中的“MyLayer”表记录。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">acObjId = acLyrTbl[<span class="string">&quot;MyLayer&quot;</span>];</span><br></pre></td></tr></table></figure>

<p>遍历LayerTable对象</p>
<p>以下示例遍历 LayerTable 对象并显示其所有图层表记录的名称：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.Runtime;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.ApplicationServices;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.DatabaseServices;</span><br><span class="line"> </span><br><span class="line">[<span class="meta">CommandMethod(<span class="string">&quot;IterateLayers&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">IterateLayers</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// Get the current document and database, and start a transaction</span></span><br><span class="line">  Document acDoc = Application.DocumentManager.MdiActiveDocument;</span><br><span class="line">  Database acCurDb = acDoc.Database;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">using</span> (Transaction acTrans = acCurDb.TransactionManager.StartTransaction())</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="comment">// This example returns the layer table for the current database</span></span><br><span class="line">      LayerTable acLyrTbl;</span><br><span class="line">      acLyrTbl = acTrans.GetObject(acCurDb.LayerTableId,</span><br><span class="line">                                   OpenMode.ForRead) <span class="keyword">as</span> LayerTable;</span><br><span class="line"> </span><br><span class="line">      <span class="comment">// Step through the Layer table and print each layer name</span></span><br><span class="line">      <span class="keyword">foreach</span> (ObjectId acObjId <span class="keyword">in</span> acLyrTbl)</span><br><span class="line">      &#123;</span><br><span class="line">          LayerTableRecord acLyrTblRec;</span><br><span class="line">          acLyrTblRec = acTrans.GetObject(acObjId,</span><br><span class="line">                                          OpenMode.ForRead) <span class="keyword">as</span> LayerTableRecord;</span><br><span class="line"> </span><br><span class="line">          acDoc.Editor.WriteMessage(<span class="string">&quot;\n&quot;</span> + acLyrTblRec.Name);</span><br><span class="line">      &#125;</span><br><span class="line"> </span><br><span class="line">      <span class="comment">// Dispose of the transaction</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在LayerTable对象中查找名为MyLayer的图层表记录</p>
<p>以下示例检查 LayerTable 对象以确定名为MyLayer的图层是否存在，并显示相应的消息：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.Runtime;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.ApplicationServices;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.DatabaseServices;</span><br><span class="line"> </span><br><span class="line">[<span class="meta">CommandMethod(<span class="string">&quot;FindMyLayer&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">FindMyLayer</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// Get the current document and database, and start a transaction</span></span><br><span class="line">  Document acDoc = Application.DocumentManager.MdiActiveDocument;</span><br><span class="line">  Database acCurDb = acDoc.Database;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">using</span> (Transaction acTrans = acCurDb.TransactionManager.StartTransaction())</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="comment">// Returns the layer table for the current database</span></span><br><span class="line">      LayerTable acLyrTbl;</span><br><span class="line">      acLyrTbl = acTrans.GetObject(acCurDb.LayerTableId,</span><br><span class="line">                                   OpenMode.ForRead) <span class="keyword">as</span> LayerTable;</span><br><span class="line"> </span><br><span class="line">      <span class="comment">// Check to see if MyLayer exists in the Layer table</span></span><br><span class="line">      <span class="keyword">if</span> (acLyrTbl.Has(<span class="string">&quot;MyLayer&quot;</span>) != <span class="literal">true</span>)</span><br><span class="line">      &#123;</span><br><span class="line">          acDoc.Editor.WriteMessage(<span class="string">&quot;\n&#x27;MyLayer&#x27; does not exist&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">          acDoc.Editor.WriteMessage(<span class="string">&quot;\n&#x27;MyLayer&#x27; exists&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line"> </span><br><span class="line">      <span class="comment">// Dispose of the transaction</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="擦除集合对象的成员（-NET）"><a href="#擦除集合对象的成员（-NET）" class="headerlink" title="擦除集合对象的成员（.NET）"></a>擦除集合对象的成员（.NET）</h3><p>可以使用成员对象上的 Erase 方法删除集合对象中的成员。例如，下面的代码从 LayerTable 对象中擦除图层MyLayer。</p>
<p>在从图形中删除图层之前，应确保可以安全地删除该图层。若要确定是否可以擦除图层或其他命名对象（如块或文字样式），应使用 Purge 方法。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.Runtime;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.ApplicationServices;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.DatabaseServices;</span><br><span class="line"> </span><br><span class="line">[<span class="meta">CommandMethod(<span class="string">&quot;RemoveMyLayer&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">RemoveMyLayer</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// Get the current document and database, and start a transaction</span></span><br><span class="line">  Document acDoc = Application.DocumentManager.MdiActiveDocument;</span><br><span class="line">  Database acCurDb = acDoc.Database;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">using</span> (Transaction acTrans = acCurDb.TransactionManager.StartTransaction())</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="comment">// Returns the layer table for the current database</span></span><br><span class="line">      LayerTable acLyrTbl;</span><br><span class="line">      acLyrTbl = acTrans.GetObject(acCurDb.LayerTableId,</span><br><span class="line">                                   OpenMode.ForRead) <span class="keyword">as</span> LayerTable;</span><br><span class="line"> </span><br><span class="line">      <span class="comment">// Check to see if MyLayer exists in the Layer table</span></span><br><span class="line">      <span class="keyword">if</span> (acLyrTbl.Has(<span class="string">&quot;MyLayer&quot;</span>) == <span class="literal">true</span>)</span><br><span class="line">      &#123;</span><br><span class="line">          LayerTableRecord acLyrTblRec;</span><br><span class="line">          acLyrTblRec = acTrans.GetObject(acLyrTbl[<span class="string">&quot;MyLayer&quot;</span>],</span><br><span class="line">                                          OpenMode.ForWrite) <span class="keyword">as</span> LayerTableRecord;</span><br><span class="line"> </span><br><span class="line">          <span class="keyword">try</span></span><br><span class="line">          &#123;</span><br><span class="line">              acLyrTblRec.Erase();</span><br><span class="line">              acDoc.Editor.WriteMessage(<span class="string">&quot;\n&#x27;MyLayer&#x27; was erased&quot;</span>);</span><br><span class="line"> </span><br><span class="line">              <span class="comment">// Commit the changes</span></span><br><span class="line">              acTrans.Commit();</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">catch</span></span><br><span class="line">          &#123;</span><br><span class="line">              acDoc.Editor.WriteMessage(<span class="string">&quot;\n&#x27;MyLayer&#x27; could not be erased&quot;</span>);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">          acDoc.Editor.WriteMessage(<span class="string">&quot;\n&#x27;MyLayer&#x27; does not exist&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line"> </span><br><span class="line">      <span class="comment">// Dispose of the transaction</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一旦对象被擦除，以后就不应该在程序中再次尝试访问该对象;否则将发生错误。上面的示例测试在再次访问对象之前查看对象是否存在。当请求删除一个对象时，你应该使用 Has 方法检查该对象是否存在，或者使用 Try 语句来捕获任何发生的异常。</p>
<h2 id="了解属性和方法（-NET）"><a href="#了解属性和方法（-NET）" class="headerlink" title="了解属性和方法（.NET）"></a>了解属性和方法（.NET）</h2><p>每个对象都有关联的属性和方法。属性描述单个对象的各个方面，而方法是可以在单个对象上执行的操作。创建对象后，可以通过其属性和方法查询和编辑对象。</p>
<p>例如，Circle对象具有 Center 属性。此属性表示世界坐标系（WCS）中位于该圆中心的点。要更改圆心，只需将 Center 属性设置为新点。 Circle 对象也有一个名为 GetOffsetCurves 的方法。此方法在距现有圆的指定偏移距离处创建新对象。</p>
<p>若要查看 Circle 对象的所有属性和方法的列表，请参阅 Circle 对象参考主题或使用Microsoft® Visual Studio®中的对象浏览器。</p>
<h3 id="进程外与进程内（-NET）"><a href="#进程外与进程内（-NET）" class="headerlink" title="进程外与进程内（.NET）"></a>进程外与进程内（.NET）</h3><p>当你开发一个新的应用程序时，它可以在进程内运行，也可以在进程外运行。AutoCAD .NET API设计为仅在进程内运行，这与可在进程内或进程外使用的ActiveX Automation库不同。</p>
<ul>
<li>进程内应用程序被设计为在与宿主应用程序相同的进程空间中运行。在这种情况下，DLL程序集将加载到宿主应用程序AutoCAD中。</li>
<li>进程外应用程序不与宿主应用程序在同一空间中运行。这些应用程序通常构建为独立的可执行文件。</li>
</ul>
<p>如果需要创建独立应用程序来驱动AutoCAD，最好创建一个使用 CreateObject 和 GetObject 方法的应用程序，以创建AutoCAD应用程序的新实例或返回当前正在运行的实例之一。返回对 AcadApplication 的引用后，可以使用 SendCommand 方法将进程内.NET应用程序加载到AutoCAD中，该方法是 AcadApplication 的 ActiveDocument 属性的成员。</p>
<p>作为在进程内执行.NET应用程序的替代方法，可以为应用程序使用COM互操作。</p>
<p><strong>注意：</strong>COM应用程序访问AutoCAD 2024的ProgID为<em>AutoCAD.Application.24.3</em>。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Runtime.InteropServices;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.Interop;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.Runtime;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.ApplicationServices;</span><br><span class="line"> </span><br><span class="line">[<span class="meta">CommandMethod(<span class="string">&quot;ConnectToAcad&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ConnectToAcad</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">  AcadApplication acAppComObj = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="built_in">string</span> strProgId = <span class="string">&quot;AutoCAD.Application.24.3&quot;</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// Get a running instance of AutoCAD</span></span><br><span class="line">  <span class="keyword">try</span></span><br><span class="line">  &#123;</span><br><span class="line">      acAppComObj = (AcadApplication)Marshal.GetActiveObject(strProgId);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> <span class="comment">// An error occurs if no instance is running</span></span><br><span class="line">  &#123;</span><br><span class="line">      <span class="keyword">try</span></span><br><span class="line">      &#123;</span><br><span class="line">          <span class="comment">// Create a new instance of AutoCAD</span></span><br><span class="line">          acAppComObj = (AcadApplication)Activator.CreateInstance(Type.GetTypeFromProgID(strProgId), <span class="literal">true</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span></span><br><span class="line">      &#123;</span><br><span class="line">          <span class="comment">// If an instance of AutoCAD is not created then message and exit</span></span><br><span class="line">          System.Windows.Forms.MessageBox.Show(<span class="string">&quot;Instance of &#x27;AutoCAD.Application&#x27;&quot;</span> +</span><br><span class="line">                                               <span class="string">&quot; could not be created.&quot;</span>);</span><br><span class="line"> </span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// Display the application and return the name and version</span></span><br><span class="line">  acAppComObj.Visible = <span class="literal">true</span>;</span><br><span class="line">  System.Windows.Forms.MessageBox.Show(<span class="string">&quot;Now running &quot;</span> + acAppComObj.Name + </span><br><span class="line">                                       <span class="string">&quot; version &quot;</span> + acAppComObj.Version);</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// Get the active document</span></span><br><span class="line">  AcadDocument acDocComObj;</span><br><span class="line">  acDocComObj = acAppComObj.ActiveDocument;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// Optionally, load your assembly and start your command or if your assembly</span></span><br><span class="line">  <span class="comment">// is demandloaded, simply start the command of your in-process assembly.</span></span><br><span class="line">  acDocComObj.SendCommand(<span class="string">&quot;(command &quot;</span> + (<span class="built_in">char</span>)<span class="number">34</span> + <span class="string">&quot;NETLOAD&quot;</span> + (<span class="built_in">char</span>)<span class="number">34</span> + <span class="string">&quot; &quot;</span> +</span><br><span class="line">                          (<span class="built_in">char</span>)<span class="number">34</span> + <span class="string">&quot;c:/myapps/mycommands.dll&quot;</span> + (<span class="built_in">char</span>)<span class="number">34</span> + <span class="string">&quot;) &quot;</span>);</span><br><span class="line"> </span><br><span class="line">  acDocComObj.SendCommand(<span class="string">&quot;MyCommand &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="定义命令和AutoLISP函数（-NET）"><a href="#定义命令和AutoLISP函数（-NET）" class="headerlink" title="定义命令和AutoLISP函数（.NET）"></a>定义命令和AutoLISP函数（.NET）</h2><p>可以使用AutoCAD .NET API通过使用两个属性（ CommandMethod 和 LispFunction ）来定义命令和AutoLISP®函数。在AutoCAD中执行命令或AutoLISP函数时，将两个特性之一放置在应调用的方法之前。</p>
<p>用于命令的方法不应使用参数定义。但是，用于定义AutoLISP函数的方法应使用 ResultBuffer 对象类型的单个参数进行定义。</p>
<p>Topics in this section  本节中的主题</p>
<ul>
<li>命令定义（.NET）</li>
<li>AutoLISP函数定义（.NET）</li>
</ul>
<h3 id="命令定义（-NET）"><a href="#命令定义（-NET）" class="headerlink" title="命令定义（.NET）"></a>命令定义（.NET）</h3><p>定义命令时，使用 CommandMethod 属性。 CommandMethod 属性需要一个字符串值作为正在定义的命令的全局名称。沿着全局命令名， CommandMethod 属性可以接受以下值：</p>
<ul>
<li><strong>命令标志</strong>-定义命令的行为</li>
<li><strong>Group Name</strong>-命令组名称</li>
<li><strong>本地名称</strong>-本地命令名称，通常是特定于语言的</li>
<li><strong>Help Topic Name</strong>-按F1时应显示的帮助主题名称</li>
<li><strong>上下文菜单类型标志</strong>-定义命令激活时的上下文菜单行为</li>
<li><strong>Help File Name</strong>-包含帮助主题的帮助文件，当命令处于活动状态并按下F1键时，将显示该帮助主题</li>
</ul>
<p>下表列出了可用于定义命令行为的可用标志。</p>
<table>
<thead>
<tr>
<th align="left">枚举值</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">ActionMacro</td>
<td align="left">命令可以用动作录制器录制为动作。</td>
</tr>
<tr>
<td align="left">Defun</td>
<td align="left">命令可以作为LISP函数调用，因此可以使用 acedGetArgs() 从LISP接收参数，并可以使用 acedRetXxx() 函数将值返回到LISP。此标志只能由Visual LISP引擎设置。</td>
</tr>
<tr>
<td align="left">DocExclusiveLock</td>
<td align="left">当命令被调用时，文档将被独占锁定。</td>
</tr>
<tr>
<td align="left">DocReadLock</td>
<td align="left">当命令被调用时，文档将被读锁定。</td>
</tr>
<tr>
<td align="left">Interruptible</td>
<td align="left">当提示用户输入时，命令可能会中断。</td>
</tr>
<tr>
<td align="left">Modal</td>
<td align="left">当另一个命令处于活动状态时，无法调用该命令。</td>
</tr>
<tr>
<td align="left">NoActionRecording</td>
<td align="left">命令不能用动作录制器录制为动作。</td>
</tr>
<tr>
<td align="left">NoBlockEditor</td>
<td align="left">不能从块编辑器中使用命令。</td>
</tr>
<tr>
<td align="left">NoHistory</td>
<td align="left">命令未添加到repeat-last-command历史记录列表。</td>
</tr>
<tr>
<td align="left">NoInferConstraint</td>
<td align="left">推断约束时不能使用命令。</td>
</tr>
<tr>
<td align="left">NoInternalLock</td>
<td align="left">文档不能内部锁定。</td>
</tr>
<tr>
<td align="left">NoMultiple</td>
<td align="left">命令宏中带有星号（*）前缀时，命令不支持多重行为。</td>
</tr>
<tr>
<td align="left">NoNewStack</td>
<td align="left">命令不在堆栈上创建新项。</td>
</tr>
<tr>
<td align="left">NoOEM</td>
<td align="left">无法从AutoCAD OEM访问命令。</td>
</tr>
<tr>
<td align="left">NoPaperSpace</td>
<td align="left">不能从图纸空间使用命令。</td>
</tr>
<tr>
<td align="left">NoPerspective</td>
<td align="left">当PERSPECTIVE设置为1时，无法使用命令。</td>
</tr>
<tr>
<td align="left">NoTileMode</td>
<td align="left">当TILEMODE设置为1时，无法使用命令。</td>
</tr>
<tr>
<td align="left">NoUndoMarker</td>
<td align="left">命令不支持撤消标记。这适用于不修改数据库的命令，因此不应显示在撤消文件中。</td>
</tr>
<tr>
<td align="left">Redraw</td>
<td align="left">检索优先拾取集或夹点集时，不会清除它们。</td>
</tr>
<tr>
<td align="left">Session</td>
<td align="left">命令在应用程序的上下文中而不是在当前文档上下文中执行。</td>
</tr>
<tr>
<td align="left">TempShowDynDimension</td>
<td align="left">命令允许在选定图元时临时显示动态尺寸。</td>
</tr>
<tr>
<td align="left">Transparent</td>
<td align="left">命令可以在另一个命令处于活动状态时使用。</td>
</tr>
<tr>
<td align="left">Undefined</td>
<td align="left">命令只能通过其全局名称使用。</td>
</tr>
<tr>
<td align="left">UsePickSet</td>
<td align="left">检索到优先拾取集时，将清除该集。</td>
</tr>
</tbody></table>
<p><strong>实例和静态命令方法</strong></p>
<p>命令方法可以声明为实例方法或静态方法。静态命令方法在C#中使用static关键字声明，在VB. NET中使用 Shared 关键字声明。实例命令方法是不使用static或 Shared 关键字声明的公共类成员。</p>
<p>对于实例命令方法，方法的封闭类型为每个打开的文档单独实例化。这意味着每个文档都获得命令实例数据的私有副本。因此，当用户切换文档时，不存在丢失特定于文档的数据的危险。如果一个实例方法需要全局共享数据，它可以通过声明static或Shared成员变量来实现。</p>
<p>对于静态命令方法，托管包装运行时模块不需要实例化封闭类型。无论文档上下文如何，都使用方法数据的单个副本。静态命令通常不使用每个文档的数据，也不需要特别考虑MDI模式。</p>
<p>实例和静态方法可以用命令标志来定义，以适应特殊要求。例如，一个实例方法可以用一个设置 CommandFlags.Session 标志的属性来声明。这意味着该命令在应用程序执行上下文中运行，但也维护每个文档的数据。此类命令的AutoCAD示例是PROPERTIES命令。</p>
<p>同样地，静态方法可以在没有 CommandFlags.Session 标志的情况下声明。这种组合对于在文档上下文中运行但不需要维护每个文档数据的命令很有用。</p>
<p><strong>定义命令的语法</strong></p>
<p>下面演示了如何创建一个 CommandMethod 属性，该属性定义了一个名为CheckForPickfirstSelection的命令。该属性还使用命令标志 UsePickSet 来指示允许命令使用在命令启动之前选择的对象。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">CommandMethod(<span class="string">&quot;CheckForPickfirstSelection&quot;</span>, CommandFlags.UsePickSet)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CheckForPickfirstSelection</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"> . . .</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以通过在VB.NET中使用“+”运算符和C#中的“|”操作符。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">CommandMethod(<span class="string">&quot;CheckForPickfirstSelection&quot;</span>, CommandFlags.UsePickSet |</span></span><br><span class="line"><span class="meta">                                             CommandFlags.NoBlockEditor)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CheckForPickfirstSelection</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"> . . .</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AutoLISP函数定义（-NET）"><a href="#AutoLISP函数定义（-NET）" class="headerlink" title="AutoLISP函数定义（.NET）"></a>AutoLISP函数定义（.NET）</h3><p>定义AutoLISP函数时，使用 LispFunction 属性。 LispFunction 属性需要一个字符串值，用作所定义AutoLISP函数的全局名称。沿着全局函数名， LispFunction 结构可以接受以下值：</p>
<ul>
<li><strong>本地名称</strong>-本地函数名，通常是特定于语言的</li>
<li><strong>Help Topic Name</strong>-应与AutoLISP函数关联的帮助主题名称</li>
<li><strong>Help File Name</strong>-包含帮助主题的帮助文件，当命令处于活动状态并按下F1键时，将显示该帮助主题</li>
</ul>
<p><strong>定义AutoLISP函数的命令</strong></p>
<p>下面演示如何创建一个 LispFunction 属性，该属性定义名为InsertDynamicBlock的AutoLISP函数。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">LispFunction(<span class="string">&quot;DisplayFullName&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DisplayFullName</span>(<span class="params">ResultBuffer rbArgs</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"> . . .</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>传递给AutoLISP函数的值</strong></p>
<p>使用 Foreach 循环遍历AutoLISP函数在 ResultBuffer 中返回的值。 ResultBuffer 是 TypedValue 对象的集合。 TypedValue 对象的 TypeCode 属性可用于确定传递到AutoLISP函数中的每个值的值类型。 Value 属性用于返回 TypedValue 对象的值。</p>
<p>支持的数据类型包括：</p>
<ul>
<li>Boolean or bool  </li>
<li>Double or double  </li>
<li>Integer or int  </li>
<li>Null or void  </li>
<li>ObjectId</li>
<li>Point2d</li>
<li>Point3d</li>
<li>ResultBuffer</li>
<li>SelectionSet  </li>
<li>String or string  </li>
<li>TypedValue</li>
</ul>
<p><strong>定义AutoLISP函数的步骤</strong></p>
<p>此示例代码定义名为 DisplayFullName 的AutoLISP函数。虽然.NET项目中定义的方法接受单个值，但AutoLISP函数需要两个字符串值来生成正确的输出。</p>
<p>将.NET项目加载到AutoCAD中，然后在命令提示下输入以下命令：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">(displayfullname <span class="string">&quot;First&quot;</span> <span class="string">&quot;Last&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>以下是执行AutoLISP函数后显示的输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Name: First Last</span><br></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.Runtime;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.ApplicationServices;</span><br><span class="line"> </span><br><span class="line">[<span class="meta">LispFunction(<span class="string">&quot;DisplayFullName&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DisplayFullName</span>(<span class="params">ResultBuffer rbArgs</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (rbArgs != <span class="literal">null</span>)</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="built_in">string</span> strVal1 = <span class="string">&quot;&quot;</span>;</span><br><span class="line">      <span class="built_in">string</span> strVal2 = <span class="string">&quot;&quot;</span>;</span><br><span class="line"> </span><br><span class="line">      <span class="built_in">int</span> nCnt = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">foreach</span> (TypedValue rb <span class="keyword">in</span> rbArgs)</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="keyword">if</span> (rb.TypeCode == (<span class="built_in">int</span>)Autodesk.AutoCAD.Runtime.LispDataType.Text)</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="keyword">switch</span>(nCnt)</span><br><span class="line">              &#123;</span><br><span class="line">                  <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                      strVal1 = rb.Value.ToString();</span><br><span class="line">                      <span class="keyword">break</span>;</span><br><span class="line">                  <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                      strVal2 = rb.Value.ToString();</span><br><span class="line">                      <span class="keyword">break</span>;</span><br><span class="line">              &#125;</span><br><span class="line"> </span><br><span class="line">              nCnt = nCnt + <span class="number">1</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"> </span><br><span class="line">      Application.DocumentManager.MdiActiveDocument.Editor.</span><br><span class="line">         WriteMessage(<span class="string">&quot;\nName: &quot;</span> + strVal1 + <span class="string">&quot; &quot;</span> + strVal2);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="注：翻译自ObjectARX-Managed-NET-Developer’s-Guide，且只保留了C-部分的代码"><a href="#注：翻译自ObjectARX-Managed-NET-Developer’s-Guide，且只保留了C-部分的代码" class="headerlink" title="注：翻译自ObjectARX: Managed .NET Developer’s Guide，且只保留了C#部分的代码"></a><em><strong>注：</strong></em>翻译自<a href="https://help.autodesk.com/view/OARX/2024/ENU/?guid=GUID-C3F3C736-40CF-44A0-9210-55F6A939B6F2">ObjectARX: Managed .NET Developer’s Guide</a>，且只保留了C#部分的代码</h2>]]></content>
      <categories>
        <category>ObjectARX：Managed.NET开发人员指南</category>
      </categories>
      <tags>
        <tag>CAD</tag>
      </tags>
  </entry>
  <entry>
    <title>03创建和编辑AutoCAD图元（.NET）</title>
    <url>/2025/01/14/ObjectARX%EF%BC%9AManaged.NET%E5%BC%80%E5%8F%91%E4%BA%BA%E5%91%98%E6%8C%87%E5%8D%97/03%E5%88%9B%E5%BB%BA%E5%92%8C%E7%BC%96%E8%BE%91AutoCAD%E5%9B%BE%E5%85%83%EF%BC%88.NET%EF%BC%89/</url>
    <content><![CDATA[<h1 id="创建和编辑AutoCAD图元（-NET）"><a href="#创建和编辑AutoCAD图元（-NET）" class="headerlink" title="创建和编辑AutoCAD图元（.NET）"></a>创建和编辑AutoCAD图元（.NET）</h1><p>可以创建一系列对象，从简单的直线和圆到样条曲线、椭圆和关联填充区域。一般来说，您可以使用 AppendEntity 函数将对象添加到 BlockTableRecord 对象。创建对象后，可以更改其特性，例如图层、颜色和线型。</p>
<p>图形数据库与其他数据库程序类似，可以将模型空间中的Line对象视为表记录，将模型空间视为其数据库表。使用数据库时，必须先打开和关闭记录，然后才能使用它们。存储在 Database 对象中的对象没有什么不同，您可以使用 GetObject 函数从数据库中检索对象并定义如何使用该对象。</p>
<p>本节中的主题</p>
<ul>
<li><p>打开和关闭对象（.NET）</p>
</li>
<li><p>创建对象（.NET）</p>
</li>
<li><p>使用选择集（.NET）</p>
<p>选择集可以由单个对象组成，也可以是更复杂的分组：例如，某个图层上的对象集。</p>
</li>
<li><p>编辑命名对象和2D对象（.NET）</p>
</li>
<li><p>使用图层、颜色和线型（.NET）</p>
</li>
<li><p>保存和恢复图层状态（.NET）</p>
</li>
<li><p>将文本添加到图形（.NET）</p>
</li>
</ul>
<h2 id="打开和关闭对象（-NET）"><a href="#打开和关闭对象（-NET）" class="headerlink" title="打开和关闭对象（.NET）"></a>打开和关闭对象（.NET）</h2><p>无论您是在处理对象（如直线、圆和线）还是符号表及其记录，都需要打开对象进行读取或写入。当查询一个对象时，你想打开这个对象进行读取，但是如果你要对这个对象进行修改，你想打开它进行写入。</p>
<p>本节中的主题</p>
<ul>
<li><p>使用ObjectIds（.NET）</p>
</li>
<li><p>将事务与事务管理器（.NET）一起使用</p>
</li>
<li><p>不使用事务管理器打开和关闭对象（.NET）</p>
</li>
<li><p>升级和降级Open Objects（.NET）</p>
<p>通过升级或降级对象，可以将对象的当前打开模式从读更改为写或从写更改为读。</p>
</li>
<li><p>关于使用动态语言（.NET）</p>
<p>AutoCAD托管.NET API允许您利用.NET 4.0中引入的动态语言编译器（DLR）。</p>
</li>
</ul>
<h3 id="使用ObjectIds（-NET）"><a href="#使用ObjectIds（-NET）" class="headerlink" title="使用ObjectIds（.NET）"></a>使用ObjectIds（.NET）</h3><p>数据库中包含的每个对象都被分配了几个唯一的id。访问对象的独特方式包括：</p>
<ul>
<li>Entity handle  </li>
<li>ObjectId</li>
<li>Instance pointer</li>
</ul>
<p>访问对象的最常见方式是通过其ObjectId。如果您的项目同时使用COM互操作和托管AutoCAD .NET API，则ObjectId非常有效。如果创建自定义AutoLISP函数，则可能需要使用实体句柄。</p>
<p>句柄在AutoCAD会话之间是永久性的，因此，如果需要将图形信息导出到外部文件（稍后可能需要使用该文件来更新图形），则句柄是访问对象的最佳方式。数据库中对象的ObjectId仅在数据库加载到内存中时才存在。一旦数据库关闭，分配给对象的ObjectId就不再存在，并且在下次打开数据库时可能会有所不同。</p>
<p><strong>获取ObjectId</strong></p>
<p>使用对象时，在打开对象进行查询或编辑之前，需要先获取ObjectId。当打开图形文件时，ObjectId将被分配给数据库中的现有对象，而新对象在首次创建时将被分配ObjectId。通常通过以下方式获取数据库中现有对象的ObjectId：</p>
<ul>
<li>使用 Database 对象的成员属性，例如 Clayer ，它检索当前图层的对象ID</li>
<li>迭代符号表，如图层符号表</li>
</ul>
<p><strong>打开对象</strong></p>
<p>获取Object Id后，使用 GetObject 函数打开指定Object Id的对象。可以通过以下方式打开对象：</p>
<ul>
<li>Read.打开一个对象进行读取。</li>
<li>Write. 如果对象尚未打开，则打开该对象进行写入。</li>
<li>Notify.通知。当对象处于关闭状态、打开进行读取或打开进行写入时，打开对象进行通知，但当对象已打开进行通知时，不打开对象进行通知。此模式适用于对象可能从其自身代码中修改自身的情况，例如定义AutoCAD Managed .NET API不支持的自定义对象时。</li>
</ul>
<p>您应该以最适合访问对象的情况的模式打开对象。由于创建撤消记录，打开对象进行写操作会引入额外的开销。如果不确定要打开的对象是否是要使用的对象，则应将其打开以进行读取，然后将对象从读取模式升级到写入模式。有关升级对象的更多信息，请参阅“升级和降级开放对象（.NET）”。</p>
<p>GetObject 和 Open 函数都返回一个对象。在使用某些编程语言时，您需要根据值被赋给的变量强制转换返回值。如果您使用的是VB.NET，则无需担心转换返回值，因为它已为您完成。</p>
<p>当使用动态编译语言（DLR）时，您不需要担心打开对象进行读取或写入。对象的打开对您来说是透明的，提交对对象所做的更改的过程也是透明的，而不使用事务。</p>
<p>以下示例说明如何获取当前数据库的零层的 LayerTableRecord 。</p>
<p>下面的示例在不再需要事务后手动处置该事务。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Document acCurDb = Application.DocumentManager.MdiActiveDocument.Database;</span><br><span class="line">Transaction acTrans = acCurDb.TransactionManager.StartTransaction();</span><br><span class="line"> </span><br><span class="line">LayerTableRecord acLyrTblRec;</span><br><span class="line">acLyrTblRec = acTrans.GetObject(acCurDb.LayerZero,</span><br><span class="line">                                OpenMode.ForRead) <span class="keyword">as</span> LayerTableRecord;</span><br><span class="line"> </span><br><span class="line">acTrans.Dispose();</span><br></pre></td></tr></table></figure>

<p>下面的示例使用 Using 语句在不再需要事务后释放该事务。 Using 语句是首选的编码风格。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Document acCurDb = Application.DocumentManager.MdiActiveDocument.Database;</span><br><span class="line"><span class="keyword">using</span> (Transaction acTrans = acCurDb.TransactionManager.StartTransaction())</span><br><span class="line">&#123;</span><br><span class="line">    LayerTableRecord acLyrTblRec;</span><br><span class="line">    acLyrTblRec = acTrans.GetObject(acCurDb.LayerZero,</span><br><span class="line">                                    OpenMode.ForRead) <span class="keyword">as</span> LayerTableRecord;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="将事务与事务管理器（-NET）一起使用"><a href="#将事务与事务管理器（-NET）一起使用" class="headerlink" title="将事务与事务管理器（.NET）一起使用"></a>将事务与事务管理器（.NET）一起使用</h3><p>事务用于将多个对象上的多个操作组合在一起作为单个操作。事务通过事务管理器启动和管理。一旦一个事务开始，你就可以使用 GetObject 函数打开一个对象。</p>
<p>当您使用使用 GetObject 打开的对象时，事务管理器会跟踪对对象所做的更改。您创建并添加到数据库中的任何新对象都应该使用 AddNewlyCreatedDBObject 函数添加到事务中。对象被编辑或添加到数据库后，您可以保存对数据库所做的更改，并使用使用事务管理器创建的事务对象上的 Commit 函数关闭所有打开的对象。一旦你完成了一个事务，调用 Dispose 函数关闭这个事务。</p>
<p>本节中的主题</p>
<ul>
<li>使用事务访问和创建对象（.NET）</li>
<li>提交和回滚更改（.NET）</li>
<li>释放对象（.NET）</li>
<li>嵌套事务（.NET）</li>
</ul>
<h4 id="使用事务访问和创建对象（-NET）"><a href="#使用事务访问和创建对象（-NET）" class="headerlink" title="使用事务访问和创建对象（.NET）"></a>使用事务访问和创建对象（.NET）</h4><p>从当前数据库的 TransactionManager 属性访问事务管理器。引用事务管理器后，可以使用以下方法之一来启动或获取事务：</p>
<ul>
<li>StartTransaction-通过创建 Transaction 对象的新实例来启动新事务。当需要多次写入对象并通过使用不同的嵌套级别控制如何回滚更改时，请使用此方法。</li>
<li>StartOpenCloseTransation-创建一个 OpenCloseTransaction 对象，它的行为类似于 Transaction 对象，它包装了对象的 Open 和 Close 方法，使其更容易关闭所有打开的对象，而不必显式关闭每个打开的对象。建议在可能被调用未知次数的支持或实用程序函数中使用，并在处理大多数事件处理程序时使用。</li>
</ul>
<p>一旦有了 Transaction 或 OpenCloseTransaction 对象，就可以使用 GetObject 方法打开存储在数据库中的对象进行读或写。 GetObject 方法返回一个 DBObject ，它可以转换为它所代表的实际对象类型。</p>
<p>在事务处理期间打开的所有打开对象在事务处理结束时关闭。要结束事务，请调用事务对象的 Dispose 方法。如果使用 Using 和 End Using 关键字来指示事务的开始和结束，则不需要调用 Dispose 方法。</p>
<p>在释放事务之前，您应该提交使用 Commit 方法所做的任何更改。如果在处置事务之前没有提交更改，则所做的任何更改都将回滚到事务开始之前的状态。</p>
<p>可以启动多个事务。可以使用 TransactionManager 对象的 NumberOfActiveTransactions 属性检索活动事务的数量，而可以使用 TopTransaction 属性检索最顶部或最新的事务。</p>
<p>事务可以一个嵌套在另一个内部，以便回滚在例程执行期间所做的某些更改。</p>
<p><strong>查询对象</strong></p>
<p>下面的示例演示如何使用事务打开和读取中的对象。使用 GetObject 方法首先打开 BlockTable ，然后打开Model空间记录。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.Runtime;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.ApplicationServices;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.DatabaseServices;</span><br><span class="line"> </span><br><span class="line">[<span class="meta">CommandMethod(<span class="string">&quot;StartTransactionManager&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">StartTransactionManager</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Get the current document and database</span></span><br><span class="line">    Document acDoc = Application.DocumentManager.MdiActiveDocument;</span><br><span class="line">    Database acCurDb = acDoc.Database;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Start a transaction</span></span><br><span class="line">    <span class="keyword">using</span> (Transaction acTrans = acCurDb.TransactionManager.StartTransaction())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Open the Block table for read</span></span><br><span class="line">        BlockTable acBlkTbl;</span><br><span class="line">        acBlkTbl = acTrans.GetObject(acCurDb.BlockTableId,</span><br><span class="line">                                     OpenMode.ForRead) <span class="keyword">as</span> BlockTable;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// Open the Block table record Model space for read</span></span><br><span class="line">        BlockTableRecord acBlkTblRec;</span><br><span class="line">        acBlkTblRec = acTrans.GetObject(acBlkTbl[BlockTableRecord.ModelSpace],</span><br><span class="line">                                        OpenMode.ForRead) <span class="keyword">as</span> BlockTableRecord;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// Step through the Block table record</span></span><br><span class="line">        <span class="keyword">foreach</span> (ObjectId asObjId <span class="keyword">in</span> acBlkTblRec)</span><br><span class="line">        &#123;</span><br><span class="line">            acDoc.Editor.WriteMessage(<span class="string">&quot;\nDXF name: &quot;</span> + asObjId.ObjectClass.DxfName);</span><br><span class="line">            acDoc.Editor.WriteMessage(<span class="string">&quot;\nObjectID: &quot;</span> + asObjId.ToString());</span><br><span class="line">            acDoc.Editor.WriteMessage(<span class="string">&quot;\nHandle: &quot;</span> + asObjId.Handle.ToString());</span><br><span class="line">            acDoc.Editor.WriteMessage(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// Dispose of the transaction</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>向数据库添加新对象</strong></p>
<p>下面的示例演示如何在事务中向数据库中添加一个圆对象。使用 GetObject 方法首先打开BlockTable进行读取，然后打开Model空间记录进行写入。打开Model空间进行写操作后，使用 AppendEntity 和 AddNewlyCreatedDBObject 函数将新的Circle对象附加到Model空间以及事务。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.Runtime;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.ApplicationServices;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.DatabaseServices;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.Geometry;</span><br><span class="line"> </span><br><span class="line">[<span class="meta">CommandMethod(<span class="string">&quot;AddNewCircleTransaction&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">AddNewCircleTransaction</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Get the current document and database</span></span><br><span class="line">    Document acDoc = Application.DocumentManager.MdiActiveDocument;</span><br><span class="line">    Database acCurDb = acDoc.Database;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start a transaction</span></span><br><span class="line">    <span class="keyword">using</span> (Transaction acTrans = acCurDb.TransactionManager.StartOpenCloseTransaction())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Open the Block table for read</span></span><br><span class="line">        BlockTable acBlkTbl;</span><br><span class="line">        acBlkTbl = acTrans.GetObject(acCurDb.BlockTableId,</span><br><span class="line">                                        OpenMode.ForRead) <span class="keyword">as</span> BlockTable;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Open the Block table record Model space for write</span></span><br><span class="line">        BlockTableRecord acBlkTblRec;</span><br><span class="line">        acBlkTblRec = acTrans.GetObject(acBlkTbl[BlockTableRecord.ModelSpace],</span><br><span class="line">                                        OpenMode.ForWrite) <span class="keyword">as</span> BlockTableRecord;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create a circle with a radius of 3 at 5,5</span></span><br><span class="line">        <span class="keyword">using</span> (Circle acCirc = <span class="keyword">new</span> Circle())</span><br><span class="line">        &#123;</span><br><span class="line">            acCirc.Center = <span class="keyword">new</span> Point3d(<span class="number">5</span>, <span class="number">5</span>, <span class="number">0</span>);</span><br><span class="line">            acCirc.Radius = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Add the new object to Model space and the transaction</span></span><br><span class="line">            acBlkTblRec.AppendEntity(acCirc);</span><br><span class="line">            acTrans.AddNewlyCreatedDBObject(acCirc, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Commit the changes and dispose of the transaction</span></span><br><span class="line">        acTrans.Commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="提交和回滚更改（-NET）"><a href="#提交和回滚更改（-NET）" class="headerlink" title="提交和回滚更改（.NET）"></a>提交和回滚更改（.NET）</h4><p>使用事务时，可以决定何时将对对象的更改保存到图形数据库中。您可以使用 Commit 方法保存对事务中打开的对象所做的更改。如果你的程序遇到错误，你可以使用 Abort 方法回滚在事务中所做的任何更改。</p>
<p>如果在调用 Dispose 之前没有调用 Commit ，则回滚事务中所做的所有更改。无论调用 Commit 还是 Abort ，都需要调用 Dispose 来表示事务结束。如果transaction对象是用 Using 语句启动的，则不必调用 Dispose 。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Commit the changes made within the transaction</span></span><br><span class="line">&lt;transaction&gt;.Commit();</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Abort the transaction and rollback to the previous state</span></span><br><span class="line">&lt;transaction&gt;.Abort();</span><br></pre></td></tr></table></figure>

<h4 id="Dispose-对象（-NET）"><a href="#Dispose-对象（-NET）" class="headerlink" title="Dispose 对象（.NET）"></a>Dispose 对象（.NET）</h4><p>在.NET中创建新对象时，必须通过处理过程和垃圾收集从内存中正确释放对象。你可以使用 Dispose 方法或 Using 语句来通知一个对象何时可以进行垃圾回收。在大多数情况下， Using 语句是首选方法，因为它在不再需要对象时进行适当的调用来关闭和释放对象。</p>
<p>您需要在以下条件下释放对象：</p>
<ul>
<li>总是使用 Transaction 或 DocumentLock 对象</li>
<li>总是使用新创建的数据库对象，从 DBObject 派生的对象，这些对象正在添加到事务中</li>
<li>始终使用新创建的数据库对象，即从 DBObject 派生的对象，这些对象未添加到数据库中</li>
<li>不必与现有的数据库对象，从 DBObject 派生的对象，用transaction对象和 GetObject 方法打开</li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Dispose an object with the using statement</span></span><br><span class="line"><span class="keyword">using</span> (&lt;dataType&gt; &lt;<span class="built_in">object</span>&gt;  = &lt;<span class="keyword">value</span>&gt;)</span><br><span class="line">    <span class="comment">// Do something here</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Manually dispose of an object with the Dispose method</span></span><br><span class="line">&lt;<span class="built_in">object</span>&gt;. Dispose ();</span><br></pre></td></tr></table></figure>

<h4 id="嵌套事务（-NET）"><a href="#嵌套事务（-NET）" class="headerlink" title="嵌套事务（.NET）"></a>嵌套事务（.NET）</h4><p>事务可以一个嵌套在另一个内部。您可能有一个外部事务来撤消例程所做的所有更改，而内部事务只撤消所做更改的一部分。当你处理嵌套事务时，你从一个顶层事务开始，它也是最外层的事务。</p>
<p>当您开始新的事务时，它们将被添加到前一个事务中。嵌套事务必须按照与创建它们相反的顺序提交或中止。所以如果你有三个事务，你必须在第二个之前关闭第三个或最里面的一个，最后关闭第一个。如果中止第一个事务，则将撤消所有三个事务所做的更改。</p>
<p>下图显示事务在嵌套时的显示方式。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2024/ENU/OARX-DevGuide-Managed/images/GUID-ECA5C137-B00E-4686-8086-86EB4DC55F6E.png"></p>
<p><strong>使用嵌套事务创建和修改对象</strong></p>
<p>下面的示例演示如何使用三个事务创建 Circle 和 Line 对象，然后更改它们的颜色。圆的颜色在第二和第三个事务中改变，但是由于第三个事务被中止，所以只有在第一和第二个事务中所做的改变被保存到数据库中。此外，在创建和关闭活动事务时，会在“命令行”窗口中打印活动事务的数量。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.Runtime;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.ApplicationServices;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.DatabaseServices;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.Geometry;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.EditorInput;</span><br><span class="line"> </span><br><span class="line">[<span class="meta">CommandMethod(<span class="string">&quot;NestedTransactions&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">NestedTransactions</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Get the current document and database</span></span><br><span class="line">    Document acDoc = Application.DocumentManager.MdiActiveDocument;</span><br><span class="line">    Database acCurDb = acDoc.Database;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create a reference to the Transaction Manager</span></span><br><span class="line">    Autodesk.AutoCAD.DatabaseServices.TransactionManager acTransMgr;</span><br><span class="line">    acTransMgr = acCurDb.TransactionManager;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create a new transaction</span></span><br><span class="line">    <span class="keyword">using</span> (Transaction acTrans1 = acTransMgr.StartTransaction())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Print the current number of active transactions</span></span><br><span class="line">        acDoc.Editor.WriteMessage(<span class="string">&quot;\nNumber of transactions active: &quot;</span> +</span><br><span class="line">                                    acTransMgr.NumberOfActiveTransactions.ToString());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Open the Block table for read</span></span><br><span class="line">        BlockTable acBlkTbl;</span><br><span class="line">        acBlkTbl = acTrans1.GetObject(acCurDb.BlockTableId,</span><br><span class="line">                                        OpenMode.ForRead) <span class="keyword">as</span> BlockTable;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Open the Block table record Model space for write</span></span><br><span class="line">        BlockTableRecord acBlkTblRec;</span><br><span class="line">        acBlkTblRec = acTrans1.GetObject(acBlkTbl[BlockTableRecord.ModelSpace],</span><br><span class="line">                                            OpenMode.ForWrite) <span class="keyword">as</span> BlockTableRecord;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create a circle with a radius of 3 at 5,5</span></span><br><span class="line">        <span class="keyword">using</span> (Circle acCirc = <span class="keyword">new</span> Circle())</span><br><span class="line">        &#123;</span><br><span class="line">            acCirc.Center = <span class="keyword">new</span> Point3d(<span class="number">5</span>, <span class="number">5</span>, <span class="number">0</span>);</span><br><span class="line">            acCirc.Radius = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Add the new object to Model space and the transaction</span></span><br><span class="line">            acBlkTblRec.AppendEntity(acCirc);</span><br><span class="line">            acTrans1.AddNewlyCreatedDBObject(acCirc, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Create the second transaction</span></span><br><span class="line">            <span class="keyword">using</span> (Transaction acTrans2 = acTransMgr.StartTransaction())</span><br><span class="line">            &#123;</span><br><span class="line">                acDoc.Editor.WriteMessage(<span class="string">&quot;\nNumber of transactions active: &quot;</span> +</span><br><span class="line">                                            acTransMgr.NumberOfActiveTransactions.ToString());</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Change the circle&#x27;s color</span></span><br><span class="line">                acCirc.ColorIndex = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Get the object that was added to Transaction 1 and set it to the color 5</span></span><br><span class="line">                <span class="keyword">using</span> (Line acLine = <span class="keyword">new</span> Line(<span class="keyword">new</span> Point3d(<span class="number">2</span>, <span class="number">5</span>, <span class="number">0</span>), <span class="keyword">new</span> Point3d(<span class="number">10</span>, <span class="number">7</span>, <span class="number">0</span>)))</span><br><span class="line">                &#123;</span><br><span class="line">                    acLine.ColorIndex = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// Add the new object to Model space and the transaction</span></span><br><span class="line">                    acBlkTblRec.AppendEntity(acLine);</span><br><span class="line">                    acTrans2.AddNewlyCreatedDBObject(acLine, <span class="literal">true</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Create the third transaction</span></span><br><span class="line">                <span class="keyword">using</span> (Transaction acTrans3 = acTransMgr.StartTransaction())</span><br><span class="line">                &#123;</span><br><span class="line">                    acDoc.Editor.WriteMessage(<span class="string">&quot;\nNumber of transactions active: &quot;</span> +</span><br><span class="line">                                                acTransMgr.NumberOfActiveTransactions.ToString());</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// Change the circle&#x27;s color</span></span><br><span class="line">                    acCirc.ColorIndex = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// Update the display of the drawing</span></span><br><span class="line">                    acDoc.Editor.WriteMessage(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">                    acDoc.Editor.Regen();</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// Request to keep or discard the changes in the third transaction</span></span><br><span class="line">                    PromptKeywordOptions pKeyOpts = <span class="keyword">new</span> PromptKeywordOptions(<span class="string">&quot;&quot;</span>);</span><br><span class="line">                    pKeyOpts.Message = <span class="string">&quot;\nKeep color change &quot;</span>;</span><br><span class="line">                    pKeyOpts.Keywords.Add(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">                    pKeyOpts.Keywords.Add(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">                    pKeyOpts.Keywords.Default = <span class="string">&quot;No&quot;</span>;</span><br><span class="line">                    pKeyOpts.AllowNone = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">                    PromptResult pKeyRes = acDoc.Editor.GetKeywords(pKeyOpts);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (pKeyRes.StringResult == <span class="string">&quot;No&quot;</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">// Discard the changes in transaction 3</span></span><br><span class="line">                        acTrans3.Abort();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">// Save the changes in transaction 3</span></span><br><span class="line">                        acTrans3.Commit();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// Dispose the transaction</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                acDoc.Editor.WriteMessage(<span class="string">&quot;\nNumber of transactions active: &quot;</span> +</span><br><span class="line">                                            acTransMgr.NumberOfActiveTransactions.ToString());</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Keep the changes to transaction 2</span></span><br><span class="line">                acTrans2.Commit();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        acDoc.Editor.WriteMessage(<span class="string">&quot;\nNumber of transactions active: &quot;</span> +</span><br><span class="line">                                    acTransMgr.NumberOfActiveTransactions.ToString());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Keep the changes to transaction 1</span></span><br><span class="line">        acTrans1.Commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="不使用事务管理器打开和关闭对象（-NET）"><a href="#不使用事务管理器打开和关闭对象（-NET）" class="headerlink" title="不使用事务管理器打开和关闭对象（.NET）"></a>不使用事务管理器打开和关闭对象（.NET）</h3><p>事务使打开和处理多个对象变得更容易，但它们不是打开和编辑对象的唯一方法。除了使用事务之外，您还可以使用 Open 和 Close 方法打开和关闭对象。您仍然需要获得对象ID才能使用 Open 方法。与transactions中使用的 GetObject 方法一样，您需要指定一个开放模式，并且返回值是一个对象。</p>
<p>如果您在使用 Open 方法打开对象后对其进行了更改，则可以使用 Cancel 方法回滚自打开对象以来所做的所有更改。 Cancel 必须在每个要回滚的对象上调用。在关闭对象后，还必须使用 Dispose 方法正确地释放对象，或者可以使用 Using 语句关闭和释放对象。</p>
<p>注意：对象必须与打开和关闭操作配对。如果你使用了没有 Using 语句的 Open 方法，你必须在一个打开的对象上调用 Close 或 Cancel 方法。如果无法关闭对象，将导致读取访问冲突，并导致AutoCAD变得不稳定。</p>
<p>如果您需要处理单个对象，与使用事务管理器相比，使用 Open 和 Close 方法可以减少您可能必须编写的代码行数。但是，建议使用事务来打开和关闭对象。</p>
<p>注意：使用事务时，不应直接使用 Open 和 Close 方法，因为事务管理器可能无法正确打开或关闭对象，这可能会导致AutoCAD变得不稳定。相反，使用 StartOpenCloseTransation 方法创建一个 OpenCloseTransaction 对象，它包装了 Open 和 Close 方法。</p>
<p><strong>查询对象（手动打开和关闭对象）</strong></p>
<p>这个例子演示了如何手动打开和关闭对象，而不使用transaction和 GetObject 方法。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.Runtime;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.ApplicationServices;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.DatabaseServices;</span><br><span class="line"> </span><br><span class="line">[<span class="meta">CommandMethod(<span class="string">&quot;OpenCloseObjectId&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">OpenCloseObjectId</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Get the current document and database</span></span><br><span class="line">    Document acDoc = Application.DocumentManager.MdiActiveDocument;</span><br><span class="line">    Database acCurDb = acDoc.Database;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Open the Block table for read</span></span><br><span class="line">    BlockTable acBlkTbl = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        acBlkTbl = acCurDb.BlockTableId.Open(OpenMode.ForRead) <span class="keyword">as</span> BlockTable;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Open the Block table record Model space for read</span></span><br><span class="line">        BlockTableRecord acBlkTblRec = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            acBlkTblRec = acBlkTbl[BlockTableRecord.ModelSpace].Open(OpenMode.ForRead) <span class="keyword">as</span> BlockTableRecord;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Step through the Block table record</span></span><br><span class="line">            <span class="keyword">foreach</span> (ObjectId acObjId <span class="keyword">in</span> acBlkTblRec)</span><br><span class="line">            &#123;</span><br><span class="line">                acDoc.Editor.WriteMessage(<span class="string">&quot;\nDXF name: &quot;</span> + acObjId.ObjectClass.DxfName);</span><br><span class="line">                acDoc.Editor.WriteMessage(<span class="string">&quot;\nObjectID: &quot;</span> + acObjId.ToString());</span><br><span class="line">                acDoc.Editor.WriteMessage(<span class="string">&quot;\nHandle: &quot;</span> + acObjId.Handle.ToString());</span><br><span class="line">                acDoc.Editor.WriteMessage(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Autodesk.AutoCAD.Runtime.Exception es)</span><br><span class="line">        &#123;</span><br><span class="line">            System.Windows.Forms.MessageBox.Show(es.Message);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Close the Block table</span></span><br><span class="line">            <span class="keyword">if</span> (!acBlkTblRec.ObjectId.IsNull)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// Close the Block table record</span></span><br><span class="line">                acBlkTblRec.Close();</span><br><span class="line">                acBlkTblRec.Dispose();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Autodesk.AutoCAD.Runtime.Exception es)</span><br><span class="line">    &#123;</span><br><span class="line">        System.Windows.Forms.MessageBox.Show(es.Message);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Close the Block table</span></span><br><span class="line">        <span class="keyword">if</span> (!acBlkTbl.ObjectId.IsNull)</span><br><span class="line">        &#123;</span><br><span class="line">            acBlkTbl.Close();</span><br><span class="line">            acBlkTbl.Dispose();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>查询对象（使用语句）</strong></p>
<p>下面的示例演示如何使用Using语句打开和关闭对象，而不是手动关闭和释放对象。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.Runtime;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.ApplicationServices;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.DatabaseServices;</span><br><span class="line"> </span><br><span class="line">[<span class="meta">CommandMethod(<span class="string">&quot;OpenCloseObjectIdWithUsing&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">OpenCloseObjectIdWithUsing</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Get the current document and database</span></span><br><span class="line">    Document acDoc = Application.DocumentManager.MdiActiveDocument;</span><br><span class="line">    Database acCurDb = acDoc.Database;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Open the Block table for read</span></span><br><span class="line">    <span class="keyword">using</span> (BlockTable acBlkTbl = acCurDb.BlockTableId.Open(OpenMode.ForRead) <span class="keyword">as</span> BlockTable)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Open the Block table record Model space for read</span></span><br><span class="line">        <span class="keyword">using</span> (BlockTableRecord acBlkTblRec = acBlkTbl[BlockTableRecord.ModelSpace].Open(OpenMode.ForRead)</span><br><span class="line">                                                <span class="keyword">as</span> BlockTableRecord)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Step through the Block table record</span></span><br><span class="line">            <span class="keyword">foreach</span> (ObjectId acObjId <span class="keyword">in</span> acBlkTblRec)</span><br><span class="line">            &#123;</span><br><span class="line">                acDoc.Editor.WriteMessage(<span class="string">&quot;\nDXF name: &quot;</span> + acObjId.ObjectClass.DxfName);</span><br><span class="line">                acDoc.Editor.WriteMessage(<span class="string">&quot;\nObjectID: &quot;</span> + acObjId.ToString());</span><br><span class="line">                acDoc.Editor.WriteMessage(<span class="string">&quot;\nHandle: &quot;</span> + acObjId.Handle.ToString());</span><br><span class="line">                acDoc.Editor.WriteMessage(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Close the Block table record</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Close the Block table</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>向数据库添加新对象</strong></p>
<p>这个例子演示了如何创建一个新的对象，并将其追加到模型空间，而不使用事务管理器。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.Runtime;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.ApplicationServices;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.DatabaseServices;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.Geometry;</span><br><span class="line"> </span><br><span class="line">[<span class="meta">CommandMethod(<span class="string">&quot;AddNewCircleOpenClose&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">AddNewCircleOpenClose</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Get the current document and database</span></span><br><span class="line">    Document acDoc = Application.DocumentManager.MdiActiveDocument;</span><br><span class="line">    Database acCurDb = acDoc.Database;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Open the Block table for read</span></span><br><span class="line">    <span class="keyword">using</span> (BlockTable acBlkTbl = acCurDb.BlockTableId.Open(OpenMode.ForRead) <span class="keyword">as</span> BlockTable)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Open the Block table record Model space for write</span></span><br><span class="line">        <span class="keyword">using</span> (BlockTableRecord acBlkTblRec = acBlkTbl[BlockTableRecord.ModelSpace].Open(OpenMode.ForWrite)</span><br><span class="line">                                                <span class="keyword">as</span> BlockTableRecord)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Create a circle with a radius of 3 at 5,5</span></span><br><span class="line">            <span class="keyword">using</span> (Circle acCirc = <span class="keyword">new</span> Circle())</span><br><span class="line">            &#123;</span><br><span class="line">                acCirc.Center = <span class="keyword">new</span> Point3d(<span class="number">5</span>, <span class="number">5</span>, <span class="number">0</span>);</span><br><span class="line">                acCirc.Radius = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Add the new object to Model space and the transaction</span></span><br><span class="line">                acBlkTblRec.AppendEntity(acCirc);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Close and dispose the circle object</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Close the Block table record</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Close the Block table</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="升级和降级Open-Objects（-NET）"><a href="#升级和降级Open-Objects（-NET）" class="headerlink" title="升级和降级Open Objects（.NET）"></a>升级和降级Open Objects（.NET）</h3><p>通过升级或降级对象，可以将对象的当前打开模式从读更改为写或从写更改为读。</p>
<p>这些方法可用于升级或降级以前打开的对象：</p>
<ul>
<li>Transaction.GetObject method – 如果对象是用 Transaction.GetObject 方法打开的，则使用该方法以所需的新打开模式重新打开对象。</li>
<li>UpgradeOpen and DowngradeOpen methods –如果对象是用 Open 方法或 OpenCloseTransaction.GetObject 打开的，则使用 UpgradeOpen 方法将对象的打开模式从读更改为写，或使用 DowngradeOpen 方法将对象的打开模式从写更改为读。您不需要将对 DowngradeOpen 的调用与每个 UpgradeOpen 配对，因为关闭对象或处置事务将足以清理对象的打开状态。</li>
</ul>
<p>建议使用与对象的使用方式最匹配的模式打开对象，因为打开对象以读取并查询对象的属性比打开对象以写入并查询对象的属性更有效。如果你不确定一个对象是否需要修改，最好打开对象进行读操作，然后升级它进行写操作，因为这有助于减少程序的开销。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.Runtime;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.ApplicationServices;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.DatabaseServices;</span><br><span class="line"> </span><br><span class="line">[<span class="meta">CommandMethod(<span class="string">&quot;FreezeDoorLayer&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">FreezeDoorLayer</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Get the current document and database</span></span><br><span class="line">    Document acDoc = Application.DocumentManager.MdiActiveDocument;</span><br><span class="line">    Database acCurDb = acDoc.Database;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start a transaction</span></span><br><span class="line">    <span class="keyword">using</span> (Transaction acTrans = acCurDb.TransactionManager.StartTransaction())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Open the Layer table for read</span></span><br><span class="line">        LayerTable acLyrTbl;</span><br><span class="line">        acLyrTbl = acTrans.GetObject(acCurDb.LayerTableId,</span><br><span class="line">                                        OpenMode.ForRead) <span class="keyword">as</span> LayerTable;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Step through each layer and update those that start with &#x27;Door&#x27;</span></span><br><span class="line">        <span class="keyword">foreach</span> (ObjectId acObjId <span class="keyword">in</span> acLyrTbl)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Open the Layer table record for read</span></span><br><span class="line">            LayerTableRecord acLyrTblRec;</span><br><span class="line">            acLyrTblRec = acTrans.GetObject(acObjId,</span><br><span class="line">                                            OpenMode.ForRead) <span class="keyword">as</span> LayerTableRecord;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Check to see if the layer&#x27;s name starts with &#x27;Door&#x27; </span></span><br><span class="line">            <span class="keyword">if</span> (acLyrTblRec.Name.StartsWith(<span class="string">&quot;Door&quot;</span>,</span><br><span class="line">                                            StringComparison.OrdinalIgnoreCase) == <span class="literal">true</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// Check to see if the layer is current, if so then do not freeze it</span></span><br><span class="line">                <span class="keyword">if</span> (acLyrTblRec.ObjectId != acCurDb.Clayer)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// Change from read to write mode</span></span><br><span class="line">                    acTrans.GetObject(acObjId, OpenMode.ForWrite);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// Freeze the layer</span></span><br><span class="line">                    acLyrTblRec.IsFrozen = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Commit the changes and dispose of the transaction</span></span><br><span class="line">        acTrans.Commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="关于使用动态语言（-NET）"><a href="#关于使用动态语言（-NET）" class="headerlink" title="关于使用动态语言（.NET）"></a>关于使用动态语言（.NET）</h3><p>AutoCAD托管.NET API允许您利用.NET 4.0中引入的动态语言编译器（DLR）。</p>
<p>使用DLR可以直接访问对象，而无需：</p>
<ul>
<li>打开一个对象进行读或写，然后在完成后关闭该对象。</li>
<li>利用事务来提交所做的更改。</li>
</ul>
<p>在使用DLR时，一旦获得对象的ObjectId，就可以直接访问对象的属性和方法。获得ObjectId后，可以将ObjectId赋给数据类型的变量：</p>
<ul>
<li>Object in VB.NET  </li>
<li>dynamic in C#</li>
</ul>
<p>获取ObjectId的方式因对象保存到数据库的方式而异。对于存储在表或字典中的对象，您可以通过以下方式访问其ObjectId：</p>
<ul>
<li>使用ObjectId的Item方法访问集合中的元素。</li>
<li>创建对表或字典的ObjectId的引用，并将其赋值给变量，然后访问数组的元素。</li>
</ul>
<p>以下示例代码显示了使用DLR访问存储在表或字典中的对象的两个选项：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">C<span class="meta">#</span></span><br><span class="line"><span class="comment">// Item method</span></span><br><span class="line"><span class="built_in">dynamic</span> acCurDb = HostApplicationServices.WorkingDatabase;</span><br><span class="line"><span class="built_in">dynamic</span> acMSpace = acCurDb.BlockTableId.Item(BlockTableRecord.ModelSpace);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Reference an element directly from a collection</span></span><br><span class="line"><span class="built_in">dynamic</span> acCurDb = HostApplicationServices.WorkingDatabase;</span><br><span class="line"><span class="built_in">dynamic</span> acBlkTbl = acCurDb.BlockTableId;</span><br><span class="line"><span class="built_in">dynamic</span> acMSpace = acBlkTbl[BlockTableRecord.ModelSpace];</span><br></pre></td></tr></table></figure>

<p>重要：使用DLR和C#时，您需要引用Microsoft.CSharp库。</p>
<p><strong>使用GetEnumerator方法</strong></p>
<p>在使用DLR的 GetEnumerator 方法时，需要在使用完枚举器对象后显式释放枚举器对象。下面的示例演示了如何在使用完枚举器对象后释放枚举器。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">C<span class="meta">#</span></span><br><span class="line"><span class="built_in">dynamic</span> acCurDb = HostApplicationServices.WorkingDatabase;</span><br><span class="line"><span class="keyword">var</span> acLtypeTbl = acCurDb.LinetypeTableId;</span><br><span class="line"><span class="keyword">var</span> acTblEnum = acLtypeTbl.GetEnumerator();</span><br><span class="line">...</span><br><span class="line">acTblEnum.Dispose();</span><br></pre></td></tr></table></figure>

<p><strong>使用LINQ脚本</strong></p>
<p>可以使用LINQ查询来查询带有DLR的图形中的表或字典的内容。下面的示例演示如何使用LINQ查询来查询当前图形中为哪些图层指定了某些状态。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">CommandMethod(<span class="string">&quot;LINQ&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">LINQExample</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">dynamic</span> db = HostApplicationServices.WorkingDatabase;</span><br><span class="line">    <span class="built_in">dynamic</span> doc = Application.DocumentManager.MdiActiveDocument;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> layers = db.LayerTableId;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> newrec = layers.Add(<span class="keyword">new</span> LayerTableRecord());</span><br><span class="line">        newrec.Name = <span class="string">&quot;Layer&quot;</span> + i.ToString();</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">            newrec.IsFrozen = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">1</span>)</span><br><span class="line">            newrec.IsOff = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> OffLayers = <span class="function"><span class="keyword">from</span> l <span class="title">in</span> (<span class="params">IEnumerable&lt;<span class="built_in">dynamic</span>&gt;</span>)layers</span></span><br><span class="line"><span class="function">                    <span class="keyword">where</span> l.IsOff</span></span><br><span class="line"><span class="function">                    <span class="keyword">select</span> l</span>;</span><br><span class="line"></span><br><span class="line">    doc.Editor.WriteMessage(<span class="string">&quot;\nLayers Turned Off:&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">foreach</span> (<span class="built_in">dynamic</span> rec <span class="keyword">in</span> OffLayers)</span><br><span class="line">        doc.Editor.WriteMessage(<span class="string">&quot;\n - &quot;</span> + rec.Name);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> frozenOrOffNames = <span class="function"><span class="keyword">from</span> l <span class="title">in</span> (<span class="params">IEnumerable&lt;<span class="built_in">dynamic</span>&gt;</span>)layers</span></span><br><span class="line"><span class="function">                            <span class="keyword">where</span> l.IsFrozen</span> == <span class="literal">true</span> || l.IsOff == <span class="literal">true</span></span><br><span class="line">                            <span class="keyword">select</span> l;</span><br><span class="line"></span><br><span class="line">    doc.Editor.WriteMessage(<span class="string">&quot;\nLayers Frozen or Turned Off:&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">foreach</span> (<span class="built_in">dynamic</span> rec <span class="keyword">in</span> frozenOrOffNames)</span><br><span class="line">        doc.Editor.WriteMessage(<span class="string">&quot;\n - &quot;</span> + rec.Name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>示例代码</strong></p>
<p>此页面上的示例代码使用以下名称空间：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Autodesk.AutoCAD.Runtime</span><br><span class="line">Autodesk.AutoCAD.ApplicationServices</span><br><span class="line">Autodesk.AutoCAD.DatabaseServices</span><br><span class="line">Autodesk.AutoCAD.Colors</span><br><span class="line">Autodesk.AutoCAD.Geometry</span><br></pre></td></tr></table></figure>

<p>下面的示例代码演示了如何将Line添加到当前空间;使用和不使用DLR。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">CommandMethod(<span class="string">&quot;ADDLINE&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">AddLine</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Get the current database</span></span><br><span class="line">    Database acCurDb = HostApplicationServices.WorkingDatabase;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start a transaction</span></span><br><span class="line">    <span class="keyword">using</span> (Transaction acTrans = acCurDb.TransactionManager.StartTransaction())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Open the Block table for read</span></span><br><span class="line">        BlockTable acBlkTbl;</span><br><span class="line">        acBlkTbl = acTrans.GetObject(acCurDb.BlockTableId,</span><br><span class="line">                                     OpenMode.ForRead) <span class="keyword">as</span> BlockTable;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Open the Block table record Model space for write</span></span><br><span class="line">        BlockTableRecord acBlkTblRec;</span><br><span class="line">        acBlkTblRec = acTrans.GetObject(acBlkTbl[BlockTableRecord.ModelSpace],</span><br><span class="line">                                        OpenMode.ForWrite) <span class="keyword">as</span> BlockTableRecord;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create a line that starts at 5,5 and ends at 12,3</span></span><br><span class="line">        <span class="keyword">using</span> (Line acLine = <span class="keyword">new</span> Line(<span class="keyword">new</span> Point3d(<span class="number">5</span>, <span class="number">5</span>, <span class="number">0</span>),</span><br><span class="line">                                      <span class="keyword">new</span> Point3d(<span class="number">12</span>, <span class="number">3</span>, <span class="number">0</span>)))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Add the new object to the block table record and the transaction</span></span><br><span class="line">            acBlkTblRec.AppendEntity(acLine);</span><br><span class="line">            acTrans.AddNewlyCreatedDBObject(acLine, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Save the new object to the database</span></span><br><span class="line">        acTrans.Commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>C#动态语言（DLR）</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">CommandMethod(<span class="string">&quot;ADDLINE&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">AddLine</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Get the current database</span></span><br><span class="line">    <span class="built_in">dynamic</span> acCurDb = HostApplicationServices.WorkingDatabase;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create a dynamic reference to model or paper space</span></span><br><span class="line">    <span class="built_in">dynamic</span> acSpace = acCurDb.CurrentSpaceId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create a line that starts at 5,5 and ends at 12,3</span></span><br><span class="line">    <span class="built_in">dynamic</span> acLine = <span class="keyword">new</span> Line(<span class="keyword">new</span> Point3d(<span class="number">5</span>, <span class="number">5</span>, <span class="number">0</span>),</span><br><span class="line">                              <span class="keyword">new</span> Point3d(<span class="number">12</span>, <span class="number">3</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add the new object to the current space</span></span><br><span class="line">    acSpace.AppendEntity(acLine);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面的示例代码演示了如何将层添加到当前数据库;使用和不使用DLR。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">CommandMethod(<span class="string">&quot;ADDLAYER&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">AddLayer</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Get the current database</span></span><br><span class="line">    Database acCurDb = HostApplicationServices.WorkingDatabase;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> (Transaction acTrans = acCurDb.TransactionManager.StartTransaction())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Returns the layer table for the current database</span></span><br><span class="line">        LayerTable acLyrTbl;</span><br><span class="line">        acLyrTbl = acTrans.GetObject(acCurDb.LayerTableId,</span><br><span class="line">                                     OpenMode.ForRead) <span class="keyword">as</span> LayerTable;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check to see if MyLayer exists in the Layer table</span></span><br><span class="line">        <span class="keyword">if</span> (acLyrTbl.Has(<span class="string">&quot;MyLayer&quot;</span>) != <span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Open the Layer Table for write</span></span><br><span class="line">            acTrans.GetObject(acCurDb.LayerTableId, OpenMode.ForWrite);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Create a new layer named &quot;MyLayer&quot;</span></span><br><span class="line">            <span class="keyword">using</span> (LayerTableRecord acLyrTblRec = <span class="keyword">new</span> LayerTableRecord())</span><br><span class="line">            &#123;</span><br><span class="line">                acLyrTblRec.Name = <span class="string">&quot;MyLayer&quot;</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Assign the ACI color 3 to the new layer</span></span><br><span class="line">                Color acClr = Color.FromColorIndex(ColorMethod.ByAci, <span class="number">3</span>);</span><br><span class="line">                acLyrTblRec.Color = acClr;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Add the new layer table record to the layer table and the transaction</span></span><br><span class="line">                acLyrTbl.Add(acLyrTblRec);</span><br><span class="line">                acTrans.AddNewlyCreatedDBObject(acLyrTblRec, <span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Commit the changes</span></span><br><span class="line">            acTrans.Commit();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Dispose of the transaction</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>C#动态语言（DLR）</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">CommandMethod(<span class="string">&quot;ADDLAYER&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">AddLayer</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Get the current database</span></span><br><span class="line">    <span class="built_in">dynamic</span> acCurDb = HostApplicationServices.WorkingDatabase;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dynamic</span> acLyrTbl = acCurDb.LayerTableId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check to see if MyLayer exists in the Layer table</span></span><br><span class="line">    <span class="keyword">if</span> (acLyrTbl.Has(<span class="string">&quot;MyLayer&quot;</span>) != <span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Create a new layer named &quot;MyLayer&quot;</span></span><br><span class="line">        <span class="built_in">dynamic</span> acLyrTblRec = <span class="keyword">new</span> LayerTableRecord();</span><br><span class="line">        acLyrTblRec.Name = <span class="string">&quot;MyLayer&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Assign the ACI color 3 to the new layer</span></span><br><span class="line">        <span class="built_in">dynamic</span> acClr = Color.FromColorIndex(ColorMethod.ByAci, <span class="number">3</span>);</span><br><span class="line">        acLyrTblRec.Color = acClr;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Add the new layer table record to the layer table</span></span><br><span class="line">        acLyrTbl.Add(acLyrTblRec);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面演示了如何逐步遍历并列出当前空间中的所有对象（使用和不使用DLR）。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">CommandMethod(<span class="string">&quot;LISTOBJECTS&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ListObjects</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Get the current document and database</span></span><br><span class="line">    Document acDoc = Application.DocumentManager.MdiActiveDocument;</span><br><span class="line">    Database acCurDb = HostApplicationServices.WorkingDatabase;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> (Transaction acTrans = acCurDb.TransactionManager.StartTransaction())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Open the Block table record Model space for write</span></span><br><span class="line">        BlockTableRecord acSpace;</span><br><span class="line">        acSpace = acTrans.GetObject(acCurDb.CurrentSpaceId,</span><br><span class="line">                                    OpenMode.ForRead) <span class="keyword">as</span> BlockTableRecord;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Step through the current space</span></span><br><span class="line">        <span class="keyword">foreach</span> (ObjectId objId <span class="keyword">in</span> acSpace)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Display the class and current layer of the object</span></span><br><span class="line">            Entity acEnt = (Entity)acTrans.GetObject(objId, OpenMode.ForRead);</span><br><span class="line">            acDoc.Editor.WriteMessage(<span class="string">&quot;\nObject Class: &quot;</span> + acEnt.GetRXClass().Name +</span><br><span class="line">                                      <span class="string">&quot;\nCurrent Layer: &quot;</span> + acEnt.Layer + </span><br><span class="line">                                       <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        acTrans.Commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>C#动态语言（DLR）</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">CommandMethod(<span class="string">&quot;LISTOBJECTS&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ListObjects</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Get the current document and database</span></span><br><span class="line">    <span class="built_in">dynamic</span> acDoc = Application.DocumentManager.MdiActiveDocument;</span><br><span class="line">    <span class="built_in">dynamic</span> acCurDb = HostApplicationServices.WorkingDatabase;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create a dynamic reference to model or paper space</span></span><br><span class="line">    <span class="built_in">dynamic</span> acSpace = acCurDb.CurrentSpaceId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step through the current space</span></span><br><span class="line">    <span class="keyword">foreach</span> (<span class="built_in">dynamic</span> acEnt <span class="keyword">in</span> acSpace)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Display the class and current layer of the object</span></span><br><span class="line">        acDoc.Editor.WriteMessage(<span class="string">&quot;\nObject Class: &quot;</span> + acEnt.GetRXClass().Name +</span><br><span class="line">                                  <span class="string">&quot;\nCurrent Layer: &quot;</span> + acEnt.Layer +</span><br><span class="line">                                  <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="创建对象（-NET）"><a href="#创建对象（-NET）" class="headerlink" title="创建对象（.NET）"></a>创建对象（.NET）</h2><p>AutoCAD通常提供几种不同的方法来创建相同的图形对象。虽然AutoCAD .NET API不提供创建对象的相同组合，但它确实为每种对象类型提供了基本的对象构造函数，而且还为许多对象构造函数提供了替代。</p>
<p>例如，在AutoCAD中，有四种不同的方法可以创建圆：（1）通过指定圆心和半径，（2）通过定义直径的两个点，（3）通过定义圆周的三个点，或（4）通过两条切线和一个半径。但是，在AutoCAD .NET API中，提供了两种创建圆的方法。一种方法不接受任何参数，而第二种方法需要圆心、圆的法线方向和半径。</p>
<p><strong>注意：</strong>对象是使用New关键字创建的，然后根据您使用的是容器（符号表或字典）还是 BlockTableRecord 对象，使用 Add 或 AppendEntity 将对象附加到父对象。</p>
<p><strong>设置对象的默认属性值</strong></p>
<p>创建新的图形对象时，将为以下实体属性值分配当前文档的数据库中定义的当前实体值：</p>
<ul>
<li>颜色</li>
<li>层</li>
<li>线型</li>
<li>线型比例</li>
<li>线宽</li>
<li>打印样式名称</li>
<li>可见性</li>
<li>透明度</li>
</ul>
<p><strong>注意：</strong>如果对象的属性需要设置为当前数据库的默认值，请调用要更改的对象的 SetDatabaseDefaults 方法。</p>
<p>本节中的主题</p>
<ul>
<li>确定父对象（.NET）</li>
<li>创建线（.NET）</li>
<li>创建曲线对象（.NET）</li>
<li>创建点对象（.NET）</li>
<li>创建实体填充区域（.NET）</li>
<li>使用面域（.NET）</li>
<li>创建图案填充（.NET）</li>
</ul>
<h3 id="确定父对象（-NET）"><a href="#确定父对象（-NET）" class="headerlink" title="确定父对象（.NET）"></a>确定父对象（.NET）</h3><p>图形对象附加到 BlockTableRecord 对象，如模型或图纸空间。通过 BlockTable 对象参照表示模型和图纸空间的块。如果您想在当前空间而不是特定空间中工作，则可以使用 CurrentSpaceId 属性从当前数据库中获取当前空间的ObjectId。</p>
<p>可以使用 DatabaseServices 命名空间下的 SymbolUtilityServices 类的属性或 GetBlockModelSpaceId 和 GetBlockPaperSpaceId 方法从 BlockTable 对象检索模型和图纸空间的块表记录的ObjectId。</p>
<p><strong>访问模型空间、图纸空间或当前空间</strong></p>
<p>以下示例演示如何访问与模型空间、图纸空间或当前空间关联的块表记录。一旦引用块表记录，就会向块表记录添加一个新线。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.Runtime;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.ApplicationServices;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.DatabaseServices;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.Geometry;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.EditorInput;</span><br><span class="line"> </span><br><span class="line">[<span class="meta">CommandMethod(<span class="string">&quot;AccessSpace&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">AccessSpace</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Get the current document and database</span></span><br><span class="line">    Document acDoc = Application.DocumentManager.MdiActiveDocument;</span><br><span class="line">    Database acCurDb = acDoc.Database;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start a transaction</span></span><br><span class="line">    <span class="keyword">using</span> (Transaction acTrans = acCurDb.TransactionManager.StartTransaction())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Open the Block table for read</span></span><br><span class="line">        BlockTable acBlkTbl;</span><br><span class="line">        acBlkTbl = acTrans.GetObject(acCurDb.BlockTableId,</span><br><span class="line">                                        OpenMode.ForRead) <span class="keyword">as</span> BlockTable;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Open the Block table record for read</span></span><br><span class="line">        BlockTableRecord acBlkTblRec;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Request which table record to open</span></span><br><span class="line">        PromptKeywordOptions pKeyOpts = <span class="keyword">new</span> PromptKeywordOptions(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        pKeyOpts.Message = <span class="string">&quot;\nEnter which space to create the line in &quot;</span>;</span><br><span class="line">        pKeyOpts.Keywords.Add(<span class="string">&quot;Model&quot;</span>);</span><br><span class="line">        pKeyOpts.Keywords.Add(<span class="string">&quot;Paper&quot;</span>);</span><br><span class="line">        pKeyOpts.Keywords.Add(<span class="string">&quot;Current&quot;</span>);</span><br><span class="line">        pKeyOpts.AllowNone = <span class="literal">false</span>;</span><br><span class="line">        pKeyOpts.AppendKeywordsToMessage = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        PromptResult pKeyRes = acDoc.Editor.GetKeywords(pKeyOpts);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pKeyRes.StringResult == <span class="string">&quot;Model&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Get the ObjectID for Model space from the Block table</span></span><br><span class="line">            acBlkTblRec = acTrans.GetObject(acBlkTbl[BlockTableRecord.ModelSpace],</span><br><span class="line">                                            OpenMode.ForWrite) <span class="keyword">as</span> BlockTableRecord;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pKeyRes.StringResult == <span class="string">&quot;Paper&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Get the ObjectID for Paper space from the Block table</span></span><br><span class="line">            acBlkTblRec = acTrans.GetObject(acBlkTbl[BlockTableRecord.PaperSpace],</span><br><span class="line">                                            OpenMode.ForWrite) <span class="keyword">as</span> BlockTableRecord;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Get the ObjectID for the current space from the database</span></span><br><span class="line">            acBlkTblRec = acTrans.GetObject(acCurDb.CurrentSpaceId,</span><br><span class="line">                                            OpenMode.ForWrite) <span class="keyword">as</span> BlockTableRecord;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create a line that starts at 2,5 and ends at 10,7</span></span><br><span class="line">        <span class="keyword">using</span> (Line acLine = <span class="keyword">new</span> Line(<span class="keyword">new</span> Point3d(<span class="number">2</span>, <span class="number">5</span>, <span class="number">0</span>),</span><br><span class="line">                                <span class="keyword">new</span> Point3d(<span class="number">10</span>, <span class="number">7</span>, <span class="number">0</span>)))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Add the new object to the block table record and the transaction</span></span><br><span class="line">            acBlkTblRec.AppendEntity(acLine);</span><br><span class="line">            acTrans.AddNewlyCreatedDBObject(acLine, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Save the new line to the database</span></span><br><span class="line">        acTrans.Commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="创建线（-NET）"><a href="#创建线（-NET）" class="headerlink" title="创建线（.NET）"></a>创建线（.NET）</h3><p>直线是AutoCAD中最基本的对象。您可以创建各种线-单线，以及带有和不带有圆弧的多条线段。通常，通过指定坐标点来绘制直线。创建线时，线将继承图形数据库中的当前设置，例如图层、线型和颜色。</p>
<p>要创建直线，请创建以下对象之一的新实例：</p>
<p>Line<br>创建一条线。</p>
<p>Polyline<br>创建二维轻量化对象。</p>
<p>MLine<br>创建多行。</p>
<p>Polyline2D<br>创建二维图形。</p>
<p>Polyline3D<br>创建三维视图。</p>
<p>注意：Polyline 2D对象是AutoCAD 14版之前版本中的旧版图元对象，Polyline对象表示AutoCAD 14版中引入的新优化图元。</p>
<p> 本节中的主题</p>
<ul>
<li>创建直线对象（.NET）</li>
<li>创建多段线对象（.NET）</li>
</ul>
<h4 id="创建直线对象（-NET）"><a href="#创建直线对象（-NET）" class="headerlink" title="创建直线对象（.NET）"></a>创建直线对象（.NET）</h4><p>此示例向模型空间添加一条从（5，5，0）开始到（12，3，0）结束的线。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.Runtime;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.ApplicationServices;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.DatabaseServices;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.Geometry;</span><br><span class="line"> </span><br><span class="line">[<span class="meta">CommandMethod(<span class="string">&quot;AddLine&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">AddLine</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Get the current document and database</span></span><br><span class="line">    Document acDoc = Application.DocumentManager.MdiActiveDocument;</span><br><span class="line">    Database acCurDb = acDoc.Database;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start a transaction</span></span><br><span class="line">    <span class="keyword">using</span> (Transaction acTrans = acCurDb.TransactionManager.StartTransaction())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Open the Block table for read</span></span><br><span class="line">        BlockTable acBlkTbl;</span><br><span class="line">        acBlkTbl = acTrans.GetObject(acCurDb.BlockTableId,</span><br><span class="line">                                        OpenMode.ForRead) <span class="keyword">as</span> BlockTable;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Open the Block table record Model space for write</span></span><br><span class="line">        BlockTableRecord acBlkTblRec;</span><br><span class="line">        acBlkTblRec = acTrans.GetObject(acBlkTbl[BlockTableRecord.ModelSpace],</span><br><span class="line">                                        OpenMode.ForWrite) <span class="keyword">as</span> BlockTableRecord;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create a line that starts at 5,5 and ends at 12,3</span></span><br><span class="line">        <span class="keyword">using</span> (Line acLine = <span class="keyword">new</span> Line(<span class="keyword">new</span> Point3d(<span class="number">5</span>, <span class="number">5</span>, <span class="number">0</span>),</span><br><span class="line">                                      <span class="keyword">new</span> Point3d(<span class="number">12</span>, <span class="number">3</span>, <span class="number">0</span>)))</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Add the new object to the block table record and the transaction</span></span><br><span class="line">            acBlkTblRec.AppendEntity(acLine);</span><br><span class="line">            acTrans.AddNewlyCreatedDBObject(acLine, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Save the new object to the database</span></span><br><span class="line">        acTrans.Commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="创建多段线对象（-NET）"><a href="#创建多段线对象（-NET）" class="headerlink" title="创建多段线对象（.NET）"></a>创建多段线对象（.NET）</h4><p>此示例使用二维坐标（2，4）、（4，2）和（6，4）向模型空间添加具有两条直线段的轻量化图元。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">CommandMethod(<span class="string">&quot;AddLightweightPolyline&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">AddLightweightPolyline</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Get the current document and database</span></span><br><span class="line">    Document acDoc = Application.DocumentManager.MdiActiveDocument;</span><br><span class="line">    Database acCurDb = acDoc.Database;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start a transaction</span></span><br><span class="line">    <span class="keyword">using</span> (Transaction acTrans = acCurDb.TransactionManager.StartTransaction())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Open the Block table for read</span></span><br><span class="line">        BlockTable acBlkTbl;</span><br><span class="line">        acBlkTbl = acTrans.GetObject(acCurDb.BlockTableId,</span><br><span class="line">                                        OpenMode.ForRead) <span class="keyword">as</span> BlockTable;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Open the Block table record Model space for write</span></span><br><span class="line">        BlockTableRecord acBlkTblRec;</span><br><span class="line">        acBlkTblRec = acTrans.GetObject(acBlkTbl[BlockTableRecord.ModelSpace],</span><br><span class="line">                                        OpenMode.ForWrite) <span class="keyword">as</span> BlockTableRecord;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create a polyline with two segments (3 points)</span></span><br><span class="line">        <span class="keyword">using</span> (Polyline acPoly = <span class="keyword">new</span> Polyline())</span><br><span class="line">        &#123;</span><br><span class="line">            acPoly.AddVertexAt(<span class="number">0</span>, <span class="keyword">new</span> Point2d(<span class="number">2</span>, <span class="number">4</span>), <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            acPoly.AddVertexAt(<span class="number">1</span>, <span class="keyword">new</span> Point2d(<span class="number">4</span>, <span class="number">2</span>), <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            acPoly.AddVertexAt(<span class="number">2</span>, <span class="keyword">new</span> Point2d(<span class="number">6</span>, <span class="number">4</span>), <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Add the new object to the block table record and the transaction</span></span><br><span class="line">            acBlkTblRec.AppendEntity(acPoly);</span><br><span class="line">            acTrans.AddNewlyCreatedDBObject(acPoly, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Save the new object to the database</span></span><br><span class="line">        acTrans.Commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="创建曲线对象（-NET）"><a href="#创建曲线对象（-NET）" class="headerlink" title="创建曲线对象（.NET）"></a>创建曲线对象（.NET）</h3><p>可以使用AutoCAD创建各种曲线对象，包括样条曲线、螺旋线、圆、圆弧和椭圆。所有曲线都在当前UCS的<em>XY</em>平面上创建。</p>
<p>若要创建曲线，请创建以下对象之一的新实例：</p>
<ul>
<li><p>Arc 弧</p>
<p>在给定圆心、半径、起始角和终止角的情况下创建圆弧。</p>
</li>
<li><p>Circle 圆</p>
<p>在给定圆心和半径的情况下创建圆。</p>
</li>
<li><p>Ellipse 椭圆</p>
<p>在给定中心点、长轴上的点和半径比的情况下创建椭圆。</p>
</li>
<li><p>Spline 样条</p>
<p>创建二次或三次NURBS（非均匀有理B样条）曲线。</p>
</li>
<li><p>Helix 螺旋</p>
<p>创建二维或三维螺旋对象。</p>
</li>
</ul>
<p>本节中的主题</p>
<ul>
<li>创建圆对象（.NET）</li>
<li>创建弧形对象（.NET）</li>
<li>创建样条线对象（.NET）</li>
</ul>
<h4 id="创建圆对象（-NET）"><a href="#创建圆对象（-NET）" class="headerlink" title="创建圆对象（.NET）"></a>创建圆对象（.NET）</h4><p>本示例在模型空间中创建一个圆心为（2，3，0）、半径为4.25的圆。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.Runtime;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.ApplicationServices;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.DatabaseServices;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.Geometry;</span><br><span class="line"> </span><br><span class="line">[<span class="meta">CommandMethod(<span class="string">&quot;AddCircle&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">AddCircle</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Get the current document and database</span></span><br><span class="line">    Document acDoc = Application.DocumentManager.MdiActiveDocument;</span><br><span class="line">    Database acCurDb = acDoc.Database;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start a transaction</span></span><br><span class="line">    <span class="keyword">using</span> (Transaction acTrans = acCurDb.TransactionManager.StartTransaction())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Open the Block table for read</span></span><br><span class="line">        BlockTable acBlkTbl;</span><br><span class="line">        acBlkTbl = acTrans.GetObject(acCurDb.BlockTableId,</span><br><span class="line">                                        OpenMode.ForRead) <span class="keyword">as</span> BlockTable;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Open the Block table record Model space for write</span></span><br><span class="line">        BlockTableRecord acBlkTblRec;</span><br><span class="line">        acBlkTblRec = acTrans.GetObject(acBlkTbl[BlockTableRecord.ModelSpace],</span><br><span class="line">                                        OpenMode.ForWrite) <span class="keyword">as</span> BlockTableRecord;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create a circle that is at 2,3 with a radius of 4.25</span></span><br><span class="line">        <span class="keyword">using</span> (Circle acCirc = <span class="keyword">new</span> Circle())</span><br><span class="line">        &#123;</span><br><span class="line">            acCirc.Center = <span class="keyword">new</span> Point3d(<span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span>);</span><br><span class="line">            acCirc.Radius = <span class="number">4.25</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Add the new object to the block table record and the transaction</span></span><br><span class="line">            acBlkTblRec.AppendEntity(acCirc);</span><br><span class="line">            acTrans.AddNewlyCreatedDBObject(acCirc, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Save the new object to the database</span></span><br><span class="line">        acTrans.Commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="创建弧形对象（-NET）"><a href="#创建弧形对象（-NET）" class="headerlink" title="创建弧形对象（.NET）"></a>创建弧形对象（.NET）</h4><p>本示例在模型空间中创建一个圆弧，其中心点为（6.25，9.125，0），半径为6，起始角度为1.117（64度），终止角度为3.5605（204度）。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.Runtime;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.ApplicationServices;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.DatabaseServices;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.Geometry;</span><br><span class="line"> </span><br><span class="line">[<span class="meta">CommandMethod(<span class="string">&quot;AddArc&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">AddArc</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Get the current document and database</span></span><br><span class="line">    Document acDoc = Application.DocumentManager.MdiActiveDocument;</span><br><span class="line">    Database acCurDb = acDoc.Database;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start a transaction</span></span><br><span class="line">    <span class="keyword">using</span> (Transaction acTrans = acCurDb.TransactionManager.StartTransaction())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Open the Block table for read</span></span><br><span class="line">        BlockTable acBlkTbl;</span><br><span class="line">        acBlkTbl = acTrans.GetObject(acCurDb.BlockTableId,</span><br><span class="line">                                        OpenMode.ForRead) <span class="keyword">as</span> BlockTable;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Open the Block table record Model space for write</span></span><br><span class="line">        BlockTableRecord acBlkTblRec;</span><br><span class="line">        acBlkTblRec = acTrans.GetObject(acBlkTbl[BlockTableRecord.ModelSpace],</span><br><span class="line">                                        OpenMode.ForWrite) <span class="keyword">as</span> BlockTableRecord;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create an arc that is at 6.25,9.125 with a radius of 6, and</span></span><br><span class="line">        <span class="comment">// starts at 64 degrees and ends at 204 degrees</span></span><br><span class="line">        <span class="keyword">using</span> (Arc acArc = <span class="keyword">new</span> Arc(<span class="keyword">new</span> Point3d(<span class="number">6.25</span>, <span class="number">9.125</span>, <span class="number">0</span>),</span><br><span class="line">                            <span class="number">6</span>, <span class="number">1.117</span>, <span class="number">3.5605</span>))</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Add the new object to the block table record and the transaction</span></span><br><span class="line">            acBlkTblRec.AppendEntity(acArc);</span><br><span class="line">            acTrans.AddNewlyCreatedDBObject(acArc, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Save the new line to the database</span></span><br><span class="line">        acTrans.Commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="创建样条线对象（-NET）"><a href="#创建样条线对象（-NET）" class="headerlink" title="创建样条线对象（.NET）"></a>创建样条线对象（.NET）</h4><p>此示例使用三个点（0，0，0）、（5，5，0）和（10，0，0）在模型空间中创建圆。样条曲线的起点切线和终点切线为（0.5，0.5，0.0）。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.Runtime;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.ApplicationServices;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.DatabaseServices;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.Geometry;</span><br><span class="line"> </span><br><span class="line">[<span class="meta">CommandMethod(<span class="string">&quot;AddSpline&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">AddSpline</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Get the current document and database</span></span><br><span class="line">    Document acDoc = Application.DocumentManager.MdiActiveDocument;</span><br><span class="line">    Database acCurDb = acDoc.Database;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start a transaction</span></span><br><span class="line">    <span class="keyword">using</span> (Transaction acTrans = acCurDb.TransactionManager.StartTransaction())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Open the Block table for read</span></span><br><span class="line">        BlockTable acBlkTbl;</span><br><span class="line">        acBlkTbl = acTrans.GetObject(acCurDb.BlockTableId,</span><br><span class="line">                                        OpenMode.ForRead) <span class="keyword">as</span> BlockTable;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Open the Block table record Model space for write</span></span><br><span class="line">        BlockTableRecord acBlkTblRec;</span><br><span class="line">        acBlkTblRec = acTrans.GetObject(acBlkTbl[BlockTableRecord.ModelSpace],</span><br><span class="line">                                        OpenMode.ForWrite) <span class="keyword">as</span> BlockTableRecord;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Define the fit points for the spline</span></span><br><span class="line">        Point3dCollection ptColl = <span class="keyword">new</span> Point3dCollection();</span><br><span class="line">        ptColl.Add(<span class="keyword">new</span> Point3d(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">        ptColl.Add(<span class="keyword">new</span> Point3d(<span class="number">5</span>, <span class="number">5</span>, <span class="number">0</span>));</span><br><span class="line">        ptColl.Add(<span class="keyword">new</span> Point3d(<span class="number">10</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Get a 3D vector from the point (0.5,0.5,0)</span></span><br><span class="line">        Vector3d vecTan = <span class="keyword">new</span> Point3d(<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0</span>).GetAsVector();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create a spline through (0, 0, 0), (5, 5, 0), and (10, 0, 0) with a</span></span><br><span class="line">        <span class="comment">// start and end tangency of (0.5, 0.5, 0.0)</span></span><br><span class="line">        <span class="keyword">using</span> (Spline acSpline = <span class="keyword">new</span> Spline(ptColl, vecTan, vecTan, <span class="number">4</span>, <span class="number">0.0</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Add the new object to the block table record and the transaction</span></span><br><span class="line">            acBlkTblRec.AppendEntity(acSpline);</span><br><span class="line">            acTrans.AddNewlyCreatedDBObject(acSpline, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Save the new line to the database</span></span><br><span class="line">        acTrans.Commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="创建点对象（-NET）"><a href="#创建点对象（-NET）" class="headerlink" title="创建点对象（.NET）"></a>创建点对象（.NET）</h3><p>Point 对象可能很有用，例如，作为节点或参照点，可以捕捉到这些点或从这些点偏移对象。可以设置点的样式及其相对于屏幕的大小或以绝对单位设置。</p>
<p>Database 对象的 Pdmode 和 Pdsize 属性控制Point对象的外观。如果 Pdmode 的值为0、2、3和4，则指定要通过该点绘制的图形。值为1时，不选择要显示的内容。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2024/ENU/OARX-DevGuide-Managed/images/GUID-B5AFFED6-5B41-42F8-8236-11A501E8E6B2.png" alt="img"></p>
<p>将32、64或96加到前一个值上，除了通过点绘制的图形外，还可以选择围绕点绘制的形状：</p>
<p><img src="https://help.autodesk.com/cloudhelp/2024/ENU/OARX-DevGuide-Managed/images/GUID-0202DF5B-87D8-4F66-B637-68A3B8691FDA.png" alt="img"></p>
<p>Pdsize 控制点图形的大小，但 Pdmode 为0和1时除外。设置为0时，将在图形区域高度的5%处生成点。将 Pdsize 设置为正值可指定点图形的绝对大小。负值被解释为视口大小的百分比。重新生成图形时，将重新计算所有点的大小。</p>
<p>更改 Pdmode 和 Pdsize 后，现有点的外观将在下次重新生成图形时更改。</p>
<p><strong>创建Point对象并更改其外观</strong></p>
<p>以下示例在模型空间中的坐标（5，5，0）处创建 Point 对象。然后更新 Pdmode 和 Pdsize 属性。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.Runtime;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.ApplicationServices;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.DatabaseServices;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.Geometry;</span><br><span class="line"> </span><br><span class="line">[<span class="meta">CommandMethod(<span class="string">&quot;AddPointAndSetPointStyle&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">AddPointAndSetPointStyle</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Get the current document and database</span></span><br><span class="line">    Document acDoc = Application.DocumentManager.MdiActiveDocument;</span><br><span class="line">    Database acCurDb = acDoc.Database;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start a transaction</span></span><br><span class="line">    <span class="keyword">using</span> (Transaction acTrans = acCurDb.TransactionManager.StartTransaction())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Open the Block table for read</span></span><br><span class="line">        BlockTable acBlkTbl;</span><br><span class="line">        acBlkTbl = acTrans.GetObject(acCurDb.BlockTableId,</span><br><span class="line">                                        OpenMode.ForRead) <span class="keyword">as</span> BlockTable;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Open the Block table record Model space for write</span></span><br><span class="line">        BlockTableRecord acBlkTblRec;</span><br><span class="line">        acBlkTblRec = acTrans.GetObject(acBlkTbl[BlockTableRecord.ModelSpace],</span><br><span class="line">                                        OpenMode.ForWrite) <span class="keyword">as</span> BlockTableRecord;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create a point at (4, 3, 0) in Model space</span></span><br><span class="line">        <span class="keyword">using</span> (DBPoint acPoint = <span class="keyword">new</span> DBPoint(<span class="keyword">new</span> Point3d(<span class="number">4</span>, <span class="number">3</span>, <span class="number">0</span>)))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Add the new object to the block table record and the transaction</span></span><br><span class="line">            acBlkTblRec.AppendEntity(acPoint);</span><br><span class="line">            acTrans.AddNewlyCreatedDBObject(acPoint, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Set the style for all point objects in the drawing</span></span><br><span class="line">        acCurDb.Pdmode = <span class="number">34</span>;</span><br><span class="line">        acCurDb.Pdsize = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Save the new object to the database</span></span><br><span class="line">        acTrans.Commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="创建实体填充区域（-NET）"><a href="#创建实体填充区域（-NET）" class="headerlink" title="创建实体填充区域（.NET）"></a>创建实体填充区域（.NET）</h3><p>您可以创建用颜色填充的三角形和四边形区域。创建填充区域时，请将FILLMODE系统变量设置为禁用以提高性能，并在创建填充后将其重新设置为启用。</p>
<p>创建四边形实体填充区域时，第三和第四个点的顺序决定其形状。比较以下插图：</p>
<p><img src="https://help.autodesk.com/cloudhelp/2024/ENU/OARX-DevGuide-Managed/images/GUID-EE1EE395-0874-4BCC-99E0-346BFA7DAF0F.png" alt="img"></p>
<p>前两个点定义多边形的一条边。第三个点定义在第二个点的对角位置。如果第四个点设置为等于第三个点，则会创建一个填充三角形。</p>
<p><strong>创建实体填充对象</strong></p>
<p>以下示例使用坐标（0，0，0）、（5，0，0）、（5，8，0）和（0，8，0）在模型空间中创建四边形实体（蝴蝶结）。它还使用坐标（10，0，0）、（15，0，0）、（10，8，0）和（15，8，0）创建矩形形状的四边形实体。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.Runtime;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.ApplicationServices;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.DatabaseServices;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.Geometry;</span><br><span class="line"> </span><br><span class="line">[<span class="meta">CommandMethod(<span class="string">&quot;Add2DSolid&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Add2DSolid</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Get the current document and database</span></span><br><span class="line">    Document acDoc = Application.DocumentManager.MdiActiveDocument;</span><br><span class="line">    Database acCurDb = acDoc.Database;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start a transaction</span></span><br><span class="line">    <span class="keyword">using</span> (Transaction acTrans = acCurDb.TransactionManager.StartTransaction())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Open the Block table for read</span></span><br><span class="line">        BlockTable acBlkTbl;</span><br><span class="line">        acBlkTbl = acTrans.GetObject(acCurDb.BlockTableId,</span><br><span class="line">                                        OpenMode.ForRead) <span class="keyword">as</span> BlockTable;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Open the Block table record Model space for write</span></span><br><span class="line">        BlockTableRecord acBlkTblRec;</span><br><span class="line">        acBlkTblRec = acTrans.GetObject(acBlkTbl[BlockTableRecord.ModelSpace],</span><br><span class="line">                                        OpenMode.ForWrite) <span class="keyword">as</span> BlockTableRecord;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create a quadrilateral (bow-tie) solid in Model space</span></span><br><span class="line">        <span class="keyword">using</span> (Solid ac2DSolidBow = <span class="keyword">new</span> Solid(<span class="keyword">new</span> Point3d(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>),</span><br><span class="line">                                        <span class="keyword">new</span> Point3d(<span class="number">5</span>, <span class="number">0</span>, <span class="number">0</span>),</span><br><span class="line">                                        <span class="keyword">new</span> Point3d(<span class="number">5</span>, <span class="number">8</span>, <span class="number">0</span>),</span><br><span class="line">                                        <span class="keyword">new</span> Point3d(<span class="number">0</span>, <span class="number">8</span>, <span class="number">0</span>)))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Add the new object to the block table record and the transaction</span></span><br><span class="line">            acBlkTblRec.AppendEntity(ac2DSolidBow);</span><br><span class="line">            acTrans.AddNewlyCreatedDBObject(ac2DSolidBow, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create a quadrilateral (square) solid in Model space</span></span><br><span class="line">        <span class="keyword">using</span> (Solid ac2DSolidSqr = <span class="keyword">new</span> Solid(<span class="keyword">new</span> Point3d(<span class="number">10</span>, <span class="number">0</span>, <span class="number">0</span>),</span><br><span class="line">                                        <span class="keyword">new</span> Point3d(<span class="number">15</span>, <span class="number">0</span>, <span class="number">0</span>),</span><br><span class="line">                                        <span class="keyword">new</span> Point3d(<span class="number">10</span>, <span class="number">8</span>, <span class="number">0</span>),</span><br><span class="line">                                        <span class="keyword">new</span> Point3d(<span class="number">15</span>, <span class="number">8</span>, <span class="number">0</span>)))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Add the new object to the block table record and the transaction</span></span><br><span class="line">            acBlkTblRec.AppendEntity(ac2DSolidSqr);</span><br><span class="line">            acTrans.AddNewlyCreatedDBObject(ac2DSolidSqr, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Save the new object to the database</span></span><br><span class="line">        acTrans.Commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用面域（-NET）"><a href="#使用面域（-NET）" class="headerlink" title="使用面域（.NET）"></a>使用面域（.NET）</h3><p>面域是您从称为环的闭合形状创建的二维封闭面域。回路是由直线和曲线对象组成的闭合边界，这些对象本身不相交。回路可以是直线、轻型多段线、二维和三维多段线、圆、圆弧、椭圆、椭圆弧、样条曲线、三维面、轨迹和实体的组合。</p>
<p>组成环的对象必须是闭合的，或者通过与其他对象共享端点来形成闭合面域。它们也必须共面（在同一平面上）。组成面域的循环必须定义为对象数组。</p>
<p>本节中的主题</p>
<ul>
<li>创建面域（.NET）</li>
<li>创建复合面域（.NET）</li>
</ul>
<h4 id="创建面域（-NET）"><a href="#创建面域（-NET）" class="headerlink" title="创建面域（.NET）"></a>创建面域（.NET）</h4><p>通过创建 Region 对象的实例，然后将其附加到 BlockTableRecord 对象，可以将面域添加到 BlockTableRecord 对象。在将其添加到 BlockTableRecord 对象之前，需要根据形成闭合环的对象计算面域。 CreateFromCurves 函数在由输入对象数组形成的每个闭合循环中创建一个面域。 CreateFromCurves 方法返回并需要 DBObjectCollection 对象。</p>
<p>AutoCAD将闭合的二维多段线和平面三维多段线转换为单独的面域，然后转换形成闭合平面环的多段线、直线和曲线。如果两条以上的曲线共享一个端点，则生成的面域可能是任意的。因此，实际上可以使用 CreateFromCurves 方法创建多个面域。您需要将创建的每个面域附加到 BlockTableRecord 对象。</p>
<p><strong>创建简单面域</strong></p>
<p>下面的示例从单个圆创建面域。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.Runtime;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.ApplicationServices;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.DatabaseServices;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.Geometry;</span><br><span class="line"> </span><br><span class="line">[<span class="meta">CommandMethod(<span class="string">&quot;AddRegion&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">AddRegion</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Get the current document and database</span></span><br><span class="line">    Document acDoc = Application.DocumentManager.MdiActiveDocument;</span><br><span class="line">    Database acCurDb = acDoc.Database;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start a transaction</span></span><br><span class="line">    <span class="keyword">using</span> (Transaction acTrans = acCurDb.TransactionManager.StartTransaction())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Open the Block table for read</span></span><br><span class="line">        BlockTable acBlkTbl;</span><br><span class="line">        acBlkTbl = acTrans.GetObject(acCurDb.BlockTableId,</span><br><span class="line">                                        OpenMode.ForRead) <span class="keyword">as</span> BlockTable;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Open the Block table record Model space for write</span></span><br><span class="line">        BlockTableRecord acBlkTblRec;</span><br><span class="line">        acBlkTblRec = acTrans.GetObject(acBlkTbl[BlockTableRecord.ModelSpace],</span><br><span class="line">                                        OpenMode.ForWrite) <span class="keyword">as</span> BlockTableRecord;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create an in memory circle</span></span><br><span class="line">        <span class="keyword">using</span> (Circle acCirc = <span class="keyword">new</span> Circle())</span><br><span class="line">        &#123;</span><br><span class="line">            acCirc.Center = <span class="keyword">new</span> Point3d(<span class="number">2</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">            acCirc.Radius = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Adds the circle to an object array</span></span><br><span class="line">            DBObjectCollection acDBObjColl = <span class="keyword">new</span> DBObjectCollection();</span><br><span class="line">            acDBObjColl.Add(acCirc);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Calculate the regions based on each closed loop</span></span><br><span class="line">            DBObjectCollection myRegionColl = <span class="keyword">new</span> DBObjectCollection();</span><br><span class="line">            myRegionColl = Region.CreateFromCurves(acDBObjColl);</span><br><span class="line">            Region acRegion = myRegionColl[<span class="number">0</span>] <span class="keyword">as</span> Region;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Add the new object to the block table record and the transaction</span></span><br><span class="line">            acBlkTblRec.AppendEntity(acRegion);</span><br><span class="line">            acTrans.AddNewlyCreatedDBObject(acRegion, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Dispose of the in memory circle not appended to the database</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Save the new object to the database</span></span><br><span class="line">        acTrans.Commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="创建复合面域（-NET）"><a href="#创建复合面域（-NET）" class="headerlink" title="创建复合面域（.NET）"></a>创建复合面域（.NET）</h4><p>可以通过减去、合并面域或三维实体或查找面域或三维实体的交点来创建复合面域。然后可以拉伸或旋转复合面域以创建复杂实体。要创建复合面域，请使用 BooleanOperation 方法。</p>
<p><strong>减去面域</strong></p>
<p>当您从一个面域减去另一个面域时，您从第一个面域调用 BooleanOperation 方法。这是要从中减去的面域。例如，要计算平面图需要铺多少地毯，请从地板空间的外边界调用 BooleanOperation 方法，并使用无地毯面域（例如柱子和柜台）作为布尔参数列表中的对象。</p>
<p><strong>合并面域</strong></p>
<p>要合并面域，请调用 BooleanOperation 方法并使用常量 BooleanOperationType.BoolUnite 而不是 BooleanOperationType.BoolSubtract 进行操作。您可以按任意顺序组合联合收割机面域以将它们联合起来。</p>
<p><strong>找到两个面域的交集</strong></p>
<p>要找到两个面域的交集，请使用常量 BooleanOperationType.BoolIntersect 。可以按任意顺序组合联合收割机面域以使其相交。</p>
<p><strong>创建复合面域</strong></p>
<p>下面的示例从两个圆创建两个面域，然后从较大的面域中减去较小的面域以创建轮子。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.Runtime;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.ApplicationServices;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.DatabaseServices;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.Geometry;</span><br><span class="line"> </span><br><span class="line">[<span class="meta">CommandMethod(<span class="string">&quot;CreateCompositeRegions&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CreateCompositeRegions</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Get the current document and database</span></span><br><span class="line">    Document acDoc = Application.DocumentManager.MdiActiveDocument;</span><br><span class="line">    Database acCurDb = acDoc.Database;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start a transaction</span></span><br><span class="line">    <span class="keyword">using</span> (Transaction acTrans = acCurDb.TransactionManager.StartTransaction())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Open the Block table for read</span></span><br><span class="line">        BlockTable acBlkTbl;</span><br><span class="line">        acBlkTbl = acTrans.GetObject(acCurDb.BlockTableId,</span><br><span class="line">                                        OpenMode.ForRead) <span class="keyword">as</span> BlockTable;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Open the Block table record Model space for write</span></span><br><span class="line">        BlockTableRecord acBlkTblRec;</span><br><span class="line">        acBlkTblRec = acTrans.GetObject(acBlkTbl[BlockTableRecord.ModelSpace],</span><br><span class="line">                                        OpenMode.ForWrite) <span class="keyword">as</span> BlockTableRecord;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create two in memory circles</span></span><br><span class="line">        <span class="keyword">using</span> (Circle acCirc1 = <span class="keyword">new</span> Circle())</span><br><span class="line">        &#123;</span><br><span class="line">            acCirc1.Center = <span class="keyword">new</span> Point3d(<span class="number">4</span>, <span class="number">4</span>, <span class="number">0</span>);</span><br><span class="line">            acCirc1.Radius = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">using</span> (Circle acCirc2 = <span class="keyword">new</span> Circle())</span><br><span class="line">            &#123;</span><br><span class="line">                acCirc2.Center = <span class="keyword">new</span> Point3d(<span class="number">4</span>, <span class="number">4</span>, <span class="number">0</span>);</span><br><span class="line">                acCirc2.Radius = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Adds the circle to an object array</span></span><br><span class="line">                DBObjectCollection acDBObjColl = <span class="keyword">new</span> DBObjectCollection();</span><br><span class="line">                acDBObjColl.Add(acCirc1);</span><br><span class="line">                acDBObjColl.Add(acCirc2);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Calculate the regions based on each closed loop</span></span><br><span class="line">                DBObjectCollection myRegionColl = <span class="keyword">new</span> DBObjectCollection();</span><br><span class="line">                myRegionColl = Region.CreateFromCurves(acDBObjColl);</span><br><span class="line">                Region acRegion1 = myRegionColl[<span class="number">0</span>] <span class="keyword">as</span> Region;</span><br><span class="line">                Region acRegion2 = myRegionColl[<span class="number">1</span>] <span class="keyword">as</span> Region;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Subtract region 1 from region 2</span></span><br><span class="line">                <span class="keyword">if</span> (acRegion1.Area &gt; acRegion2.Area)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// Subtract the smaller region from the larger one</span></span><br><span class="line">                    acRegion1.BooleanOperation(BooleanOperationType.BoolSubtract, acRegion2);</span><br><span class="line">                    acRegion2.Dispose();</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// Add the final region to the database</span></span><br><span class="line">                    acBlkTblRec.AppendEntity(acRegion1);</span><br><span class="line">                    acTrans.AddNewlyCreatedDBObject(acRegion1, <span class="literal">true</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// Subtract the smaller region from the larger one</span></span><br><span class="line">                    acRegion2.BooleanOperation(BooleanOperationType.BoolSubtract, acRegion1);</span><br><span class="line">                    acRegion1.Dispose();</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// Add the final region to the database</span></span><br><span class="line">                    acBlkTblRec.AppendEntity(acRegion2);</span><br><span class="line">                    acTrans.AddNewlyCreatedDBObject(acRegion2, <span class="literal">true</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Dispose of the in memory objects not appended to the database</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Save the new object to the database</span></span><br><span class="line">        acTrans.Commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="创建图案填充（-NET）"><a href="#创建图案填充（-NET）" class="headerlink" title="创建图案填充（.NET）"></a>创建图案填充（.NET）</h3><p>闭合边界可以用图案填充。</p>
<p>创建图案填充时，最初不指定要填充的区域。首先，您必须创建 Hatch 对象。完成此操作后，可以指定外部循环，即图案填充的最外边界。然后，可以继续指定图案填充中可能存在的任何内环。</p>
<p>本节中的主题</p>
<ul>
<li>创建图案填充对象（.NET）</li>
<li>关联图案填充（.NET）</li>
<li>指定填充图案类型和名称（.NET）</li>
<li>定义图案填充边界（.NET）</li>
</ul>
<h4 id="创建图案填充对象（-NET）"><a href="#创建图案填充对象（-NET）" class="headerlink" title="创建图案填充对象（.NET）"></a>创建图案填充对象（.NET）</h4><p>创建 Hatch 对象时，请指定填充图案类型、填充图案名称和关联性。创建图案填充对象后，将无法更改图案填充关联性。</p>
<p>若要创建Hatch对象，请创建该对象的新实例，然后使用 AppendEntity 方法将其添加到 BlockTableRecord 对象。</p>
<h4 id="关联图案填充（-NET）"><a href="#关联图案填充（-NET）" class="headerlink" title="关联图案填充（.NET）"></a>关联图案填充（.NET）</h4><p>可以创建关联或非关联图案填充。关联图案填充链接到其边界，并在修改边界时更新。非关联图案填充独立于其边界。</p>
<p>若要使图案填充具有关联性，请将创建的图案填充对象的 Associative 特性设置为 TRUE 。若要使图案填充不关联，请将 Associative 特性设置为 FALSE 。</p>
<p>在附加图案填充循环之前，必须设置图案填充的关联性。如果图案填充对象是非关联的，则可以通过将 Associative 特性设置为 TRUE 并重新附加图案填充循环来使其再次关联。</p>
<h4 id="指定填充图案类型和名称（-NET）"><a href="#指定填充图案类型和名称（-NET）" class="headerlink" title="指定填充图案类型和名称（.NET）"></a>指定填充图案类型和名称（.NET）</h4><p>AutoCAD提供了实体填充和五十多种行业标准填充图案。填充图案亮显图形的特定特征或区域。例如，图案可以帮助区分3D对象的组件或表示构成对象的材料。</p>
<p>可以使用AutoCAD提供的阵列或外部阵列库中的阵列。</p>
<p>若要指定唯一的图案，必须同时指定图案填充对象的图案类型和名称。模式类型指定在何处查找模式名称。输入图案类型时，请使用以下常量之一：</p>
<ul>
<li><p>HatchPatternType.PreDefined</p>
<p>从<em>acad.pat</em>或<em>acadiso.pat</em>文件中定义的阵列名称中删除阵列名称。</p>
</li>
<li><p>HatchPatternType.UserDefined</p>
<p>使用当前线型定义线型图案。</p>
</li>
<li><p>HatchPatternType.CustomDefined</p>
<p>从除<em>acad.pat</em>或<em>acadiso.pat</em>文件之外的PAT中删除图案名称。</p>
<p>输入图案名称时，请使用对图案类型指定的文件有效的名称。</p>
</li>
</ul>
<h4 id="定义图案填充边界（-NET）"><a href="#定义图案填充边界（-NET）" class="headerlink" title="定义图案填充边界（.NET）"></a>定义图案填充边界（.NET）</h4><p>创建图案填充对象后，可以添加图案填充边界。边界可以是直线、圆弧、圆、二维多段线、椭圆、样条曲线和面域的任意组合。</p>
<p>添加的第一个边界必须是外边界，它定义了要由图案填充的最外边界。要添加外部边界，请使用 AppendLoop 方法，并将 HatchLoopTypes.Outermost 常量用于要追加的循环类型。</p>
<p>定义外部边界后，可以继续添加其他边界。使用带有 HatchLoopTypes.Default 常量的 AppendLoop 方法添加内部边界。</p>
<p>内部边界定义图案填充内的孤岛。Hatch对象如何处理这些孤岛取决于 HatchStyle 属性的设置。 HatchStyle 属性可以设置为以下条件之一：</p>
<p>图案填充样式定义</p>
<table>
<thead>
<tr>
<th align="left">HatchStyle</th>
<th align="left">Condition</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><img src="https://help.autodesk.com/cloudhelp/2024/ENU/OARX-DevGuide-Managed/images/GUID-EDF56CD1-C251-4D41-89F8-C3D29395DBD3.png" alt="img"></td>
<td align="left">Normal  (HatchStyle.Normal)</td>
<td align="left">指定标准样式或法线。该选项从最外侧的面积边界向内填充。如果AutoCAD遇到内部边界，它将关闭图案填充，直到遇到另一个边界。这是 HatchStyle 属性的默认设置。</td>
</tr>
<tr>
<td align="left"><img src="https://help.autodesk.com/cloudhelp/2024/ENU/OARX-DevGuide-Managed/images/GUID-16DC4CEC-E2A8-4D2B-A2E1-E783EAAAFACF.png" alt="img"></td>
<td align="left">Outer (HatchStyle.Outer)</td>
<td align="left">仅填充最外面的区域。此样式也会从区域边界向内填充图案，但如果遇到内部边界，则会关闭图案填充，并且不会再次启用。</td>
</tr>
<tr>
<td align="left"><img src="https://help.autodesk.com/cloudhelp/2024/ENU/OARX-DevGuide-Managed/images/GUID-714AC326-A55B-4580-A0F8-F5E058573AEF.png" alt="img"></td>
<td align="left">Ignore (HatchStyle.Ignore)</td>
<td align="left">忽略内部结构。此选项将填充所有内部对象。</td>
</tr>
</tbody></table>
<p>完成图案填充的定义后，必须先对其进行计算，然后才能显示。使用 EvaluateHatch 方法来执行此操作。</p>
<p> <strong>创建图案填充对象</strong></p>
<p>以下示例在模型空间中创建关联的图案填充。创建图案填充后，可以更改与图案填充关联的圆的大小。图案填充将更改以匹配圆的大小。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.Runtime;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.ApplicationServices;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.DatabaseServices;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.Geometry;</span><br><span class="line"> </span><br><span class="line">[<span class="meta">CommandMethod(<span class="string">&quot;AddHatch&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">AddHatch</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Get the current document and database</span></span><br><span class="line">    Document acDoc = Application.DocumentManager.MdiActiveDocument;</span><br><span class="line">    Database acCurDb = acDoc.Database;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start a transaction</span></span><br><span class="line">    <span class="keyword">using</span> (Transaction acTrans = acCurDb.TransactionManager.StartTransaction())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Open the Block table for read</span></span><br><span class="line">        BlockTable acBlkTbl;</span><br><span class="line">        acBlkTbl = acTrans.GetObject(acCurDb.BlockTableId,</span><br><span class="line">                                        OpenMode.ForRead) <span class="keyword">as</span> BlockTable;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Open the Block table record Model space for write</span></span><br><span class="line">        BlockTableRecord acBlkTblRec;</span><br><span class="line">        acBlkTblRec = acTrans.GetObject(acBlkTbl[BlockTableRecord.ModelSpace],</span><br><span class="line">                                        OpenMode.ForWrite) <span class="keyword">as</span> BlockTableRecord;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create a circle object for the closed boundary to hatch</span></span><br><span class="line">        <span class="keyword">using</span> (Circle acCirc = <span class="keyword">new</span> Circle())</span><br><span class="line">        &#123;</span><br><span class="line">            acCirc.Center = <span class="keyword">new</span> Point3d(<span class="number">3</span>, <span class="number">3</span>, <span class="number">0</span>);</span><br><span class="line">            acCirc.Radius = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Add the new circle object to the block table record and the transaction</span></span><br><span class="line">            acBlkTblRec.AppendEntity(acCirc);</span><br><span class="line">            acTrans.AddNewlyCreatedDBObject(acCirc, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Adds the circle to an object id array</span></span><br><span class="line">            ObjectIdCollection acObjIdColl = <span class="keyword">new</span> ObjectIdCollection();</span><br><span class="line">            acObjIdColl.Add(acCirc.ObjectId);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Create the hatch object and append it to the block table record</span></span><br><span class="line">            <span class="keyword">using</span> (Hatch acHatch = <span class="keyword">new</span> Hatch())</span><br><span class="line">            &#123;</span><br><span class="line">                acBlkTblRec.AppendEntity(acHatch);</span><br><span class="line">                acTrans.AddNewlyCreatedDBObject(acHatch, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Set the properties of the hatch object</span></span><br><span class="line">                <span class="comment">// Associative must be set after the hatch object is appended to the </span></span><br><span class="line">                <span class="comment">// block table record and before AppendLoop</span></span><br><span class="line">                acHatch.SetHatchPattern(HatchPatternType.PreDefined, <span class="string">&quot;ANSI31&quot;</span>);</span><br><span class="line">                acHatch.Associative = <span class="literal">true</span>;</span><br><span class="line">                acHatch.AppendLoop(HatchLoopTypes.Outermost, acObjIdColl);</span><br><span class="line">                acHatch.EvaluateHatch(<span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Save the new object to the database</span></span><br><span class="line">        acTrans.Commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用选择集（-NET）"><a href="#使用选择集（-NET）" class="headerlink" title="使用选择集（.NET）"></a>使用选择集（.NET）</h2><p>选择集可以由单个对象组成，也可以是更复杂的分组：例如，某个图层上的对象集。</p>
<p>选择集通常是通过以下方式创建的：在命令启动之前，通过拾取第一选择或在命令处于活动状态时的“选择对象：”提示下，请求用户在绘图区域中选择对象。选择集不是持久性对象，如果需要维护选择集以供多个命令之间使用或将来使用，则需要创建自定义字典，并将在选择集中找到的ObjectId作为软指针记录在字典记录中。</p>
<p>作为将ObjectId存储为软指针的替代方案，您可以将每个对象句柄存储在字典中。然后使用 Database.GetObjectId 方法从存储的句柄中获取对象的ObjectId。</p>
<p>注意：无论你将ObjectId存储为字典中的软指针还是句柄，你都需要在访问它之前确保对象存在。</p>
<p><strong>提示和选择过滤器</strong></p>
<p>选择集的管理被拆分到属于 Autodesk.AutoCAD.EditorInput 命名空间的多个对象中。使用 Editor 对象提示用户进行选择，并执行选择操作。 PromptSelectionOptions 对象用于配置选择操作开始时显示给用户的提示， SelectionFilter 类可用于按实体属性筛选选择集。</p>
<p>PromptSelectionOptions 类提供了用于指定提示关键字的 SetKeywords 方法，以及用于配置提示消息的 MessageForAdding 和 MessageForRemoval 属性。如“ResultBuffer数据类型（.NET）”主题中所述， SelectionFilter 类以 TypedValue 对象数组的形式接受筛选器参数。每个 TypedValue 对象表示一个过滤条件。可以为选择指定任何数量的条件。</p>
<p>当应用程序准备好提示选择时，您可以调用 Editor 对象上的 GetSelection 方法。 Editor.GetSelection 方法存在于许多重载版本中。对于使用标准AutoCAD提示的简单、未过滤的选择，可以使用无参数重载。对于希望提供自定义提示消息（包括关键字）的情况，可以使用接受 PromptSelectionOptions 对象的重载。若要指定筛选器，请使用接受 SelectionFilter 对象的重载。</p>
<p>其他选择方法涵盖了AutoCAD程序中可用的全部选择模式。 Editor.SelectImplied 方法提供对隐含的或先选择的选择集的访问。 Editor.SelectPrevious 方法返回在上一个选择集中选择的对象。像 SelectCrossingWindow 和 SelectFence 这样的方法让应用程序通过窗口、交叉、栅栏和多边形来选择实体。</p>
<h3 id="获取PickFirst选择集（-NET）"><a href="#获取PickFirst选择集（-NET）" class="headerlink" title="获取PickFirst选择集（.NET）"></a>获取PickFirst选择集（.NET）</h3><p>在启动命令之前选择对象时，将创建PickFirst选择集。要获得PickFirst选择集的对象，必须满足以下几个条件：</p>
<ul>
<li>PICKFIRST系统变量必须设置为1</li>
<li>必须使用PickFirst选择集的命令定义 UsePickSet 命令标志</li>
<li>调用 SelectImplied 方法以获取PickFirst选择集</li>
</ul>
<p>SetImpliedSelection 方法用于清除当前PickFirst选择集。</p>
<p><strong>获取PickFirst选择集</strong></p>
<p>此示例显示PickFirst选择集中的对象数，然后请求用户选择其他对象。在请求用户选择对象之前，将使用 SetImpliedSelection 方法清除当前PickFirst选择集。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.Runtime;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.ApplicationServices;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.DatabaseServices;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.EditorInput;</span><br><span class="line"> </span><br><span class="line">[<span class="meta">CommandMethod(<span class="string">&quot;CheckForPickfirstSelection&quot;</span>, CommandFlags.UsePickSet)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CheckForPickfirstSelection</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Get the current document</span></span><br><span class="line">    Editor acDocEd = Application.DocumentManager.MdiActiveDocument.Editor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get the PickFirst selection set</span></span><br><span class="line">    PromptSelectionResult acSSPrompt;</span><br><span class="line">    acSSPrompt = acDocEd.SelectImplied();</span><br><span class="line"></span><br><span class="line">    SelectionSet acSSet;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the prompt status is OK, objects were selected before</span></span><br><span class="line">    <span class="comment">// the command was started</span></span><br><span class="line">    <span class="keyword">if</span> (acSSPrompt.Status == PromptStatus.OK)</span><br><span class="line">    &#123;</span><br><span class="line">        acSSet = acSSPrompt.Value;</span><br><span class="line"></span><br><span class="line">        Application.ShowAlertDialog(<span class="string">&quot;Number of objects in Pickfirst selection: &quot;</span> +</span><br><span class="line">                                    acSSet.Count.ToString());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        Application.ShowAlertDialog(<span class="string">&quot;Number of objects in Pickfirst selection: 0&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Clear the PickFirst selection set</span></span><br><span class="line">    ObjectId[] idarrayEmpty = <span class="keyword">new</span> ObjectId[<span class="number">0</span>];</span><br><span class="line">    acDocEd.SetImpliedSelection(idarrayEmpty);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Request for objects to be selected in the drawing area</span></span><br><span class="line">    acSSPrompt = acDocEd.GetSelection();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the prompt status is OK, objects were selected</span></span><br><span class="line">    <span class="keyword">if</span> (acSSPrompt.Status == PromptStatus.OK)</span><br><span class="line">    &#123;</span><br><span class="line">        acSSet = acSSPrompt.Value;</span><br><span class="line"></span><br><span class="line">        Application.ShowAlertDialog(<span class="string">&quot;Number of objects selected: &quot;</span> +</span><br><span class="line">                                    acSSet.Count.ToString());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        Application.ShowAlertDialog(<span class="string">&quot;Number of objects selected: 0&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="在绘图区域中选择对象（-NET）"><a href="#在绘图区域中选择对象（-NET）" class="headerlink" title="在绘图区域中选择对象（.NET）"></a>在绘图区域中选择对象（.NET）</h3><p>可以通过让用户交互选择对象来选择对象，也可以通过AutoCAD .NET API模拟多种对象选择选项。如果您的例程执行多个选择集，则需要跟踪返回的每个选择集，或者创建 ObjectIdCollection 对象来跟踪所有选定对象。使用以下函数可以从图形中选择对象：</p>
<p> <strong>获取选择</strong></p>
<p>允许用户从屏幕上拾取对象。</p>
<p><strong>选择全部</strong></p>
<p>显示图形中的所有对象。</p>
<p>注意：所有布局和空间中的对象都将被选中，包括对象将被锁定或冻结。</p>
<p><strong>选择交叉多边形</strong></p>
<p>选择放置在通过指定点定义的多边形内或与该多边形相交的对象。多边形可以是任何形状，但不能交叉或接触自身。</p>
<p><strong>选择交叉窗口</strong></p>
<p>选择由两个点定义的区域内或穿过该区域的对象。</p>
<p> <strong>选择围栏</strong></p>
<p>选择与选择栏交叉的所有对象。围栏选择与交叉多边形选择类似，不同之处在于围栏不是闭合的，并且围栏可以自己交叉。</p>
<p><strong>选择最后一个</strong></p>
<p>选择在当前空间中创建的最后一个对象。</p>
<p><strong>选择上一个</strong></p>
<p>选择在上一个“选择对象：”提示期间选择的所有对象。</p>
<p><strong>选择窗口</strong></p>
<p>选择所有完全放置在由两点定义的矩形内的对象。</p>
<p><strong>选择窗口多边形</strong></p>
<p>选择完全放置在由点定义的多边形内的对象。多边形可以是任何形状，但不能交叉或接触自身。</p>
<p><strong>通过点选择</strong></p>
<p>选择通过给定点的对象，并将其放置到活动选择集中。</p>
<p><strong>按多边形选择</strong></p>
<p>选择在围栏内的对象并将其添加到活动选择集中。</p>
<p><strong>提示在屏幕上输入对象并重新选择选择集</strong></p>
<p>此示例提示用户选择对象，然后将每个选定对象的颜色更改为绿色或AutoCAD颜色索引3。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.Runtime;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.ApplicationServices;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.DatabaseServices;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.EditorInput;</span><br><span class="line"> </span><br><span class="line">[<span class="meta">CommandMethod(<span class="string">&quot;SelectObjectsOnscreen&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SelectObjectsOnscreen</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Get the current document and database</span></span><br><span class="line">    Document acDoc = Application.DocumentManager.MdiActiveDocument;</span><br><span class="line">    Database acCurDb = acDoc.Database;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start a transaction</span></span><br><span class="line">    <span class="keyword">using</span> (Transaction acTrans = acCurDb.TransactionManager.StartTransaction())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Request for objects to be selected in the drawing area</span></span><br><span class="line">        PromptSelectionResult acSSPrompt = acDoc.Editor.GetSelection();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If the prompt status is OK, objects were selected</span></span><br><span class="line">        <span class="keyword">if</span> (acSSPrompt.Status == PromptStatus.OK)</span><br><span class="line">        &#123;</span><br><span class="line">            SelectionSet acSSet = acSSPrompt.Value;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Step through the objects in the selection set</span></span><br><span class="line">            <span class="keyword">foreach</span> (SelectedObject acSSObj <span class="keyword">in</span> acSSet)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// Check to make sure a valid SelectedObject object was returned</span></span><br><span class="line">                <span class="keyword">if</span> (acSSObj != <span class="literal">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// Open the selected object for write</span></span><br><span class="line">                    Entity acEnt = acTrans.GetObject(acSSObj.ObjectId,</span><br><span class="line">                                                        OpenMode.ForWrite) <span class="keyword">as</span> Entity;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (acEnt != <span class="literal">null</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">// Change the object&#x27;s color to Green</span></span><br><span class="line">                        acEnt.ColorIndex = <span class="number">3</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Save the new object to the database</span></span><br><span class="line">            acTrans.Commit();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Dispose of the transaction</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用交叉窗口选择对象</strong></p>
<p>本示例选择与交叉窗口相交的对象。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.Runtime;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.ApplicationServices;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.DatabaseServices;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.Geometry;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.EditorInput;</span><br><span class="line"> </span><br><span class="line">[<span class="meta">CommandMethod(<span class="string">&quot;SelectObjectsByCrossingWindow&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SelectObjectsByCrossingWindow</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Get the current document editor</span></span><br><span class="line">    Editor acDocEd = Application.DocumentManager.MdiActiveDocument.Editor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create a crossing window from (2,2,0) to (10,8,0)</span></span><br><span class="line">    PromptSelectionResult acSSPrompt;</span><br><span class="line">    acSSPrompt = acDocEd.SelectCrossingWindow(<span class="keyword">new</span> Point3d(<span class="number">2</span>, <span class="number">2</span>, <span class="number">0</span>),</span><br><span class="line">                                                <span class="keyword">new</span> Point3d(<span class="number">10</span>, <span class="number">8</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the prompt status is OK, objects were selected</span></span><br><span class="line">    <span class="keyword">if</span> (acSSPrompt.Status == PromptStatus.OK)</span><br><span class="line">    &#123;</span><br><span class="line">        SelectionSet acSSet = acSSPrompt.Value;</span><br><span class="line"></span><br><span class="line">        Application.ShowAlertDialog(<span class="string">&quot;Number of objects selected: &quot;</span> +</span><br><span class="line">                                    acSSet.Count.ToString());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        Application.ShowAlertDialog(<span class="string">&quot;Number of objects selected: 0&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="选择集关键字（-NET）"><a href="#选择集关键字（-NET）" class="headerlink" title="选择集关键字（.NET）"></a>选择集关键字（.NET）</h3><p>应用程序可以在实际创建选择集之前使用关键字提示用户选择首选项。</p>
<p>通过创建 PromptSelectionOptions 对象的实例，可以将关键字分配给对象选择操作。创建 PromptSelectionOptions 对象后，将使用 SetKeywords 方法指定用户可以在命令提示符下输入的每个关键字。一旦将关键字分配给 PromptSelectionOptions 对象，则必须将 PromptSelectionOptions 对象传递给编辑器的 GetSelection 方法。</p>
<p>用户可以在 Select objects: 提示符处输入的关键字的实现由 PromptSelectionOptions.KeywordInput 事件处理程序处理。当用户在结果提示符处输入关键字时，将引发 KeywordInput 事件并调用应用程序的处理程序。</p>
<p>一个 KeywordInput 处理程序接收一个 SelectionTextInputEventArgs 参数，该参数同时作为输入和输出参数。 SelectionTextInputEventArgs 参数的 Input 属性指示所选的关键字。典型的处理程序将此关键字与应用程序的关键字列表中的关键字进行比较，并调用适当的选择方法。如果实体是由selection方法返回的，应用程序会使用 SelectionTextInputEventArgs.AddObjects 方法将这些实体添加到 SelectionTextInputEventArgs 参数中。当原始的 GetSelection 调用返回时，它将选定的实体提供给设置关键字列表的方法。</p>
<p>下面的示例定义了五个关键字，并添加了一个处理程序来支持用户选择的关键字。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SelectionKeywordInputHandler</span>(<span class="params"><span class="built_in">object</span> sender, SelectionTextInputEventArgs eSelectionInput</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">			 <span class="comment">// Gets the current document editor and define other variables for the current scope</span></span><br><span class="line">			 Editor acDocEd = Application.DocumentManager.MdiActiveDocument.Editor;</span><br><span class="line">    PromptSelectionResult acSSPrompt = <span class="literal">null</span>;</span><br><span class="line">    SelectionSet acSSet = <span class="literal">null</span>;</span><br><span class="line">    ObjectId[] acObjIds = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">	   <span class="comment">// See if the user choose the myFence keyword</span></span><br><span class="line">	   <span class="keyword">switch</span> (eSelectionInput.Input) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;myFence&quot;</span>:</span><br><span class="line">			         <span class="comment">// Uses the four points to define a fence selection</span></span><br><span class="line">            Point3dCollection ptsFence = <span class="keyword">new</span> Point3dCollection();</span><br><span class="line">            ptsFence.Add(<span class="keyword">new</span> Point3d(<span class="number">5.0</span>, <span class="number">5.0</span>, <span class="number">0.0</span>));</span><br><span class="line">            ptsFence.Add(<span class="keyword">new</span> Point3d(<span class="number">13.0</span>, <span class="number">15.0</span>, <span class="number">0.0</span>));</span><br><span class="line">            ptsFence.Add(<span class="keyword">new</span> Point3d(<span class="number">12.0</span>, <span class="number">9.0</span>, <span class="number">0.0</span>));</span><br><span class="line">            ptsFence.Add(<span class="keyword">new</span> Point3d(<span class="number">5.0</span>, <span class="number">5.0</span>, <span class="number">0.0</span>));</span><br><span class="line"></span><br><span class="line">            acSSPrompt = acDocEd.SelectFence(ptsFence);</span><br><span class="line">			         <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;myWindow&quot;</span>:</span><br><span class="line">			         <span class="comment">// Defines a rectangular window selection</span></span><br><span class="line">            acSSPrompt = acDocEd.SelectWindow(<span class="keyword">new</span> Point3d(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>), <span class="keyword">new</span> Point3d(<span class="number">30.0</span>, <span class="number">20.0</span>, <span class="number">0.0</span>));</span><br><span class="line">			         <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;myWPoly&quot;</span>:</span><br><span class="line">			         <span class="comment">// Uses the four points to define a polygon window selection</span></span><br><span class="line">            Point3dCollection ptsPolygon = <span class="keyword">new</span> Point3dCollection();</span><br><span class="line">            ptsPolygon.Add(<span class="keyword">new</span> Point3d(<span class="number">5.0</span>, <span class="number">5.0</span>, <span class="number">0.0</span>));</span><br><span class="line">            ptsPolygon.Add(<span class="keyword">new</span> Point3d(<span class="number">13.0</span>, <span class="number">15.0</span>, <span class="number">0.0</span>));</span><br><span class="line">            ptsPolygon.Add(<span class="keyword">new</span> Point3d(<span class="number">12.0</span>, <span class="number">9.0</span>, <span class="number">0.0</span>));</span><br><span class="line">            ptsPolygon.Add(<span class="keyword">new</span> Point3d(<span class="number">5.0</span>, <span class="number">5.0</span>, <span class="number">0.0</span>));</span><br><span class="line"></span><br><span class="line">            acSSPrompt = acDocEd.SelectWindowPolygon(ptsPolygon);</span><br><span class="line">			         <span class="keyword">break</span>;</span><br><span class="line">		      <span class="keyword">case</span> <span class="string">&quot;myLastSel&quot;</span>:</span><br><span class="line">			        <span class="comment">// Gets the last object created</span></span><br><span class="line">			        acSSPrompt = acDocEd.SelectLast();</span><br><span class="line">			        <span class="keyword">break</span>;</span><br><span class="line">		      <span class="keyword">case</span> <span class="string">&quot;myPrevSel&quot;</span>:</span><br><span class="line">			        <span class="comment">// Gets the previous object selection set</span></span><br><span class="line">			        acSSPrompt = acDocEd.SelectPrevious();</span><br><span class="line">			        <span class="keyword">break</span>;</span><br><span class="line">	   &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the prompt status is OK, objects were selected and return</span></span><br><span class="line">    <span class="keyword">if</span> (acSSPrompt != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (acSSPrompt.Status == PromptStatus.OK)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Objects were selected, so add them to the current selection</span></span><br><span class="line">            acSSet = acSSPrompt.Value;</span><br><span class="line">            acObjIds = acSSet.GetObjectIds();</span><br><span class="line">            eSelectionInput.AddObjects(acObjIds);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="meta">CommandMethod(<span class="string">&quot;SelectionKeywordInput&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SelectionKeywordInput</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Gets the current document editor</span></span><br><span class="line">    Editor acDocEd = Application.DocumentManager.MdiActiveDocument.Editor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Setups the keyword options</span></span><br><span class="line">    PromptSelectionOptions acKeywordOpts = <span class="keyword">new</span> PromptSelectionOptions();</span><br><span class="line">    acKeywordOpts.Keywords.Add(<span class="string">&quot;myFence&quot;</span>);</span><br><span class="line">    acKeywordOpts.Keywords.Add(<span class="string">&quot;myWindow&quot;</span>);</span><br><span class="line">    acKeywordOpts.Keywords.Add(<span class="string">&quot;myWPoly&quot;</span>);</span><br><span class="line">    acKeywordOpts.Keywords.Add(<span class="string">&quot;myLastSel&quot;</span>);</span><br><span class="line">    acKeywordOpts.Keywords.Add(<span class="string">&quot;myPrevSel&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Adds the event handler for keyword input</span></span><br><span class="line">    acKeywordOpts.KeywordInput += <span class="keyword">new</span> SelectionTextInputEventHandler(SelectionKeywordInputHandler);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Prompts the user for a selection set</span></span><br><span class="line">    PromptSelectionResult acSSPrompt = acDocEd.GetSelection(acKeywordOpts);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the prompt status is OK, objects were selected</span></span><br><span class="line">    <span class="keyword">if</span> (acSSPrompt.Status == PromptStatus.OK)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Gets the selection set</span></span><br><span class="line">        SelectionSet acSSet = acSSPrompt.Value;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Gets the objects from the selection set</span></span><br><span class="line">        ObjectId[] acObjIds = acSSet.GetObjectIds();</span><br><span class="line">        Database acCurDb = Application.DocumentManager.MdiActiveDocument.Database;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Starts a transaction</span></span><br><span class="line">        <span class="keyword">using</span> (Transaction acTrans = acCurDb.TransactionManager.StartTransaction())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// Gets information about each object</span></span><br><span class="line">                <span class="keyword">foreach</span> (ObjectId acObjId <span class="keyword">in</span> acObjIds)</span><br><span class="line">                &#123;</span><br><span class="line">                    Entity acEnt = (Entity)acTrans.GetObject(acObjId, OpenMode.ForWrite, <span class="literal">true</span>);</span><br><span class="line">                    acDocEd.WriteMessage(<span class="string">&quot;\nObject selected: &quot;</span> + acEnt.GetType().FullName);</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">finally</span></span><br><span class="line">            &#123;</span><br><span class="line">                acTrans.Dispose();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Removes the event handler for keyword input</span></span><br><span class="line">    acKeywordOpts.KeywordInput -= <span class="keyword">new</span> SelectionTextInputEventHandler(SelectionKeywordInputHandler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="添加到或合并多个选择集（-NET）"><a href="#添加到或合并多个选择集（-NET）" class="headerlink" title="添加到或合并多个选择集（.NET）"></a>添加到或合并多个选择集（.NET）</h3><p>可以通过创建 ObjectIdCollection 对象，然后将多个选择集的对象ID添加到一起来合并多个选择集。除了向 ObjectIdCollection 对象添加对象ID之外，还可以删除对象ID。一旦所有对象id都添加到 ObjectIdCollection 对象中，您就可以遍历对象id的集合，并根据需要操作每个对象。</p>
<p><strong>将选定对象添加到选择集中</strong></p>
<p>本示例提示用户选择对象两次，然后将创建的两个选择集合并为一个选择集。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.Runtime;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.ApplicationServices;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.DatabaseServices;</span><br><span class="line"><span class="keyword">using</span> Autodesk.AutoCAD.EditorInput;</span><br><span class="line"> </span><br><span class="line">[<span class="meta">CommandMethod(<span class="string">&quot;MergeSelectionSets&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MergeSelectionSets</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Get the current document editor</span></span><br><span class="line">    Editor acDocEd = Application.DocumentManager.MdiActiveDocument.Editor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Request for objects to be selected in the drawing area</span></span><br><span class="line">    PromptSelectionResult acSSPrompt;</span><br><span class="line">    acSSPrompt = acDocEd.GetSelection();</span><br><span class="line"></span><br><span class="line">    SelectionSet acSSet1;</span><br><span class="line">    ObjectIdCollection acObjIdColl = <span class="keyword">new</span> ObjectIdCollection();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the prompt status is OK, objects were selected</span></span><br><span class="line">    <span class="keyword">if</span> (acSSPrompt.Status == PromptStatus.OK)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Get the selected objects</span></span><br><span class="line">        acSSet1 = acSSPrompt.Value;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Append the selected objects to the ObjectIdCollection</span></span><br><span class="line">        acObjIdColl = <span class="keyword">new</span> ObjectIdCollection(acSSet1.GetObjectIds());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Request for objects to be selected in the drawing area</span></span><br><span class="line">    acSSPrompt = acDocEd.GetSelection();</span><br><span class="line"></span><br><span class="line">    SelectionSet acSSet2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the prompt status is OK, objects were selected</span></span><br><span class="line">    <span class="keyword">if</span> (acSSPrompt.Status == PromptStatus.OK)</span><br><span class="line">    &#123;</span><br><span class="line">        acSSet2 = acSSPrompt.Value;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check the size of the ObjectIdCollection, if zero, then initialize it</span></span><br><span class="line">        <span class="keyword">if</span> (acObjIdColl.Count == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            acObjIdColl = <span class="keyword">new</span> ObjectIdCollection(acSSet2.GetObjectIds());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Step through the second selection set</span></span><br><span class="line">            <span class="keyword">foreach</span> (ObjectId acObjId <span class="keyword">in</span> acSSet2.GetObjectIds())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// Add each object id to the ObjectIdCollection</span></span><br><span class="line">                acObjIdColl.Add(acObjId);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Application.ShowAlertDialog(<span class="string">&quot;Number of objects selected: &quot;</span> +</span><br><span class="line">                                acObjIdColl.Count.ToString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="定义选择筛选器的规则（-NET）"><a href="#定义选择筛选器的规则（-NET）" class="headerlink" title="定义选择筛选器的规则（.NET）"></a>定义选择筛选器的规则（.NET）</h3><p>可以使用选择过滤器限制选择哪些对象并将其添加到选择集中。选择过滤器列表可用于按特性或类型过滤选定对象。例如，您可能希望仅选择蓝色对象或特定图层上的对象。也可以组合联合收割机选择标准。例如，可以创建一个选择过滤器，将选择限制在名为“图案”的图层上的蓝色圆。</p>
<p><strong>注意：</strong>过滤识别明确分配给对象的值，而不是层继承的值。例如，如果对象的线型特性设置为ByLayer，并且指定给它的图层设置为隐藏线型;过滤指定为隐藏线型的对象不会选择这些对象，因为它们的线型特性设置为ByLayer。</p>
<h3 id="从选择集中删除对象（-NET）"><a href="#从选择集中删除对象（-NET）" class="headerlink" title="从选择集中删除对象（.NET）"></a>从选择集中删除对象（.NET）</h3><p>创建选择集后，可以使用选定对象的对象ID。选择集不允许添加对象ID或从中删除对象ID，但可以使用 ObjectIdCollection 对象将多个选择集合并为单个对象。您可以从 ObjectIdCollection 对象中添加和删除对象ID。使用 Remove 或 RemoveAt 方法从 ObjectIdCollection 对象中删除对象ID。</p>
<p>本节中的主题</p>
<ul>
<li>使用选择过滤器定义选择集规则（.NET）</li>
<li>在选择筛选器中指定多个条件（.NET）</li>
<li>增加过滤器列表条件的复杂性（.NET）</li>
<li>在选择集筛选条件（.NET）中使用通配符模式</li>
<li>扩展数据过滤器（.NET）</li>
</ul>
<h4 id="使用选择过滤器定义选择集规则（-NET）"><a href="#使用选择过滤器定义选择集规则（-NET）" class="headerlink" title="使用选择过滤器定义选择集规则（.NET）"></a>使用选择过滤器定义选择集规则（.NET）</h4><p>选择筛选器由 TypedValues 形式的参数对组成。 TypedValue 的第一个参数标识过滤器的类型（例如，对象），第二个参数指定您正在过滤的值（例如，圆）。筛选器类型是一个指定要使用的筛选器的通配符组代码。这里列出了一些最常见的过滤器类型。</p>
<p><strong>常用过滤器的编码</strong></p>
<table>
<thead>
<tr>
<th align="left">DXF code</th>
<th align="left">Filter type</th>
</tr>
</thead>
<tbody><tr>
<td align="left">0 (or DxfCode.Start)</td>
<td align="left">对象类型（String串）例如“Line”、“Circle”、“Arc”等等。</td>
</tr>
<tr>
<td align="left">2 (or DxfCode.BlockName)</td>
<td align="left">块名称（String）插入参照的块名。</td>
</tr>
<tr>
<td align="left">8 or (DxfCode.LayerName)</td>
<td align="left">图层名称（String） 例如“Layer 0”。</td>
</tr>
<tr>
<td align="left">60 (DxfCode.Visibility)</td>
<td align="left">对象可见性（Integer）Use 0 &#x3D; visible, 1 &#x3D; invisible.</td>
</tr>
<tr>
<td align="left">62 (or DxfCode.Color)</td>
<td align="left">颜色编号（Integer） 从0到256的数字索引值。零表示BYBLOCK。256表示BYLAYER。负值表示图层已关闭。</td>
</tr>
<tr>
<td align="left">67</td>
<td align="left">模型&#x2F;图纸空间指示器（Integer） 使用0或omitted &#x3D;模型空间，1 &#x3D;图纸空间。</td>
</tr>
</tbody></table>
<p><strong>为选择集指定单个选择条件</strong></p>
<p>下面的代码提示用户选择要包含在选择集中的对象，并筛选出除圆以外的所有对象。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">CommandMethod(<span class="string">&quot;FilterSelectionSet&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">FilterSelectionSet</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Get the current document editor</span></span><br><span class="line">    Editor acDocEd = Application.DocumentManager.MdiActiveDocument.Editor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create a TypedValue array to define the filter criteria</span></span><br><span class="line">    TypedValue[] acTypValAr = <span class="keyword">new</span> TypedValue[<span class="number">1</span>];</span><br><span class="line">    acTypValAr.SetValue(<span class="keyword">new</span> TypedValue((<span class="built_in">int</span>)DxfCode.Start, <span class="string">&quot;CIRCLE&quot;</span>), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Assign the filter criteria to a SelectionFilter object</span></span><br><span class="line">    SelectionFilter acSelFtr = <span class="keyword">new</span> SelectionFilter(acTypValAr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Request for objects to be selected in the drawing area</span></span><br><span class="line">    PromptSelectionResult acSSPrompt;</span><br><span class="line">    acSSPrompt = acDocEd.GetSelection(acSelFtr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the prompt status is OK, objects were selected</span></span><br><span class="line">    <span class="keyword">if</span> (acSSPrompt.Status == PromptStatus.OK)</span><br><span class="line">    &#123;</span><br><span class="line">        SelectionSet acSSet = acSSPrompt.Value;</span><br><span class="line"></span><br><span class="line">        Application.ShowAlertDialog(<span class="string">&quot;Number of objects selected: &quot;</span> +</span><br><span class="line">                                    acSSet.Count.ToString());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        Application.ShowAlertDialog(<span class="string">&quot;Number of objects selected: 0&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="在选择筛选器中指定多个条件（-NET）"><a href="#在选择筛选器中指定多个条件（-NET）" class="headerlink" title="在选择筛选器中指定多个条件（.NET）"></a>在选择筛选器中指定多个条件（.NET）</h4><p><strong>选择符合三个标准的对象</strong></p>
<p>下面的示例指定了三个筛选选定对象的条件：对象必须是圆形，颜色为蓝色，并且必须位于图层0上。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">CommandMethod(<span class="string">&quot;FilterBlueCircleOnLayer0&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">FilterBlueCircleOnLayer0</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Get the current document editor</span></span><br><span class="line">    Editor acDocEd = Application.DocumentManager.MdiActiveDocument.Editor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create a TypedValue array to define the filter criteria</span></span><br><span class="line">    TypedValue[] acTypValAr = <span class="keyword">new</span> TypedValue[<span class="number">3</span>];</span><br><span class="line">    acTypValAr.SetValue(<span class="keyword">new</span> TypedValue((<span class="built_in">int</span>)DxfCode.Color, <span class="number">5</span>), <span class="number">0</span>);</span><br><span class="line">    acTypValAr.SetValue(<span class="keyword">new</span> TypedValue((<span class="built_in">int</span>)DxfCode.Start, <span class="string">&quot;CIRCLE&quot;</span>), <span class="number">1</span>);</span><br><span class="line">    acTypValAr.SetValue(<span class="keyword">new</span> TypedValue((<span class="built_in">int</span>)DxfCode.LayerName, <span class="string">&quot;0&quot;</span>), <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Assign the filter criteria to a SelectionFilter object</span></span><br><span class="line">    SelectionFilter acSelFtr = <span class="keyword">new</span> SelectionFilter(acTypValAr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Request for objects to be selected in the drawing area</span></span><br><span class="line">    PromptSelectionResult acSSPrompt;</span><br><span class="line">    acSSPrompt = acDocEd.GetSelection(acSelFtr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the prompt status is OK, objects were selected</span></span><br><span class="line">    <span class="keyword">if</span> (acSSPrompt.Status == PromptStatus.OK)</span><br><span class="line">    &#123;</span><br><span class="line">        SelectionSet acSSet = acSSPrompt.Value;</span><br><span class="line"></span><br><span class="line">        Application.ShowAlertDialog(<span class="string">&quot;Number of objects selected: &quot;</span> +</span><br><span class="line">                                    acSSet.Count.ToString());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        Application.ShowAlertDialog(<span class="string">&quot;Number of objects selected: 0&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="增加过滤器列表条件的复杂性（-NET）"><a href="#增加过滤器列表条件的复杂性（-NET）" class="headerlink" title="增加过滤器列表条件的复杂性（.NET）"></a>增加过滤器列表条件的复杂性（.NET）</h4><p>指定多个选择条件时，AutoCAD假定选定对象必须满足每个条件。你可以用其他方式来限定你的标准。对于数值项，可以指定关系运算（例如，圆的半径必须大于或等于5.0）。对于所有项目，您可以指定逻辑操作（例如 Text 或 MText ）。</p>
<p>使用-4\f25 ASCII码或常量 DxfCode.Operator 表示选择过滤器中的关系运算符。运算符表示为字符串。下表显示了允许的关系运算符。</p>
<p><strong>选择集过滤器列表的关系运算符</strong></p>
<table>
<thead>
<tr>
<th align="left">Operator  操作符</th>
<th align="left">Description  描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">“*”</td>
<td align="left">一切都为真（Always true）</td>
</tr>
<tr>
<td align="left">“&#x3D;”</td>
<td align="left">等于</td>
</tr>
<tr>
<td align="left">“!&#x3D;”</td>
<td align="left">不等于</td>
</tr>
<tr>
<td align="left">“&#x2F;&#x3D;”</td>
<td align="left">不等于</td>
</tr>
<tr>
<td align="left">“&lt;&gt;”</td>
<td align="left">不等于</td>
</tr>
<tr>
<td align="left">“&lt;”</td>
<td align="left">小于</td>
</tr>
<tr>
<td align="left">“&lt;&#x3D;”</td>
<td align="left">小于或等于</td>
</tr>
<tr>
<td align="left">“&gt;”</td>
<td align="left">大于</td>
</tr>
<tr>
<td align="left">“&gt;&#x3D;”</td>
<td align="left">大于或等于</td>
</tr>
<tr>
<td align="left">“&amp;”</td>
<td align="left">按位与（仅限整数组）</td>
</tr>
<tr>
<td align="left">“&amp;&#x3D;”</td>
<td align="left">按位掩码等于（仅限整数组）</td>
</tr>
</tbody></table>
<p>选择过滤器中的逻辑运算符也由分组代码或常量 DxfCode.Operator 表示，运算符是一个字符串，但运算符必须成对。开始运算符前面是小于符号（&lt;），结束运算符后面是大于符号（&gt;）。下表列出了选择集筛选中允许的逻辑运算符。</p>
<p><strong>选择集筛选器列表的逻辑分组运算符</strong></p>
<table>
<thead>
<tr>
<th align="left">Starting operator</th>
<th align="left">Encloses</th>
<th align="left">Ending operator</th>
</tr>
</thead>
<tbody><tr>
<td align="left">“&lt;AND”</td>
<td align="left">一个或多个操作数</td>
<td align="left">“AND&gt;”</td>
</tr>
<tr>
<td align="left">“&lt;OR”</td>
<td align="left">一个或多个操作数</td>
<td align="left">“OR&gt;”</td>
</tr>
<tr>
<td align="left">“&lt;XOR”</td>
<td align="left">两个操作数</td>
<td align="left">“XOR&gt;”</td>
</tr>
<tr>
<td align="left">“&lt;NOT”</td>
<td align="left">一个操作数</td>
<td align="left">“NOT&gt;”</td>
</tr>
</tbody></table>
<p><strong>选择半径大于或等于5.0的圆</strong></p>
<p>下面的示例选择半径大于或等于5.0的圆。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">CommandMethod(<span class="string">&quot;FilterRelational&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">FilterRelational</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Get the current document editor</span></span><br><span class="line">    Editor acDocEd = Application.DocumentManager.MdiActiveDocument.Editor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create a TypedValue array to define the filter criteria</span></span><br><span class="line">    TypedValue[] acTypValAr = <span class="keyword">new</span> TypedValue[<span class="number">3</span>];</span><br><span class="line">    acTypValAr.SetValue(<span class="keyword">new</span> TypedValue((<span class="built_in">int</span>)DxfCode.Start, <span class="string">&quot;CIRCLE&quot;</span>), <span class="number">0</span>);</span><br><span class="line">    acTypValAr.SetValue(<span class="keyword">new</span> TypedValue((<span class="built_in">int</span>)DxfCode.Operator, <span class="string">&quot;&gt;=&quot;</span>), <span class="number">1</span>);</span><br><span class="line">    acTypValAr.SetValue(<span class="keyword">new</span> TypedValue(<span class="number">40</span>, <span class="number">5</span>), <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Assign the filter criteria to a SelectionFilter object</span></span><br><span class="line">    SelectionFilter acSelFtr = <span class="keyword">new</span> SelectionFilter(acTypValAr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Request for objects to be selected in the drawing area</span></span><br><span class="line">    PromptSelectionResult acSSPrompt;</span><br><span class="line">    acSSPrompt = acDocEd.GetSelection(acSelFtr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the prompt status is OK, objects were selected</span></span><br><span class="line">    <span class="keyword">if</span> (acSSPrompt.Status == PromptStatus.OK)</span><br><span class="line">    &#123;</span><br><span class="line">        SelectionSet acSSet = acSSPrompt.Value;</span><br><span class="line"></span><br><span class="line">        Application.ShowAlertDialog(<span class="string">&quot;Number of objects selected: &quot;</span> +</span><br><span class="line">                                    acSSet.Count.ToString());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        Application.ShowAlertDialog(<span class="string">&quot;Number of objects selected: 0&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>选择文字或多行文字</strong></p>
<p>下面的示例指定可以选择 Text 或 MText 对象。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">CommandMethod(<span class="string">&quot;FilterForText&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">FilterForText</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Get the current document editor</span></span><br><span class="line">    Editor acDocEd = Application.DocumentManager.MdiActiveDocument.Editor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create a TypedValue array to define the filter criteria</span></span><br><span class="line">    TypedValue[] acTypValAr = <span class="keyword">new</span> TypedValue[<span class="number">4</span>];</span><br><span class="line">    acTypValAr.SetValue(<span class="keyword">new</span> TypedValue((<span class="built_in">int</span>)DxfCode.Operator, <span class="string">&quot;&lt;or&quot;</span>), <span class="number">0</span>);</span><br><span class="line">    acTypValAr.SetValue(<span class="keyword">new</span> TypedValue((<span class="built_in">int</span>)DxfCode.Start, <span class="string">&quot;TEXT&quot;</span>), <span class="number">1</span>);</span><br><span class="line">    acTypValAr.SetValue(<span class="keyword">new</span> TypedValue((<span class="built_in">int</span>)DxfCode.Start, <span class="string">&quot;MTEXT&quot;</span>), <span class="number">2</span>);</span><br><span class="line">    acTypValAr.SetValue(<span class="keyword">new</span> TypedValue((<span class="built_in">int</span>)DxfCode.Operator, <span class="string">&quot;or&gt;&quot;</span>), <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Assign the filter criteria to a SelectionFilter object</span></span><br><span class="line">    SelectionFilter acSelFtr = <span class="keyword">new</span> SelectionFilter(acTypValAr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Request for objects to be selected in the drawing area</span></span><br><span class="line">    PromptSelectionResult acSSPrompt;</span><br><span class="line">    acSSPrompt = acDocEd.GetSelection(acSelFtr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the prompt status is OK, objects were selected</span></span><br><span class="line">    <span class="keyword">if</span> (acSSPrompt.Status == PromptStatus.OK)</span><br><span class="line">    &#123;</span><br><span class="line">        SelectionSet acSSet = acSSPrompt.Value;</span><br><span class="line"></span><br><span class="line">        Application.ShowAlertDialog(<span class="string">&quot;Number of objects selected: &quot;</span> +</span><br><span class="line">                                    acSSet.Count.ToString());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        Application.ShowAlertDialog(<span class="string">&quot;Number of objects selected: 0&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="在选择集筛选条件（-NET）中使用通配符模式"><a href="#在选择集筛选条件（-NET）中使用通配符模式" class="headerlink" title="在选择集筛选条件（.NET）中使用通配符模式"></a>在选择集筛选条件（.NET）中使用通配符模式</h4><p>选择筛选器中的符号名称和字符串可以包含通配符模式。</p>
<p>下表确定了AutoCAD可识别的通配符，以及每个通配符在字符串上下文中的含义：</p>
<p>通配符</p>
<table>
<thead>
<tr>
<th align="left">字符</th>
<th align="left">定义</th>
</tr>
</thead>
<tbody><tr>
<td align="left"># (pound)</td>
<td align="left">匹配任何单个数字</td>
</tr>
<tr>
<td align="left">@ (at)</td>
<td align="left">匹配任何单个字母字符</td>
</tr>
<tr>
<td align="left">. (period)</td>
<td align="left">匹配任何单个非字母数字字符</td>
</tr>
<tr>
<td align="left">* (asterisk)</td>
<td align="left">匹配任何字符序列，包括空字符序列，并且可以在搜索模式中的任何位置使用：开头、中间或结尾</td>
</tr>
<tr>
<td align="left">? (question mark)</td>
<td align="left">匹配任何单个字符</td>
</tr>
<tr>
<td align="left">~ (tilde)</td>
<td align="left">如果它是模式中的第一个字符，则它匹配除模式之外的任何字符</td>
</tr>
<tr>
<td align="left">[…]</td>
<td align="left">匹配所包含的任何字符</td>
</tr>
<tr>
<td align="left">[~…]</td>
<td align="left">匹配任何未括起来的单个字符</td>
</tr>
<tr>
<td align="left">- (hyphen)</td>
<td align="left">在方括号内用于指定单个字符的范围</td>
</tr>
<tr>
<td align="left">, (comma)</td>
<td align="left">分离两种模式</td>
</tr>
<tr>
<td align="left">&#96; (reverse quote)</td>
<td align="left">转义特殊字符（按字面意思读取下一个字符）</td>
</tr>
</tbody></table>
<p><strong>选择文本中出现特定单词的多行文字</strong></p>
<p>下面的示例定义一个选择筛选器，该筛选器选择包含文本字符串“The”的 MText 对象。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">CommandMethod(<span class="string">&quot;FilterMtextWildcard&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">FilterMtextWildcard</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Get the current document editor</span></span><br><span class="line">    Editor acDocEd = Application.DocumentManager.MdiActiveDocument.Editor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create a TypedValue array to define the filter criteria</span></span><br><span class="line">    TypedValue[] acTypValAr = <span class="keyword">new</span> TypedValue[<span class="number">2</span>];</span><br><span class="line">    acTypValAr.SetValue(<span class="keyword">new</span> TypedValue((<span class="built_in">int</span>)DxfCode.Start, <span class="string">&quot;MTEXT&quot;</span>), <span class="number">0</span>);</span><br><span class="line">    acTypValAr.SetValue(<span class="keyword">new</span> TypedValue((<span class="built_in">int</span>)DxfCode.Text, <span class="string">&quot;*The*&quot;</span>), <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Assign the filter criteria to a SelectionFilter object</span></span><br><span class="line">    SelectionFilter acSelFtr = <span class="keyword">new</span> SelectionFilter(acTypValAr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Request for objects to be selected in the drawing area</span></span><br><span class="line">    PromptSelectionResult acSSPrompt;</span><br><span class="line">    acSSPrompt = acDocEd.GetSelection(acSelFtr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the prompt status is OK, objects were selected</span></span><br><span class="line">    <span class="keyword">if</span> (acSSPrompt.Status == PromptStatus.OK)</span><br><span class="line">    &#123;</span><br><span class="line">        SelectionSet acSSet = acSSPrompt.Value;</span><br><span class="line"></span><br><span class="line">        Application.ShowAlertDialog(<span class="string">&quot;Number of objects selected: &quot;</span> +</span><br><span class="line">                                    acSSet.Count.ToString());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        Application.ShowAlertDialog(<span class="string">&quot;Number of objects selected: 0&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="扩展数据过滤器（-NET）"><a href="#扩展数据过滤器（-NET）" class="headerlink" title="扩展数据过滤器（.NET）"></a>扩展数据过滤器（.NET）</h4><p>外部应用程序可以将文本字符串、数值、三维点、距离和图层名称等数据附着到AutoCAD对象。此数据称为扩展数据。您可以筛选包含指定应用程序的扩展数据的实体。</p>
<p><strong>选择包含扩展数据的圆</strong></p>
<p>以下示例过滤包含由“MY_APP”应用程序添加的扩展数据的圆：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">CommandMethod(<span class="string">&quot;FilterXdata&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">FilterXdata</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Get the current document editor</span></span><br><span class="line">    Editor acDocEd = Application.DocumentManager.MdiActiveDocument.Editor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create a TypedValue array to define the filter criteria</span></span><br><span class="line">    TypedValue[] acTypValAr = <span class="keyword">new</span> TypedValue[<span class="number">2</span>];</span><br><span class="line">    acTypValAr.SetValue(<span class="keyword">new</span> TypedValue((<span class="built_in">int</span>)DxfCode.Start, <span class="string">&quot;Circle&quot;</span>), <span class="number">0</span>);</span><br><span class="line">    acTypValAr.SetValue(<span class="keyword">new</span> TypedValue((<span class="built_in">int</span>)DxfCode.ExtendedDataRegAppName, </span><br><span class="line">                                        <span class="string">&quot;MY_APP&quot;</span>), <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Assign the filter criteria to a SelectionFilter object</span></span><br><span class="line">    SelectionFilter acSelFtr = <span class="keyword">new</span> SelectionFilter(acTypValAr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Request for objects to be selected in the drawing area</span></span><br><span class="line">    PromptSelectionResult acSSPrompt;</span><br><span class="line">    acSSPrompt = acDocEd.GetSelection(acSelFtr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the prompt status is OK, objects were selected</span></span><br><span class="line">    <span class="keyword">if</span> (acSSPrompt.Status == PromptStatus.OK)</span><br><span class="line">    &#123;</span><br><span class="line">        SelectionSet acSSet = acSSPrompt.Value;</span><br><span class="line"></span><br><span class="line">        Application.ShowAlertDialog(<span class="string">&quot;Number of objects selected: &quot;</span> +</span><br><span class="line">                                    acSSet.Count.ToString());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        Application.ShowAlertDialog(<span class="string">&quot;Number of objects selected: 0&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="编辑命名和2D对象（-NET）"><a href="#编辑命名和2D对象（-NET）" class="headerlink" title="编辑命名和2D对象（.NET）"></a>编辑命名和2D对象（.NET）</h2><p>可以使用与每个对象关联的方法和属性修改现有对象。如果修改图形对象的可见属性，请使用 Regen 方法在屏幕上重绘对象。 Regen 方法是 Editor 对象的成员。</p>
<p>本节中的主题</p>
<ul>
<li>使用命名对象（.NET）</li>
<li>擦除对象（.NET）</li>
<li>复制对象（.NET）</li>
<li>偏移对象（.NET）</li>
<li>转换对象（.NET）</li>
<li>阵列对象（.NET）</li>
<li>延伸和修剪对象（.NET）</li>
<li>分解对象（.NET）</li>
<li>编辑多段线（.NET）</li>
<li>编辑样条曲线（.NET）</li>
<li>编辑图案填充（.NET）</li>
</ul>
<h3 id="使用命名对象（-NET）"><a href="#使用命名对象（-NET）" class="headerlink" title="使用命名对象（.NET）"></a>使用命名对象（.NET）</h3><p>除了AutoCAD使用的图形对象外，图形数据库中还存储有多种类型的非图形对象。这些对象具有与其相关联的描述性名称。例如，块、图层、编组和标注样式都指定了名称，并且在大多数情况下都可以重命名。符号表记录的名称显示在AutoCAD的用户界面中，而对象的对象ID在大多数情况下用于在整个AutoCAD .NET API中引用该对象。</p>
<p>例如，将 LayerTableRecord 对象的对象ID指定给图形对象的“层”属性，而不是指定给 LayerTableRecord 的实际名称。但是，可以使用要访问的层的名称从层表中获取 LayerTableRecord 对象的对象ID。</p>
<p>本节中的主题</p>
<ul>
<li>清除未引用的命名对象（.NET）</li>
<li>重命名对象（.NET）</li>
</ul>
<h4 id="清除未引用的命名对象（-NET）"><a href="#清除未引用的命名对象（-NET）" class="headerlink" title="清除未引用的命名对象（.NET）"></a>清除未引用的命名对象（.NET）</h4><p>可以随时从数据库中清除未引用的命名对象。不能清除被其他对象引用的命名对象。例如，字体文件可能被文本样式引用，图层可能被该图层上的对象引用。清除可减小图形文件保存到磁盘时的大小。</p>
<p>使用 Purge 方法从图形数据库中清除未参照的对象。 Purge 方法需要一个要以 ObjectIdCollection 或 ObjectIdGraph 对象形式清除的对象列表。传递到 Purge 方法中的 ObjectIdCollection 或 ObjectIdGraph 对象将使用可以从数据库中删除的对象进行更新。在调用 Purge 之后，必须擦除返回的每个对象。</p>
<p><strong>移除所有未引用的图层</strong></p>
<p>下面的示例演示如何从数据库中清除所有未引用的图层。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">CommandMethod(<span class="string">&quot;PurgeUnreferencedLayers&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PurgeUnreferencedLayers</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Get the current document and database</span></span><br><span class="line">    Document acDoc = Application.DocumentManager.MdiActiveDocument;</span><br><span class="line">    Database acCurDb = acDoc.Database;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start a transaction</span></span><br><span class="line">    <span class="keyword">using</span> (Transaction acTrans = acCurDb.TransactionManager.StartTransaction())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Open the Layer table for read</span></span><br><span class="line">        LayerTable acLyrTbl;</span><br><span class="line">        acLyrTbl = acTrans.GetObject(acCurDb.LayerTableId,</span><br><span class="line">                                        OpenMode.ForRead) <span class="keyword">as</span> LayerTable;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create an ObjectIdCollection to hold the object ids for each table record</span></span><br><span class="line">        ObjectIdCollection acObjIdColl = <span class="keyword">new</span> ObjectIdCollection();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Step through each layer and add iterator to the ObjectIdCollection</span></span><br><span class="line">        <span class="keyword">foreach</span> (ObjectId acObjId <span class="keyword">in</span> acLyrTbl)</span><br><span class="line">        &#123;</span><br><span class="line">            acObjIdColl.Add(acObjId);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Remove the layers that are in use and return the ones that can be erased</span></span><br><span class="line">        acCurDb.Purge(acObjIdColl);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Step through the returned ObjectIdCollection</span></span><br><span class="line">        <span class="comment">// and erase each unreferenced layer</span></span><br><span class="line">        <span class="keyword">foreach</span> (ObjectId acObjId <span class="keyword">in</span> acObjIdColl)</span><br><span class="line">        &#123;</span><br><span class="line">            SymbolTableRecord acSymTblRec;</span><br><span class="line">            acSymTblRec = acTrans.GetObject(acObjId,</span><br><span class="line">                                            OpenMode.ForWrite) <span class="keyword">as</span> SymbolTableRecord;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// Erase the unreferenced layer</span></span><br><span class="line">                acSymTblRec.Erase(<span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Autodesk.AutoCAD.Runtime.Exception Ex)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// Layer could not be deleted</span></span><br><span class="line">                Application.ShowAlertDialog(<span class="string">&quot;Error:\n&quot;</span> + Ex.Message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Commit the changes and dispose of the transaction</span></span><br><span class="line">        acTrans.Commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>VBA&#x2F;ActiveX交叉引用</strong></p>
<p>在ActiveX Automation库中，您可以使用 PurgeAll 方法删除所有未引用的命名对象，它将标识可以删除的对象。但是，对于AutoCAD .NET API，您需要提供要清除的对象，然后 Purge 方法将返回实际可以清除的对象。因此，在使用AutoCAD .NET API从数据库中清除所有未引用的命名对象时，需要做更多的工作。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ThisDrawing.PurgeAll</span><br></pre></td></tr></table></figure>

<h4 id="重命名对象（-NET）"><a href="#重命名对象（-NET）" class="headerlink" title="重命名对象（.NET）"></a>重命名对象（.NET）</h4><p>随着图形变得越来越复杂，可以重命名对象以使名称保持有意义或避免与已插入或附着的其他图形中的名称冲突。Name属性用于获取当前名称或更改命名对象的名称。</p>
<p>可以重命名任何命名对象，但AutoCAD保留的命名对象（例如图层0或CONTINUOUS线型）除外。</p>
<p>名称最长可达255个字符。除了字母和数字之外，名称还可以包含空格（尽管AutoCAD会删除直接出现在名称前后的空格）以及Microsoft® Windows®或AutoCAD未用于其他目的的任何特殊字符。不能使用的特殊字符包括小于号和大于号（&lt;&gt;）、正斜线和反斜线（&#x2F; \）、引号（“）、冒号（：）、分号（;）、问号（？）、逗号（，）、空格（*）、竖线（|）、等号（&#x3D;）和单引号（’）。也不能使用Unicode字体创建的特殊字符。</p>
<p><strong>重命名图层</strong></p>
<p>此示例创建图层“0”的副本，并将新图层重命名为“MyLayer”。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">CommandMethod(<span class="string">&quot;RenameLayer&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">RenameLayer</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Get the current document and database</span></span><br><span class="line">    Document acDoc = Application.DocumentManager.MdiActiveDocument;</span><br><span class="line">    Database acCurDb = acDoc.Database;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start a transaction</span></span><br><span class="line">    <span class="keyword">using</span> (Transaction acTrans = acCurDb.TransactionManager.StartTransaction())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Returns the layer table for the current database</span></span><br><span class="line">        LayerTable acLyrTbl;</span><br><span class="line">        acLyrTbl = acTrans.GetObject(acCurDb.LayerTableId,</span><br><span class="line">                                        OpenMode.ForWrite) <span class="keyword">as</span> LayerTable;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Clone layer 0 (copy it and its properties) as a new layer</span></span><br><span class="line">        LayerTableRecord acLyrTblRec;</span><br><span class="line">        acLyrTblRec = acTrans.GetObject(acLyrTbl[<span class="string">&quot;0&quot;</span>],</span><br><span class="line">                                        OpenMode.ForRead).Clone() <span class="keyword">as</span> LayerTableRecord;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Change the name of the cloned layer</span></span><br><span class="line">        acLyrTblRec.Name = <span class="string">&quot;MyLayer&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Add the cloned layer to the Layer table and transaction</span></span><br><span class="line">        acLyrTbl.Add(acLyrTblRec);</span><br><span class="line">        acTrans.AddNewlyCreatedDBObject(acLyrTblRec, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Save changes and dispose of the transaction</span></span><br><span class="line">        acTrans.Commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="擦除对象（-NET）"><a href="#擦除对象（-NET）" class="headerlink" title="擦除对象（.NET）"></a>擦除对象（.NET）</h3><p>您可以使用 Erase 方法删除非图形和图形对象。</p>
<p><strong>注意：</strong>虽然许多非图形对象（如层表和模型空间块表记录）都有 Erase 方法，但不应调用该方法。如果在其中一个对象上调用 Erase ，则会发生错误。</p>
<p>创建和擦除一个多段线</p>
<p>此示例创建一个轻量级的多段线，然后将其擦除。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">CommandMethod(<span class="string">&quot;EraseObject&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">EraseObject</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Get the current document and database</span></span><br><span class="line">    Document acDoc = Application.DocumentManager.MdiActiveDocument;</span><br><span class="line">    Database acCurDb = acDoc.Database;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start a transaction</span></span><br><span class="line">    <span class="keyword">using</span> (Transaction acTrans = acCurDb.TransactionManager.StartTransaction())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Open the Block table for read</span></span><br><span class="line">        BlockTable acBlkTbl;</span><br><span class="line">        acBlkTbl = acTrans.GetObject(acCurDb.BlockTableId,</span><br><span class="line">                                        OpenMode.ForRead) <span class="keyword">as</span> BlockTable;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Open the Block table record Model space for write</span></span><br><span class="line">        BlockTableRecord acBlkTblRec;</span><br><span class="line">        acBlkTblRec = acTrans.GetObject(acBlkTbl[BlockTableRecord.ModelSpace],</span><br><span class="line">                                        OpenMode.ForWrite) <span class="keyword">as</span> BlockTableRecord;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create a lightweight polyline</span></span><br><span class="line">        <span class="keyword">using</span> (Polyline acPoly = <span class="keyword">new</span> Polyline())</span><br><span class="line">        &#123;</span><br><span class="line">            acPoly.AddVertexAt(<span class="number">0</span>, <span class="keyword">new</span> Point2d(<span class="number">2</span>, <span class="number">4</span>), <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            acPoly.AddVertexAt(<span class="number">1</span>, <span class="keyword">new</span> Point2d(<span class="number">4</span>, <span class="number">2</span>), <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            acPoly.AddVertexAt(<span class="number">2</span>, <span class="keyword">new</span> Point2d(<span class="number">6</span>, <span class="number">4</span>), <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Add the new object to the block table record and the transaction</span></span><br><span class="line">            acBlkTblRec.AppendEntity(acPoly);</span><br><span class="line">            acTrans.AddNewlyCreatedDBObject(acPoly, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Update the display and display an alert message</span></span><br><span class="line">            acDoc.Editor.Regen();</span><br><span class="line">            Application.ShowAlertDialog(<span class="string">&quot;Erase the newly added polyline.&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Erase the polyline from the drawing</span></span><br><span class="line">            acPoly.Erase(<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Save the new object to the database</span></span><br><span class="line">        acTrans.Commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="复制对象（-NET）"><a href="#复制对象（-NET）" class="headerlink" title="复制对象（.NET）"></a>复制对象（.NET）</h3><p>您可以在数据库中创建大多数非图形对象和图形对象的副本。您可以使用 Clone 函数创建对象的副本。克隆对象后，可以在将返回的对象添加到数据库之前对其进行修改。通过使用 Clone 和 TransformBy 方法，可以模拟AutoCAD中的许多修改命令。</p>
<p>沿着创建对象的直接副本，还可以使用 Clone 和 TransformBy 方法来偏移、镜像和阵列对象。</p>
<p>本节中的主题</p>
<ul>
<li>(.NET)  复制对象（.NET）</li>
<li>在Database之间复制对象（.NET）</li>
</ul>
<h4 id="复制对象（-NET）-1"><a href="#复制对象（-NET）-1" class="headerlink" title="复制对象（.NET）"></a>复制对象（.NET）</h4><p>要复制对象，请使用为该对象提供的 Clone 函数。此方法创建一个新对象，该对象是原始对象的副本。创建重复对象后，可以在将其添加或追加到数据库之前对其进行修改。如果不变换对象或更改其位置，则新对象将位于与原始对象相同的位置。</p>
<p>如果您可能想要复制大量对象，则可以将每个对象ID添加到 ObjectIdCollection 对象，然后重新配置每个对象。当您重新定义每个对象时，您可以对每个对象使用 Clone 函数，然后将新对象添加或追加到数据库中。</p>
<p> <strong>复制单个对象</strong></p>
<p>下面的示例创建一个新圆，然后创建该圆的直接副本以创建第二个圆。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">CommandMethod(<span class="string">&quot;SingleCopy&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SingleCopy</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Get the current document and database</span></span><br><span class="line">    Document acDoc = Application.DocumentManager.MdiActiveDocument;</span><br><span class="line">    Database acCurDb = acDoc.Database;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start a transaction</span></span><br><span class="line">    <span class="keyword">using</span> (Transaction acTrans = acCurDb.TransactionManager.StartTransaction())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Open the Block table for read</span></span><br><span class="line">        BlockTable acBlkTbl;</span><br><span class="line">        acBlkTbl = acTrans.GetObject(acCurDb.BlockTableId,</span><br><span class="line">                                        OpenMode.ForRead) <span class="keyword">as</span> BlockTable;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Open the Block table record Model space for write</span></span><br><span class="line">        BlockTableRecord acBlkTblRec;</span><br><span class="line">        acBlkTblRec = acTrans.GetObject(acBlkTbl[BlockTableRecord.ModelSpace],</span><br><span class="line">                                        OpenMode.ForWrite) <span class="keyword">as</span> BlockTableRecord;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create a circle that is at 2,3 with a radius of 4.25</span></span><br><span class="line">        <span class="keyword">using</span> (Circle acCirc = <span class="keyword">new</span> Circle())</span><br><span class="line">        &#123;</span><br><span class="line">            acCirc.Center = <span class="keyword">new</span> Point3d(<span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span>);</span><br><span class="line">            acCirc.Radius = <span class="number">4.25</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Add the new object to the block table record and the transaction</span></span><br><span class="line">            acBlkTblRec.AppendEntity(acCirc);</span><br><span class="line">            acTrans.AddNewlyCreatedDBObject(acCirc, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Create a copy of the circle and change its radius</span></span><br><span class="line">            Circle acCircClone = acCirc.Clone() <span class="keyword">as</span> Circle;</span><br><span class="line">            acCircClone.Radius = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Add the cloned circle</span></span><br><span class="line">            acBlkTblRec.AppendEntity(acCircClone);</span><br><span class="line">            acTrans.AddNewlyCreatedDBObject(acCircClone, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Save the new object to the database</span></span><br><span class="line">        acTrans.Commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复制多个对象</strong></p>
<p>下面的示例使用 ObjectIdCollection 对象来跟踪应复制的对象。一旦对象id被添加到集合中，集合将被迭代，新对象将使用 Clone 方法创建，然后添加到模型空间。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">CommandMethod(<span class="string">&quot;MultipleCopy&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MultipleCopy</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Get the current document and database</span></span><br><span class="line">    Document acDoc = Application.DocumentManager.MdiActiveDocument;</span><br><span class="line">    Database acCurDb = acDoc.Database;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start a transaction</span></span><br><span class="line">    <span class="keyword">using</span> (Transaction acTrans = acCurDb.TransactionManager.StartTransaction())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Open the Block table for read</span></span><br><span class="line">        BlockTable acBlkTbl;</span><br><span class="line">        acBlkTbl = acTrans.GetObject(acCurDb.BlockTableId,</span><br><span class="line">                                        OpenMode.ForRead) <span class="keyword">as</span> BlockTable;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Open the Block table record Model space for write</span></span><br><span class="line">        BlockTableRecord acBlkTblRec;</span><br><span class="line">        acBlkTblRec = acTrans.GetObject(acBlkTbl[BlockTableRecord.ModelSpace],</span><br><span class="line">                                        OpenMode.ForWrite) <span class="keyword">as</span> BlockTableRecord;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create a circle that is at (0,0,0) with a radius of 5</span></span><br><span class="line">        <span class="keyword">using</span> (Circle acCirc1 = <span class="keyword">new</span> Circle())</span><br><span class="line">        &#123;</span><br><span class="line">            acCirc1.Center = <span class="keyword">new</span> Point3d(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            acCirc1.Radius = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Add the new object to the block table record and the transaction</span></span><br><span class="line">            acBlkTblRec.AppendEntity(acCirc1);</span><br><span class="line">            acTrans.AddNewlyCreatedDBObject(acCirc1, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Create a circle that is at (0,0,0) with a radius of 7</span></span><br><span class="line">            <span class="keyword">using</span> (Circle acCirc2 = <span class="keyword">new</span> Circle())</span><br><span class="line">            &#123;</span><br><span class="line">                acCirc2.Center = <span class="keyword">new</span> Point3d(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">                acCirc2.Radius = <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Add the new object to the block table record and the transaction</span></span><br><span class="line">                acBlkTblRec.AppendEntity(acCirc2);</span><br><span class="line">                acTrans.AddNewlyCreatedDBObject(acCirc2, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Add all the objects to clone</span></span><br><span class="line">                DBObjectCollection acDBObjColl = <span class="keyword">new</span> DBObjectCollection();</span><br><span class="line">                acDBObjColl.Add(acCirc1);</span><br><span class="line">                acDBObjColl.Add(acCirc2);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">foreach</span> (Entity acEnt <span class="keyword">in</span> acDBObjColl)</span><br><span class="line">                &#123;</span><br><span class="line">                    Entity acEntClone;</span><br><span class="line">                    acEntClone = acEnt.Clone() <span class="keyword">as</span> Entity;</span><br><span class="line">                    acEntClone.ColorIndex = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// Create a matrix and move each copied entity 15 units</span></span><br><span class="line">                    acEntClone.TransformBy(Matrix3d.Displacement(<span class="keyword">new</span> Vector3d(<span class="number">15</span>, <span class="number">0</span>, <span class="number">0</span>)));</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// Add the cloned object</span></span><br><span class="line">                    acBlkTblRec.AppendEntity(acEntClone);</span><br><span class="line">                    acTrans.AddNewlyCreatedDBObject(acEntClone, <span class="literal">true</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Save the new object to the database</span></span><br><span class="line">        acTrans.Commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="在Database之间复制对象（-NET）"><a href="#在Database之间复制对象（-NET）" class="headerlink" title="在Database之间复制对象（.NET）"></a>在Database之间复制对象（.NET）</h4><p>可以在两个数据库之间复制对象。 Clone 函数用于复制同一数据库中的对象，而 WblockCloneObjects 方法用于将对象从一个数据库复制到另一个数据库。 WblockCloneObjects 方法是 Database 对象的成员。 WblockCloneObjects 方法需要以下参数：</p>
<ul>
<li><strong>ObjectIdCollection</strong>-要克隆的对象的列表。</li>
<li><strong>ObjectId</strong>-正在克隆的对象的新父对象的ObjectId。</li>
<li><strong>IdMapping</strong>-正在克隆的对象的当前和新ObjectId的数据结构。</li>
<li><strong>DuplicateRecordCloning</strong>-确定应如何处理重复对象。</li>
<li><strong>Defer Translation</strong> - 控制是否应转换对象ID。</li>
</ul>
<p><strong>将对象从一个数据库复制到另一个数据库</strong></p>
<p>此示例创建两个Circle对象，然后使用 WblockCloneObjects 方法将圆复制到新图形中。该示例还在复制圆之前使用<em>acad.dwt</em>文件创建新图形。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">CommandMethod(<span class="string">&quot;CopyObjectsBetweenDatabases&quot;</span>, CommandFlags.Session)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CopyObjectsBetweenDatabases</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    ObjectIdCollection acObjIdColl = <span class="keyword">new</span> ObjectIdCollection();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get the current document and database</span></span><br><span class="line">    Document acDoc = Application.DocumentManager.MdiActiveDocument;</span><br><span class="line">    Database acCurDb = acDoc.Database;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Lock the current document</span></span><br><span class="line">    <span class="keyword">using</span> (DocumentLock acLckDocCur = acDoc.LockDocument())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Start a transaction</span></span><br><span class="line">        <span class="keyword">using</span> (Transaction acTrans = acCurDb.TransactionManager.StartTransaction())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Open the Block table record for read</span></span><br><span class="line">            BlockTable acBlkTbl;</span><br><span class="line">            acBlkTbl = acTrans.GetObject(acCurDb.BlockTableId,</span><br><span class="line">                                            OpenMode.ForRead) <span class="keyword">as</span> BlockTable;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Open the Block table record Model space for write</span></span><br><span class="line">            BlockTableRecord acBlkTblRec;</span><br><span class="line">            acBlkTblRec = acTrans.GetObject(acBlkTbl[BlockTableRecord.ModelSpace],</span><br><span class="line">                                            OpenMode.ForWrite) <span class="keyword">as</span> BlockTableRecord;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Create a circle that is at (0,0,0) with a radius of 5</span></span><br><span class="line">            <span class="keyword">using</span> (Circle acCirc1 = <span class="keyword">new</span> Circle())</span><br><span class="line">            &#123;</span><br><span class="line">                acCirc1.Center = <span class="keyword">new</span> Point3d(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">                acCirc1.Radius = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Add the new object to the block table record and the transaction</span></span><br><span class="line">                acBlkTblRec.AppendEntity(acCirc1);</span><br><span class="line">                acTrans.AddNewlyCreatedDBObject(acCirc1, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Create a circle that is at (0,0,0) with a radius of 7</span></span><br><span class="line">                <span class="keyword">using</span> (Circle acCirc2 = <span class="keyword">new</span> Circle())</span><br><span class="line">                &#123;</span><br><span class="line">                    acCirc2.Center = <span class="keyword">new</span> Point3d(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">                    acCirc2.Radius = <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// Add the new object to the block table record and the transaction</span></span><br><span class="line">                    acBlkTblRec.AppendEntity(acCirc2);</span><br><span class="line">                    acTrans.AddNewlyCreatedDBObject(acCirc2, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// Add all the objects to copy to the new document</span></span><br><span class="line">                    acObjIdColl = <span class="keyword">new</span> ObjectIdCollection();</span><br><span class="line">                    acObjIdColl.Add(acCirc1.ObjectId);</span><br><span class="line">                    acObjIdColl.Add(acCirc2.ObjectId);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Save the new objects to the database</span></span><br><span class="line">            acTrans.Commit();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Unlock the document</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Change the file and path to match a drawing template on your workstation</span></span><br><span class="line">    <span class="built_in">string</span> sLocalRoot = Application.GetSystemVariable(<span class="string">&quot;LOCALROOTPREFIX&quot;</span>) <span class="keyword">as</span> <span class="built_in">string</span>;</span><br><span class="line">    <span class="built_in">string</span> sTemplatePath = sLocalRoot + <span class="string">&quot;Template\\acad.dwt&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create a new drawing to copy the objects to</span></span><br><span class="line">    DocumentCollection acDocMgr = Application.DocumentManager;</span><br><span class="line">    Document acNewDoc = acDocMgr.Add(sTemplatePath);</span><br><span class="line">    Database acDbNewDoc = acNewDoc.Database;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Lock the new document</span></span><br><span class="line">    <span class="keyword">using</span> (DocumentLock acLckDoc = acNewDoc.LockDocument())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Start a transaction in the new database</span></span><br><span class="line">        <span class="keyword">using</span> (Transaction acTrans = acDbNewDoc.TransactionManager.StartTransaction())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Open the Block table for read</span></span><br><span class="line">            BlockTable acBlkTblNewDoc;</span><br><span class="line">            acBlkTblNewDoc = acTrans.GetObject(acDbNewDoc.BlockTableId,</span><br><span class="line">                                                OpenMode.ForRead) <span class="keyword">as</span> BlockTable;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Open the Block table record Model space for read</span></span><br><span class="line">            BlockTableRecord acBlkTblRecNewDoc;</span><br><span class="line">            acBlkTblRecNewDoc = acTrans.GetObject(acBlkTblNewDoc[BlockTableRecord.ModelSpace],</span><br><span class="line">                                                    OpenMode.ForRead) <span class="keyword">as</span> BlockTableRecord;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Clone the objects to the new database</span></span><br><span class="line">            IdMapping acIdMap = <span class="keyword">new</span> IdMapping();</span><br><span class="line">            acCurDb.WblockCloneObjects(acObjIdColl, acBlkTblRecNewDoc.ObjectId, acIdMap,</span><br><span class="line">                                        DuplicateRecordCloning.Ignore, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Save the copied objects to the database</span></span><br><span class="line">            acTrans.Commit();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Unlock the document</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set the new document current</span></span><br><span class="line">    acDocMgr.MdiActiveDocument = acNewDoc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="偏移对象（-NET）"><a href="#偏移对象（-NET）" class="headerlink" title="偏移对象（.NET）"></a>偏移对象（.NET）</h3><p>偏移对象将在距原始对象指定的偏移距离处创建新对象。可以偏移圆弧、圆、椭圆、直线、轻型多段线、多段线、样条曲线和构造线。</p>
<p>要偏移对象，请使用为该对象提供的 GetOffsetCurves 方法。该函数需要一个正或负的距离数值来偏移对象。如果距离为负，AutoCAD会将其解释为偏移，以生成“较小”曲线（即，对于圆弧，它将偏移到小于起始曲线半径的给定距离的半径）。如果“较小”没有意义，则AutoCAD将在较小<em>的X、Y、Z</em>WCS坐标方向上偏移。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2024/ENU/OARX-DevGuide-Managed/images/GUID-D3C3CBB3-B570-4E8A-8D5A-A78D38BC60E3.png"></p>
<p>对于许多对象，此操作的结果将是一条新曲线（可能与原始曲线的类型不同）。例如，偏移椭圆将生成样条曲线，因为结果确实符合椭圆的方程。在某些情况下，可能需要偏移结果为多条曲线。因此，该函数返回一个 DBObjectCollection 对象，其中包含通过偏移曲线创建的所有对象。返回的 DBObjectCollection 对象需要为创建的每个对象迭代，然后附加到图形数据库。</p>
<p>偏移一条多段线</p>
<p>此示例创建一条多段线图元，然后将其偏移。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">CommandMethod(<span class="string">&quot;OffsetObject&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">OffsetObject</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Get the current document and database</span></span><br><span class="line">    Document acDoc = Application.DocumentManager.MdiActiveDocument;</span><br><span class="line">    Database acCurDb = acDoc.Database;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start a transaction</span></span><br><span class="line">    <span class="keyword">using</span> (Transaction acTrans = acCurDb.TransactionManager.StartTransaction())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Open the Block table for read</span></span><br><span class="line">        BlockTable acBlkTbl;</span><br><span class="line">        acBlkTbl = acTrans.GetObject(acCurDb.BlockTableId,</span><br><span class="line">                                        OpenMode.ForRead) <span class="keyword">as</span> BlockTable;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Open the Block table record Model space for write</span></span><br><span class="line">        BlockTableRecord acBlkTblRec;</span><br><span class="line">        acBlkTblRec = acTrans.GetObject(acBlkTbl[BlockTableRecord.ModelSpace],</span><br><span class="line">                                        OpenMode.ForWrite) <span class="keyword">as</span> BlockTableRecord;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create a lightweight polyline</span></span><br><span class="line">        <span class="keyword">using</span> (Polyline acPoly = <span class="keyword">new</span> Polyline())</span><br><span class="line">        &#123;</span><br><span class="line">            acPoly.AddVertexAt(<span class="number">0</span>, <span class="keyword">new</span> Point2d(<span class="number">1</span>, <span class="number">1</span>), <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            acPoly.AddVertexAt(<span class="number">1</span>, <span class="keyword">new</span> Point2d(<span class="number">1</span>, <span class="number">2</span>), <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            acPoly.AddVertexAt(<span class="number">2</span>, <span class="keyword">new</span> Point2d(<span class="number">2</span>, <span class="number">2</span>), <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            acPoly.AddVertexAt(<span class="number">3</span>, <span class="keyword">new</span> Point2d(<span class="number">3</span>, <span class="number">2</span>), <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            acPoly.AddVertexAt(<span class="number">4</span>, <span class="keyword">new</span> Point2d(<span class="number">4</span>, <span class="number">4</span>), <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            acPoly.AddVertexAt(<span class="number">5</span>, <span class="keyword">new</span> Point2d(<span class="number">4</span>, <span class="number">1</span>), <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Add the new object to the block table record and the transaction</span></span><br><span class="line">            acBlkTblRec.AppendEntity(acPoly);</span><br><span class="line">            acTrans.AddNewlyCreatedDBObject(acPoly, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Offset the polyline a given distance</span></span><br><span class="line">            DBObjectCollection acDbObjColl = acPoly.GetOffsetCurves(<span class="number">0.25</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Step through the new objects created</span></span><br><span class="line">            <span class="keyword">foreach</span> (Entity acEnt <span class="keyword">in</span> acDbObjColl)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// Add each offset object</span></span><br><span class="line">                acBlkTblRec.AppendEntity(acEnt);</span><br><span class="line">                acTrans.AddNewlyCreatedDBObject(acEnt, <span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Save the new objects to the database</span></span><br><span class="line">        acTrans.Commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="转换对象（-NET）"><a href="#转换对象（-NET）" class="headerlink" title="转换对象（.NET）"></a>转换对象（.NET）</h3><p>您可以使用由 Matrix3d 对象和 TransformBy 方法表示的4 x 4变换矩阵来移动、缩放、旋转和镜像对象。您还可以使用 GetTransformedCopy 方法创建实体的副本，然后将转换应用于副本。 Matrix3d 对象是 Geometry 命名空间的一部分。</p>
<p>矩阵的前三列指定缩放和旋转。矩阵的第四列是平移向量。下表演示了变换矩阵配置，其中R &#x3D;旋转，T &#x3D;平移：</p>
<p>变换矩阵配置</p>
<table>
<thead>
<tr>
<th>R00</th>
<th>R01</th>
<th>R02</th>
<th>T0</th>
</tr>
</thead>
<tbody><tr>
<td>R10</td>
<td>R11</td>
<td>R12</td>
<td>T1</td>
</tr>
<tr>
<td>R20</td>
<td>R21</td>
<td>R22</td>
<td>T2</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
</tbody></table>
<p>要转换一个对象，首先初始化一个 Matrix3d 对象。可以使用双精度数数组初始化变换矩阵，也可以从表示世界坐标系或用户坐标系的矩阵开始。初始化后，您可以使用 Matrix3d 对象的函数来修改矩阵的缩放、旋转或位移变换。</p>
<p>完成变换矩阵后，使用 TransformBy 方法将矩阵应用于对象。下面的代码行演示了将矩阵（ dMatrix ）应用于对象（ acObj ）：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">acObj.TransformBy(dMatrix);</span><br></pre></td></tr></table></figure>

<p><strong>旋转矩阵的示例</strong></p>
<p>下面显示了一个用于定义变换矩阵的数据数组，该数组被分配给变量 dMatrix ，该变量将使图元绕点（0，0，0）旋转90度。</p>
<p><strong>旋转矩阵：绕点（0，0，0）90度</strong></p>
<table>
<thead>
<tr>
<th>0.0</th>
<th>-1.0</th>
<th>0.0</th>
<th>0.0</th>
</tr>
</thead>
<tbody><tr>
<td>1.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
</tr>
<tr>
<td>0.0</td>
<td>0.0</td>
<td>1.0</td>
<td>0.0</td>
</tr>
<tr>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>1.0</td>
</tr>
</tbody></table>
<p><strong>C#</strong></p>
<p>使用数据数组初始化变换矩阵，其中包含将对象旋转90度的信息。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">double</span>[] dMatrix = <span class="keyword">new</span> <span class="built_in">double</span>[<span class="number">16</span>];</span><br><span class="line"> </span><br><span class="line">dMatrix[<span class="number">0</span>] = <span class="number">0.0</span>;</span><br><span class="line">dMatrix[<span class="number">1</span>] = <span class="number">-1.0</span>;</span><br><span class="line">dMatrix[<span class="number">2</span>] = <span class="number">0.0</span>;</span><br><span class="line">dMatrix[<span class="number">3</span>] = <span class="number">0.0</span>;</span><br><span class="line">dMatrix[<span class="number">4</span>] = <span class="number">1.0</span>;</span><br><span class="line">dMatrix[<span class="number">5</span>] = <span class="number">0.0</span>;</span><br><span class="line">dMatrix[<span class="number">6</span>] = <span class="number">0.0</span>;</span><br><span class="line">dMatrix[<span class="number">7</span>] = <span class="number">0.0</span>;</span><br><span class="line">dMatrix[<span class="number">8</span>] = <span class="number">0.0</span>;</span><br><span class="line">dMatrix[<span class="number">9</span>] = <span class="number">0.0</span>;</span><br><span class="line">dMatrix[<span class="number">10</span>] = <span class="number">1.0</span>;</span><br><span class="line">dMatrix[<span class="number">11</span>] = <span class="number">0.0</span>;</span><br><span class="line">dMatrix[<span class="number">12</span>] = <span class="number">0.0</span>;</span><br><span class="line">dMatrix[<span class="number">13</span>] = <span class="number">0.0</span>;</span><br><span class="line">dMatrix[<span class="number">14</span>] = <span class="number">0.0</span>;</span><br><span class="line">dMatrix[<span class="number">15</span>] = <span class="number">1.0</span>;</span><br><span class="line"> </span><br><span class="line">Matrix3d acMat3d = <span class="keyword">new</span> Matrix3d(dMatrix);</span><br></pre></td></tr></table></figure>

<p>初始化一个没有数据数组的变换矩阵，并使用 Rotation 函数返回一个将对象旋转90度的变换矩阵。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Matrix3d acMat3d = <span class="keyword">new</span> Matrix3d();</span><br><span class="line"> </span><br><span class="line">acMat3d = Matrix3d.Rotation(Math.PI / <span class="number">2</span>,</span><br><span class="line">                            curUCS.Zaxis,</span><br><span class="line">                            <span class="keyword">new</span> Point3d(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br></pre></td></tr></table></figure>

<p><strong>变换矩阵的其他示例</strong></p>
<p>以下是转换矩阵的更多示例：</p>
<p><strong>旋转矩阵：关于点（5，5，0）的45度</strong></p>
<table>
<thead>
<tr>
<th>0.707107</th>
<th>-0.707107</th>
<th>0.0</th>
<th>5.0</th>
</tr>
</thead>
<tbody><tr>
<td>0.707107</td>
<td>0.707107</td>
<td>0.0</td>
<td>-2.071068</td>
</tr>
<tr>
<td>0.0</td>
<td>0.0</td>
<td>1.0</td>
<td>0.0</td>
</tr>
<tr>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>1.0</td>
</tr>
</tbody></table>
<p><strong>平移矩阵：将实体移动（10，10，0）</strong></p>
<table>
<thead>
<tr>
<th>1.0</th>
<th>0.0</th>
<th>0.0</th>
<th>10.0</th>
</tr>
</thead>
<tbody><tr>
<td>0.0</td>
<td>1.0</td>
<td>0.0</td>
<td>10.0</td>
</tr>
<tr>
<td>0.0</td>
<td>0.0</td>
<td>1.0</td>
<td>0.0</td>
</tr>
<tr>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>1.0</td>
</tr>
</tbody></table>
<p><strong>缩放矩阵：在点（0，0，0）处缩放10，10</strong></p>
<table>
<thead>
<tr>
<th>10.0</th>
<th>0.0</th>
<th>0.0</th>
<th>0.0</th>
</tr>
</thead>
<tbody><tr>
<td>0.0</td>
<td>10.0</td>
<td>0.0</td>
<td>0.0</td>
</tr>
<tr>
<td>0.0</td>
<td>0.0</td>
<td>10.0</td>
<td>0.0</td>
</tr>
<tr>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>1.0</td>
</tr>
</tbody></table>
<p><strong>缩放矩阵：在点（2，2，0）处缩放10，10</strong></p>
<table>
<thead>
<tr>
<th>10.0</th>
<th>0.0</th>
<th>0.0</th>
<th>-18.0</th>
</tr>
</thead>
<tbody><tr>
<td>0.0</td>
<td>10.0</td>
<td>0.0</td>
<td>-18.0</td>
</tr>
<tr>
<td>0.0</td>
<td>0.0</td>
<td>10.0</td>
<td>0.0</td>
</tr>
<tr>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>1.0</td>
</tr>
</tbody></table>
<p> 本节中的主题</p>
<ul>
<li>移动对象（.NET）</li>
<li>旋转对象（.NET）</li>
<li>镜像对象（.NET）</li>
<li>缩放对象（.NET）</li>
</ul>
<h4 id="移动对象（-NET）"><a href="#移动对象（-NET）" class="headerlink" title="移动对象（.NET）"></a>移动对象（.NET）</h4><p>可以沿指定矢量沿着移动所有图形对象和属性参照对象。</p>
<p>要移动对象，请使用变换矩阵的 Displacement 功能。这个函数需要一个 Vector3d 对象作为输入。如果你不知道你需要的向量，你可以创建一个 Point3d 对象，然后使用 GetVectorTo 方法返回两点之间的向量。位移向量指示给定对象要移动多远以及向哪个方向移动。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2024/ENU/OARX-DevGuide-Managed/images/GUID-6F6FB891-54BC-4A4D-9415-19D9BA63D1F9.png" alt="img"></p>
<p><strong>沿着向量移动圆</strong></p>
<p>本示例创建一个圆，然后将该圆沿X轴沿着移动两个单位。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">CommandMethod(<span class="string">&quot;MoveObject&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MoveObject</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Get the current document and database</span></span><br><span class="line">    Document acDoc = Application.DocumentManager.MdiActiveDocument;</span><br><span class="line">    Database acCurDb = acDoc.Database;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start a transaction</span></span><br><span class="line">    <span class="keyword">using</span> (Transaction acTrans = acCurDb.TransactionManager.StartTransaction())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Open the Block table for read</span></span><br><span class="line">        BlockTable acBlkTbl;</span><br><span class="line">        acBlkTbl = acTrans.GetObject(acCurDb.BlockTableId,</span><br><span class="line">                                        OpenMode.ForRead) <span class="keyword">as</span> BlockTable;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Open the Block table record Model space for write</span></span><br><span class="line">        BlockTableRecord acBlkTblRec;</span><br><span class="line">        acBlkTblRec = acTrans.GetObject(acBlkTbl[BlockTableRecord.ModelSpace],</span><br><span class="line">                                        OpenMode.ForWrite) <span class="keyword">as</span> BlockTableRecord;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create a circle that is at 2,2 with a radius of 0.5</span></span><br><span class="line">        <span class="keyword">using</span> (Circle acCirc = <span class="keyword">new</span> Circle())</span><br><span class="line">        &#123;</span><br><span class="line">            acCirc.Center = <span class="keyword">new</span> Point3d(<span class="number">2</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">            acCirc.Radius = <span class="number">0.5</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Create a matrix and move the circle using a vector from (0,0,0) to (2,0,0)</span></span><br><span class="line">            Point3d acPt3d = <span class="keyword">new</span> Point3d(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            Vector3d acVec3d = acPt3d.GetVectorTo(<span class="keyword">new</span> Point3d(<span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">            acCirc.TransformBy(Matrix3d.Displacement(acVec3d));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Add the new object to the block table record and the transaction</span></span><br><span class="line">            acBlkTblRec.AppendEntity(acCirc);</span><br><span class="line">            acTrans.AddNewlyCreatedDBObject(acCirc, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Save the new objects to the database</span></span><br><span class="line">        acTrans.Commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="旋转对象（-NET）"><a href="#旋转对象（-NET）" class="headerlink" title="旋转对象（.NET）"></a>旋转对象（.NET）</h4><p>可以旋转所有图形对象和属性参照对象。</p>
<p>要旋转对象，请使用变换矩阵的 Rotation 功能。此函数需要一个以弧度表示的旋转角度、一个旋转轴和一个基点。旋转轴必须表示为 Vector3d 对象，基点必须表示为 Point3d 对象。此角度确定对象相对于其当前位置绕基点旋转的距离。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2024/ENU/OARX-DevGuide-Managed/images/GUID-D174E9D2-D3F8-4BD8-95ED-67C0D34C9F74.png" alt="img"></p>
<p><strong>围绕基点旋转多段线</strong></p>
<p>此示例创建一个闭合的多段线，然后将对象围绕基点（4，4.25，0）旋转45度。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">CommandMethod(<span class="string">&quot;RotateObject&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">RotateObject</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Get the current document and database</span></span><br><span class="line">    Document acDoc = Application.DocumentManager.MdiActiveDocument;</span><br><span class="line">    Database acCurDb = acDoc.Database;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start a transaction</span></span><br><span class="line">    <span class="keyword">using</span> (Transaction acTrans = acCurDb.TransactionManager.StartTransaction())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Open the Block table for read</span></span><br><span class="line">        BlockTable acBlkTbl;</span><br><span class="line">        acBlkTbl = acTrans.GetObject(acCurDb.BlockTableId,</span><br><span class="line">                                     OpenMode.ForRead) <span class="keyword">as</span> BlockTable;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Open the Block table record Model space for write</span></span><br><span class="line">        BlockTableRecord acBlkTblRec;</span><br><span class="line">        acBlkTblRec = acTrans.GetObject(acBlkTbl[BlockTableRecord.ModelSpace],</span><br><span class="line">                                        OpenMode.ForWrite) <span class="keyword">as</span> BlockTableRecord;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create a lightweight polyline</span></span><br><span class="line">        <span class="keyword">using</span> (Polyline acPoly = <span class="keyword">new</span> Polyline())</span><br><span class="line">        &#123;</span><br><span class="line">            acPoly.AddVertexAt(<span class="number">0</span>, <span class="keyword">new</span> Point2d(<span class="number">1</span>, <span class="number">2</span>), <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            acPoly.AddVertexAt(<span class="number">1</span>, <span class="keyword">new</span> Point2d(<span class="number">1</span>, <span class="number">3</span>), <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            acPoly.AddVertexAt(<span class="number">2</span>, <span class="keyword">new</span> Point2d(<span class="number">2</span>, <span class="number">3</span>), <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            acPoly.AddVertexAt(<span class="number">3</span>, <span class="keyword">new</span> Point2d(<span class="number">3</span>, <span class="number">3</span>), <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            acPoly.AddVertexAt(<span class="number">4</span>, <span class="keyword">new</span> Point2d(<span class="number">4</span>, <span class="number">4</span>), <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            acPoly.AddVertexAt(<span class="number">5</span>, <span class="keyword">new</span> Point2d(<span class="number">4</span>, <span class="number">2</span>), <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Close the polyline</span></span><br><span class="line">            acPoly.Closed = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            Matrix3d curUCSMatrix = acDoc.Editor.CurrentUserCoordinateSystem;</span><br><span class="line">            CoordinateSystem3d curUCS = curUCSMatrix.CoordinateSystem3d;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Rotate the polyline 45 degrees, around the Z-axis of the current UCS</span></span><br><span class="line">            <span class="comment">// using a base point of (4,4.25,0)</span></span><br><span class="line">            acPoly.TransformBy(Matrix3d.Rotation(<span class="number">0.7854</span>,</span><br><span class="line">                                                 curUCS.Zaxis,</span><br><span class="line">                                                 <span class="keyword">new</span> Point3d(<span class="number">4</span>, <span class="number">4.25</span>, <span class="number">0</span>)));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Add the new object to the block table record and the transaction</span></span><br><span class="line">            acBlkTblRec.AppendEntity(acPoly);</span><br><span class="line">            acTrans.AddNewlyCreatedDBObject(acPoly, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Save the new objects to the database</span></span><br><span class="line">        acTrans.Commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="镜像对象（-NET）"><a href="#镜像对象（-NET）" class="headerlink" title="镜像对象（.NET）"></a>镜像对象（.NET）</h4><p>镜像沿轴或镜像线沿着翻转对象。可以镜像所有图形对象。</p>
<p>要镜像对象，请使用变换矩阵的 Mirroring 功能。此函数需要一个 Point3d 、 Plane 或 Line3d 对象来定义镜像线。由于镜像是使用变换矩阵完成的，因此不会创建新对象。如果要保留原始对象，则需要先创建对象的副本，然后再对其进行镜像。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2024/ENU/OARX-DevGuide-Managed/images/GUID-8B7BD9BC-4DD7-4EA3-8880-4602EBA551CE.png" alt="img"></p>
<p>若要管理 Text 对象的反射特性，请使用MIRTEXT系统变量。MIRRTEXT的默认设置为On（1），这会导致 Text 对象像任何其他对象一样被镜像。当MIRRTEXT为Off（0）时，不镜像文本。使用 GetSystemVariable 和 SetSystemVariable 方法查询并设置MIRRText设置。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2024/ENU/OARX-DevGuide-Managed/images/GUID-901696EF-1468-4ED0-9913-7A69E62598E6.png" alt="img"></p>
<p>可以在图纸空间中镜像视口对象，尽管这样做对其模型空间视图或模型空间对象没有影响。</p>
<p><strong>绕轴镜像多段线</strong></p>
<p>此示例创建了一个多段线，并围绕一个轴镜像该镜像。新创建的颜色为蓝色。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">CommandMethod(<span class="string">&quot;MirrorObject&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MirrorObject</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Get the current document and database</span></span><br><span class="line">    Document acDoc = Application.DocumentManager.MdiActiveDocument;</span><br><span class="line">    Database acCurDb = acDoc.Database;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start a transaction</span></span><br><span class="line">    <span class="keyword">using</span> (Transaction acTrans = acCurDb.TransactionManager.StartTransaction())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Open the Block table for read</span></span><br><span class="line">        BlockTable acBlkTbl;</span><br><span class="line">        acBlkTbl = acTrans.GetObject(acCurDb.BlockTableId,</span><br><span class="line">                                        OpenMode.ForRead) <span class="keyword">as</span> BlockTable;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Open the Block table record Model space for write</span></span><br><span class="line">        BlockTableRecord acBlkTblRec;</span><br><span class="line">        acBlkTblRec = acTrans.GetObject(acBlkTbl[BlockTableRecord.ModelSpace],</span><br><span class="line">                                        OpenMode.ForWrite) <span class="keyword">as</span> BlockTableRecord;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create a lightweight polyline</span></span><br><span class="line">        <span class="keyword">using</span> (Polyline acPoly = <span class="keyword">new</span> Polyline())</span><br><span class="line">        &#123;</span><br><span class="line">            acPoly.AddVertexAt(<span class="number">0</span>, <span class="keyword">new</span> Point2d(<span class="number">1</span>, <span class="number">1</span>), <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            acPoly.AddVertexAt(<span class="number">1</span>, <span class="keyword">new</span> Point2d(<span class="number">1</span>, <span class="number">2</span>), <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            acPoly.AddVertexAt(<span class="number">2</span>, <span class="keyword">new</span> Point2d(<span class="number">2</span>, <span class="number">2</span>), <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            acPoly.AddVertexAt(<span class="number">3</span>, <span class="keyword">new</span> Point2d(<span class="number">3</span>, <span class="number">2</span>), <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            acPoly.AddVertexAt(<span class="number">4</span>, <span class="keyword">new</span> Point2d(<span class="number">4</span>, <span class="number">4</span>), <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            acPoly.AddVertexAt(<span class="number">5</span>, <span class="keyword">new</span> Point2d(<span class="number">4</span>, <span class="number">1</span>), <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Create a bulge of -2 at vertex 1</span></span><br><span class="line">            acPoly.SetBulgeAt(<span class="number">1</span>, <span class="number">-2</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Close the polyline</span></span><br><span class="line">            acPoly.Closed = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Add the new object to the block table record and the transaction</span></span><br><span class="line">            acBlkTblRec.AppendEntity(acPoly);</span><br><span class="line">            acTrans.AddNewlyCreatedDBObject(acPoly, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Create a copy of the original polyline</span></span><br><span class="line">            Polyline acPolyMirCopy = acPoly.Clone() <span class="keyword">as</span> Polyline;</span><br><span class="line">            acPolyMirCopy.ColorIndex = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Define the mirror line</span></span><br><span class="line">            Point3d acPtFrom = <span class="keyword">new</span> Point3d(<span class="number">0</span>, <span class="number">4.25</span>, <span class="number">0</span>);</span><br><span class="line">            Point3d acPtTo = <span class="keyword">new</span> Point3d(<span class="number">4</span>, <span class="number">4.25</span>, <span class="number">0</span>);</span><br><span class="line">            Line3d acLine3d = <span class="keyword">new</span> Line3d(acPtFrom, acPtTo);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Mirror the polyline across the X axis</span></span><br><span class="line">            acPolyMirCopy.TransformBy(Matrix3d.Mirroring(acLine3d));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Add the new object to the block table record and the transaction</span></span><br><span class="line">            acBlkTblRec.AppendEntity(acPolyMirCopy);</span><br><span class="line">            acTrans.AddNewlyCreatedDBObject(acPolyMirCopy, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Save the new objects to the database</span></span><br><span class="line">        acTrans.Commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="缩放对象（-NET）"><a href="#缩放对象（-NET）" class="headerlink" title="缩放对象（.NET）"></a>缩放对象（.NET）</h4><p>可以通过基于当前图形单位指定基点和比例因子来缩放对象。可以缩放所有图形对象以及属性参照对象。</p>
<p>要缩放对象，请使用变换矩阵的 Scaling 功能。此函数要求对象的比例因子为数值，缩放操作的基点为 Point3d 对象。 Scaling 函数在X、Y和Z方向上均匀缩放对象。对象的尺寸将乘以比例因子。比例因子大于1将放大对象。比例因子介于0和1之间时，对象会缩小。</p>
<p>注意：如果需要不均匀地缩放对象，则需要使用适当的数据数组初始化变换矩阵，然后使用对象的 TransformBy 方法。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2024/ENU/OARX-DevGuide-Managed/images/GUID-517930CB-1960-4955-B6A2-51BD02DA4F4C.png"></p>
<p><strong>缩放多段线</strong></p>
<p>此示例创建一个封闭的轻量化对象，然后从基点（4，4.25，0）将对象缩放0.5。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">CommandMethod(<span class="string">&quot;ScaleObject&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ScaleObject</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Get the current document and database</span></span><br><span class="line">    Document acDoc = Application.DocumentManager.MdiActiveDocument;</span><br><span class="line">    Database acCurDb = acDoc.Database;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start a transaction</span></span><br><span class="line">    <span class="keyword">using</span> (Transaction acTrans = acCurDb.TransactionManager.StartTransaction())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Open the Block table for read</span></span><br><span class="line">        BlockTable acBlkTbl;</span><br><span class="line">        acBlkTbl = acTrans.GetObject(acCurDb.BlockTableId,</span><br><span class="line">                                     OpenMode.ForRead) <span class="keyword">as</span> BlockTable;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Open the Block table record Model space for write</span></span><br><span class="line">        BlockTableRecord acBlkTblRec;</span><br><span class="line">        acBlkTblRec = acTrans.GetObject(acBlkTbl[BlockTableRecord.ModelSpace],</span><br><span class="line">                                        OpenMode.ForWrite) <span class="keyword">as</span> BlockTableRecord;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create a lightweight polyline</span></span><br><span class="line">        <span class="keyword">using</span> (Polyline acPoly = <span class="keyword">new</span> Polyline())</span><br><span class="line">        &#123;</span><br><span class="line">            acPoly.AddVertexAt(<span class="number">0</span>, <span class="keyword">new</span> Point2d(<span class="number">1</span>, <span class="number">2</span>), <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            acPoly.AddVertexAt(<span class="number">1</span>, <span class="keyword">new</span> Point2d(<span class="number">1</span>, <span class="number">3</span>), <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            acPoly.AddVertexAt(<span class="number">2</span>, <span class="keyword">new</span> Point2d(<span class="number">2</span>, <span class="number">3</span>), <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            acPoly.AddVertexAt(<span class="number">3</span>, <span class="keyword">new</span> Point2d(<span class="number">3</span>, <span class="number">3</span>), <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            acPoly.AddVertexAt(<span class="number">4</span>, <span class="keyword">new</span> Point2d(<span class="number">4</span>, <span class="number">4</span>), <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            acPoly.AddVertexAt(<span class="number">5</span>, <span class="keyword">new</span> Point2d(<span class="number">4</span>, <span class="number">2</span>), <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Close the polyline</span></span><br><span class="line">            acPoly.Closed = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Reduce the object by a factor of 0.5 </span></span><br><span class="line">            <span class="comment">// using a base point of (4,4.25,0)</span></span><br><span class="line">            acPoly.TransformBy(Matrix3d.Scaling(<span class="number">0.5</span>, <span class="keyword">new</span> Point3d(<span class="number">4</span>, <span class="number">4.25</span>, <span class="number">0</span>)));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Add the new object to the block table record and the transaction</span></span><br><span class="line">            acBlkTblRec.AppendEntity(acPoly);</span><br><span class="line">            acTrans.AddNewlyCreatedDBObject(acPoly, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Save the new objects to the database</span></span><br><span class="line">        acTrans.Commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="阵列对象（-NET）"><a href="#阵列对象（-NET）" class="headerlink" title="阵列对象（.NET）"></a>阵列对象（.NET）</h3><p>可以创建对象的环形阵列或矩形阵列。对象阵列不是使用一组专用函数创建的，而是通过复制对象，然后使用变换矩阵旋转和移动复制的对象的组合来创建的。下面概述了每种类型的阵列的基本逻辑：</p>
<p><strong>环形阵列</strong>。复制要阵列的对象，并基于围绕基点的角度移动它。从对象到阵列基点的距离用于计算创建的每个副本的放置。移动复制的对象后，可以根据对象相对于基点的角度旋转对象。创建每个副本后，需要将其追加到块表记录中。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2024/ENU/OARX-DevGuide-Managed/images/GUID-4FCDBF6E-D3D6-46E8-8494-1414177E332F.png" alt="img"></p>
<p><strong>矩形阵列</strong>。根据所需的行数和列数将对象复制到阵列中。复制对象的复制距离基于行和列之间的指定距离。您首先要创建的副本数量要与原件的第一行或第一列相同。创建第一行或第一列后，可以根据创建的第一行或第一列为其余行或列创建对象数。创建每个副本后，需要将其追加到块表记录中。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2024/ENU/OARX-DevGuide-Managed/images/GUID-E3D5E813-DA3A-467C-BD5D-CCCC8C9E113D.png" alt="img"></p>
<p>本节中的主题</p>
<ul>
<li>创建环形阵列（.NET）</li>
<li>创建矩形阵列（.NET）</li>
</ul>
<h4 id="创建环形阵列（-NET）"><a href="#创建环形阵列（-NET）" class="headerlink" title="创建环形阵列（.NET）"></a>创建环形阵列（.NET）</h4><p>此示例创建一个圆，然后执行圆的环形阵列。这将创建四个围绕基点（4，4，0）填充180度的圆。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> Point2d <span class="title">PolarPoints</span>(<span class="params">Point2d pPt, <span class="built_in">double</span> dAng, <span class="built_in">double</span> dDist</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Point2d(pPt.X + dDist * Math.Cos(dAng),</span><br><span class="line">                     pPt.Y + dDist * Math.Sin(dAng));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">[<span class="meta">CommandMethod(<span class="string">&quot;PolarArrayObject&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PolarArrayObject</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Get the current document and database</span></span><br><span class="line">    Document acDoc = Application.DocumentManager.MdiActiveDocument;</span><br><span class="line">    Database acCurDb = acDoc.Database;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start a transaction</span></span><br><span class="line">    <span class="keyword">using</span> (Transaction acTrans = acCurDb.TransactionManager.StartTransaction())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Open the Block table record for read</span></span><br><span class="line">        BlockTable acBlkTbl;</span><br><span class="line">        acBlkTbl = acTrans.GetObject(acCurDb.BlockTableId,</span><br><span class="line">                                        OpenMode.ForRead) <span class="keyword">as</span> BlockTable;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Open the Block table record Model space for write</span></span><br><span class="line">        BlockTableRecord acBlkTblRec;</span><br><span class="line">        acBlkTblRec = acTrans.GetObject(acBlkTbl[BlockTableRecord.ModelSpace],</span><br><span class="line">                                        OpenMode.ForWrite) <span class="keyword">as</span> BlockTableRecord;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create a circle that is at 2,2 with a radius of 1</span></span><br><span class="line">        <span class="keyword">using</span> (Circle acCirc = <span class="keyword">new</span> Circle())</span><br><span class="line">        &#123;</span><br><span class="line">            acCirc.Center = <span class="keyword">new</span> Point3d(<span class="number">2</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">            acCirc.Radius = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Add the new object to the block table record and the transaction</span></span><br><span class="line">            acBlkTblRec.AppendEntity(acCirc);</span><br><span class="line">            acTrans.AddNewlyCreatedDBObject(acCirc, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Create a 4 object polar array that goes a 180</span></span><br><span class="line">            <span class="built_in">int</span> nCount = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Set a value in radians for 60 degrees</span></span><br><span class="line">            <span class="built_in">double</span> dAng = <span class="number">1.0472</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Use (4,4,0) as the base point for the array</span></span><br><span class="line">            Point2d acPt2dArrayBase = <span class="keyword">new</span> Point2d(<span class="number">4</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (nCount &lt; <span class="number">4</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                Entity acEntClone = acCirc.Clone() <span class="keyword">as</span> Entity;</span><br><span class="line"></span><br><span class="line">                Extents3d acExts;</span><br><span class="line">                Point2d acPtObjBase;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Typically the upper-left corner of an object&#x27;s extents is used</span></span><br><span class="line">                <span class="comment">// for the point on the object to be arrayed unless it is</span></span><br><span class="line">                <span class="comment">// an object like a circle.</span></span><br><span class="line">                Circle acCircArrObj = acEntClone <span class="keyword">as</span> Circle;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (acCircArrObj != <span class="literal">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    acPtObjBase = <span class="keyword">new</span> Point2d(acCircArrObj.Center.X,</span><br><span class="line">                                                acCircArrObj.Center.Y);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    acExts = acEntClone.Bounds.GetValueOrDefault();</span><br><span class="line">                    acPtObjBase = <span class="keyword">new</span> Point2d(acExts.MinPoint.X,</span><br><span class="line">                                                acExts.MaxPoint.Y);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">double</span> dDist = acPt2dArrayBase.GetDistanceTo(acPtObjBase);</span><br><span class="line">                <span class="built_in">double</span> dAngFromX = acPt2dArrayBase.GetVectorTo(acPtObjBase).Angle;</span><br><span class="line"></span><br><span class="line">                Point2d acPt2dTo = PolarPoints(acPt2dArrayBase,</span><br><span class="line">                                                (nCount * dAng) + dAngFromX,</span><br><span class="line">                                                dDist);</span><br><span class="line"></span><br><span class="line">                Vector2d acVec2d = acPtObjBase.GetVectorTo(acPt2dTo);</span><br><span class="line">                Vector3d acVec3d = <span class="keyword">new</span> Vector3d(acVec2d.X, acVec2d.Y, <span class="number">0</span>);</span><br><span class="line">                acEntClone.TransformBy(Matrix3d.Displacement(acVec3d));</span><br><span class="line"></span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                // The following code demonstrates how to rotate each object like</span></span><br><span class="line"><span class="comment">                // the ARRAY command does.</span></span><br><span class="line"><span class="comment">                acExts = acEntClone.Bounds.GetValueOrDefault();</span></span><br><span class="line"><span class="comment">                acPtObjBase = new Point2d(acExts.MinPoint.X,</span></span><br><span class="line"><span class="comment">                                            acExts.MaxPoint.Y);</span></span><br><span class="line"><span class="comment">                </span></span><br><span class="line"><span class="comment">                // Rotate the cloned entity around its upper-left extents point</span></span><br><span class="line"><span class="comment">                Matrix3d curUCSMatrix = acDoc.Editor.CurrentUserCoordinateSystem;</span></span><br><span class="line"><span class="comment">                CoordinateSystem3d curUCS = curUCSMatrix.CoordinateSystem3d;</span></span><br><span class="line"><span class="comment">                acEntClone.TransformBy(Matrix3d.Rotation(nCount * dAng,</span></span><br><span class="line"><span class="comment">                                                            curUCS.Zaxis,</span></span><br><span class="line"><span class="comment">                                                            new Point3d(acPtObjBase.X,</span></span><br><span class="line"><span class="comment">                                                                        acPtObjBase.Y, 0)));</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line"></span><br><span class="line">                acBlkTblRec.AppendEntity(acEntClone);</span><br><span class="line">                acTrans.AddNewlyCreatedDBObject(acEntClone, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">                nCount = nCount + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Save the new objects to the database</span></span><br><span class="line">        acTrans.Commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="创建矩形阵列（-NET）"><a href="#创建矩形阵列（-NET）" class="headerlink" title="创建矩形阵列（.NET）"></a>创建矩形阵列（.NET）</h4><p>此示例创建一个圆，然后执行圆的矩形阵列，创建五行和五列圆。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> Point2d <span class="title">PolarPoints</span>(<span class="params">Point2d pPt, <span class="built_in">double</span> dAng, <span class="built_in">double</span> dDist</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Point2d(pPt.X + dDist * Math.Cos(dAng),</span><br><span class="line">                     pPt.Y + dDist * Math.Sin(dAng));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">[<span class="meta">CommandMethod(<span class="string">&quot;RectangularArrayObject&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">RectangularArrayObject</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Get the current document and database</span></span><br><span class="line">    Document acDoc = Application.DocumentManager.MdiActiveDocument;</span><br><span class="line">    Database acCurDb = acDoc.Database;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start a transaction</span></span><br><span class="line">    <span class="keyword">using</span> (Transaction acTrans = acCurDb.TransactionManager.StartTransaction())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Open the Block table record for read</span></span><br><span class="line">        BlockTable acBlkTbl;</span><br><span class="line">        acBlkTbl = acTrans.GetObject(acCurDb.BlockTableId,</span><br><span class="line">                                        OpenMode.ForRead) <span class="keyword">as</span> BlockTable;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Open the Block table record Model space for write</span></span><br><span class="line">        BlockTableRecord acBlkTblRec;</span><br><span class="line">        acBlkTblRec = acTrans.GetObject(acBlkTbl[BlockTableRecord.ModelSpace],</span><br><span class="line">                                        OpenMode.ForWrite) <span class="keyword">as</span> BlockTableRecord;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create a circle that is at 2,2 with a radius of 0.5</span></span><br><span class="line">        <span class="keyword">using</span> (Circle acCirc = <span class="keyword">new</span> Circle())</span><br><span class="line">        &#123;</span><br><span class="line">            acCirc.Center = <span class="keyword">new</span> Point3d(<span class="number">2</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">            acCirc.Radius = <span class="number">0.5</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Add the new object to the block table record and the transaction</span></span><br><span class="line">            acBlkTblRec.AppendEntity(acCirc);</span><br><span class="line">            acTrans.AddNewlyCreatedDBObject(acCirc, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Create a rectangular array with 5 rows and 5 columns</span></span><br><span class="line">            <span class="built_in">int</span> nRows = <span class="number">5</span>;</span><br><span class="line">            <span class="built_in">int</span> nColumns = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Set the row and column offsets along with the base array angle</span></span><br><span class="line">            <span class="built_in">double</span> dRowOffset = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">double</span> dColumnOffset = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">double</span> dArrayAng = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Get the angle from X for the current UCS </span></span><br><span class="line">            Matrix3d curUCSMatrix = acDoc.Editor.CurrentUserCoordinateSystem;</span><br><span class="line">            CoordinateSystem3d curUCS = curUCSMatrix.CoordinateSystem3d;</span><br><span class="line">            Vector2d acVec2dAng = <span class="keyword">new</span> Vector2d(curUCS.Xaxis.X,</span><br><span class="line">                                                curUCS.Xaxis.Y);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If the UCS is rotated, adjust the array angle accordingly</span></span><br><span class="line">            dArrayAng = dArrayAng + acVec2dAng.Angle;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Use the upper-left corner of the objects extents for the array base point</span></span><br><span class="line">            Extents3d acExts = acCirc.Bounds.GetValueOrDefault();</span><br><span class="line">            Point2d acPt2dArrayBase = <span class="keyword">new</span> Point2d(acExts.MinPoint.X,</span><br><span class="line">                                                    acExts.MaxPoint.Y);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Track the objects created for each column</span></span><br><span class="line">            DBObjectCollection acDBObjCollCols = <span class="keyword">new</span> DBObjectCollection();</span><br><span class="line">            acDBObjCollCols.Add(acCirc);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Create the number of objects for the first column</span></span><br><span class="line">            <span class="built_in">int</span> nColumnsCount = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (nColumns &gt; nColumnsCount)</span><br><span class="line">            &#123;</span><br><span class="line">                Entity acEntClone = acCirc.Clone() <span class="keyword">as</span> Entity;</span><br><span class="line">                acDBObjCollCols.Add(acEntClone);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Caclucate the new point for the copied object (move)</span></span><br><span class="line">                Point2d acPt2dTo = PolarPoints(acPt2dArrayBase,</span><br><span class="line">                                                dArrayAng,</span><br><span class="line">                                                dColumnOffset * nColumnsCount);</span><br><span class="line"></span><br><span class="line">                Vector2d acVec2d = acPt2dArrayBase.GetVectorTo(acPt2dTo);</span><br><span class="line">                Vector3d acVec3d = <span class="keyword">new</span> Vector3d(acVec2d.X, acVec2d.Y, <span class="number">0</span>);</span><br><span class="line">                acEntClone.TransformBy(Matrix3d.Displacement(acVec3d));</span><br><span class="line"></span><br><span class="line">                acBlkTblRec.AppendEntity(acEntClone);</span><br><span class="line">                acTrans.AddNewlyCreatedDBObject(acEntClone, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">                nColumnsCount = nColumnsCount + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Set a value in radians for 90 degrees</span></span><br><span class="line">            <span class="built_in">double</span> dAng = Math.PI / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Track the objects created for each row and column</span></span><br><span class="line">            DBObjectCollection acDBObjCollLvls = <span class="keyword">new</span> DBObjectCollection();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">foreach</span> (DBObject acObj <span class="keyword">in</span> acDBObjCollCols)</span><br><span class="line">            &#123;</span><br><span class="line">                acDBObjCollLvls.Add(acObj);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Create the number of objects for each row</span></span><br><span class="line">            <span class="keyword">foreach</span> (Entity acEnt <span class="keyword">in</span> acDBObjCollCols)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">int</span> nRowsCount = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> (nRows &gt; nRowsCount)</span><br><span class="line">                &#123;</span><br><span class="line">                    Entity acEntClone = acEnt.Clone() <span class="keyword">as</span> Entity;</span><br><span class="line">                    acDBObjCollLvls.Add(acEntClone);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// Caclucate the new point for the copied object (move)</span></span><br><span class="line">                    Point2d acPt2dTo = PolarPoints(acPt2dArrayBase,</span><br><span class="line">                                                    dArrayAng + dAng,</span><br><span class="line">                                                    dRowOffset * nRowsCount);</span><br><span class="line"></span><br><span class="line">                    Vector2d acVec2d = acPt2dArrayBase.GetVectorTo(acPt2dTo);</span><br><span class="line">                    Vector3d acVec3d = <span class="keyword">new</span> Vector3d(acVec2d.X, acVec2d.Y, <span class="number">0</span>);</span><br><span class="line">                    acEntClone.TransformBy(Matrix3d.Displacement(acVec3d));</span><br><span class="line"></span><br><span class="line">                    acBlkTblRec.AppendEntity(acEntClone);</span><br><span class="line">                    acTrans.AddNewlyCreatedDBObject(acEntClone, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">                    nRowsCount = nRowsCount + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Save the new objects to the database</span></span><br><span class="line">        acTrans.Commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="延伸和修剪对象（-NET）"><a href="#延伸和修剪对象（-NET）" class="headerlink" title="延伸和修剪对象（.NET）"></a>延伸和修剪对象（.NET）</h3><p>您可以更改弧的角度，也可以更改直线、开放多段线、椭圆弧和开放样条曲线的长度。结果与延伸和修剪对象类似。</p>
<p>可以通过编辑对象的属性来延伸或修剪对象。例如，要延长一条线，只需更改 StartPoint 或 EndPoint 属性的坐标。若要更改圆弧的角度，请更改圆弧的 StartAngle 或 EndAngle 属性。更改对象的特性后，可能需要重新生成显示以查看图形窗口中的更改。</p>
<p><strong>加长一条线</strong></p>
<p>此示例创建一条直线，然后更改该直线的端点，从而生成一条较长的直线。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">CommandMethod(<span class="string">&quot;ExtendObject&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ExtendObject</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Get the current document and database</span></span><br><span class="line">    Document acDoc = Application.DocumentManager.MdiActiveDocument;</span><br><span class="line">    Database acCurDb = acDoc.Database;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start a transaction</span></span><br><span class="line">    <span class="keyword">using</span> (Transaction acTrans = acCurDb.TransactionManager.StartTransaction())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Open the Block table for read</span></span><br><span class="line">        BlockTable acBlkTbl;</span><br><span class="line">        acBlkTbl = acTrans.GetObject(acCurDb.BlockTableId,</span><br><span class="line">                                        OpenMode.ForRead) <span class="keyword">as</span> BlockTable;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Open the Block table record Model space for write</span></span><br><span class="line">        BlockTableRecord acBlkTblRec;</span><br><span class="line">        acBlkTblRec = acTrans.GetObject(acBlkTbl[BlockTableRecord.ModelSpace],</span><br><span class="line">                                        OpenMode.ForWrite) <span class="keyword">as</span> BlockTableRecord;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create a line that starts at (4,4,0) and ends at (7,7,0)</span></span><br><span class="line">        <span class="keyword">using</span> (Line acLine = <span class="keyword">new</span> Line(<span class="keyword">new</span> Point3d(<span class="number">4</span>, <span class="number">4</span>, <span class="number">0</span>),</span><br><span class="line">                                <span class="keyword">new</span> Point3d(<span class="number">7</span>, <span class="number">7</span>, <span class="number">0</span>)))</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Add the new object to the block table record and the transaction</span></span><br><span class="line">            acBlkTblRec.AppendEntity(acLine);</span><br><span class="line">            acTrans.AddNewlyCreatedDBObject(acLine, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Update the display and diaplay a message box</span></span><br><span class="line">            acDoc.Editor.Regen();</span><br><span class="line">            Application.ShowAlertDialog(<span class="string">&quot;Before extend&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Double the length of the line</span></span><br><span class="line">            acLine.EndPoint = acLine.EndPoint + acLine.Delta;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Save the new object to the database</span></span><br><span class="line">        acTrans.Commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="分解对象（-NET）"><a href="#分解对象（-NET）" class="headerlink" title="分解对象（.NET）"></a>分解对象（.NET）</h3><p>分解对象会将单个对象转换为其组成部分。使用 Explode 函数分解对象，它需要一个用于返回结果对象的 DBObjectCollection 对象。例如，分解对象可能导致创建包含多条直线和圆弧的对象集合。</p>
<p>如果块被分解，则返回的对象集合将保存用于定义块的图形对象。对象分解后，原始对象保持不变。如果希望返回的对象替换原始对象，则必须删除原始对象，然后必须将返回的对象添加到块表记录中。</p>
<p> <strong>分解一个多段线</strong></p>
<p>此示例创建一个多段线，然后将对象分解为最简单的对象。分解对象后，将对其进行处理，并将返回的对象添加到模型空间。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">CommandMethod(<span class="string">&quot;ExplodeObject&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ExplodeObject</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Get the current document and database</span></span><br><span class="line">    Document acDoc = Application.DocumentManager.MdiActiveDocument;</span><br><span class="line">    Database acCurDb = acDoc.Database;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start a transaction</span></span><br><span class="line">    <span class="keyword">using</span> (Transaction acTrans = acCurDb.TransactionManager.StartTransaction())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Open the Block table for read</span></span><br><span class="line">        BlockTable acBlkTbl;</span><br><span class="line">        acBlkTbl = acTrans.GetObject(acCurDb.BlockTableId,</span><br><span class="line">                                        OpenMode.ForRead) <span class="keyword">as</span> BlockTable;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Open the Block table record Model space for write</span></span><br><span class="line">        BlockTableRecord acBlkTblRec;</span><br><span class="line">        acBlkTblRec = acTrans.GetObject(acBlkTbl[BlockTableRecord.ModelSpace],</span><br><span class="line">                                        OpenMode.ForWrite) <span class="keyword">as</span> BlockTableRecord;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create a lightweight polyline</span></span><br><span class="line">        <span class="keyword">using</span> (Polyline acPoly = <span class="keyword">new</span> Polyline())</span><br><span class="line">        &#123;</span><br><span class="line">            acPoly.AddVertexAt(<span class="number">0</span>, <span class="keyword">new</span> Point2d(<span class="number">1</span>, <span class="number">1</span>), <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            acPoly.AddVertexAt(<span class="number">1</span>, <span class="keyword">new</span> Point2d(<span class="number">1</span>, <span class="number">2</span>), <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            acPoly.AddVertexAt(<span class="number">2</span>, <span class="keyword">new</span> Point2d(<span class="number">2</span>, <span class="number">2</span>), <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            acPoly.AddVertexAt(<span class="number">3</span>, <span class="keyword">new</span> Point2d(<span class="number">3</span>, <span class="number">2</span>), <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            acPoly.AddVertexAt(<span class="number">4</span>, <span class="keyword">new</span> Point2d(<span class="number">4</span>, <span class="number">4</span>), <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            acPoly.AddVertexAt(<span class="number">5</span>, <span class="keyword">new</span> Point2d(<span class="number">4</span>, <span class="number">1</span>), <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Sets the bulge at index 3</span></span><br><span class="line">            acPoly.SetBulgeAt(<span class="number">3</span>, <span class="number">-0.5</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Explodes the polyline</span></span><br><span class="line">            DBObjectCollection acDBObjColl = <span class="keyword">new</span> DBObjectCollection();</span><br><span class="line">            acPoly.Explode(acDBObjColl);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">foreach</span> (Entity acEnt <span class="keyword">in</span> acDBObjColl)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// Add the new object to the block table record and the transaction</span></span><br><span class="line">                acBlkTblRec.AppendEntity(acEnt);</span><br><span class="line">                acTrans.AddNewlyCreatedDBObject(acEnt, <span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Dispose of the in memory polyline</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Save the new objects to the database</span></span><br><span class="line">        acTrans.Commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="编辑多段线（-NET）"><a href="#编辑多段线（-NET）" class="headerlink" title="编辑多段线（.NET）"></a>编辑多段线（.NET）</h3><p>二维和三维多段线、矩形、多边形、圆环和三维多边形网格都是双曲面变体，并且以相同的方式进行编辑。</p>
<p>AutoCAD可识别拟合多段线和样条曲线拟合多段线。样条拟合使用曲线拟合，类似于B样条。样条曲线拟合多段线有两种：二次和三次。这两条多段线都由SPLINETYPE系统变量控制。拟合曲面使用标准曲线进行曲线拟合，并利用在任何给定顶点上设置的任何切线方向。</p>
<p>要编辑对象，请使用 Polyline 、 Polyline2d 或 Polyline3d 对象的属性和方法。使用以下属性和方法打开或关闭顶点、更改顶点的坐标或添加顶点：</p>
<p><strong>Closed 属性</strong></p>
<p>打开或闭合多段线</p>
<p><strong>ConstantWidth 属性</strong> </p>
<p>设置多段线的恒定宽度。</p>
<p><strong>AppendVertex 方法</strong></p>
<p>将顶点添加到二维或三维多段线。</p>
<p><strong>ReverseCurve</strong> </p>
<p>反转多段线的方向。</p>
<p>使用以下方法更新多段线的凸度或宽度：</p>
<p><strong>SetBulgeAt</strong>  </p>
<p>在给定分段索引的情况下，设置多段线的凸度。</p>
<p><strong>SetStartWidthAt</strong> </p>
<p>在给定段索引的情况下，设置多段线的起始宽度。</p>
<p><strong>Straighten</strong>  </p>
<p>拉直二维或三维多段线。</p>
<p><strong>编辑多段线</strong></p>
<p>此示例创建一个多段线。然后，它将向第三段的顶点添加一个凸起，向第三段添加一个顶点，更改最后一段的宽度，最后闭合第三段。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">CommandMethod(<span class="string">&quot;EditPolyline&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">EditPolyline</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Get the current document and database</span></span><br><span class="line">    Document acDoc = Application.DocumentManager.MdiActiveDocument;</span><br><span class="line">    Database acCurDb = acDoc.Database;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start a transaction</span></span><br><span class="line">    <span class="keyword">using</span> (Transaction acTrans = acCurDb.TransactionManager.StartTransaction())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Open the Block table for read</span></span><br><span class="line">        BlockTable acBlkTbl;</span><br><span class="line">        acBlkTbl = acTrans.GetObject(acCurDb.BlockTableId,</span><br><span class="line">                                        OpenMode.ForRead) <span class="keyword">as</span> BlockTable;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Open the Block table record Model space for write</span></span><br><span class="line">        BlockTableRecord acBlkTblRec;</span><br><span class="line">        acBlkTblRec = acTrans.GetObject(acBlkTbl[BlockTableRecord.ModelSpace],</span><br><span class="line">                                        OpenMode.ForWrite) <span class="keyword">as</span> BlockTableRecord;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create a lightweight polyline</span></span><br><span class="line">        <span class="keyword">using</span> (Polyline acPoly = <span class="keyword">new</span> Polyline())</span><br><span class="line">        &#123;</span><br><span class="line">            acPoly.AddVertexAt(<span class="number">0</span>, <span class="keyword">new</span> Point2d(<span class="number">1</span>, <span class="number">1</span>), <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            acPoly.AddVertexAt(<span class="number">1</span>, <span class="keyword">new</span> Point2d(<span class="number">1</span>, <span class="number">2</span>), <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            acPoly.AddVertexAt(<span class="number">2</span>, <span class="keyword">new</span> Point2d(<span class="number">2</span>, <span class="number">2</span>), <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            acPoly.AddVertexAt(<span class="number">3</span>, <span class="keyword">new</span> Point2d(<span class="number">3</span>, <span class="number">2</span>), <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            acPoly.AddVertexAt(<span class="number">4</span>, <span class="keyword">new</span> Point2d(<span class="number">4</span>, <span class="number">4</span>), <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Add the new object to the block table record and the transaction</span></span><br><span class="line">            acBlkTblRec.AppendEntity(acPoly);</span><br><span class="line">            acTrans.AddNewlyCreatedDBObject(acPoly, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Sets the bulge at index 3</span></span><br><span class="line">            acPoly.SetBulgeAt(<span class="number">3</span>, <span class="number">-0.5</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Add a new vertex</span></span><br><span class="line">            acPoly.AddVertexAt(<span class="number">5</span>, <span class="keyword">new</span> Point2d(<span class="number">4</span>, <span class="number">1</span>), <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Sets the start and end width at index 4</span></span><br><span class="line">            acPoly.SetStartWidthAt(<span class="number">4</span>, <span class="number">0.1</span>);</span><br><span class="line">            acPoly.SetEndWidthAt(<span class="number">4</span>, <span class="number">0.5</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Close the polyline</span></span><br><span class="line">            acPoly.Closed = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Save the new objects to the database</span></span><br><span class="line">        acTrans.Commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="编辑样条曲线（-NET）"><a href="#编辑样条曲线（-NET）" class="headerlink" title="编辑样条曲线（.NET）"></a>编辑样条曲线（.NET）</h3><p>可以编辑开放或闭合样条曲线的属性，甚至可以将其转换为曲线。使用以下特性可以打开或关闭样条曲线、更改其控制点或反转样条曲线的方向：</p>
<ul>
<li><p><strong>Degree</strong> </p>
<p>返回样条曲线的多项式表示形式。</p>
</li>
<li><p><strong>EndFitTangent</strong>  </p>
<p>返回样条线的端点切线作为方向向量。</p>
</li>
<li><p><strong>FitTolerance</strong>  </p>
<p>使用新公差值将样条曲线重新拟合到现有点。</p>
</li>
<li><p><strong>NumControlPoints</strong>  </p>
<p>返回样条曲线的控制点数。</p>
</li>
<li><p><strong>NumFitPoints</strong></p>
<p>返回样条曲线的拟合点数。</p>
</li>
<li><p><strong>StartFitTangent</strong>  </p>
<p>返回样条线的起始切线。</p>
</li>
<li><p><strong>InsertFitPointAt</strong>  </p>
<p>在给定索引处向样条曲线添加单个拟合点。</p>
</li>
<li><p><strong>ElevateDegree</strong></p>
<p>将样条曲线的阶数增加到给定的阶数。</p>
</li>
<li><p><strong>GetControlPointAt</strong></p>
<p>获取给定索引处样条曲线的控制点。(Gets只有一个控制点）。 NumControlPoints 属性包含样条曲线的控制点数量。</p>
</li>
<li><p><strong>GetFitPointAt</strong></p>
<p>获取给定索引处样条曲线的拟合点。(Gets仅一个拟合点。要查询样条曲线的所有拟合点，请使用 FitData 属性，然后查询使用其 GetFitPoints 成员函数返回的 FitData 对象。 NumFitPoints 属性包含样条曲线的拟合点数。</p>
</li>
<li><p><strong>RemoveFitPointAt</strong></p>
<p>在给定索引处创建样条曲线的拟合点。</p>
</li>
<li><p><strong>ReverseCurve</strong>  </p>
<p>反转样条曲线的方向。</p>
</li>
<li><p><strong>SetControlPointAt</strong>  </p>
<p>在给定索引处设置样条曲线的控制点。</p>
</li>
<li><p><strong>SetFitPointAt</strong>  </p>
<p>在给定索引处设置样条曲线的拟合点。(Sets仅一个拟合点。要更改样条曲线的所有拟合点，请使用 FitPoints 属性。）</p>
</li>
<li><p><strong>SetWeightAt</strong>  </p>
<p>设置给定索引处控制点的权重。</p>
</li>
</ul>
<p>使用以下只读属性查询样条曲线：</p>
<ul>
<li><p><strong>Area</strong>  </p>
<p>获取样条线的封闭区域。</p>
</li>
<li><p><strong>Closed</strong>  </p>
<p>指示样条曲线是打开的还是闭合的。</p>
</li>
<li><p><strong>Degree</strong>  </p>
<p>获取样条曲线的多项式表示形式的阶数。</p>
</li>
<li><p><strong>IsPeriodic</strong></p>
<p>指定给定的样条曲线是否是周期性的。</p>
</li>
<li><p><strong>IsPlanar</strong></p>
<p>指定给定样条曲线是否为平面样条曲线。</p>
</li>
<li><p><strong>IsRational</strong>  </p>
<p>指定给定的样条曲线是否合理。</p>
</li>
<li><p><strong>NumControlPoints</strong>  </p>
<p>获取样条曲线的控制点数目。</p>
</li>
<li><p><strong>NumfFitPoints</strong></p>
<p>获取样条曲线的拟合点数。</p>
</li>
</ul>
<p><strong>更改样条曲线上的控制点</strong></p>
<p>本示例创建样条曲线，然后更改样条曲线的第一个控制点。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">CommandMethod(<span class="string">&quot;EditSpline&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">EditSpline</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Get the current document and database</span></span><br><span class="line">    Document acDoc = Application.DocumentManager.MdiActiveDocument;</span><br><span class="line">    Database acCurDb = acDoc.Database;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start a transaction</span></span><br><span class="line">    <span class="keyword">using</span> (Transaction acTrans = acCurDb.TransactionManager.StartTransaction())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Open the Block table for read</span></span><br><span class="line">        BlockTable acBlkTbl;</span><br><span class="line">        acBlkTbl = acTrans.GetObject(acCurDb.BlockTableId,</span><br><span class="line">                                        OpenMode.ForRead) <span class="keyword">as</span> BlockTable;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Open the Block table record Model space for write</span></span><br><span class="line">        BlockTableRecord acBlkTblRec;</span><br><span class="line">        acBlkTblRec = acTrans.GetObject(acBlkTbl[BlockTableRecord.ModelSpace],</span><br><span class="line">                                        OpenMode.ForWrite) <span class="keyword">as</span> BlockTableRecord;</span><br><span class="line">                </span><br><span class="line">        <span class="comment">// Create a Point3d Collection</span></span><br><span class="line">        Point3dCollection acPt3dColl = <span class="keyword">new</span> Point3dCollection();</span><br><span class="line">        acPt3dColl.Add(<span class="keyword">new</span> Point3d(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        acPt3dColl.Add(<span class="keyword">new</span> Point3d(<span class="number">5</span>, <span class="number">5</span>, <span class="number">0</span>));</span><br><span class="line">        acPt3dColl.Add(<span class="keyword">new</span> Point3d(<span class="number">10</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Set the start and end tangency</span></span><br><span class="line">        Vector3d acStartTan = <span class="keyword">new</span> Vector3d(<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0</span>);</span><br><span class="line">        Vector3d acEndTan = <span class="keyword">new</span> Vector3d(<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create a spline</span></span><br><span class="line">        <span class="keyword">using</span> (Spline acSpline = <span class="keyword">new</span> Spline(acPt3dColl,</span><br><span class="line">                                        acStartTan,</span><br><span class="line">                                        acEndTan, <span class="number">4</span>, <span class="number">0</span>))</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Set a control point</span></span><br><span class="line">            acSpline.SetControlPointAt(<span class="number">0</span>, <span class="keyword">new</span> Point3d(<span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Add the new object to the block table record and the transaction</span></span><br><span class="line">            acBlkTblRec.AppendEntity(acSpline);</span><br><span class="line">            acTrans.AddNewlyCreatedDBObject(acSpline, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Save the new objects to the database</span></span><br><span class="line">        acTrans.Commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="编辑图案填充（-NET）"><a href="#编辑图案填充（-NET）" class="headerlink" title="编辑图案填充（.NET）"></a>编辑图案填充（.NET）</h3><p>可以编辑填充边界和填充图案。如果编辑关联图案填充的边界，则只要编辑产生有效边界，阵列就会更新。即使关联图案填充位于已关闭的图层上，它们也会更新。可以修改填充图案或为现有填充选择新图案，但只能在创建填充时设置关联性。可以使用 Associative 属性检查 Hatch 对象是否关联。</p>
<p>必须使用 EvaluateHatch 方法重新计算图案填充，才能查看对图案填充所做的任何编辑。</p>
<p>本节中的主题</p>
<ul>
<li>编辑填充边界 (.NET)</li>
<li>编辑填充模式(.NET)</li>
</ul>
<h4 id="编辑填充边界-NET"><a href="#编辑填充边界-NET" class="headerlink" title="编辑填充边界 (.NET)"></a>编辑填充边界 (.NET)</h4><p>可以在 Hatch 对象的边界上附加、插入或删除循环。关联图案填充将更新以匹配对其边界所做的任何更改。不更新非关联图案填充。</p>
<p>要编辑图案填充边界，请使用以下方法之一：</p>
<ul>
<li><p>AppendLoop </p>
<p>将一个循环添加到图案填充。您定义了循环的类型，该类型附加了 AppendLoop 方法的第一个参数和由 HatchLoopTypes 枚举定义的常量。</p>
</li>
<li><p>GetLoopAt </p>
<p> 获取图案填充的给定索引处的循环。</p>
</li>
<li><p>InsertLoopAt </p>
<p> 在图案填充的给定索引处创建循环。</p>
</li>
<li><p>RemoveLoopAt</p>
<p> 在图案填充的给定索引处创建循环。</p>
</li>
</ul>
<p>要查询图案填充边界，请使用以下方法之一：</p>
<ul>
<li><p>LoopTypeAt</p>
<p>获取图案填充的给定索引处的循环类型。</p>
</li>
<li><p>NumberOfLoops </p>
<p>获取图案填充的循环数。</p>
</li>
</ul>
<p><strong>将内部循环附加到图案填充</strong></p>
<p>本示例创建关联图案填充。然后创建一个圆，并将该圆作为内环附加到图案填充。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">CommandMethod(<span class="string">&quot;EditHatchAppendLoop&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">EditHatchAppendLoop</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Get the current document and database</span></span><br><span class="line">    Document acDoc = Application.DocumentManager.MdiActiveDocument;</span><br><span class="line">    Database acCurDb = acDoc.Database;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start a transaction</span></span><br><span class="line">    <span class="keyword">using</span> (Transaction acTrans = acCurDb.TransactionManager.StartTransaction())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Open the Block table for read</span></span><br><span class="line">        BlockTable acBlkTbl;</span><br><span class="line">        acBlkTbl = acTrans.GetObject(acCurDb.BlockTableId,</span><br><span class="line">                                        OpenMode.ForRead) <span class="keyword">as</span> BlockTable;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Open the Block table record Model space for write</span></span><br><span class="line">        BlockTableRecord acBlkTblRec;</span><br><span class="line">        acBlkTblRec = acTrans.GetObject(acBlkTbl[BlockTableRecord.ModelSpace],</span><br><span class="line">                                        OpenMode.ForWrite) <span class="keyword">as</span> BlockTableRecord;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create an arc object for the closed boundary to hatch</span></span><br><span class="line">        <span class="keyword">using</span> (Arc acArc = <span class="keyword">new</span> Arc(<span class="keyword">new</span> Point3d(<span class="number">5</span>, <span class="number">3</span>, <span class="number">0</span>), <span class="number">3</span>, <span class="number">0</span>, <span class="number">3.141592</span>))</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            acBlkTblRec.AppendEntity(acArc);</span><br><span class="line">            acTrans.AddNewlyCreatedDBObject(acArc, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Create an line object for the closed boundary to hatch</span></span><br><span class="line">            <span class="keyword">using</span> (Line acLine = <span class="keyword">new</span> Line(acArc.StartPoint, acArc.EndPoint))</span><br><span class="line">            &#123;</span><br><span class="line">                acBlkTblRec.AppendEntity(acLine);</span><br><span class="line">                acTrans.AddNewlyCreatedDBObject(acLine, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Adds the arc and line to an object id collection</span></span><br><span class="line">                ObjectIdCollection acObjIdColl = <span class="keyword">new</span> ObjectIdCollection();</span><br><span class="line">                acObjIdColl.Add(acArc.ObjectId);</span><br><span class="line">                acObjIdColl.Add(acLine.ObjectId);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Create the hatch object and append it to the block table record</span></span><br><span class="line">                <span class="keyword">using</span> (Hatch acHatch = <span class="keyword">new</span> Hatch())</span><br><span class="line">                &#123;</span><br><span class="line">                    acBlkTblRec.AppendEntity(acHatch);</span><br><span class="line">                    acTrans.AddNewlyCreatedDBObject(acHatch, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// Set the properties of the hatch object</span></span><br><span class="line">                    <span class="comment">// Associative must be set after the hatch object is appended to the </span></span><br><span class="line">                    <span class="comment">// block table record and before AppendLoop</span></span><br><span class="line">                    acHatch.SetHatchPattern(HatchPatternType.PreDefined, <span class="string">&quot;ANSI31&quot;</span>);</span><br><span class="line">                    acHatch.Associative = <span class="literal">true</span>;</span><br><span class="line">                    acHatch.AppendLoop(HatchLoopTypes.Outermost, acObjIdColl);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// Create a circle object for the inner boundary of the hatch</span></span><br><span class="line">                    <span class="keyword">using</span> (Circle acCirc = <span class="keyword">new</span> Circle())</span><br><span class="line">                    &#123;</span><br><span class="line">                        acCirc.Center = <span class="keyword">new</span> Point3d(<span class="number">5</span>, <span class="number">4.5</span>, <span class="number">0</span>);</span><br><span class="line">                        acCirc.Radius = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                        acBlkTblRec.AppendEntity(acCirc);</span><br><span class="line">                        acTrans.AddNewlyCreatedDBObject(acCirc, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// Adds the circle to an object id collection</span></span><br><span class="line">                        acObjIdColl.Clear();</span><br><span class="line">                        acObjIdColl.Add(acCirc.ObjectId);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// Append the circle as the inner loop of the hatch and evaluate it</span></span><br><span class="line">                        acHatch.AppendLoop(HatchLoopTypes.Default, acObjIdColl);</span><br><span class="line">                        acHatch.EvaluateHatch(<span class="literal">true</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Save the new object to the database</span></span><br><span class="line">        acTrans.Commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="编辑填充模式-NET"><a href="#编辑填充模式-NET" class="headerlink" title="编辑填充模式 (.NET)"></a>编辑填充模式 (.NET)</h4><p>可以更改现有填充图案的角度或间距，也可以将其替换为实体填充、渐变填充或AutoCAD提供的预定义图案之一。“边界图案填充”对话框中的“图案”选项或功能区上的“图案”库将显示这些图案的列表。为了减小文件大小，图案填充在图形中定义为单个图形对象。</p>
<p>使用以下属性和方法编辑填充图案：</p>
<ul>
<li><p>GradientAngle </p>
<p>指定图案填充的渐变角度。</p>
</li>
<li><p>GradientName </p>
<p>返回图案填充的渐变名称。</p>
</li>
<li><p>GradientShift </p>
<p> 指定图案填充的渐变移动。</p>
</li>
<li><p>GradientType </p>
<p>返回图案填充的渐变类型。</p>
</li>
<li><p>PatternAngle</p>
<p>指定填充图案的角度（弧度）。</p>
</li>
<li><p>PatternDouble</p>
<p>指定用户定义的图案填充是否为双图案填充。</p>
</li>
<li><p>PatternName </p>
<p>返回图案填充的填充图案名称。(Use用于设置填充图案名称和填充类型的 SetHatchPattern 方法。）</p>
</li>
<li><p>PatternScale</p>
<p>指定填充图案比例。</p>
</li>
<li><p>PatternSpace</p>
<p>指定用户定义的填充图案间距。</p>
</li>
<li><p>PatternType </p>
<p> 返回图案填充的填充图案类型。(Use用于设置填充图案名称和填充类型的 SetHatchPattern 方法。）</p>
</li>
<li><p>SetGradient </p>
<p>设置图案填充的渐变类型和名称。</p>
</li>
<li><p>SetHatchPattern</p>
<p>设置图案填充的图案类型和名称。</p>
</li>
</ul>
<p><strong>更改图案填充的图案间距</strong></p>
<p>本示例创建图案填充。然后将图案填充的当前图案间距加2。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">CommandMethod(<span class="string">&quot;EditHatchPatternScale&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">EditHatchPatternScale</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Get the current document and database</span></span><br><span class="line">    Document acDoc = Application.DocumentManager.MdiActiveDocument;</span><br><span class="line">    Database acCurDb = acDoc.Database;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start a transaction</span></span><br><span class="line">    <span class="keyword">using</span> (Transaction acTrans = acCurDb.TransactionManager.StartTransaction())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Open the Block table for read</span></span><br><span class="line">        BlockTable acBlkTbl;</span><br><span class="line">        acBlkTbl = acTrans.GetObject(acCurDb.BlockTableId,</span><br><span class="line">                                        OpenMode.ForRead) <span class="keyword">as</span> BlockTable;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Open the Block table record Model space for write</span></span><br><span class="line">        BlockTableRecord acBlkTblRec;</span><br><span class="line">        acBlkTblRec = acTrans.GetObject(acBlkTbl[BlockTableRecord.ModelSpace],</span><br><span class="line">                                        OpenMode.ForWrite) <span class="keyword">as</span> BlockTableRecord;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create a circle object for the boundary of the hatch</span></span><br><span class="line">        <span class="keyword">using</span> (Circle acCirc = <span class="keyword">new</span> Circle())</span><br><span class="line">        &#123;</span><br><span class="line">            acCirc.Center = <span class="keyword">new</span> Point3d(<span class="number">5</span>, <span class="number">3</span>, <span class="number">0</span>);</span><br><span class="line">            acCirc.Radius = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">            acBlkTblRec.AppendEntity(acCirc);</span><br><span class="line">            acTrans.AddNewlyCreatedDBObject(acCirc, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Adds the arc and line to an object id collection</span></span><br><span class="line">            ObjectIdCollection acObjIdColl = <span class="keyword">new</span> ObjectIdCollection();</span><br><span class="line">            acObjIdColl.Add(acCirc.ObjectId);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Create the hatch object and append it to the block table record</span></span><br><span class="line">            <span class="keyword">using</span> (Hatch acHatch = <span class="keyword">new</span> Hatch())</span><br><span class="line">            &#123;</span><br><span class="line">                acBlkTblRec.AppendEntity(acHatch);</span><br><span class="line">                acTrans.AddNewlyCreatedDBObject(acHatch, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Set the properties of the hatch object</span></span><br><span class="line">                <span class="comment">// Associative must be set after the hatch object is appended to the </span></span><br><span class="line">                <span class="comment">// block table record and before AppendLoop</span></span><br><span class="line">                acHatch.SetHatchPattern(HatchPatternType.PreDefined, <span class="string">&quot;ANSI31&quot;</span>);</span><br><span class="line">                acHatch.Associative = <span class="literal">true</span>;</span><br><span class="line">                acHatch.AppendLoop(HatchLoopTypes.Outermost, acObjIdColl);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Evaluate the hatch</span></span><br><span class="line">                acHatch.EvaluateHatch(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Increase the pattern scale by 2 and re-evaluate the hatch</span></span><br><span class="line">                acHatch.PatternScale = acHatch.PatternScale + <span class="number">2</span>;</span><br><span class="line">                acHatch.SetHatchPattern(acHatch.PatternType, acHatch.PatternName);</span><br><span class="line">                acHatch.EvaluateHatch(<span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Save the new object to the database</span></span><br><span class="line">        acTrans.Commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用图层、颜色和线型（-NET）"><a href="#使用图层、颜色和线型（-NET）" class="headerlink" title="使用图层、颜色和线型（.NET）"></a>使用图层、颜色和线型（.NET）</h2><p>图层就像透明的覆盖层，您可以在其上组织和分组不同类型的图形信息。您创建的对象具有包括图层、颜色和线型在内的特性。颜色有助于区分图形中的相似元素，线型有助于轻松区分不同的绘图元素（如中心线或隐藏线）。组织图层和图层上的对象可以更轻松地管理图形中的信息。</p>
<p>本节中的主题</p>
<ul>
<li>使用图层（.NET）</li>
<li>使用颜色（.NET）</li>
<li>使用线型（.NET）</li>
</ul>
<h3 id="使用图层（-NET）"><a href="#使用图层（-NET）" class="headerlink" title="使用图层（.NET）"></a>使用图层（.NET）</h3><p>始终在图层上绘制。它可以是默认图层，也可以是您自己创建并命名的图层。每个图层都有关联的颜色和线型以及其他特性。例如，可以创建一个仅绘制中心线的图层，并将颜色和线型CENTER指定给该图层。然后，每当您想要绘制中心线时，您都可以切换到该层并开始绘制。</p>
<p>所有图层和线型都存储在单独的符号表中。图层保留在 LayerTable 中，线型保留在 LinetypeTable 中。</p>
<p>本节中的主题</p>
<ul>
<li>对图层和线型排序（.NET）</li>
<li>创建和命名图层（.NET）</li>
<li>将图层置为当前（.NET）</li>
<li>打开和关闭图层（.NET）</li>
<li>冻结和解冻图层（.NET）</li>
<li>锁定和解锁层（.NET）</li>
<li>为图层指定颜色（.NET）</li>
<li>将线型指定给图层（.NET）</li>
<li>擦除图层（.NET）</li>
</ul>
<h4 id="对图层和线型排序（-NET）"><a href="#对图层和线型排序（-NET）" class="headerlink" title="对图层和线型排序（.NET）"></a>对图层和线型排序（.NET）</h4><p>可以在“图层”和“线型”表中查找图形中的所有图层和线型。</p>
<p><strong>遍历图层表</strong></p>
<p>下面的代码循环访问Layers表以收集图形中所有图层的名称。然后，这些名称将显示在消息框中。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">CommandMethod(<span class="string">&quot;DisplayLayerNames&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DisplayLayerNames</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Get the current document and database</span></span><br><span class="line">    Document acDoc = Application.DocumentManager.MdiActiveDocument;</span><br><span class="line">    Database acCurDb = acDoc.Database;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start a transaction</span></span><br><span class="line">    <span class="keyword">using</span> (Transaction acTrans = acCurDb.TransactionManager.StartTransaction())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Open the Layer table for read</span></span><br><span class="line">        LayerTable acLyrTbl;</span><br><span class="line">        acLyrTbl = acTrans.GetObject(acCurDb.LayerTableId,</span><br><span class="line">                                        OpenMode.ForRead) <span class="keyword">as</span> LayerTable;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">string</span> sLayerNames = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">foreach</span> (ObjectId acObjId <span class="keyword">in</span> acLyrTbl)</span><br><span class="line">        &#123;</span><br><span class="line">            LayerTableRecord acLyrTblRec;</span><br><span class="line">            acLyrTblRec = acTrans.GetObject(acObjId,</span><br><span class="line">                                            OpenMode.ForRead) <span class="keyword">as</span> LayerTableRecord;</span><br><span class="line"></span><br><span class="line">            sLayerNames = sLayerNames + <span class="string">&quot;\n&quot;</span> + acLyrTblRec.Name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Application.ShowAlertDialog(<span class="string">&quot;The layers in this drawing are: &quot;</span> +</span><br><span class="line">                                    sLayerNames);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Dispose of the transaction</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="创建和命名图层（-NET）"><a href="#创建和命名图层（-NET）" class="headerlink" title="创建和命名图层（.NET）"></a>创建和命名图层（.NET）</h4><p>可以创建新图层，并为这些图层指定颜色和线型特性。每个单独的层都是“层”（Layers）表格的一部分。使用 Add 函数创建一个新图层并将其添加到图层表中。</p>
<p>可以在创建图层时为其指定名称。若要在创建层后更改其名称，请使用 Name 特性。图层名称最多可包含255个字符，并包含字母、数字和特殊字符美元符号（$）、连字符（-）和下划线（_）。</p>
<p><strong>创建一个新图层，将其指定为绿色，然后向图层中添加一个对象</strong></p>
<p>下面的代码创建一个新的层和圆对象。新图层被指定为绿色。将圆指定给图层，圆的颜色将相应地更改。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">CommandMethod(<span class="string">&quot;CreateAndAssignALayer&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CreateAndAssignALayer</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Get the current document and database</span></span><br><span class="line">    Document acDoc = Application.DocumentManager.MdiActiveDocument;</span><br><span class="line">    Database acCurDb = acDoc.Database;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start a transaction</span></span><br><span class="line">    <span class="keyword">using</span> (Transaction acTrans = acCurDb.TransactionManager.StartTransaction())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Open the Layer table for read</span></span><br><span class="line">        LayerTable acLyrTbl;</span><br><span class="line">        acLyrTbl = acTrans.GetObject(acCurDb.LayerTableId,</span><br><span class="line">                                        OpenMode.ForRead) <span class="keyword">as</span> LayerTable;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">string</span> sLayerName = <span class="string">&quot;Center&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (acLyrTbl.Has(sLayerName) == <span class="literal">false</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">using</span> (LayerTableRecord acLyrTblRec = <span class="keyword">new</span> LayerTableRecord())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// Assign the layer the ACI color 3 and a name</span></span><br><span class="line">                acLyrTblRec.Color = Color.FromColorIndex(ColorMethod.ByAci, <span class="number">3</span>);</span><br><span class="line">                acLyrTblRec.Name = sLayerName;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Upgrade the Layer table for write</span></span><br><span class="line">                acTrans.GetObject(acCurDb.LayerTableId, OpenMode.ForWrite);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Append the new layer to the Layer table and the transaction</span></span><br><span class="line">                acLyrTbl.Add(acLyrTblRec);</span><br><span class="line">                acTrans.AddNewlyCreatedDBObject(acLyrTblRec, <span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Open the Block table for read</span></span><br><span class="line">        BlockTable acBlkTbl;</span><br><span class="line">        acBlkTbl = acTrans.GetObject(acCurDb.BlockTableId,</span><br><span class="line">                                        OpenMode.ForRead) <span class="keyword">as</span> BlockTable;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Open the Block table record Model space for write</span></span><br><span class="line">        BlockTableRecord acBlkTblRec;</span><br><span class="line">        acBlkTblRec = acTrans.GetObject(acBlkTbl[BlockTableRecord.ModelSpace],</span><br><span class="line">                                        OpenMode.ForWrite) <span class="keyword">as</span> BlockTableRecord;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create a circle object</span></span><br><span class="line">        <span class="keyword">using</span> (Circle acCirc = <span class="keyword">new</span> Circle())</span><br><span class="line">        &#123;</span><br><span class="line">            acCirc.Center = <span class="keyword">new</span> Point3d(<span class="number">2</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">            acCirc.Radius = <span class="number">1</span>;</span><br><span class="line">            acCirc.Layer = sLayerName;</span><br><span class="line"></span><br><span class="line">            acBlkTblRec.AppendEntity(acCirc);</span><br><span class="line">            acTrans.AddNewlyCreatedDBObject(acCirc, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Save the changes and dispose of the transaction</span></span><br><span class="line">        acTrans.Commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="将图层置为当前（-NET）"><a href="#将图层置为当前（-NET）" class="headerlink" title="将图层置为当前（.NET）"></a>将图层置为当前（.NET）</h4><p>您始终在活动层上绘制。激活某个层时，将在该层上创建新对象。如果激活其他图层，则会为创建的任何新对象指定该新的激活图层，并使用其颜色和线型。如果图层处于冻结状态，则无法激活该图层。</p>
<p>要激活图层，请使用 Database 对象的 Clayer 特性或CLAYER系统变量。举例来说：</p>
<p><strong>使图层成为数据库中的当前图层</strong></p>
<p>此示例通过具有 Clayer 属性的 Database 对象设置当前图层。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">CommandMethod(<span class="string">&quot;SetLayerCurrent&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SetLayerCurrent</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Get the current document and database</span></span><br><span class="line">    Document acDoc = Application.DocumentManager.MdiActiveDocument;</span><br><span class="line">    Database acCurDb = acDoc.Database;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start a transaction</span></span><br><span class="line">    <span class="keyword">using</span> (Transaction acTrans = acCurDb.TransactionManager.StartTransaction())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Open the Layer table for read</span></span><br><span class="line">        LayerTable acLyrTbl;</span><br><span class="line">        acLyrTbl = acTrans.GetObject(acCurDb.LayerTableId,</span><br><span class="line">                                        OpenMode.ForRead) <span class="keyword">as</span> LayerTable;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">string</span> sLayerName = <span class="string">&quot;Center&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (acLyrTbl.Has(sLayerName) == <span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Set the layer Center current</span></span><br><span class="line">            acCurDb.Clayer = acLyrTbl[sLayerName];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Save the changes</span></span><br><span class="line">            acTrans.Commit();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Dispose of the transaction</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用CLAYER系统变量将图层置为当前图层</strong></p>
<p>此示例使用CLAYER系统变量将图层设置为当前图层。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Application.SetSystemVariable(<span class="string">&quot;CLAYER&quot;</span>, <span class="string">&quot;Center&quot;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="打开和关闭图层（-NET）"><a href="#打开和关闭图层（-NET）" class="headerlink" title="打开和关闭图层（.NET）"></a>打开和关闭图层（.NET）</h4><p>关闭的图层将与图形一起重新生成，但不会显示或打印。通过关闭图层，可以避免每次解冻图层时重新生成图形。打开已关闭的图层时，AutoCAD将在该图层上重绘对象。</p>
<p>对表示要打开或关闭的图层的 LayerTableRecord 对象使用 IsOff 特性。如果输入值 TRUE ，则图层将关闭。如果输入值 FALSE ，则图层将启用。</p>
<p><strong>关闭图层</strong></p>
<p>此示例创建一个新层并将其关闭，然后向该层添加一个圆，使该圆不再可见。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">CommandMethod(<span class="string">&quot;TurnLayerOff&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">TurnLayerOff</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Get the current document and database</span></span><br><span class="line">    Document acDoc = Application.DocumentManager.MdiActiveDocument;</span><br><span class="line">    Database acCurDb = acDoc.Database;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start a transaction</span></span><br><span class="line">    <span class="keyword">using</span> (Transaction acTrans = acCurDb.TransactionManager.StartTransaction())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Open the Layer table for read</span></span><br><span class="line">        LayerTable acLyrTbl;</span><br><span class="line">        acLyrTbl = acTrans.GetObject(acCurDb.LayerTableId,</span><br><span class="line">                                        OpenMode.ForRead) <span class="keyword">as</span> LayerTable;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">string</span> sLayerName = <span class="string">&quot;ABC&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (acLyrTbl.Has(sLayerName) == <span class="literal">false</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">using</span> (LayerTableRecord acLyrTblRec = <span class="keyword">new</span> LayerTableRecord())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// Assign the layer a name</span></span><br><span class="line">                acLyrTblRec.Name = sLayerName;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Turn the layer off</span></span><br><span class="line">                acLyrTblRec.IsOff = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Upgrade the Layer table for write</span></span><br><span class="line">                acTrans.GetObject(acCurDb.LayerTableId, OpenMode.ForWrite);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Append the new layer to the Layer table and the transaction</span></span><br><span class="line">                acLyrTbl.Add(acLyrTblRec);</span><br><span class="line">                acTrans.AddNewlyCreatedDBObject(acLyrTblRec, <span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            LayerTableRecord acLyrTblRec = acTrans.GetObject(acLyrTbl[sLayerName],</span><br><span class="line">                                            OpenMode.ForWrite) <span class="keyword">as</span> LayerTableRecord;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Turn the layer off</span></span><br><span class="line">            acLyrTblRec.IsOff = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Open the Block table for read</span></span><br><span class="line">        BlockTable acBlkTbl;</span><br><span class="line">        acBlkTbl = acTrans.GetObject(acCurDb.BlockTableId,</span><br><span class="line">                                        OpenMode.ForRead) <span class="keyword">as</span> BlockTable;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Open the Block table record Model space for write</span></span><br><span class="line">        BlockTableRecord acBlkTblRec;</span><br><span class="line">        acBlkTblRec = acTrans.GetObject(acBlkTbl[BlockTableRecord.ModelSpace],</span><br><span class="line">                                        OpenMode.ForWrite) <span class="keyword">as</span> BlockTableRecord;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create a circle object</span></span><br><span class="line">        <span class="keyword">using</span> (Circle acCirc = <span class="keyword">new</span> Circle())</span><br><span class="line">        &#123;</span><br><span class="line">            acCirc.Center = <span class="keyword">new</span> Point3d(<span class="number">2</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">            acCirc.Radius = <span class="number">1</span>;</span><br><span class="line">            acCirc.Layer = sLayerName;</span><br><span class="line"></span><br><span class="line">            acBlkTblRec.AppendEntity(acCirc);</span><br><span class="line">            acTrans.AddNewlyCreatedDBObject(acCirc, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Save the changes and dispose of the transaction</span></span><br><span class="line">        acTrans.Commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="冻结和解冻图层（-NET）"><a href="#冻结和解冻图层（-NET）" class="headerlink" title="冻结和解冻图层（.NET）"></a>冻结和解冻图层（.NET）</h4><p>可以冻结图层以加快显示更改、提高对象选择性能并减少复杂图形的再生时间。AutoCAD不会显示、打印或重新生成冻结图层上的对象。冻结长时间不使用的图层。当您“解冻”冻结的图层时，AutoCAD会重新生成并显示该图层上的对象。</p>
<p>使用 IsFrozen 特性冻结或解冻图层。如果输入值 TRUE ，则图层将被冻结。如果输入值 FALSE ，则解冻图层。</p>
<p><strong>冻结图层</strong></p>
<p>此示例创建一个名为“ABC”的新层，然后冻结该层。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">CommandMethod(<span class="string">&quot;FreezeLayer&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">FreezeLayer</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Get the current document and database</span></span><br><span class="line">    Document acDoc = Application.DocumentManager.MdiActiveDocument;</span><br><span class="line">    Database acCurDb = acDoc.Database;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start a transaction</span></span><br><span class="line">    <span class="keyword">using</span> (Transaction acTrans = acCurDb.TransactionManager.StartTransaction())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Open the Layer table for read</span></span><br><span class="line">        LayerTable acLyrTbl;</span><br><span class="line">        acLyrTbl = acTrans.GetObject(acCurDb.LayerTableId,</span><br><span class="line">                                        OpenMode.ForRead) <span class="keyword">as</span> LayerTable;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">string</span> sLayerName = <span class="string">&quot;ABC&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (acLyrTbl.Has(sLayerName) == <span class="literal">false</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">using</span> (LayerTableRecord acLyrTblRec = <span class="keyword">new</span> LayerTableRecord())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// Assign the layer a name</span></span><br><span class="line">                acLyrTblRec.Name = sLayerName;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Freeze the layer</span></span><br><span class="line">                acLyrTblRec.IsFrozen = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Upgrade the Layer table for write</span></span><br><span class="line">                acTrans.GetObject(acCurDb.LayerTableId, OpenMode.ForWrite);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Append the new layer to the Layer table and the transaction</span></span><br><span class="line">                acLyrTbl.Add(acLyrTblRec);</span><br><span class="line">                acTrans.AddNewlyCreatedDBObject(acLyrTblRec, <span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            LayerTableRecord acLyrTblRec = acTrans.GetObject(acLyrTbl[sLayerName],</span><br><span class="line">                                            OpenMode.ForWrite) <span class="keyword">as</span> LayerTableRecord;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Freeze the layer</span></span><br><span class="line">            acLyrTblRec.IsFrozen = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Save the changes and dispose of the transaction</span></span><br><span class="line">        acTrans.Commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="锁定和解锁层（-NET）"><a href="#锁定和解锁层（-NET）" class="headerlink" title="锁定和解锁层（.NET）"></a>锁定和解锁层（.NET）</h4><p>无法编辑锁定图层上的对象;但是，如果图层打开并解冻，则这些对象仍然可见。您可以将锁定的图层置为当前图层，并向其添加对象。您可以冻结和关闭锁定的图层，并更改其关联的颜色和线型。</p>
<p>使用 IsLocked 特性锁定或解锁图层。如果输入值 TRUE ，则图层将被锁定。如果输入值 FALSE ，则图层将被解锁。</p>
<p>此示例创建一个名为“ABC”的新层，然后锁定该层。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">CommandMethod(<span class="string">&quot;LockLayer&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">LockLayer</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Get the current document and database</span></span><br><span class="line">    Document acDoc = Application.DocumentManager.MdiActiveDocument;</span><br><span class="line">    Database acCurDb = acDoc.Database;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start a transaction</span></span><br><span class="line">    <span class="keyword">using</span> (Transaction acTrans = acCurDb.TransactionManager.StartTransaction())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Open the Layer table for read</span></span><br><span class="line">        LayerTable acLyrTbl;</span><br><span class="line">        acLyrTbl = acTrans.GetObject(acCurDb.LayerTableId,</span><br><span class="line">                                        OpenMode.ForRead) <span class="keyword">as</span> LayerTable;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">string</span> sLayerName = <span class="string">&quot;ABC&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (acLyrTbl.Has(sLayerName) == <span class="literal">false</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">using</span> (LayerTableRecord acLyrTblRec = <span class="keyword">new</span> LayerTableRecord())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// Assign the layer a name</span></span><br><span class="line">                acLyrTblRec.Name = sLayerName;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Lock the layer</span></span><br><span class="line">                acLyrTblRec.IsLocked = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Upgrade the Layer table for write</span></span><br><span class="line">                acTrans.GetObject(acCurDb.LayerTableId, OpenMode.ForWrite);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Append the new layer to the Layer table and the transaction</span></span><br><span class="line">                acLyrTbl.Add(acLyrTblRec);</span><br><span class="line">                acTrans.AddNewlyCreatedDBObject(acLyrTblRec, <span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            LayerTableRecord acLyrTblRec = acTrans.GetObject(acLyrTbl[sLayerName],</span><br><span class="line">                                            OpenMode.ForWrite) <span class="keyword">as</span> LayerTableRecord;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Lock the layer</span></span><br><span class="line">            acLyrTblRec.IsLocked = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Save the changes and dispose of the transaction</span></span><br><span class="line">        acTrans.Commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="为图层指定颜色（-NET）"><a href="#为图层指定颜色（-NET）" class="headerlink" title="为图层指定颜色（.NET）"></a>为图层指定颜色（.NET）</h4><p>每一层都可以有自己的颜色。层的颜色由Color对象标识，该对象是Colors命名空间的一部分。该对象可以保存RGB值、ACI编号（1到255之间的整数）或配色系统颜色。</p>
<p>要为图层指定颜色，请使用 Color 特性。</p>
<p>注意：像直线和圆这样的对象支持两种不同的属性来控制它们的当前颜色。 Color 属性用于指定RGB值、ACI编号或配色系统颜色，而 ColorIndex 属性仅支持ACI编号。</p>
<p>如果使用ACI颜色0或“ByBlock”，AutoCAD将以默认颜色（白色或黑色，具体取决于配置）绘制新对象，直到将它们编组到块中。插入块后，块中的对象将继承当前特性设置。</p>
<p>如果使用ACI颜色256或ByLayer，则新对象将继承在其上绘制它们的图层的颜色。</p>
<p><strong>设置图层的颜色</strong></p>
<p>下面的示例创建三个新图层，并使用三种颜色方法中的每一种为每个图层指定不同的颜色。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">CommandMethod(<span class="string">&quot;SetLayerColor&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SetLayerColor</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Get the current document and database</span></span><br><span class="line">    Document acDoc = Application.DocumentManager.MdiActiveDocument;</span><br><span class="line">    Database acCurDb = acDoc.Database;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start a transaction</span></span><br><span class="line">    <span class="keyword">using</span> (Transaction acTrans = acCurDb.TransactionManager.StartTransaction())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Open the Layer table for read</span></span><br><span class="line">        LayerTable acLyrTbl;</span><br><span class="line">        acLyrTbl = acTrans.GetObject(acCurDb.LayerTableId,</span><br><span class="line">                                        OpenMode.ForRead) <span class="keyword">as</span> LayerTable;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Define an array of layer names</span></span><br><span class="line">        <span class="built_in">string</span>[] sLayerNames = <span class="keyword">new</span> <span class="built_in">string</span>[<span class="number">3</span>];</span><br><span class="line">        sLayerNames[<span class="number">0</span>] = <span class="string">&quot;ACIRed&quot;</span>;</span><br><span class="line">        sLayerNames[<span class="number">1</span>] = <span class="string">&quot;TrueBlue&quot;</span>;</span><br><span class="line">        sLayerNames[<span class="number">2</span>] = <span class="string">&quot;ColorBookYellow&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Define an array of colors for the layers</span></span><br><span class="line">        Color[] acColors = <span class="keyword">new</span> Color[<span class="number">3</span>];</span><br><span class="line">        acColors[<span class="number">0</span>] = Color.FromColorIndex(ColorMethod.ByAci, <span class="number">1</span>);</span><br><span class="line">        acColors[<span class="number">1</span>] = Color.FromRgb(<span class="number">23</span>, <span class="number">54</span>, <span class="number">232</span>);</span><br><span class="line">        acColors[<span class="number">2</span>] = Color.FromNames(<span class="string">&quot;PANTONE Yellow 0131 C&quot;</span>,</span><br><span class="line">                                      <span class="string">&quot;PANTONE+ Pastels &amp; Neons Coated&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">int</span> nCnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Add or change each layer in the drawing</span></span><br><span class="line">        <span class="keyword">foreach</span> (<span class="built_in">string</span> sLayerName <span class="keyword">in</span> sLayerNames)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (acLyrTbl.Has(sLayerName) == <span class="literal">false</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">using</span> (LayerTableRecord acLyrTblRec = <span class="keyword">new</span> LayerTableRecord())</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// Assign the layer a name</span></span><br><span class="line">                    acLyrTblRec.Name = sLayerName;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// Set the color of the layer</span></span><br><span class="line">                    acLyrTblRec.Color = acColors[nCnt];</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// Upgrade the Layer table for write</span></span><br><span class="line">                    <span class="keyword">if</span> (acLyrTbl.IsWriteEnabled == <span class="literal">false</span>) acTrans.GetObject(acCurDb.LayerTableId, OpenMode.ForWrite);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// Append the new layer to the Layer table and the transaction</span></span><br><span class="line">                    acLyrTbl.Add(acLyrTblRec);</span><br><span class="line">                    acTrans.AddNewlyCreatedDBObject(acLyrTblRec, <span class="literal">true</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// Open the layer if it already exists for write</span></span><br><span class="line">                LayerTableRecord acLyrTblRec = acTrans.GetObject(acLyrTbl[sLayerName],</span><br><span class="line">                                                                 OpenMode.ForWrite) <span class="keyword">as</span> LayerTableRecord;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Set the color of the layer</span></span><br><span class="line">                acLyrTblRec.Color = acColors[nCnt];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            nCnt = nCnt + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Save the changes and dispose of the transaction</span></span><br><span class="line">        acTrans.Commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="将线型指定给图层（-NET）"><a href="#将线型指定给图层（-NET）" class="headerlink" title="将线型指定给图层（.NET）"></a>将线型指定给图层（.NET）</h4><p>定义图层时，线型提供了另一种表达视觉信息的方式。线型是由短划线、点和空格组成的重复图案，可用于区分不同线条的用途。</p>
<p>线型名称和定义描述了特定的点划线序列、破折号和空格的相对长度以及任何包含的文字或形状的特征。</p>
<p>使用线型特性可以将线型指定给图层。此属性将线型的名称作为输入。</p>
<p>注意：必须先在图形中定义线型，然后才能将线型指定给图层。</p>
<p><strong>设置图层的线型</strong></p>
<p>下面的示例创建一个名为“ABC”的新图层，并为其指定“Center”线型。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">CommandMethod(<span class="string">&quot;SetLayerLinetype&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SetLayerLinetype</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Get the current document and database</span></span><br><span class="line">    Document acDoc = Application.DocumentManager.MdiActiveDocument;</span><br><span class="line">    Database acCurDb = acDoc.Database;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start a transaction</span></span><br><span class="line">    <span class="keyword">using</span> (Transaction acTrans = acCurDb.TransactionManager.StartTransaction())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Open the Layer table for read</span></span><br><span class="line">        LayerTable acLyrTbl;</span><br><span class="line">        acLyrTbl = acTrans.GetObject(acCurDb.LayerTableId,</span><br><span class="line">                                        OpenMode.ForRead) <span class="keyword">as</span> LayerTable;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">string</span> sLayerName = <span class="string">&quot;ABC&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (acLyrTbl.Has(sLayerName) == <span class="literal">false</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">using</span> (LayerTableRecord acLyrTblRec = <span class="keyword">new</span> LayerTableRecord())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// Assign the layer a name</span></span><br><span class="line">                acLyrTblRec.Name = sLayerName;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Open the Layer table for read</span></span><br><span class="line">                LinetypeTable acLinTbl;</span><br><span class="line">                acLinTbl = acTrans.GetObject(acCurDb.LinetypeTableId,</span><br><span class="line">                                                OpenMode.ForRead) <span class="keyword">as</span> LinetypeTable;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (acLinTbl.Has(<span class="string">&quot;Center&quot;</span>) == <span class="literal">true</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// Set the linetype for the layer</span></span><br><span class="line">                    acLyrTblRec.LinetypeObjectId = acLinTbl[<span class="string">&quot;Center&quot;</span>];</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Upgrade the Layer table for write</span></span><br><span class="line">                acTrans.GetObject(acCurDb.LayerTableId, OpenMode.ForWrite);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Append the new layer to the Layer table and the transaction</span></span><br><span class="line">                acLyrTbl.Add(acLyrTblRec);</span><br><span class="line">                acTrans.AddNewlyCreatedDBObject(acLyrTblRec, <span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            LayerTableRecord acLyrTblRec = acTrans.GetObject(acLyrTbl[sLayerName],</span><br><span class="line">                                            OpenMode.ForRead) <span class="keyword">as</span> LayerTableRecord;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Open the Layer table for read</span></span><br><span class="line">            LinetypeTable acLinTbl;</span><br><span class="line">            acLinTbl = acTrans.GetObject(acCurDb.LinetypeTableId,</span><br><span class="line">                                            OpenMode.ForRead) <span class="keyword">as</span> LinetypeTable;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (acLinTbl.Has(<span class="string">&quot;Center&quot;</span>) == <span class="literal">true</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// Upgrade the Layer Table Record for write</span></span><br><span class="line">                acTrans.GetObject(acLyrTbl[sLayerName], OpenMode.ForWrite);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Set the linetype for the layer</span></span><br><span class="line">                acLyrTblRec.LinetypeObjectId = acLinTbl[<span class="string">&quot;Center&quot;</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Save the changes and dispose of the transaction</span></span><br><span class="line">        acTrans.Commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="擦除图层（-NET）"><a href="#擦除图层（-NET）" class="headerlink" title="擦除图层（.NET）"></a>擦除图层（.NET）</h4><p>可以在绘图任务期间随时删除图层。不能删除当前图层、图层0、依赖外部参照的图层或包含对象的图层。</p>
<p>要擦除图层，请使用 Erase 方法。建议使用清除功能来验证是否可以清除层，沿着验证它是否不是层0、Defpoints或当前层。</p>
<p>注意：块定义所参照的图层以及名为DEFPOINTS的特殊图层沿着不能删除，即使它们不包含可见对象。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">CommandMethod(<span class="string">&quot;EraseLayer&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">EraseLayer</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Get the current document and database</span></span><br><span class="line">    Document acDoc = Application.DocumentManager.MdiActiveDocument;</span><br><span class="line">    Database acCurDb = acDoc.Database;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start a transaction</span></span><br><span class="line">    <span class="keyword">using</span> (Transaction acTrans = acCurDb.TransactionManager.StartTransaction())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Open the Layer table for read</span></span><br><span class="line">        LayerTable acLyrTbl;</span><br><span class="line">        acLyrTbl = acTrans.GetObject(acCurDb.LayerTableId,</span><br><span class="line">                                        OpenMode.ForRead) <span class="keyword">as</span> LayerTable;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">string</span> sLayerName = <span class="string">&quot;ABC&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (acLyrTbl.Has(sLayerName) == <span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Check to see if it is safe to erase layer</span></span><br><span class="line">            ObjectIdCollection acObjIdColl = <span class="keyword">new</span> ObjectIdCollection();</span><br><span class="line">            acObjIdColl.Add(acLyrTbl[sLayerName]);</span><br><span class="line">            acCurDb.Purge(acObjIdColl);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (acObjIdColl.Count &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                LayerTableRecord acLyrTblRec;</span><br><span class="line">                acLyrTblRec = acTrans.GetObject(acObjIdColl[<span class="number">0</span>],</span><br><span class="line">                                                OpenMode.ForWrite) <span class="keyword">as</span> LayerTableRecord;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// Erase the unreferenced layer</span></span><br><span class="line">                    acLyrTblRec.Erase(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// Save the changes and dispose of the transaction</span></span><br><span class="line">                    acTrans.Commit();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (Autodesk.AutoCAD.Runtime.Exception Ex)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// Layer could not be deleted</span></span><br><span class="line">                    Application.ShowAlertDialog(<span class="string">&quot;Error:\n&quot;</span> + Ex.Message);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用颜色（-NET）"><a href="#使用颜色（-NET）" class="headerlink" title="使用颜色（.NET）"></a>使用颜色（.NET）</h3><p>使用图形中单个对象的 Color 或 ColorIndex 特性为其指定颜色。 ColorIndex 特性接受AutoCAD颜色索引（ACI）值作为0 - 256的数值。 Color 属性用于为对象指定ACI编号、真彩色或配色系统颜色。要更改 Color 属性的值，可以使用 Colors 命名空间下的 Color 对象。</p>
<p>Color 对象有 SetRGB 方法，允许您根据将红色、绿色和蓝色值混合在一起从数百万种颜色组合中进行选择。 Color 对象还包含用于指定颜色名称、配色系统、颜色索引和颜色值的方法和属性。</p>
<p>也可以为图层指定颜色。如果希望对象继承其所在图层的颜色，请通过将其ACI值设置为256，将对象的颜色设置为ByLayer。任何数量的对象和图层都可以具有相同的颜色编号。您可以将每种颜色编号指定给画笔上的不同画笔，或者使用颜色编号来标识图形中的某些对象，即使您在屏幕上看不到颜色。</p>
<p>本节中的主题</p>
<ul>
<li>为对象指定颜色值（.NET）</li>
<li>通过数据库使颜色成为当前颜色（.NET）</li>
<li>使用CECOLOR系统变量（.NET）设置当前颜色</li>
</ul>
<h4 id="为对象指定颜色值（-NET）"><a href="#为对象指定颜色值（-NET）" class="headerlink" title="为对象指定颜色值（.NET）"></a>为对象指定颜色值（.NET）</h4><p>下面的示例创建四个圆，并使用四种不同的方法为每个圆指定不同的颜色。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">CommandMethod(<span class="string">&quot;SetObjectColor&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SetObjectColor</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Get the current document and database</span></span><br><span class="line">    Document acDoc = Application.DocumentManager.MdiActiveDocument;</span><br><span class="line">    Database acCurDb = acDoc.Database;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start a transaction</span></span><br><span class="line">    <span class="keyword">using</span> (Transaction acTrans = acCurDb.TransactionManager.StartTransaction())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Define an array of colors for the layers</span></span><br><span class="line">        Color[] acColors = <span class="keyword">new</span> Color[<span class="number">3</span>];</span><br><span class="line">        acColors[<span class="number">0</span>] = Color.FromColorIndex(ColorMethod.ByAci, <span class="number">1</span>);</span><br><span class="line">        acColors[<span class="number">1</span>] = Color.FromRgb(<span class="number">23</span>, <span class="number">54</span>, <span class="number">232</span>);</span><br><span class="line">        acColors[<span class="number">2</span>] = Color.FromNames(<span class="string">&quot;PANTONE Yellow 0131 C&quot;</span>,</span><br><span class="line">                                        <span class="string">&quot;PANTONE(R) pastel coated&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Open the Block table for read</span></span><br><span class="line">        BlockTable acBlkTbl;</span><br><span class="line">        acBlkTbl = acTrans.GetObject(acCurDb.BlockTableId,</span><br><span class="line">                                        OpenMode.ForRead) <span class="keyword">as</span> BlockTable;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Open the Block table record Model space for write</span></span><br><span class="line">        BlockTableRecord acBlkTblRec;</span><br><span class="line">        acBlkTblRec = acTrans.GetObject(acBlkTbl[BlockTableRecord.ModelSpace],</span><br><span class="line">                                        OpenMode.ForWrite) <span class="keyword">as</span> BlockTableRecord;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create a circle object and assign it the ACI value of 4</span></span><br><span class="line">        Point3d acPt = <span class="keyword">new</span> Point3d(<span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">using</span> (Circle acCirc = <span class="keyword">new</span> Circle())</span><br><span class="line">        &#123;</span><br><span class="line">            acCirc.Center = acPt;</span><br><span class="line">            acCirc.Radius = <span class="number">1</span>;</span><br><span class="line">            acCirc.ColorIndex = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">            acBlkTblRec.AppendEntity(acCirc);</span><br><span class="line">            acTrans.AddNewlyCreatedDBObject(acCirc, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">int</span> nCnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (nCnt &lt; <span class="number">3</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// Create a copy of the circle</span></span><br><span class="line">                Circle acCircCopy;</span><br><span class="line">                acCircCopy = acCirc.Clone() <span class="keyword">as</span> Circle;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Shift the copy along the Y-axis</span></span><br><span class="line">                acPt = <span class="keyword">new</span> Point3d(acPt.X, acPt.Y + <span class="number">3</span>, acPt.Z);</span><br><span class="line">                acCircCopy.Center = acPt;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Assign the new color to the circle</span></span><br><span class="line">                acCircCopy.Color = acColors[nCnt];</span><br><span class="line"></span><br><span class="line">                acBlkTblRec.AppendEntity(acCircCopy);</span><br><span class="line">                acTrans.AddNewlyCreatedDBObject(acCircCopy, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">                nCnt = nCnt + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Save the changes and dispose of the transaction</span></span><br><span class="line">        acTrans.Commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="通过数据库使颜色成为当前颜色（-NET）"><a href="#通过数据库使颜色成为当前颜色（-NET）" class="headerlink" title="通过数据库使颜色成为当前颜色（.NET）"></a>通过数据库使颜色成为当前颜色（.NET）</h4><p>此示例通过具有 Cecolor 属性的 Database 对象设置当前颜色。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">CommandMethod(<span class="string">&quot;SetColorCurrent&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SetColorCurrent</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Get the current document</span></span><br><span class="line">    Document acDoc = Application.DocumentManager.MdiActiveDocument;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Set the current color</span></span><br><span class="line">    acDoc.Database.Cecolor = Color.FromColorIndex(ColorMethod.ByLayer, <span class="number">256</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="使用CECOLOR系统变量（-NET）设置当前颜色"><a href="#使用CECOLOR系统变量（-NET）设置当前颜色" class="headerlink" title="使用CECOLOR系统变量（.NET）设置当前颜色"></a>使用CECOLOR系统变量（.NET）设置当前颜色</h4><p>此示例使用CECOLOR系统变量设置当前红色。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Application.SetSystemVariable(<span class="string">&quot;CECOLOR&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="使用线型（-NET）"><a href="#使用线型（-NET）" class="headerlink" title="使用线型（.NET）"></a>使用线型（.NET）</h3><p>线型是由短划线、点和空格组成的重复图案。复杂线型是符号的重复图案。要使用线型，必须首先将其加载到图形中。在将线型加载到图形中之前，LIN库文件中必须存在线型定义。要将线型加载到图形中，请使用 Database 对象的成员方法 LoadLineTypeFile 。</p>
<p>注意：AutoCAD内部使用的线型不应与某些绘图仪提供的硬件线型混淆。两种类型的虚线产生类似的结果。但是，不要同时使用这两种类型，因为结果可能无法预测。</p>
<p><strong>将线型加载到AutoCAD</strong></p>
<p>本示例尝试从acad.lin文件加载线型“CENTER”。如果线型已存在或文件不存在，则会显示一条消息。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">CommandMethod(<span class="string">&quot;LoadLinetype&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">LoadLinetype</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Get the current document and database</span></span><br><span class="line">    Document acDoc = Application.DocumentManager.MdiActiveDocument;</span><br><span class="line">    Database acCurDb = acDoc.Database;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start a transaction</span></span><br><span class="line">    <span class="keyword">using</span> (Transaction acTrans = acCurDb.TransactionManager.StartTransaction())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Open the Linetype table for read</span></span><br><span class="line">        LinetypeTable acLineTypTbl;</span><br><span class="line">        acLineTypTbl = acTrans.GetObject(acCurDb.LinetypeTableId,</span><br><span class="line">                                            OpenMode.ForRead) <span class="keyword">as</span> LinetypeTable;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">string</span> sLineTypName = <span class="string">&quot;Center&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (acLineTypTbl.Has(sLineTypName) == <span class="literal">false</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Load the Center Linetype</span></span><br><span class="line">            acCurDb.LoadLineTypeFile(sLineTypName, <span class="string">&quot;acad.lin&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Save the changes and dispose of the transaction</span></span><br><span class="line">        acTrans.Commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本节中的主题</p>
<ul>
<li>激活线型（.NET）</li>
<li>重命名线型（.NET）</li>
<li>删除线型（.NET）</li>
<li>更改线型说明（.NET）</li>
<li>指定线型比例（.NET）</li>
</ul>
<h4 id="激活线型（-NET）"><a href="#激活线型（-NET）" class="headerlink" title="激活线型（.NET）"></a>激活线型（.NET）</h4><p>要使用线型，必须将其激活。所有新创建的对象都将使用活动线型绘制。将线型应用于对象有两种不同的方法：直接或继承。您可以直接将线型指定给对象，该对象将覆盖指定给对象所在图层的线型。否则，对象将通过将其 Linetype 或 LinetypeId 属性设置为表示ByLayer线型来继承其所在图层的线型。</p>
<p>注意：不能激活依赖于外部参照的线型。</p>
<p>每个图形中都有三种线型：BYBLOCK、BYLAYER和CONTINUOUS。可以从Linetype表对象或使用 SymbolUtilityServices 对象中的方法访问这些线型中的每一种。使用以下方法可以获取这些默认线型的对象ID：</p>
<ul>
<li><strong>GetLinetypeByBlockId</strong>-返回BYBLOCK线型的对象ID。</li>
<li><strong>GetLinetypeByLayerId</strong>-返回BYLAYER线型的对象ID。</li>
<li><strong>GetLinetypeContinuousId</strong>-返回CONTINUOUS线型的对象ID。</li>
</ul>
<h5 id="将线型指定给对象（-NET）"><a href="#将线型指定给对象（-NET）" class="headerlink" title="将线型指定给对象（.NET）"></a>将线型指定给对象（.NET）</h5><p>下面的示例创建一个圆并为其指定“Center”线型。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">CommandMethod(<span class="string">&quot;SetObjectLinetype&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SetObjectLinetype</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Get the current document and database</span></span><br><span class="line">    Document acDoc = Application.DocumentManager.MdiActiveDocument;</span><br><span class="line">    Database acCurDb = acDoc.Database;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start a transaction</span></span><br><span class="line">    <span class="keyword">using</span> (Transaction acTrans = acCurDb.TransactionManager.StartTransaction())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Open the Linetype table for read</span></span><br><span class="line">        LinetypeTable acLineTypTbl;</span><br><span class="line">        acLineTypTbl = acTrans.GetObject(acCurDb.LinetypeTableId,</span><br><span class="line">                                            OpenMode.ForRead) <span class="keyword">as</span> LinetypeTable;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">string</span> sLineTypName = <span class="string">&quot;Center&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (acLineTypTbl.Has(sLineTypName) == <span class="literal">false</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            acCurDb.LoadLineTypeFile(sLineTypName, <span class="string">&quot;acad.lin&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Open the Block table for read</span></span><br><span class="line">        BlockTable acBlkTbl;</span><br><span class="line">        acBlkTbl = acTrans.GetObject(acCurDb.BlockTableId,</span><br><span class="line">                                        OpenMode.ForRead) <span class="keyword">as</span> BlockTable;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Open the Block table record Model space for write</span></span><br><span class="line">        BlockTableRecord acBlkTblRec;</span><br><span class="line">        acBlkTblRec = acTrans.GetObject(acBlkTbl[BlockTableRecord.ModelSpace],</span><br><span class="line">                                        OpenMode.ForWrite) <span class="keyword">as</span> BlockTableRecord;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create a circle object</span></span><br><span class="line">        <span class="keyword">using</span> (Circle acCirc = <span class="keyword">new</span> Circle())</span><br><span class="line">        &#123;</span><br><span class="line">            acCirc.Center = <span class="keyword">new</span> Point3d(<span class="number">2</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">            acCirc.Radius = <span class="number">1</span>;</span><br><span class="line">            acCirc.Linetype = sLineTypName;</span><br><span class="line"></span><br><span class="line">            acBlkTblRec.AppendEntity(acCirc);</span><br><span class="line">            acTrans.AddNewlyCreatedDBObject(acCirc, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Save the changes and dispose of the transaction</span></span><br><span class="line">        acTrans.Commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="通过数据库使线型成为当前线型（-NET）"><a href="#通过数据库使线型成为当前线型（-NET）" class="headerlink" title="通过数据库使线型成为当前线型（.NET）"></a>通过数据库使线型成为当前线型（.NET）</h5><p>此示例使用 Celtype 特性将线型设置为当前通过 Database 对象。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">CommandMethod(<span class="string">&quot;SetLinetypeCurrent&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SetLinetypeCurrent</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Get the current document and database</span></span><br><span class="line">    Document acDoc = Application.DocumentManager.MdiActiveDocument;</span><br><span class="line">    Database acCurDb = acDoc.Database;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start a transaction</span></span><br><span class="line">    <span class="keyword">using</span> (Transaction acTrans = acCurDb.TransactionManager.StartTransaction())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Open the Linetype table for read</span></span><br><span class="line">        LinetypeTable acLineTypTbl;</span><br><span class="line">        acLineTypTbl = acTrans.GetObject(acCurDb.LinetypeTableId,</span><br><span class="line">                                            OpenMode.ForRead) <span class="keyword">as</span> LinetypeTable;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">string</span> sLineTypName = <span class="string">&quot;Center&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (acLineTypTbl.Has(sLineTypName) == <span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Set the linetype Center current</span></span><br><span class="line">            acCurDb.Celtype = acLineTypTbl[sLineTypName];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Save the changes</span></span><br><span class="line">            acTrans.Commit();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Dispose of the transaction</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="使用CELTYPE系统变量（-NET）使线型成为当前线型"><a href="#使用CELTYPE系统变量（-NET）使线型成为当前线型" class="headerlink" title="使用CELTYPE系统变量（.NET）使线型成为当前线型"></a>使用CELTYPE系统变量（.NET）使线型成为当前线型</h5><p>此示例使用CELTYPE系统变量设置线型的当前值。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Application.SetSystemVariable(<span class="string">&quot;CELTYPE&quot;</span>, <span class="string">&quot;Center&quot;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="重命名线型（-NET）"><a href="#重命名线型（-NET）" class="headerlink" title="重命名线型（.NET）"></a>重命名线型（.NET）</h4><p>要重命名线型，请使用 Name 特性。重命名线型时，仅重命名图形中的线型定义。LIN库文件中的名称不会更新以反映新名称。</p>
<h4 id="删除线型（-NET）"><a href="#删除线型（-NET）" class="headerlink" title="删除线型（.NET）"></a>删除线型（.NET）</h4><p>要删除线型，请使用 Erase 方法。可以在绘图任务期间随时删除线型;但是，不能删除的线型包括BYLAYER、BYBLOCK、CONTINUOUS、当前线型、正在使用的线型和依赖外部参照的线型。此外，不能删除由块定义参照的线型，即使这些线型未被任何对象使用。</p>
<h4 id="更改线型说明（-NET）"><a href="#更改线型说明（-NET）" class="headerlink" title="更改线型说明（.NET）"></a>更改线型说明（.NET）</h4><p>线型可以具有与其关联的说明。说明提供了线型的ASCII表示形式。可以使用 AsciiDescription 特性指定或修改线型描述。</p>
<p>线型说明最多可包含47个字符。说明可以是注释或一系列下划线、点、破折号和空格，以显示线型图案的简单表示。</p>
<p><strong>更改线型的描述</strong></p>
<p>下面的示例更改当前线型的说明。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">CommandMethod(<span class="string">&quot;ChangeLinetypeDescription&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ChangeLinetypeDescription</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Get the current document and database</span></span><br><span class="line">    Document acDoc = Application.DocumentManager.MdiActiveDocument;</span><br><span class="line">    Database acCurDb = acDoc.Database;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Start a transaction</span></span><br><span class="line">    <span class="keyword">using</span> (Transaction acTrans = acCurDb.TransactionManager.StartTransaction())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Open the Linetype table record of the current linetype for write</span></span><br><span class="line">        LinetypeTableRecord acLineTypTblRec;</span><br><span class="line">        acLineTypTblRec = acTrans.GetObject(acCurDb.Celtype,</span><br><span class="line">                                            OpenMode.ForWrite) <span class="keyword">as</span> LinetypeTableRecord;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// Change the description of the current linetype</span></span><br><span class="line">        acLineTypTblRec.AsciiDescription = <span class="string">&quot;Exterior Wall&quot;</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// Save the changes and dispose of the transaction</span></span><br><span class="line">        acTrans.Commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="指定线型比例（-NET）"><a href="#指定线型比例（-NET）" class="headerlink" title="指定线型比例（.NET）"></a>指定线型比例（.NET）</h4><p>可以为创建的对象指定线型比例。比例越小，每个绘图单元生成的图案重复次数越多。默认情况下，AutoCAD使用的全局线型比例为1.0，等于一个图形单位。可以更改所有图形对象和属性参照的线型比例。</p>
<p>CELTSCALE系统变量可为新创建的对象设置线型比例。LTSCALE系统变量可更改现有对象和新对象的全局线型比例。对象的 LinetypeScale 特性用于更改对象的线型比例。对象显示时的线型比例基于单个对象的线型比例乘以全局线型比例。</p>
<p><strong>更改对象的线型比例</strong></p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">CommandMethod(<span class="string">&quot;SetObjectLinetypeScale&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SetObjectLinetypeScale</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Get the current document and database</span></span><br><span class="line">    Document acDoc = Application.DocumentManager.MdiActiveDocument;</span><br><span class="line">    Database acCurDb = acDoc.Database;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start a transaction</span></span><br><span class="line">    <span class="keyword">using</span> (Transaction acTrans = acCurDb.TransactionManager.StartTransaction())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Save the current linetype</span></span><br><span class="line">        ObjectId acObjId = acCurDb.Celtype;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Set the global linetype scale</span></span><br><span class="line">        acCurDb.Ltscale = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Open the Linetype table for read</span></span><br><span class="line">        LinetypeTable acLineTypTbl;</span><br><span class="line">        acLineTypTbl = acTrans.GetObject(acCurDb.LinetypeTableId,</span><br><span class="line">                                            OpenMode.ForRead) <span class="keyword">as</span> LinetypeTable;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">string</span> sLineTypName = <span class="string">&quot;Border&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (acLineTypTbl.Has(sLineTypName) == <span class="literal">false</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            acCurDb.LoadLineTypeFile(sLineTypName, <span class="string">&quot;acad.lin&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Set the Border linetype current</span></span><br><span class="line">        acCurDb.Celtype = acLineTypTbl[sLineTypName];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Open the Block table for read</span></span><br><span class="line">        BlockTable acBlkTbl;</span><br><span class="line">        acBlkTbl = acTrans.GetObject(acCurDb.BlockTableId,</span><br><span class="line">                                        OpenMode.ForRead) <span class="keyword">as</span> BlockTable;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Open the Block table record Model space for write</span></span><br><span class="line">        BlockTableRecord acBlkTblRec;</span><br><span class="line">        acBlkTblRec = acTrans.GetObject(acBlkTbl[BlockTableRecord.ModelSpace],</span><br><span class="line">                                        OpenMode.ForWrite) <span class="keyword">as</span> BlockTableRecord;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create a circle object and set its linetype</span></span><br><span class="line">        <span class="comment">// scale to half of full size</span></span><br><span class="line">        <span class="keyword">using</span> (Circle acCirc1 = <span class="keyword">new</span> Circle())</span><br><span class="line">        &#123;</span><br><span class="line">            acCirc1.Center = <span class="keyword">new</span> Point3d(<span class="number">2</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">            acCirc1.Radius = <span class="number">4</span>;</span><br><span class="line">            acCirc1.LinetypeScale = <span class="number">0.5</span>;</span><br><span class="line"></span><br><span class="line">            acBlkTblRec.AppendEntity(acCirc1);</span><br><span class="line">            acTrans.AddNewlyCreatedDBObject(acCirc1, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Create a second circle object</span></span><br><span class="line">            <span class="keyword">using</span> (Circle acCirc2 = <span class="keyword">new</span> Circle())</span><br><span class="line">            &#123;</span><br><span class="line">                acCirc2.Center = <span class="keyword">new</span> Point3d(<span class="number">12</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">                acCirc2.Radius = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">                acBlkTblRec.AppendEntity(acCirc2);</span><br><span class="line">                acTrans.AddNewlyCreatedDBObject(acCirc2, <span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Restore the original active linetype</span></span><br><span class="line">        acCurDb.Celtype = acObjId;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Save the changes and dispose of the transaction</span></span><br><span class="line">        acTrans.Commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="保存和恢复图层状态（-NET）"><a href="#保存和恢复图层状态（-NET）" class="headerlink" title="保存和恢复图层状态（.NET）"></a>保存和恢复图层状态（.NET）</h2><p>可以将图层状态保存在图形中，以后再恢复它们。这样，在完成图形或打印图形时，可以在不同阶段轻松返回所有图层的指定设置。</p>
<p>图层状态包括图层是否在新视口中打开、冻结、锁定、打印和自动冻结，以及图层的颜色、线型、线宽和打印样式。可以指定要保存的设置，也可以为图形保存不同的设置组。</p>
<p>LayerStateManager 用于保存和恢复图层状态。</p>
<p>本节中的主题</p>
<ul>
<li>了解AutoCAD图层的状态（.NET）</li>
<li>使用LayerStateManager管理图层状态（.NET）</li>
</ul>
<h3 id="了解AutoCAD图层的状态（-NET）"><a href="#了解AutoCAD图层的状态（-NET）" class="headerlink" title="了解AutoCAD图层的状态（.NET）"></a>了解AutoCAD图层的状态（.NET）</h3><p>AutoCAD将图层设置信息保存在 LayerTable 对象的扩展字典中。第一次保存图层状态时，AutoCAD将执行以下操作：</p>
<ul>
<li>在“层”（Layers）表格上创建扩展字典。</li>
<li>在扩展字典中创建名为ACAD_LAYERSTATE的 Dictionary 对象。</li>
<li>将图形中每个图层的特性存储在ACAD_LAYERSTATE字典的 XRecord 对象中。AutoCAD将所有图层设置存储在 XRecord 中，但会标识您选择保存的特定设置。恢复图层设置时，AutoCAD仅恢复选择保存的设置。</li>
</ul>
<p>每次在图形中保存另一个图层设置时，AutoCAD都会创建另一个描述已保存设置的 XRecord 对象，并将 XRecord 存储在ACAD_LAYERSTATE字典中。下图说明了该过程。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2024/ENU/OARX-DevGuide-Managed/images/GUID-4BF2DD1C-906F-48FE-8420-773791AE4631.png"></p>
<p>在处理图层状态时，不需要（也不应尝试）直接操作条目。使用 LayerStateManager 对象的函数访问字典。一旦您引用了字典，您就可以逐步浏览表示为 DBDictionaryEntry 对象的每个条目。</p>
<p><strong>列出图形中保存的图层状态</strong></p>
<p>如果图层状态已保存在当前图形中，以下代码将列出所有已保存图层状态的名称：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">CommandMethod(<span class="string">&quot;ListLayerStates&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ListLayerStates</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Get the current document and database</span></span><br><span class="line">    Document acDoc = Application.DocumentManager.MdiActiveDocument;</span><br><span class="line">    Database acCurDb = acDoc.Database;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start a transaction</span></span><br><span class="line">    <span class="keyword">using</span> (Transaction acTrans = acCurDb.TransactionManager.StartTransaction())</span><br><span class="line">    &#123;</span><br><span class="line">        LayerStateManager acLyrStMan;</span><br><span class="line">        acLyrStMan = acCurDb.LayerStateManager;</span><br><span class="line"></span><br><span class="line">        DBDictionary acDbDict;</span><br><span class="line">        acDbDict = acTrans.GetObject(acLyrStMan.LayerStatesDictionaryId(<span class="literal">true</span>),</span><br><span class="line">                                        OpenMode.ForRead) <span class="keyword">as</span> DBDictionary;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">string</span> sLayerStateNames = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">foreach</span> (DBDictionaryEntry acDbDictEnt <span class="keyword">in</span> acDbDict)</span><br><span class="line">        &#123;</span><br><span class="line">            sLayerStateNames = sLayerStateNames + <span class="string">&quot;\n&quot;</span> + acDbDictEnt.Key;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Application.ShowAlertDialog(<span class="string">&quot;The saved layer settings in this drawing are:&quot;</span> +</span><br><span class="line">                                    sLayerStateNames);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Dispose of the transaction</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用LayerStateManager管理图层状态（-NET）"><a href="#使用LayerStateManager管理图层状态（-NET）" class="headerlink" title="使用LayerStateManager管理图层状态（.NET）"></a>使用LayerStateManager管理图层状态（.NET）</h3><p>LayerStateManager 对象提供了一组用于创建和操作保存的图层状态的函数。使用以下 LayerStateManager 函数处理图层状态：</p>
<ul>
<li><p>DeleteLayerState</p>
<p>删除保存的图层状态。</p>
</li>
<li><p>ExportLayerState</p>
<p>将指定的已保存图层状态导出到LAS文件。</p>
</li>
<li><p>ImportLayerState</p>
<p>从指定的LAS文件导入图层状态。</p>
</li>
<li><p>ImportLayerStateFromDb</p>
<p>从其他数据库导入图层状态。</p>
</li>
<li><p>RenameLayerState</p>
<p>重命名保存的图层状态。</p>
</li>
<li><p>RestoreLayerState </p>
<p>恢复当前图形中的指定图层状态。</p>
</li>
<li><p>SaveLayerState</p>
<p>重新定义指定的图层状态及其属性。</p>
</li>
</ul>
<p>数据库的 LayerStateManager 对象可以通过使用 Database 对象的 LayerManagerState 属性来访问。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Document acDoc = Application.DocumentManager.MdiActiveDocument;</span><br><span class="line">Database acCurDb = acDoc.Database;</span><br><span class="line"> </span><br><span class="line">LayerStateManager acLyrStMan;</span><br><span class="line">acLyrStMan = acCurDb.LayerStateManager;</span><br></pre></td></tr></table></figure>

<p>本节中的主题</p>
<ul>
<li>保存图层状态（.NET）</li>
<li>重命名图层状态（.NET）</li>
<li>删除图层状态（.NET）</li>
<li>还原图层状态（.NET）</li>
<li>导出和导入保存的层状态（.NET）</li>
</ul>
<h4 id="保存图层状态（-NET）"><a href="#保存图层状态（-NET）" class="headerlink" title="保存图层状态（.NET）"></a>保存图层状态（.NET）</h4><p>使用 SaveLayerState 方法保存图形中的一组图层设置。 SaveLayerState 方法需要三个参数。第一个参数是命名要保存的图层状态的字符串。第二个参数标识要保存的图层特性。使用 LayerStateMasks 枚举的常量标识要保存的图层设置。下表列出了作为 LayerStateMasks 枚举一部分的常量。</p>
<p>图层状态掩码的属性</p>
<table>
<thead>
<tr>
<th align="left">Constant name</th>
<th align="left">Layer property</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Color</td>
<td align="left">Color</td>
</tr>
<tr>
<td align="left">CurrentViewport</td>
<td align="left">Current viewport layers frozen or thawed</td>
</tr>
<tr>
<td align="left">Frozen</td>
<td align="left">Frozen or thawed</td>
</tr>
<tr>
<td align="left">LastRestored</td>
<td align="left">Last restored layer</td>
</tr>
<tr>
<td align="left">LineType</td>
<td align="left">Linetype</td>
</tr>
<tr>
<td align="left">LineWeight</td>
<td align="left">Lineweight</td>
</tr>
<tr>
<td align="left">Locked</td>
<td align="left">Locked or unlocked</td>
</tr>
<tr>
<td align="left">NewViewport</td>
<td align="left">New viewport layers frozen or thawed</td>
</tr>
<tr>
<td align="left">None</td>
<td align="left">No layer settings</td>
</tr>
<tr>
<td align="left">On</td>
<td align="left">On or off</td>
</tr>
<tr>
<td align="left">Plot</td>
<td align="left">Plotting on or off</td>
</tr>
<tr>
<td align="left">PlotStyle</td>
<td align="left">Plot style</td>
</tr>
</tbody></table>
<p>将这些常数相加以指定多个属性。</p>
<p>第三个必需的参数是要保存其层设置的视口的对象ID。使用 ObjectId.Null 不指定视口。如果尝试以已存在的名称保存图层状态，将返回错误。必须先重命名或删除现有图层状态，然后才能重新使用该名称。</p>
<p><strong>保存图层的颜色和线型设置</strong></p>
<p>下面的代码将图形中当前图层的颜色和线型设置保存为ColorLinetype。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">CommandMethod(<span class="string">&quot;SaveLayerColorAndLinetype&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SaveLayerColorAndLinetype</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Get the current document</span></span><br><span class="line">    Document acDoc = Application.DocumentManager.MdiActiveDocument;</span><br><span class="line"> </span><br><span class="line">    LayerStateManager acLyrStMan;</span><br><span class="line">    acLyrStMan = acDoc.Database.LayerStateManager;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">string</span> sLyrStName = <span class="string">&quot;ColorLinetype&quot;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (acLyrStMan.HasLayerState(sLyrStName) == <span class="literal">false</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        acLyrStMan.SaveLayerState(sLyrStName,</span><br><span class="line">                                  LayerStateMasks.Color | </span><br><span class="line">                                  LayerStateMasks.LineType,</span><br><span class="line">                                  ObjectId.Null);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="重命名图层状态（-NET）"><a href="#重命名图层状态（-NET）" class="headerlink" title="重命名图层状态（.NET）"></a>重命名图层状态（.NET）</h4><p>RenameLayerState 方法将图形中保存的图层状态从一个名称重命名为另一个名称。下面的代码将ColorLinetype图层设置重命名为OldColorLinetype。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">CommandMethod(<span class="string">&quot;RenameLayerState&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">RenameLayerState</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Get the current document</span></span><br><span class="line">    Document acDoc = Application.DocumentManager.MdiActiveDocument;</span><br><span class="line"> </span><br><span class="line">    LayerStateManager acLyrStMan;</span><br><span class="line">    acLyrStMan = acDoc.Database.LayerStateManager;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">string</span> sLyrStName = <span class="string">&quot;ColorLinetype&quot;</span>;</span><br><span class="line">    <span class="built_in">string</span> sLyrStNewName = <span class="string">&quot;OldColorLinetype&quot;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (acLyrStMan.HasLayerState(sLyrStName) == <span class="literal">true</span> &amp;&amp;</span><br><span class="line">        acLyrStMan.HasLayerState(sLyrStNewName) == <span class="literal">false</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        acLyrStMan.RenameLayerState(sLyrStName, sLyrStNewName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="删除图层状态（-NET）"><a href="#删除图层状态（-NET）" class="headerlink" title="删除图层状态（.NET）"></a>删除图层状态（.NET）</h4><p>DeleteLayerState 方法从图形中删除保存的图层状态。下面的代码删除以ColorLinetype名称保存的图层状态。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">CommandMethod(<span class="string">&quot;RemoveLayerState&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">RemoveLayerState</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Get the current document</span></span><br><span class="line">    Document acDoc = Application.DocumentManager.MdiActiveDocument;</span><br><span class="line"></span><br><span class="line">    LayerStateManager acLyrStMan;</span><br><span class="line">    acLyrStMan = acDoc.Database.LayerStateManager;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> sLyrStName = <span class="string">&quot;ColorLinetype&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (acLyrStMan.HasLayerState(sLyrStName) == <span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        acLyrStMan.DeleteLayerState(sLyrStName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="还原图层状态（-NET）"><a href="#还原图层状态（-NET）" class="headerlink" title="还原图层状态（.NET）"></a>还原图层状态（.NET）</h4><p>RestoreLayerState 方法重置图层状态中的图层设置，需要四个值。第一个值是要恢复的图层状态的名称，第二个值是要恢复其图层设置的视口的对象ID。第三个值是一个整数，它定义如何处理不在层状态中的层。第四个值确定要恢复的图层设置。</p>
<p>以下值确定如何处理未处于图层状态的图层：</p>
<ul>
<li>0 - 不处于图层状态的图层保持不变</li>
<li>1 - 关闭不在图层状态的图层</li>
<li>2 - 不在图层状态的图层在当前视口中冻结</li>
<li>4 - 图层设置恢复为视口覆盖</li>
</ul>
<p>注意：您可以使用前面列出的多个值的总和来定义未处于图层状态的图层的恢复行为。例如，可以关闭并冻结未与图层状态一起保存的图层。</p>
<p>例如，如果将颜色和线型设置保存在名称“ColorLinetype”下，然后更改这些设置，则恢复“ColorLinetype”会将图层重置为保存“ColorLinetype”时的颜色和线型。如果在保存“ColorLinetype”后向图形中添加新图层，则在恢复“ColorLinetype”时，这些新图层不会受到影响。</p>
<p><strong>恢复图形图层的颜色和线型设置</strong></p>
<p>假设当前图形中图层的颜色和线型设置以前以“ColorLinetype”的名称保存，则以下代码会将图形中每个图层的颜色和线型设置恢复为保存“ColorLinetype”时的值。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">CommandMethod(<span class="string">&quot;RestoreLayerState&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">RestoreLayerState</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Get the current document</span></span><br><span class="line">    Document acDoc = Application.DocumentManager.MdiActiveDocument;</span><br><span class="line"> </span><br><span class="line">    LayerStateManager acLyrStMan;</span><br><span class="line">    acLyrStMan = acDoc.Database.LayerStateManager;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">string</span> sLyrStName = <span class="string">&quot;ColorLinetype&quot;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (acLyrStMan.HasLayerState(sLyrStName) == <span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        acLyrStMan.RestoreLayerState(sLyrStName,</span><br><span class="line">                                     ObjectId.Null,</span><br><span class="line">                                     <span class="number">1</span>,</span><br><span class="line">                                     LayerStateMasks.Color |</span><br><span class="line">                                     LayerStateMasks.LineType);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="导出和导入保存的层状态（-NET）"><a href="#导出和导入保存的层状态（-NET）" class="headerlink" title="导出和导入保存的层状态（.NET）"></a>导出和导入保存的层状态（.NET）</h4><p>可以输出和输入保存的图层状态，以便在其他图形中使用相同的图层设置。使用 ExportLayerState 方法将保存的图层状态输出到LAS文件;使用 ImportLayerState 方法将LAS文件输入到图形。</p>
<p>注意：删除图层状态不会恢复它们;导入图层状态后，必须使用 RestoreLayerState 方法恢复图层状态。</p>
<p>ExportLayerState 方法接受两个参数。第一个参数是标识要导出的已保存图层状态的字符串。第二个参数是要将图层状态导出到的文件的名称。如果未指定文件的路径，则该文件将保存在打开图形的同一目录中。如果指定的文件名已存在，则覆盖现有文件。使用.命名文件时使用las扩展名;这是AutoCAD为导出的图层状态文件识别的扩展名。</p>
<p>ImportLayerState 方法接受一个参数：一个字符串，用于命名包含要导入的图层状态的文件。如果要输入的图层状态不在LAS文件中，而在图形文件中。可以打开图形文件，然后使用 ImportLayerStateFromDb 方法从其他图形的Database对象导入图层状态。</p>
<p>输入图层状态时，如果保存的设置中引用的任何特性在要输入到的图形中不可用，则会引发错误条件。但是，导入已完成，并使用默认属性。例如，如果将导出的图层设置为未加载到要导入该图层的图形中的线型，则会引发错误条件，并替换图形的默认线型。您的代码应考虑此错误情况，并在引发此错误时继续处理。</p>
<p>如果输入的文件为当前图形中不存在的图层定义了设置，则将在当前图形中创建这些图层。使用 RestoreLayerState 方法时，保存设置时指定的特性将指定给新图层;新图层的所有其他特性将指定为默认设置。</p>
<p><strong>导出保存的图层设置</strong></p>
<p>下面的示例将保存的图层状态导出到名为ColorLinetype.las的文件中。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">CommandMethod(<span class="string">&quot;ExportLayerState&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ExportLayerState</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Get the current document</span></span><br><span class="line">    Document acDoc = Application.DocumentManager.MdiActiveDocument;</span><br><span class="line"></span><br><span class="line">    LayerStateManager acLyrStMan;</span><br><span class="line">    acLyrStMan = acDoc.Database.LayerStateManager;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> sLyrStName = <span class="string">&quot;ColorLinetype&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (acLyrStMan.HasLayerState(sLyrStName) == <span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        acLyrStMan.ExportLayerState(sLyrStName, <span class="string">&quot;c:\\my documents\\&quot;</span> +</span><br><span class="line">                                                sLyrStName + <span class="string">&quot;.las&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>导入保存的图层设置</strong></p>
<p>下面的示例从名为ColorLinetype.las的文件导入图层状态。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">CommandMethod(<span class="string">&quot;ImportLayerState&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ImportLayerState</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Get the current document</span></span><br><span class="line">    Document acDoc = Application.DocumentManager.MdiActiveDocument;</span><br><span class="line"></span><br><span class="line">    LayerStateManager acLyrStMan;</span><br><span class="line">    acLyrStMan = acDoc.Database.LayerStateManager;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> sLyrStFileName = <span class="string">&quot;c:\\my documents\\ColorLinetype.las&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (System.IO.File.Exists(sLyrStFileName))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            acLyrStMan.ImportLayerState(sLyrStFileName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Autodesk.AutoCAD.Runtime.Exception ex)</span><br><span class="line">        &#123;</span><br><span class="line">            Application.ShowAlertDialog(ex.Message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="将文本添加到图形（-NET）"><a href="#将文本添加到图形（-NET）" class="headerlink" title="将文本添加到图形（.NET）"></a>将文本添加到图形（.NET）</h2><p>文字传达图形中的重要信息。将文字对象用于标题栏、标记工程图的各个部分、给出规格或进行注释。</p>
<p>AutoCAD提供了多种创建文字的方法。对于简短的条目，请使用单行文本。对于具有内部格式的较长条目，请使用多行文本（ MText ）。尽管所有输入的文本都使用当前文本样式（该样式用于建立默认字体和格式设置），但您可以使用多种方法自定义文本外观。</p>
<p>本节中的主题</p>
<ul>
<li>使用多行文本（.NET）</li>
<li>使用单行文字（.NET）</li>
<li>使用文本样式（.NET）</li>
<li>使用Unicode字符、控制代码和特殊字符（.NET）</li>
<li>拼写检查（.NET）</li>
</ul>
<h3 id="使用多行文本（-NET）"><a href="#使用多行文本（-NET）" class="headerlink" title="使用多行文本（.NET）"></a>使用多行文本（.NET）</h3><p>对于较长的复杂条目，请创建多行文本（ MText ）。多行文字适合指定的宽度，但可以垂直延伸到任意长度。您可以在 MText.</p>
<p> 本节中的主题</p>
<ul>
<li>创建多行文本（.NET）</li>
<li>设置多行文字格式（.NET）</li>
</ul>
<h4 id="创建多行文本（-NET）"><a href="#创建多行文本（-NET）" class="headerlink" title="创建多行文本（.NET）"></a>创建多行文本（.NET）</h4><p>先创建 MText 对象的实例，然后将其添加到表示模型或图纸空间的块表记录中，可以创建多行文字对象。 MText 对象构造函数不带任何参数。创建 MText 对象的实例后，可以使用其属性为其分配文本字符串、插入点和宽度等值。您可以更改的其他属性会影响对象的文字高度、对正、旋转角度和文字样式，或将字符格式应用于选定字符</p>
<p><strong>创建多行文字对象</strong></p>
<p>以下示例在模型空间中的坐标（2，2，0）处创建一个 MText 对象。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">CommandMethod(<span class="string">&quot;CreateMText&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CreateMText</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Get the current document and database</span></span><br><span class="line">    Document acDoc = Application.DocumentManager.MdiActiveDocument;</span><br><span class="line">    Database acCurDb = acDoc.Database;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start a transaction</span></span><br><span class="line">    <span class="keyword">using</span> (Transaction acTrans = acCurDb.TransactionManager.StartTransaction())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Open the Block table for read</span></span><br><span class="line">        BlockTable acBlkTbl;</span><br><span class="line">        acBlkTbl = acTrans.GetObject(acCurDb.BlockTableId,</span><br><span class="line">                                        OpenMode.ForRead) <span class="keyword">as</span> BlockTable;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Open the Block table record Model space for write</span></span><br><span class="line">        BlockTableRecord acBlkTblRec;</span><br><span class="line">        acBlkTblRec = acTrans.GetObject(acBlkTbl[BlockTableRecord.ModelSpace],</span><br><span class="line">                                        OpenMode.ForWrite) <span class="keyword">as</span> BlockTableRecord;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create a multiline text object</span></span><br><span class="line">        <span class="keyword">using</span> (MText acMText = <span class="keyword">new</span> MText())</span><br><span class="line">        &#123;</span><br><span class="line">            acMText.Location = <span class="keyword">new</span> Point3d(<span class="number">2</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">            acMText.Width = <span class="number">4</span>;</span><br><span class="line">            acMText.Contents = <span class="string">&quot;This is a text string for the MText object.&quot;</span>;</span><br><span class="line"></span><br><span class="line">            acBlkTblRec.AppendEntity(acMText);</span><br><span class="line">            acTrans.AddNewlyCreatedDBObject(acMText, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Save the changes and dispose of the transaction</span></span><br><span class="line">        acTrans.Commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="设置多行文字格式（-NET）"><a href="#设置多行文字格式（-NET）" class="headerlink" title="设置多行文字格式（.NET）"></a>设置多行文字格式（.NET）</h4><p>新创建的多行文字将自动采用当前文字样式的特征。默认文字样式为STANDARD。通过将格式应用于单个字符并将特性应用于多行文字对象，可以替代默认文字样式。您还可以使用本节中描述的方法指示格式或特殊字符。</p>
<p>方向选项（如样式、对正、宽度和旋转）影响多行文字边界内的所有文字，而不影响特定的单词或字符。使用 Attachment 特性可以更改多行文字对象的对齐方式，使用 Rotation 特性可以控制旋转角度。</p>
<p>TextStyleId 属性设置多行文字对象的字体和格式特征。创建多行文字时，可以从现有样式列表中选择要使用的样式。如果多行文字对象的任何部分都应用了字符格式，则更改该多行文字对象的样式时，样式将应用于整个对象，并且某些字符格式可能不会保留。例如，从TrueType样式更改为使用SHX字体的样式或其他TrueType字体会导致多行文字在整个对象中使用新字体，并且所有字符格式都将丢失。</p>
<p>下划线、堆叠文本或字体等可选选项可以应用于段落中的单个单词或字符。您还可以更改颜色、字体和文本高度。您可以更改文本字符之间的空格或增加字符的宽度。</p>
<p>使用大括号（{ }）仅对大括号内的文本应用格式更改。可以嵌套最多八层深度的支撑。</p>
<p>也可以在行或段落中输入控制代码的ASCII等效值，以指示格式或特殊字符，如公差或标注符号。</p>
<p>以下控制字符可用于创建插图中的文本。(For这个字符串的ASCII等价物，请参见下图中的示例。）</p>
<p><img src="https://help.autodesk.com/cloudhelp/2024/ENU/OARX-DevGuide-Managed/images/GUID-5414BF42-141D-4060-8C91-A873BC316192.png"></p>
<p><strong>使用控制字符设置文本格式</strong></p>
<p>下面的示例创建多行文本对象并设置其格式。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">CommandMethod(<span class="string">&quot;FormatMText&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">FormatMText</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Get the current document and database</span></span><br><span class="line">    Document acDoc = Application.DocumentManager.MdiActiveDocument;</span><br><span class="line">    Database acCurDb = acDoc.Database;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start a transaction</span></span><br><span class="line">    <span class="keyword">using</span> (Transaction acTrans = acCurDb.TransactionManager.StartTransaction())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Open the Block table for read</span></span><br><span class="line">        BlockTable acBlkTbl;</span><br><span class="line">        acBlkTbl = acTrans.GetObject(acCurDb.BlockTableId,</span><br><span class="line">                                        OpenMode.ForRead) <span class="keyword">as</span> BlockTable;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Open the Block table record Model space for write</span></span><br><span class="line">        BlockTableRecord acBlkTblRec;</span><br><span class="line">        acBlkTblRec = acTrans.GetObject(acBlkTbl[BlockTableRecord.ModelSpace],</span><br><span class="line">                                        OpenMode.ForWrite) <span class="keyword">as</span> BlockTableRecord;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create a multiline text object</span></span><br><span class="line">        <span class="keyword">using</span> (MText acMText = <span class="keyword">new</span> MText())</span><br><span class="line">        &#123;</span><br><span class="line">            acMText.Location = <span class="keyword">new</span> Point3d(<span class="number">2</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">            acMText.Width = <span class="number">4.5</span>;</span><br><span class="line">            acMText.Contents = <span class="string">&quot;&#123;&#123;\\H1.5x; Big text&#125;\\A2; over text\\A1;/\\A0;under text&#125;&quot;</span>;</span><br><span class="line"></span><br><span class="line">            acBlkTblRec.AppendEntity(acMText);</span><br><span class="line">            acTrans.AddNewlyCreatedDBObject(acMText, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Save the changes and dispose of the transaction</span></span><br><span class="line">        acTrans.Commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用单行文字（-NET）"><a href="#使用单行文字（-NET）" class="headerlink" title="使用单行文字（.NET）"></a>使用单行文字（.NET）</h3><p>添加到图形中的文字可传达各种信息。它可以是复杂的规范、标题栏信息、标签，甚至是图形的一部分。对于不需要多个字体或行的较短条目，请创建一个 DBText 对象的实例，该对象表示单行文本，便于标签。</p>
<p>本节中的主题</p>
<ul>
<li>创建单行文本（.NET）</li>
<li>更改单行文字（.NET）</li>
<li>设置文本高度（.NET）</li>
<li>设置单行文本格式（.NET）</li>
</ul>
<h4 id="创建单行文本（-NET）"><a href="#创建单行文本（-NET）" class="headerlink" title="创建单行文本（.NET）"></a>创建单行文本（.NET）</h4><p>使用单行文字时，每一行文字都是一个不同的对象。若要创建单行文字对象，请创建 DBText 对象的实例，然后将其添加到表示模型或图纸空间的块表记录中。当你创建一个 DBText 对象的新实例时，你不需要给构造函数传递任何参数。</p>
<p><strong>创建线文本</strong></p>
<p>下面的示例在模型空间中的坐标（2，2，0）处创建一个单行文字对象，高度为0.5，文字字符串为“Hello，World. “.</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">CommandMethod(<span class="string">&quot;CreateText&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CreateText</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Get the current document and database</span></span><br><span class="line">    Document acDoc = Application.DocumentManager.MdiActiveDocument;</span><br><span class="line">    Database acCurDb = acDoc.Database;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start a transaction</span></span><br><span class="line">    <span class="keyword">using</span> (Transaction acTrans = acCurDb.TransactionManager.StartTransaction())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Open the Block table for read</span></span><br><span class="line">        BlockTable acBlkTbl;</span><br><span class="line">        acBlkTbl = acTrans.GetObject(acCurDb.BlockTableId,</span><br><span class="line">                                        OpenMode.ForRead) <span class="keyword">as</span> BlockTable;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Open the Block table record Model space for write</span></span><br><span class="line">        BlockTableRecord acBlkTblRec;</span><br><span class="line">        acBlkTblRec = acTrans.GetObject(acBlkTbl[BlockTableRecord.ModelSpace],</span><br><span class="line">                                        OpenMode.ForWrite) <span class="keyword">as</span> BlockTableRecord;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create a single-line text object</span></span><br><span class="line">        <span class="keyword">using</span> (DBText acText = <span class="keyword">new</span> DBText())</span><br><span class="line">        &#123;</span><br><span class="line">            acText.Position = <span class="keyword">new</span> Point3d(<span class="number">2</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">            acText.Height = <span class="number">0.5</span>;</span><br><span class="line">            acText.TextString = <span class="string">&quot;Hello, World.&quot;</span>;</span><br><span class="line"></span><br><span class="line">            acBlkTblRec.AppendEntity(acText);</span><br><span class="line">            acTrans.AddNewlyCreatedDBObject(acText, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Save the changes and dispose of the transaction</span></span><br><span class="line">        acTrans.Commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="更改单行文字（-NET）"><a href="#更改单行文字（-NET）" class="headerlink" title="更改单行文字（.NET）"></a>更改单行文字（.NET）</h4><p>与任何其他对象一样，文本对象可以移动、旋转、擦除和复制。您也可以镜像文本。如果不希望文字在镜像时反转，则可以将MIRTEXT系统变量设置为0。您可以使用 TransformBy 和 Clone 方法移动、旋转和复制对象。</p>
<h4 id="设置文本高度（-NET）"><a href="#设置文本高度（-NET）" class="headerlink" title="设置文本高度（.NET）"></a>设置文本高度（.NET）</h4><p>文字高度决定所用字体中字母的图形单位大小。该值通常表示字体的大小，但TrueType字体除外。</p>
<p>对于TrueType字体，为文本高度指定的值可能不表示小写字母的高度。指定的高度表示大写字母的高度加上为重音标记和非英语语言中使用的其他标记保留的重音区域。分配给大写字母和重音字符的区域的相对部分由字体设计者在设计字体时确定，因此，将因字体而异。</p>
<p>除了大写字母的高度和构成用户指定高度的上升区域外，TrueType字体还有一个下降区域，用于延伸到文本插入行以下的字符部分。此类字符的示例包括y、j、p、g和q。</p>
<p>可以使用文字样式的 TextSize 属性或文字对象的 Height 属性指定文字高度。此属性只接受正数。</p>
<h4 id="设置单行文本格式（-NET）"><a href="#设置单行文本格式（-NET）" class="headerlink" title="设置单行文本格式（.NET）"></a>设置单行文本格式（.NET）</h4><p>将使用激活的文字样式创建单文字对象。可以通过更改与单行文字对象关联的文字样式或直接编辑单行文字对象的特性来更改单行文字对象的格式。<em>不能</em>将格式应用于单行文本对象中的单个单词和字符。</p>
<p>要更改与单个单行文字对象关联的文字样式，请将 TextStyleId 特性设置为新的文字样式。更改文字样式后，必须重新生成图形或更新对象才能查看图形中的更改。</p>
<p>除了图元的标准可编辑特性（颜色、图层、线型等）外，还可以在单行文字对象上更改以下特性：</p>
<ul>
<li><p>HorizontalMode</p>
<p>指定文本的水平对齐方式。</p>
</li>
<li><p>VerticalMode </p>
<p>指定文本的垂直对齐方式。</p>
</li>
<li><p>Position </p>
<p>指定文字的插入点。</p>
</li>
<li><p>Oblique </p>
<p>指定单个文字对象的倾斜角度。</p>
</li>
<li><p>Rotation </p>
<p>以弧度为单位指定文字的旋转角度。</p>
</li>
<li><p>WidthFactor </p>
<p>指定文字的比例因子。</p>
</li>
<li><p>AlignmentPoint</p>
<p>指定文字的对齐点。</p>
</li>
<li><p>IsMirroredInX</p>
<p>指定文本是否向后显示。</p>
</li>
<li><p>IsMirroredInY</p>
<p>指定文本是否颠倒显示。</p>
</li>
<li><p>TextString</p>
<p>指定显示的实际文本字符串。</p>
</li>
</ul>
<p>更改特性后，请重新生成图形或更新对象以查看所做的更改。</p>
<p>本节中的主题</p>
<ul>
<li>设置倾斜角度(.NET)</li>
<li>对齐单行文字（.NET）</li>
<li>设置文本生成标记(.NET)</li>
</ul>
<h5 id="设置倾斜角度-NET"><a href="#设置倾斜角度-NET" class="headerlink" title="设置倾斜角度(.NET)"></a>设置倾斜角度(.NET)</h5><p>倾斜角度决定文本的向前或向后倾斜。角度表示相对于其垂直轴的偏移（90度）。要设置倾斜角度，请使用 ObliquingAngle 属性更改文本样式或文本对象的 Oblique 属性。必须以弧度为单位提供倾斜角。正角度表示向右倾斜，负值将添加 2*PI 以将其转换为正等效值。</p>
<p><strong>创建倾斜文本</strong></p>
<p>这个例子创建了一个单行文本对象，然后将其倾斜45度。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">CommandMethod(<span class="string">&quot;ObliqueText&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ObliqueText</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Get the current document and database</span></span><br><span class="line">    Document acDoc = Application.DocumentManager.MdiActiveDocument;</span><br><span class="line">    Database acCurDb = acDoc.Database;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start a transaction</span></span><br><span class="line">    <span class="keyword">using</span> (Transaction acTrans = acCurDb.TransactionManager.StartTransaction())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Open the Block table for read</span></span><br><span class="line">        BlockTable acBlkTbl;</span><br><span class="line">        acBlkTbl = acTrans.GetObject(acCurDb.BlockTableId,</span><br><span class="line">                                        OpenMode.ForRead) <span class="keyword">as</span> BlockTable;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Open the Block table record Model space for write</span></span><br><span class="line">        BlockTableRecord acBlkTblRec;</span><br><span class="line">        acBlkTblRec = acTrans.GetObject(acBlkTbl[BlockTableRecord.ModelSpace],</span><br><span class="line">                                        OpenMode.ForWrite) <span class="keyword">as</span> BlockTableRecord;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create a single-line text object</span></span><br><span class="line">        <span class="keyword">using</span> (DBText acText = <span class="keyword">new</span> DBText())</span><br><span class="line">        &#123;</span><br><span class="line">            acText.Position = <span class="keyword">new</span> Point3d(<span class="number">3</span>, <span class="number">3</span>, <span class="number">0</span>);</span><br><span class="line">            acText.Height = <span class="number">0.5</span>;</span><br><span class="line">            acText.TextString = <span class="string">&quot;Hello, World.&quot;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Change the oblique angle of the text object to 45 degrees(0.707 in radians)</span></span><br><span class="line">            acText.Oblique = <span class="number">0.707</span>;</span><br><span class="line"></span><br><span class="line">            acBlkTblRec.AppendEntity(acText);</span><br><span class="line">            acTrans.AddNewlyCreatedDBObject(acText, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Save the changes and dispose of the transaction</span></span><br><span class="line">        acTrans.Commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="对齐单行文字（-NET）"><a href="#对齐单行文字（-NET）" class="headerlink" title="对齐单行文字（.NET）"></a>对齐单行文字（.NET）</h5><p>您可以水平和垂直对齐单行文字。左对齐是默认设置。要设置水平和垂直对齐选项，请使用 HorizontalMode 和 VerticalMode 属性。</p>
<p>通常，当文字对象关闭时，文字对象的位置和对齐点将根据其对正和文字样式进行调整。但是，内存中文本对象的对齐方式不会自动更新。调用 AdjustAlignment 方法，根据当前属性值更新文本对象的对齐方式。</p>
<p><strong>重新对齐文本</strong></p>
<p>下面的示例创建一个单行文本（ DBText ）对象和一个点（ DBPoint ）对象。点对象将设置为文字对齐点，并更改为红色十字准线，使其可见。文本对齐方式将更改，并显示一个消息框，以便暂停宏的执行。这使您可以查看更改文本对齐方式的影响。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">CommandMethod(<span class="string">&quot;TextAlignment&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">TextAlignment</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Get the current document and database</span></span><br><span class="line">    Document acDoc = Application.DocumentManager.MdiActiveDocument;</span><br><span class="line">    Database acCurDb = acDoc.Database;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start a transaction</span></span><br><span class="line">    <span class="keyword">using</span> (Transaction acTrans = acCurDb.TransactionManager.StartTransaction())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Open the Block table for read</span></span><br><span class="line">        BlockTable acBlkTbl;</span><br><span class="line">        acBlkTbl = acTrans.GetObject(acCurDb.BlockTableId,</span><br><span class="line">                                        OpenMode.ForRead) <span class="keyword">as</span> BlockTable;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Open the Block table record Model space for write</span></span><br><span class="line">        BlockTableRecord acBlkTblRec;</span><br><span class="line">        acBlkTblRec = acTrans.GetObject(acBlkTbl[BlockTableRecord.ModelSpace],</span><br><span class="line">                                        OpenMode.ForWrite) <span class="keyword">as</span> BlockTableRecord;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">string</span>[] textString = <span class="keyword">new</span> <span class="built_in">string</span>[<span class="number">3</span>];</span><br><span class="line">        textString[<span class="number">0</span>] = <span class="string">&quot;Left&quot;</span>;</span><br><span class="line">        textString[<span class="number">1</span>] = <span class="string">&quot;Center&quot;</span>;</span><br><span class="line">        textString[<span class="number">2</span>] = <span class="string">&quot;Right&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">int</span>[] textAlign = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">3</span>];</span><br><span class="line">        textAlign[<span class="number">0</span>] = (<span class="built_in">int</span>)TextHorizontalMode.TextLeft;</span><br><span class="line">        textAlign[<span class="number">1</span>] = (<span class="built_in">int</span>)TextHorizontalMode.TextCenter;</span><br><span class="line">        textAlign[<span class="number">2</span>] = (<span class="built_in">int</span>)TextHorizontalMode.TextRight;</span><br><span class="line"></span><br><span class="line">        Point3d acPtIns = <span class="keyword">new</span> Point3d(<span class="number">3</span>, <span class="number">3</span>, <span class="number">0</span>);</span><br><span class="line">        Point3d acPtAlign = <span class="keyword">new</span> Point3d(<span class="number">3</span>, <span class="number">3</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">int</span> nCnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">foreach</span> (<span class="built_in">string</span> strVal <span class="keyword">in</span> textString)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Create a single-line text object</span></span><br><span class="line">            <span class="keyword">using</span> (DBText acText = <span class="keyword">new</span> DBText())</span><br><span class="line">            &#123;</span><br><span class="line">                acText.Position = acPtIns;</span><br><span class="line">                acText.Height = <span class="number">0.5</span>;</span><br><span class="line">                acText.TextString = strVal;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Set the alignment for the text</span></span><br><span class="line">                acText.HorizontalMode = (TextHorizontalMode)textAlign[nCnt];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (acText.HorizontalMode != TextHorizontalMode.TextLeft)</span><br><span class="line">                &#123;</span><br><span class="line">                    acText.AlignmentPoint = acPtAlign;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                acBlkTblRec.AppendEntity(acText);</span><br><span class="line">                acTrans.AddNewlyCreatedDBObject(acText, <span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Create a point over the alignment point of the text</span></span><br><span class="line">            <span class="keyword">using</span> (DBPoint acPoint = <span class="keyword">new</span> DBPoint(acPtAlign))</span><br><span class="line">            &#123;</span><br><span class="line">                acPoint.ColorIndex = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                acBlkTblRec.AppendEntity(acPoint);</span><br><span class="line">                acTrans.AddNewlyCreatedDBObject(acPoint, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Adjust the insertion and alignment points</span></span><br><span class="line">                acPtIns = <span class="keyword">new</span> Point3d(acPtIns.X, acPtIns.Y + <span class="number">3</span>, <span class="number">0</span>);</span><br><span class="line">                acPtAlign = acPtIns;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            nCnt = nCnt + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Set the point style to crosshair</span></span><br><span class="line">        Application.SetSystemVariable(<span class="string">&quot;PDMODE&quot;</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Save the changes and dispose of the transaction</span></span><br><span class="line">        acTrans.Commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="设置文本生成标记（-NET）"><a href="#设置文本生成标记（-NET）" class="headerlink" title="设置文本生成标记（.NET）"></a>设置文本生成标记（.NET）</h5><p>文本生成标志指定文本是向后显示还是上下颠倒显示。使用 FlagBits 属性定义文本样式是控制文本的显示是向后显示还是上下颠倒显示，或者使用文本对象的 IsMirroredInX 和 IsMirroredInY 属性分别控制文本对象。</p>
<p>如果您希望文本向后显示，请将 FlagBits 设置为2;如果文本应该颠倒显示，请将 FlagBits 设置为4。使用值6可同时向后和颠倒显示文本。如果您正在修改文本对象，如果您希望文本向后显示，请将 IsMirroredInX 设置为 TRUE ，如果您希望文本上下显示，请将 IsMirroredInY 设置为TRUE。</p>
<p><strong>向后显示文本</strong></p>
<p>下面的示例创建一个单行文本对象，然后使用 IsMirroredInX 属性将其设置为向后显示。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">CommandMethod(<span class="string">&quot;BackwardsText&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">BackwardsText</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Get the current document and database</span></span><br><span class="line">    Document acDoc = Application.DocumentManager.MdiActiveDocument;</span><br><span class="line">    Database acCurDb = acDoc.Database;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start a transaction</span></span><br><span class="line">    <span class="keyword">using</span> (Transaction acTrans = acCurDb.TransactionManager.StartTransaction())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Open the Block table for read</span></span><br><span class="line">        BlockTable acBlkTbl;</span><br><span class="line">        acBlkTbl = acTrans.GetObject(acCurDb.BlockTableId,</span><br><span class="line">                                        OpenMode.ForRead) <span class="keyword">as</span> BlockTable;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Open the Block table record Model space for write</span></span><br><span class="line">        BlockTableRecord acBlkTblRec;</span><br><span class="line">        acBlkTblRec = acTrans.GetObject(acBlkTbl[BlockTableRecord.ModelSpace],</span><br><span class="line">                                        OpenMode.ForWrite) <span class="keyword">as</span> BlockTableRecord;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create a single-line text object</span></span><br><span class="line">        <span class="keyword">using</span> (DBText acText = <span class="keyword">new</span> DBText())</span><br><span class="line">        &#123;</span><br><span class="line">            acText.Position = <span class="keyword">new</span> Point3d(<span class="number">3</span>, <span class="number">3</span>, <span class="number">0</span>);</span><br><span class="line">            acText.Height = <span class="number">0.5</span>;</span><br><span class="line">            acText.TextString = <span class="string">&quot;Hello, World.&quot;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Display the text backwards</span></span><br><span class="line">            acText.IsMirroredInX = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            acBlkTblRec.AppendEntity(acText);</span><br><span class="line">            acTrans.AddNewlyCreatedDBObject(acText, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Save the changes and dispose of the transaction</span></span><br><span class="line">        acTrans.Commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用文本样式（-NET）"><a href="#使用文本样式（-NET）" class="headerlink" title="使用文本样式（.NET）"></a>使用文本样式（.NET）</h3><p>图形中的所有文本都有一个与之关联的样式。输入文本时，AutoCAD将使用当前文本样式，该样式用于设置字体、大小、角度、方向和其他文本特征。可以使用或修改默认样式，也可以创建和加载新样式。创建样式后，可以修改其属性，或在不再需要时将其删除。</p>
<p>本节中的主题</p>
<ul>
<li>创建和修改文本样式（.NET）</li>
<li>指定字体（.NET）</li>
<li>使用TrueType字体（.NET）</li>
<li>使用Unicode和大字体（.NET）</li>
<li>替代字体（.NET）</li>
</ul>
<h4 id="创建和修改文本样式（-NET）"><a href="#创建和修改文本样式（-NET）" class="headerlink" title="创建和修改文本样式（.NET）"></a>创建和修改文本样式（.NET）</h4><p>新文字继承当前文字样式的高度、宽度因子、倾斜角度和文字生成特性。要创建文本样式，请创建 TextStyleTableRecord 对象的新实例。使用 Name 特性为新文字样式指定名称。然后打开 TextStyleTable 对象进行写入，并使用 Add 方法创建新的文本样式。</p>
<p>样式名称可以包含字母、数字和特殊字符美元符号（$）、下划线（_）和连字符（-）。AutoCAD将字符转换为字符。如果不输入样式名称，新样式将没有名称。</p>
<p>可以通过更改 TextStyleTableRecord 对象的属性来修改现有样式。如果你想使用当前的文本样式，使用 Database 对象的 TextStyle 属性，它保存了当前文本样式的对象id。</p>
<p>You can also update existing text of that style type to reflect the changes. Use the following properties to modify a TextStyleTableRecord object:<br>您还可以更新该样式类型的现有文本以反映更改。使用以下属性修改 TextStyleTableRecord 对象：</p>
<ul>
<li><p>BigFontFileName<br>指定用于非ASCII字符集的特殊形状定义文件。</p>
</li>
<li><p>FileName </p>
<p>指定与字体（字符样式）关联的文件。</p>
</li>
<li><p>FlagBits</p>
<p>指定反向文字、倒置文字或同时指定两者。</p>
</li>
<li><p>Font </p>
<p>指定文字样式的字体、粗体、斜体、字符集、间距和族设置。</p>
</li>
<li><p>IsVertical</p>
<p>指定垂直或水平文本。</p>
</li>
<li><p>ObliquingAngle </p>
<p>指定字符的倾斜度。</p>
</li>
<li><p>TextSize</p>
<p>指定字符高度。</p>
</li>
<li><p>XScale</p>
<p>指定字符的扩展或压缩。</p>
</li>
</ul>
<p>如果更改现有样式的字体或方向，则使用该样式的所有文本都将更改为使用新的字体或方向。更改文字高度、宽度因子和倾斜角度不会更改现有文字，但会更改后续创建的文字对象。</p>
<p>注意：必须重新生成图形才能查看对上述属性的任何更改。</p>
<h4 id="指定字体（-NET）"><a href="#指定字体（-NET）" class="headerlink" title="指定字体（.NET）"></a>指定字体（.NET）</h4><p>字体定义组成每个字符集的文本字符的形状。一种字体可以被多个样式使用。使用 FileName 属性设置文本样式的字体文件。可以将TrueType或AutoCAD编译的SHX字体指定给文字样式。</p>
<p><strong>设置文本字体</strong></p>
<p>下面的示例使用活动文本样式的 Font 属性获取当前字体值，然后将字体的字样更改为“PlayBill”。若要查看更改字体的效果，请在运行示例之前向当前绘图中添加一些多行或单行文本。请注意，如果您的系统上没有PlayBill字体，则需要替换一种现有的字体，以使此示例正常工作。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">CommandMethod(<span class="string">&quot;UpdateTextFont&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">UpdateTextFont</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Get the current document and database</span></span><br><span class="line">    Document acDoc = Application.DocumentManager.MdiActiveDocument;</span><br><span class="line">    Database acCurDb = acDoc.Database;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Start a transaction</span></span><br><span class="line">    <span class="keyword">using</span> (Transaction acTrans = acCurDb.TransactionManager.StartTransaction())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Open the current text style for write</span></span><br><span class="line">        TextStyleTableRecord acTextStyleTblRec;</span><br><span class="line">        acTextStyleTblRec = acTrans.GetObject(acCurDb.Textstyle,</span><br><span class="line">                                              OpenMode.ForWrite) <span class="keyword">as</span> TextStyleTableRecord;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// Get the current font settings</span></span><br><span class="line">        Autodesk.AutoCAD.GraphicsInterface.FontDescriptor acFont;</span><br><span class="line">        acFont = acTextStyleTblRec.Font;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// Update the text style&#x27;s typeface with &quot;PlayBill&quot;</span></span><br><span class="line">        Autodesk.AutoCAD.GraphicsInterface.FontDescriptor acNewFont;</span><br><span class="line">        acNewFont = <span class="keyword">new</span></span><br><span class="line">          Autodesk.AutoCAD.GraphicsInterface.FontDescriptor(<span class="string">&quot;PlayBill&quot;</span>,</span><br><span class="line">                                                            acFont.Bold,</span><br><span class="line">                                                            acFont.Italic,</span><br><span class="line">                                                            acFont.CharacterSet,</span><br><span class="line">                                                            acFont.PitchAndFamily);</span><br><span class="line"> </span><br><span class="line">        acTextStyleTblRec.Font = acNewFont;</span><br><span class="line"> </span><br><span class="line">        acDoc.Editor.Regen();</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// Save the changes and dispose of the transaction</span></span><br><span class="line">        acTrans.Commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="使用TrueType字体（-NET）"><a href="#使用TrueType字体（-NET）" class="headerlink" title="使用TrueType字体（.NET）"></a>使用TrueType字体（.NET）</h4><p>TrueType字体在图形中始终显示为填充字体;但是，打印时，TEXTFILL系统变量控制是否填充字体。默认情况下，TEXTFILL设置为1以打印填充字体。将图形导出为AutoCAD®格式并在AutoCAD设备上打印时，将按设计打印字体。</p>
<h4 id="使用Unicode和大字体（-NET）"><a href="#使用Unicode和大字体（-NET）" class="headerlink" title="使用Unicode和大字体（.NET）"></a>使用Unicode和大字体（.NET）</h4><p>AutoCAD支持Unicode字符编码标准。Unicode字体可以包含65，535个字符，具有多种语言的形状。产品附带的所有AutoCAD SHX形状字体都支持Unicode字体。</p>
<p>某些字母表的文本文件包含数千个非ASCII字符。为了容纳此类文本，AutoCAD支持一种特殊类型的形状定义，称为大字体文件。您可以将样式设置为同时使用常规文件和大字体文件。使用 FileName 属性指定普通字体。使用 BigFontFileName 属性指定大字体。</p>
<p>注意：字体文件名不能包含逗号。</p>
<p>AutoCAD允许您指定在无法找到指定字体文件时使用的替代字体。使用FONTALT系统变量和应用程序的 SetSystemVariable 成员方法更改所使用的替换字体。</p>
<p><strong>更改字体文件</strong></p>
<p>下面的示例代码更改 FileName 和 BigFontFileName 属性。您需要将本示例中列出的路径信息替换为适合您系统的路径和文件名。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">CommandMethod(<span class="string">&quot;ChangeFontFiles&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ChangeFontFiles</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Get the current document and database</span></span><br><span class="line">    Document acDoc = Application.DocumentManager.MdiActiveDocument;</span><br><span class="line">    Database acCurDb = acDoc.Database;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start a transaction</span></span><br><span class="line">    <span class="keyword">using</span> (Transaction acTrans = acCurDb.TransactionManager.StartTransaction())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Open the current text style for write</span></span><br><span class="line">        TextStyleTableRecord acTextStyleTblRec;</span><br><span class="line">        acTextStyleTblRec = acTrans.GetObject(acCurDb.Textstyle,</span><br><span class="line">                                                OpenMode.ForWrite) <span class="keyword">as</span> TextStyleTableRecord;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Change the font files used for both Big and Regular fonts</span></span><br><span class="line">        acTextStyleTblRec.BigFontFileName = <span class="string">&quot;C:/AutoCAD/Fonts/bigfont.shx&quot;</span>;</span><br><span class="line">        acTextStyleTblRec.FileName = <span class="string">&quot;C:/AutoCAD/Fonts/italic.shx&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Save the changes and dispose of the transaction</span></span><br><span class="line">        acTrans.Commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="替代字体（-NET）"><a href="#替代字体（-NET）" class="headerlink" title="替代字体（.NET）"></a>替代字体（.NET）</h4><p>当AutoCAD找不到图形中指定的字体时，可以指定要替换为其他字体的字体或作为默认字体。</p>
<p>用于图形中文本的字体由文本样式确定，对于 MText ，则由应用于文本部分的各个字体格式确定。</p>
<p>您可以使用字体映射表来确保您的绘图仅使用某些字体，或将您使用的字体转换为其他字体。您可以使用这些字体映射表来强制执行公司字体标准，或方便脱机打印。AutoCAD附带默认字体映射表。您可以使用任何ASCII文本编辑器编辑此文件。还可以使用FONTMAP系统变量指定不同的字体映射表文件。</p>
<p><strong>指定备选默认字体</strong></p>
<p>如果图形指定的字体当前不在系统中，AutoCAD将自动替换指定为备用字体的字体。默认情况下，AutoCAD使用simplex.shx文件。但是，如有必要，您可以指定其他字体。使用FONTALT系统变量设置备用字体文件名。</p>
<p>如果使用的文字样式使用大字体，则可以使用FONTALT系统变量将其映射到另一种字体。字体映射必须在成对的字体文件中完成：txt.shx，bigfont.shx。</p>
<p>如果AutoCAD在打开图形时找不到字体文件，它将应用一组默认的字体替换规则。</p>
<h3 id="使用Unicode字符、控制代码和特殊字符（-NET）"><a href="#使用Unicode字符、控制代码和特殊字符（-NET）" class="headerlink" title="使用Unicode字符、控制代码和特殊字符（.NET）"></a>使用Unicode字符、控制代码和特殊字符（.NET）</h3><p>可以在文本字符串中使用Unicode字符、控制代码和特殊字符来表示符号。(All必须输入非文本字符作为其ASCII等价物。）</p>
<p>可以通过输入以下Unicode字符串来创建特殊字符：</p>
<p>Unicode字符描述</p>
<table>
<thead>
<tr>
<th align="left">Unicode character</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody><tr>
<td align="left">\U+00B0</td>
<td align="left">度数符号</td>
</tr>
<tr>
<td align="left">\U+00B1</td>
<td align="left">正&#x2F;负公差符号</td>
</tr>
<tr>
<td align="left">\U+2205</td>
<td align="left">直径标注符号</td>
</tr>
</tbody></table>
<p>除了对特殊字符使用Unicode字符外，还可以通过在文本字符串中包含控制信息来指定特殊字符。使用一对百分比符号（%%）引入每个控制序列。例如，以下控制代码使用标准AutoCAD文本和字体来绘制字符数nnn：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%%nnn</span><br></pre></td></tr></table></figure>

<p>这些控制代码仅适用于标准AutoCAD文本字体：</p>
<p>控制代码说明</p>
<table>
<thead>
<tr>
<th align="left">Control code</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody><tr>
<td align="left">%%o</td>
<td align="left">打开和关闭划线模式</td>
</tr>
<tr>
<td align="left">%%u</td>
<td align="left">打开和关闭下划线模式</td>
</tr>
<tr>
<td align="left">%%d</td>
<td align="left">绘制度数符号</td>
</tr>
<tr>
<td align="left">%%p</td>
<td align="left">绘制正负公差符号</td>
</tr>
<tr>
<td align="left">%%c</td>
<td align="left">绘制直径标注符号</td>
</tr>
<tr>
<td align="left">%%%</td>
<td align="left">绘制单个百分比符号</td>
</tr>
</tbody></table>
<h3 id="拼写检查（-NET）"><a href="#拼写检查（-NET）" class="headerlink" title="拼写检查（.NET）"></a>拼写检查（.NET）</h3><p>在拼写检查过程中，AutoCAD会将图形中的单词与当前主词典中的单词进行匹配。您添加的任何单词都存储在拼写检查时最新的自定义词典中。例如，可以添加专有名称，以便AutoCAD不再将其识别为拼写错误的单词。</p>
<p>要检查另一种语言的拼写，您可以更改为其他主词典。</p>
<p>AutoCAD.NET API中没有提供检查拼写的方法。但是，可以使用DCTMAIN系统变量指定其他主字典，或使用DCTCUST系统变量指定其他自定义字典。</p>
<h2 id="注：翻译自ObjectARX-Managed-NET-Developer’s-Guide，且只保留了C-部分的代码"><a href="#注：翻译自ObjectARX-Managed-NET-Developer’s-Guide，且只保留了C-部分的代码" class="headerlink" title="注：翻译自ObjectARX: Managed .NET Developer’s Guide，且只保留了C#部分的代码"></a><em><strong>注：</strong></em>翻译自<a href="https://help.autodesk.com/view/OARX/2024/ENU/?guid=GUID-C3F3C736-40CF-44A0-9210-55F6A939B6F2">ObjectARX: Managed .NET Developer’s Guide</a>，且只保留了C#部分的代码</h2>]]></content>
      <categories>
        <category>ObjectARX：Managed.NET开发人员指南</category>
      </categories>
      <tags>
        <tag>CAD</tag>
      </tags>
  </entry>
  <entry>
    <title>Linq标准查询运算符</title>
    <url>/2024/12/16/CSharp/LINQ/</url>
    <content><![CDATA[<h1 id="Linq标准查询运算符"><a href="#Linq标准查询运算符" class="headerlink" title="Linq标准查询运算符"></a>Linq标准查询运算符</h1><table>
<thead>
<tr>
<th>标准查询运算符</th>
<th>返回类型</th>
<th>立即执行</th>
<th>延迟的流式处理执行</th>
<th>延迟非流式处理执行</th>
</tr>
</thead>
<tbody><tr>
<td>Aggregate</td>
<td>TSource</td>
<td>X</td>
<td></td>
<td></td>
</tr>
<tr>
<td>All</td>
<td>Boolean</td>
<td>X</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Any</td>
<td>Boolean</td>
<td>X</td>
<td></td>
<td></td>
</tr>
<tr>
<td>AsEnumerable</td>
<td>IEnumerable<T></td>
<td></td>
<td>X</td>
<td></td>
</tr>
<tr>
<td>Average</td>
<td>单个数值</td>
<td>x</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Cast</td>
<td>IEnumerable<T></td>
<td></td>
<td>X</td>
<td></td>
</tr>
<tr>
<td>Concat</td>
<td>IEnumerable<T></td>
<td></td>
<td>X</td>
<td></td>
</tr>
<tr>
<td>Contains</td>
<td>Boolean</td>
<td>X</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Count</td>
<td>Int32</td>
<td>X</td>
<td></td>
<td></td>
</tr>
<tr>
<td>DefaultIfEmpty</td>
<td>IEnumerable<T></td>
<td></td>
<td>X</td>
<td></td>
</tr>
<tr>
<td>Distinct</td>
<td>IEnumerable<T></td>
<td></td>
<td>X</td>
<td></td>
</tr>
<tr>
<td>ElementAt</td>
<td>TSource</td>
<td>X</td>
<td></td>
<td></td>
</tr>
<tr>
<td>ElementAtOrDefault</td>
<td>TSource?</td>
<td>X</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Empty</td>
<td>IEnumerable<T></td>
<td>X</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Except</td>
<td>IEnumerable<T></td>
<td></td>
<td>X</td>
<td>X</td>
</tr>
<tr>
<td>First</td>
<td>TSource</td>
<td>X</td>
<td></td>
<td></td>
</tr>
<tr>
<td>FirstOrDefault</td>
<td>TSource?</td>
<td>X</td>
<td></td>
<td></td>
</tr>
<tr>
<td>GroupBy</td>
<td>IEnumerable<T></td>
<td></td>
<td></td>
<td>X</td>
</tr>
<tr>
<td>GroupJoin</td>
<td>IEnumerable<T></td>
<td></td>
<td>X</td>
<td>X</td>
</tr>
<tr>
<td>Intersect</td>
<td>IEnumerable<T></td>
<td></td>
<td>X</td>
<td>X</td>
</tr>
<tr>
<td>Join</td>
<td>IEnumerable<T></td>
<td></td>
<td>X</td>
<td>X</td>
</tr>
<tr>
<td>Last</td>
<td>TSource</td>
<td>X</td>
<td></td>
<td></td>
</tr>
<tr>
<td>LastOrDefault</td>
<td>TSource?</td>
<td>X</td>
<td></td>
<td></td>
</tr>
<tr>
<td>LongCount</td>
<td>Int64</td>
<td>X</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Max</td>
<td>单个数值 TSource 或 TResult?</td>
<td>X</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Min</td>
<td>单个数值 TSource 或 TResult?</td>
<td>X</td>
<td></td>
<td></td>
</tr>
<tr>
<td>OfType</td>
<td>IEnumerable<T></td>
<td></td>
<td>X</td>
<td></td>
</tr>
<tr>
<td>OrderBy</td>
<td>IOrderedEnumerable<TElement></td>
<td></td>
<td></td>
<td>X</td>
</tr>
<tr>
<td>OrderByDescending</td>
<td>IOrderedEnumerable<TElement></td>
<td></td>
<td></td>
<td>X</td>
</tr>
<tr>
<td>Range</td>
<td>IEnumerable<T></td>
<td></td>
<td>X</td>
<td></td>
</tr>
<tr>
<td>Repeat</td>
<td>IEnumerable<T></td>
<td></td>
<td>X</td>
<td></td>
</tr>
<tr>
<td>Reverse</td>
<td>IEnumerable<T></td>
<td></td>
<td></td>
<td>X</td>
</tr>
<tr>
<td>Select</td>
<td>IEnumerable<T></td>
<td></td>
<td>X</td>
<td></td>
</tr>
<tr>
<td>SelectMany</td>
<td>IEnumerable<T></td>
<td></td>
<td>X</td>
<td></td>
</tr>
<tr>
<td>SequenceEqual</td>
<td>Boolean</td>
<td>X</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Single</td>
<td>TSource</td>
<td>X</td>
<td></td>
<td></td>
</tr>
<tr>
<td>SingleOrDefault</td>
<td>TSource?</td>
<td>X</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Skip</td>
<td>IEnumerable<T></td>
<td></td>
<td>X</td>
<td></td>
</tr>
<tr>
<td>SkipWhile</td>
<td>IEnumerable<T></td>
<td></td>
<td>X</td>
<td></td>
</tr>
<tr>
<td>Sum</td>
<td>单个数值</td>
<td>x</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Take</td>
<td>IEnumerable<T></td>
<td></td>
<td>X</td>
<td></td>
</tr>
<tr>
<td>TakeWhile</td>
<td>IEnumerable<T></td>
<td></td>
<td>X</td>
<td></td>
</tr>
<tr>
<td>ThenBy</td>
<td>IOrderedEnumerable<TElement></td>
<td></td>
<td></td>
<td>X</td>
</tr>
<tr>
<td>ThenByDescending</td>
<td>IOrderedEnumerable<TElement></td>
<td></td>
<td></td>
<td>X</td>
</tr>
<tr>
<td>ToArray</td>
<td>TSource[] 数组</td>
<td>X</td>
<td></td>
<td></td>
</tr>
<tr>
<td>ToDictionary</td>
<td>Dictionary&lt;TKey,TValue&gt;</td>
<td>X</td>
<td></td>
<td></td>
</tr>
<tr>
<td>ToList</td>
<td>IList<T></td>
<td>X</td>
<td></td>
<td></td>
</tr>
<tr>
<td>ToLookup</td>
<td>ILookup&lt;TKey,TElement&gt;</td>
<td>X</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Union</td>
<td>IEnumerable<T></td>
<td></td>
<td>X</td>
<td></td>
</tr>
<tr>
<td>Where</td>
<td>IEnumerable<T></td>
<td></td>
<td>X</td>
<td></td>
</tr>
</tbody></table>
<h2 id="注：整理自C-中的-LINQ-查询简介"><a href="#注：整理自C-中的-LINQ-查询简介" class="headerlink" title="注：整理自C# 中的 LINQ 查询简介"></a>注：整理自<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/linq/get-started/introduction-to-linq-queries">C# 中的 LINQ 查询简介</a></h2><h2 id="Aggregate"><a href="#Aggregate" class="headerlink" title="Aggregate"></a>Aggregate</h2><p>对序列应用累加器函数。 将指定的种子值用作累加器的初始值，并使用指定的函数选择结果值。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span>[] fruits = &#123; <span class="string">&quot;apple&quot;</span>, <span class="string">&quot;mango&quot;</span>, <span class="string">&quot;orange&quot;</span>, <span class="string">&quot;passionfruit&quot;</span>, <span class="string">&quot;grape&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Determine whether any string in the array is longer than &quot;banana&quot;.</span></span><br><span class="line"><span class="built_in">string</span> longestName =</span><br><span class="line">    fruits.Aggregate(<span class="string">&quot;banana&quot;</span>,</span><br><span class="line">                    (longest, next) =&gt;</span><br><span class="line">                        next.Length &gt; longest.Length ? next : longest,</span><br><span class="line">                    <span class="comment">// Return the final result as an upper case string.</span></span><br><span class="line">                    fruit =&gt; fruit.ToUpper());</span><br><span class="line"></span><br><span class="line">Console.WriteLine(</span><br><span class="line">    <span class="string">&quot;The fruit with the longest name is &#123;0&#125;.&quot;</span>,</span><br><span class="line">    longestName);</span><br><span class="line"></span><br><span class="line"><span class="comment">// This code produces the following output:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The fruit with the longest name is PASSIONFRUIT.</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span>[] ints = &#123; <span class="number">4</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">0</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">2</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Count the even numbers in the array, using a seed value of 0.</span></span><br><span class="line"><span class="built_in">int</span> numEven = ints.Aggregate(<span class="number">0</span>, (total, next) =&gt;</span><br><span class="line">                                    next % <span class="number">2</span> == <span class="number">0</span> ? total + <span class="number">1</span> : total);</span><br><span class="line"></span><br><span class="line">Console.WriteLine(<span class="string">&quot;The number of even integers is: &#123;0&#125;&quot;</span>, numEven);</span><br><span class="line"></span><br><span class="line"><span class="comment">// This code produces the following output:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The number of even integers is: 6</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> sentence = <span class="string">&quot;the quick brown fox jumps over the lazy dog&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Split the string into individual words.</span></span><br><span class="line"><span class="built_in">string</span>[] words = sentence.Split(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Prepend each word to the beginning of the</span></span><br><span class="line"><span class="comment">// new sentence to reverse the word order.</span></span><br><span class="line"><span class="built_in">string</span> reversed = words.Aggregate((workingSentence, next) =&gt;</span><br><span class="line">                                      next + <span class="string">&quot; &quot;</span> + workingSentence);</span><br><span class="line"></span><br><span class="line">Console.WriteLine(reversed);</span><br><span class="line"></span><br><span class="line"><span class="comment">// This code produces the following output:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// dog lazy the over jumps fox brown quick the</span></span><br></pre></td></tr></table></figure>

<h2 id="All"><a href="#All" class="headerlink" title="All"></a>All</h2><p>确定序列中的所有元素是否都满足条件。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Pet</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Age &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">AllEx</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Create an array of Pets.</span></span><br><span class="line">    Pet[] pets = &#123; <span class="keyword">new</span> Pet &#123; Name=<span class="string">&quot;Barley&quot;</span>, Age=<span class="number">10</span> &#125;,</span><br><span class="line">                   <span class="keyword">new</span> Pet &#123; Name=<span class="string">&quot;Boots&quot;</span>, Age=<span class="number">4</span> &#125;,</span><br><span class="line">                   <span class="keyword">new</span> Pet &#123; Name=<span class="string">&quot;Whiskers&quot;</span>, Age=<span class="number">6</span> &#125; &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Determine whether all pet names</span></span><br><span class="line">    <span class="comment">// in the array start with &#x27;B&#x27;.</span></span><br><span class="line">    <span class="built_in">bool</span> allStartWithB = pets.All(pet =&gt;</span><br><span class="line">                                      pet.Name.StartsWith(<span class="string">&quot;B&quot;</span>));</span><br><span class="line"></span><br><span class="line">    Console.WriteLine(</span><br><span class="line">        <span class="string">&quot;&#123;0&#125; pet names start with &#x27;B&#x27;.&quot;</span>,</span><br><span class="line">        allStartWithB ? <span class="string">&quot;All&quot;</span> : <span class="string">&quot;Not all&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This code produces the following output:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Not all pet names start with &#x27;B&#x27;.</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Pet</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Age &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> LastName &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> Pet[] Pets &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">AllEx2</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    List&lt;Person&gt; people = <span class="keyword">new</span> List&lt;Person&gt;</span><br><span class="line">        &#123; <span class="keyword">new</span> Person &#123; LastName = <span class="string">&quot;Haas&quot;</span>,</span><br><span class="line">                       Pets = <span class="keyword">new</span> Pet[] &#123; <span class="keyword">new</span> Pet &#123; Name=<span class="string">&quot;Barley&quot;</span>, Age=<span class="number">10</span> &#125;,</span><br><span class="line">                                          <span class="keyword">new</span> Pet &#123; Name=<span class="string">&quot;Boots&quot;</span>, Age=<span class="number">14</span> &#125;,</span><br><span class="line">                                          <span class="keyword">new</span> Pet &#123; Name=<span class="string">&quot;Whiskers&quot;</span>, Age=<span class="number">6</span> &#125;&#125;&#125;,</span><br><span class="line">          <span class="keyword">new</span> Person &#123; LastName = <span class="string">&quot;Fakhouri&quot;</span>,</span><br><span class="line">                       Pets = <span class="keyword">new</span> Pet[] &#123; <span class="keyword">new</span> Pet &#123; Name = <span class="string">&quot;Snowball&quot;</span>, Age = <span class="number">1</span>&#125;&#125;&#125;,</span><br><span class="line">          <span class="keyword">new</span> Person &#123; LastName = <span class="string">&quot;Antebi&quot;</span>,</span><br><span class="line">                       Pets = <span class="keyword">new</span> Pet[] &#123; <span class="keyword">new</span> Pet &#123; Name = <span class="string">&quot;Belle&quot;</span>, Age = <span class="number">8</span>&#125; &#125;&#125;,</span><br><span class="line">          <span class="keyword">new</span> Person &#123; LastName = <span class="string">&quot;Philips&quot;</span>,</span><br><span class="line">                       Pets = <span class="keyword">new</span> Pet[] &#123; <span class="keyword">new</span> Pet &#123; Name = <span class="string">&quot;Sweetie&quot;</span>, Age = <span class="number">2</span>&#125;,</span><br><span class="line">                                          <span class="keyword">new</span> Pet &#123; Name = <span class="string">&quot;Rover&quot;</span>, Age = <span class="number">13</span>&#125;&#125; &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Determine which people have pets that are all older than 5.</span></span><br><span class="line">    IEnumerable&lt;<span class="built_in">string</span>&gt; names = <span class="keyword">from</span> person <span class="keyword">in</span> people</span><br><span class="line">                                <span class="keyword">where</span> person.Pets.All(pet =&gt; pet.Age &gt; <span class="number">5</span>)</span><br><span class="line">                                <span class="keyword">select</span> person.LastName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">foreach</span> (<span class="built_in">string</span> name <span class="keyword">in</span> names)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* This code produces the following output:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Haas</span></span><br><span class="line"><span class="comment">     * Antebi</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Any"><a href="#Any" class="headerlink" title="Any"></a>Any</h2><p>确定序列中是否包含元素或存在元素满足指定条件。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">List&lt;<span class="built_in">int</span>&gt; numbers = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt; &#123; <span class="number">1</span>, <span class="number">2</span> &#125;;</span><br><span class="line"><span class="built_in">bool</span> hasElements = numbers.Any();</span><br><span class="line"></span><br><span class="line">Console.WriteLine(<span class="string">&quot;The list &#123;0&#125; empty.&quot;</span>,</span><br><span class="line">    hasElements ? <span class="string">&quot;is not&quot;</span> : <span class="string">&quot;is&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// This code produces the following output:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The list is not empty.</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Pet</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Age &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> LastName &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> Pet[] Pets &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">AnyEx2</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    List&lt;Person&gt; people = <span class="keyword">new</span> List&lt;Person&gt;</span><br><span class="line">        &#123; <span class="keyword">new</span> Person &#123; LastName = <span class="string">&quot;Haas&quot;</span>,</span><br><span class="line">                       Pets = <span class="keyword">new</span> Pet[] &#123; <span class="keyword">new</span> Pet &#123; Name=<span class="string">&quot;Barley&quot;</span>, Age=<span class="number">10</span> &#125;,</span><br><span class="line">                                          <span class="keyword">new</span> Pet &#123; Name=<span class="string">&quot;Boots&quot;</span>, Age=<span class="number">14</span> &#125;,</span><br><span class="line">                                          <span class="keyword">new</span> Pet &#123; Name=<span class="string">&quot;Whiskers&quot;</span>, Age=<span class="number">6</span> &#125;&#125;&#125;,</span><br><span class="line">          <span class="keyword">new</span> Person &#123; LastName = <span class="string">&quot;Fakhouri&quot;</span>,</span><br><span class="line">                       Pets = <span class="keyword">new</span> Pet[] &#123; <span class="keyword">new</span> Pet &#123; Name = <span class="string">&quot;Snowball&quot;</span>, Age = <span class="number">1</span>&#125;&#125;&#125;,</span><br><span class="line">          <span class="keyword">new</span> Person &#123; LastName = <span class="string">&quot;Antebi&quot;</span>,</span><br><span class="line">                       Pets = <span class="keyword">new</span> Pet[] &#123; &#125;&#125;,</span><br><span class="line">          <span class="keyword">new</span> Person &#123; LastName = <span class="string">&quot;Philips&quot;</span>,</span><br><span class="line">                       Pets = <span class="keyword">new</span> Pet[] &#123; <span class="keyword">new</span> Pet &#123; Name = <span class="string">&quot;Sweetie&quot;</span>, Age = <span class="number">2</span>&#125;,</span><br><span class="line">                                          <span class="keyword">new</span> Pet &#123; Name = <span class="string">&quot;Rover&quot;</span>, Age = <span class="number">13</span>&#125;&#125; &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Determine which people have a non-empty Pet array.</span></span><br><span class="line">    IEnumerable&lt;<span class="built_in">string</span>&gt; names = <span class="keyword">from</span> person <span class="keyword">in</span> people</span><br><span class="line">                                <span class="keyword">where</span> person.Pets.Any()</span><br><span class="line">                                <span class="keyword">select</span> person.LastName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">foreach</span> (<span class="built_in">string</span> name <span class="keyword">in</span> names)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* This code produces the following output:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       Haas</span></span><br><span class="line"><span class="comment">       Fakhouri</span></span><br><span class="line"><span class="comment">       Philips</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Pet</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Age &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> Vaccinated &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">AnyEx3</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Create an array of Pets.</span></span><br><span class="line">    Pet[] pets =</span><br><span class="line">        &#123; <span class="keyword">new</span> Pet &#123; Name=<span class="string">&quot;Barley&quot;</span>, Age=<span class="number">8</span>, Vaccinated=<span class="literal">true</span> &#125;,</span><br><span class="line">          <span class="keyword">new</span> Pet &#123; Name=<span class="string">&quot;Boots&quot;</span>, Age=<span class="number">4</span>, Vaccinated=<span class="literal">false</span> &#125;,</span><br><span class="line">          <span class="keyword">new</span> Pet &#123; Name=<span class="string">&quot;Whiskers&quot;</span>, Age=<span class="number">1</span>, Vaccinated=<span class="literal">false</span> &#125; &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Determine whether any pets over age 1 are also unvaccinated.</span></span><br><span class="line">    <span class="built_in">bool</span> unvaccinated =</span><br><span class="line">        pets.Any(p =&gt; p.Age &gt; <span class="number">1</span> &amp;&amp; p.Vaccinated == <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    Console.WriteLine(</span><br><span class="line">        <span class="string">&quot;There &#123;0&#125; unvaccinated animals over age one.&quot;</span>,</span><br><span class="line">        unvaccinated ? <span class="string">&quot;are&quot;</span> : <span class="string">&quot;are not any&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This code produces the following output:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  There are unvaccinated animals over age one.</span></span><br></pre></td></tr></table></figure>

<h2 id="AsEnumerable"><a href="#AsEnumerable" class="headerlink" title="AsEnumerable"></a>AsEnumerable</h2><p>返回类型化为 IEnumerable<T> 的输入。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Custom class.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Clump</span>&lt;<span class="title">T</span>&gt; : <span class="title">List</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Custom implementation of Where().</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IEnumerable&lt;T&gt; <span class="title">Where</span>(<span class="params">Func&lt;T, <span class="built_in">bool</span>&gt; predicate</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;In Clump&#x27;s implementation of Where().&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> Enumerable.Where(<span class="keyword">this</span>, predicate);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">AsEnumerableEx1</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Create a new Clump&lt;T&gt; object.</span></span><br><span class="line">    Clump&lt;<span class="built_in">string</span>&gt; fruitClump =</span><br><span class="line">        <span class="keyword">new</span> Clump&lt;<span class="built_in">string</span>&gt; &#123; <span class="string">&quot;apple&quot;</span>, <span class="string">&quot;passionfruit&quot;</span>, <span class="string">&quot;banana&quot;</span>,</span><br><span class="line">            <span class="string">&quot;mango&quot;</span>, <span class="string">&quot;orange&quot;</span>, <span class="string">&quot;blueberry&quot;</span>, <span class="string">&quot;grape&quot;</span>, <span class="string">&quot;strawberry&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// First call to Where():</span></span><br><span class="line">    <span class="comment">// Call Clump&#x27;s Where() method with a predicate.</span></span><br><span class="line">    IEnumerable&lt;<span class="built_in">string</span>&gt; query1 =</span><br><span class="line">        fruitClump.Where(fruit =&gt; fruit.Contains(<span class="string">&quot;o&quot;</span>));</span><br><span class="line"></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;query1 has been created.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Second call to Where():</span></span><br><span class="line">    <span class="comment">// First call AsEnumerable() to hide Clump&#x27;s Where() method and thereby</span></span><br><span class="line">    <span class="comment">// force System.Linq.Enumerable&#x27;s Where() method to be called.</span></span><br><span class="line">    IEnumerable&lt;<span class="built_in">string</span>&gt; query2 =</span><br><span class="line">        fruitClump.AsEnumerable().Where(fruit =&gt; fruit.Contains(<span class="string">&quot;o&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Display the output.</span></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;query2 has been created.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This code produces the following output:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// In Clump&#x27;s implementation of Where().</span></span><br><span class="line"><span class="comment">// query1 has been created.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// query2 has been created.</span></span><br></pre></td></tr></table></figure>

<h2 id="Average"><a href="#Average" class="headerlink" title="Average"></a>Average</h2><p>计算数值序列的平均值。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">long</span>?[] longs = &#123; <span class="literal">null</span>, <span class="number">10007L</span>, <span class="number">37L</span>, <span class="number">399846234235L</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">double</span>? average = longs.Average();</span><br><span class="line"></span><br><span class="line">Console.WriteLine(<span class="string">&quot;The average is &#123;0&#125;.&quot;</span>, average);</span><br><span class="line"></span><br><span class="line"><span class="comment">// This code produces the following output:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The average is 133282081426.333.</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">List&lt;<span class="built_in">int</span>&gt; grades = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt; &#123; <span class="number">78</span>, <span class="number">92</span>, <span class="number">100</span>, <span class="number">37</span>, <span class="number">81</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">double</span> average = grades.Average();</span><br><span class="line"></span><br><span class="line">Console.WriteLine(<span class="string">&quot;The average grade is &#123;0&#125;.&quot;</span>, average);</span><br><span class="line"></span><br><span class="line"><span class="comment">// This code produces the following output:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The average grade is 77.6.</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span>[] fruits = &#123; <span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;mango&quot;</span>, <span class="string">&quot;orange&quot;</span>, <span class="string">&quot;passionfruit&quot;</span>, <span class="string">&quot;grape&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">double</span> average = fruits.Average(s =&gt; s.Length);</span><br><span class="line"></span><br><span class="line">Console.WriteLine(<span class="string">&quot;The average string length is &#123;0&#125;.&quot;</span>, average);</span><br><span class="line"></span><br><span class="line"><span class="comment">// This code produces the following output:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The average string length is 6.5.</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span>[] numbers = &#123; <span class="string">&quot;10007&quot;</span>, <span class="string">&quot;37&quot;</span>, <span class="string">&quot;299846234235&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">double</span> average = numbers.Average(num =&gt; <span class="built_in">long</span>.Parse(num));</span><br><span class="line"></span><br><span class="line">Console.WriteLine(<span class="string">&quot;The average is &#123;0&#125;.&quot;</span>, average);</span><br><span class="line"></span><br><span class="line"><span class="comment">// This code produces the following output:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The average is 99948748093.</span></span><br></pre></td></tr></table></figure>

<h2 id="Cast"><a href="#Cast" class="headerlink" title="Cast"></a>Cast</h2><p>将 IEnumerable 的元素强制转换为指定的类型。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">System.Collections.ArrayList fruits = <span class="keyword">new</span> System.Collections.ArrayList();</span><br><span class="line">fruits.Add(<span class="string">&quot;mango&quot;</span>);</span><br><span class="line">fruits.Add(<span class="string">&quot;apple&quot;</span>);</span><br><span class="line">fruits.Add(<span class="string">&quot;lemon&quot;</span>);</span><br><span class="line"></span><br><span class="line">IEnumerable&lt;<span class="built_in">string</span>&gt; query =</span><br><span class="line">    fruits.Cast&lt;<span class="built_in">string</span>&gt;().OrderBy(fruit =&gt; fruit).Select(fruit =&gt; fruit);</span><br><span class="line"></span><br><span class="line"><span class="comment">// The following code, without the cast, doesn&#x27;t compile.</span></span><br><span class="line"><span class="comment">//IEnumerable&lt;string&gt; query1 =</span></span><br><span class="line"><span class="comment">//    fruits.OrderBy(fruit =&gt; fruit).Select(fruit =&gt; fruit);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> (<span class="built_in">string</span> fruit <span class="keyword">in</span> query)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(fruit);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This code produces the following output:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// apple</span></span><br><span class="line"><span class="comment">// lemon</span></span><br><span class="line"><span class="comment">// mango</span></span><br></pre></td></tr></table></figure>

<h2 id="Concat"><a href="#Concat" class="headerlink" title="Concat"></a>Concat</h2><p>连接两个序列。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Pet</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Age &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> Pet[] <span class="title">GetCats</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    Pet[] cats = &#123; <span class="keyword">new</span> Pet &#123; Name=<span class="string">&quot;Barley&quot;</span>, Age=<span class="number">8</span> &#125;,</span><br><span class="line">                   <span class="keyword">new</span> Pet &#123; Name=<span class="string">&quot;Boots&quot;</span>, Age=<span class="number">4</span> &#125;,</span><br><span class="line">                   <span class="keyword">new</span> Pet &#123; Name=<span class="string">&quot;Whiskers&quot;</span>, Age=<span class="number">1</span> &#125; &#125;;</span><br><span class="line">    <span class="keyword">return</span> cats;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> Pet[] <span class="title">GetDogs</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    Pet[] dogs = &#123; <span class="keyword">new</span> Pet &#123; Name=<span class="string">&quot;Bounder&quot;</span>, Age=<span class="number">3</span> &#125;,</span><br><span class="line">                   <span class="keyword">new</span> Pet &#123; Name=<span class="string">&quot;Snoopy&quot;</span>, Age=<span class="number">14</span> &#125;,</span><br><span class="line">                   <span class="keyword">new</span> Pet &#123; Name=<span class="string">&quot;Fido&quot;</span>, Age=<span class="number">9</span> &#125; &#125;;</span><br><span class="line">    <span class="keyword">return</span> dogs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ConcatEx1</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    Pet[] cats = GetCats();</span><br><span class="line">    Pet[] dogs = GetDogs();</span><br><span class="line"></span><br><span class="line">    IEnumerable&lt;<span class="built_in">string</span>&gt; query =</span><br><span class="line">        cats.Select(cat =&gt; cat.Name).Concat(dogs.Select(dog =&gt; dog.Name));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">foreach</span> (<span class="built_in">string</span> name <span class="keyword">in</span> query)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This code produces the following output:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Barley</span></span><br><span class="line"><span class="comment">// Boots</span></span><br><span class="line"><span class="comment">// Whiskers</span></span><br><span class="line"><span class="comment">// Bounder</span></span><br><span class="line"><span class="comment">// Snoopy</span></span><br><span class="line"><span class="comment">// Fido</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Pet[] cats = GetCats();</span><br><span class="line">Pet[] dogs = GetDogs();</span><br><span class="line"></span><br><span class="line">IEnumerable&lt;<span class="built_in">string</span>&gt; query =</span><br><span class="line">    <span class="keyword">new</span>[] &#123; cats.Select(cat =&gt; cat.Name), dogs.Select(dog =&gt; dog.Name) &#125;</span><br><span class="line">    .SelectMany(name =&gt; name);</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> (<span class="built_in">string</span> name <span class="keyword">in</span> query)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This code produces the following output:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Barley</span></span><br><span class="line"><span class="comment">// Boots</span></span><br><span class="line"><span class="comment">// Whiskers</span></span><br><span class="line"><span class="comment">// Bounder</span></span><br><span class="line"><span class="comment">// Snoopy</span></span><br><span class="line"><span class="comment">// Fido</span></span><br></pre></td></tr></table></figure>

<h2 id="Contains"><a href="#Contains" class="headerlink" title="Contains"></a>Contains</h2><p>确定序列是否包含指定的元素。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span>[] fruits = &#123; <span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;mango&quot;</span>, <span class="string">&quot;orange&quot;</span>, <span class="string">&quot;passionfruit&quot;</span>, <span class="string">&quot;grape&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> fruit = <span class="string">&quot;mango&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">bool</span> hasMango = fruits.Contains(fruit);</span><br><span class="line"></span><br><span class="line">Console.WriteLine(</span><br><span class="line">    <span class="string">&quot;The array &#123;0&#125; contain &#x27;&#123;1&#125;&#x27;.&quot;</span>,</span><br><span class="line">    hasMango ? <span class="string">&quot;does&quot;</span> : <span class="string">&quot;does not&quot;</span>,</span><br><span class="line">    fruit);</span><br><span class="line"></span><br><span class="line"><span class="comment">// This code produces the following output:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The array does contain &#x27;mango&#x27;.</span></span><br></pre></td></tr></table></figure>

<h2 id="Count"><a href="#Count" class="headerlink" title="Count"></a>Count</h2><p>返回序列中的元素数量。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span>[] fruits = &#123; <span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;mango&quot;</span>, <span class="string">&quot;orange&quot;</span>, <span class="string">&quot;passionfruit&quot;</span>, <span class="string">&quot;grape&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> numberOfFruits = fruits.Count();</span><br><span class="line">    Console.WriteLine(</span><br><span class="line">        <span class="string">&quot;There are &#123;0&#125; fruits in the collection.&quot;</span>,</span><br><span class="line">        numberOfFruits);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (OverflowException)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;The count is too large to store as an Int32.&quot;</span>);</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Try using the LongCount() method instead.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This code produces the following output:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// There are 6 fruits in the collection.</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Pet</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> Vaccinated &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CountEx2</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    Pet[] pets = &#123; <span class="keyword">new</span> Pet &#123; Name=<span class="string">&quot;Barley&quot;</span>, Vaccinated=<span class="literal">true</span> &#125;,</span><br><span class="line">                   <span class="keyword">new</span> Pet &#123; Name=<span class="string">&quot;Boots&quot;</span>, Vaccinated=<span class="literal">false</span> &#125;,</span><br><span class="line">                   <span class="keyword">new</span> Pet &#123; Name=<span class="string">&quot;Whiskers&quot;</span>, Vaccinated=<span class="literal">false</span> &#125; &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> numberUnvaccinated = pets.Count(p =&gt; p.Vaccinated == <span class="literal">false</span>);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;There are &#123;0&#125; unvaccinated animals.&quot;</span>, numberUnvaccinated);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (OverflowException)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;The count is too large to store as an Int32.&quot;</span>);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Try using the LongCount() method instead.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This code produces the following output:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// There are 2 unvaccinated animals.</span></span><br></pre></td></tr></table></figure>

<h2 id="DefaultIfEmpty"><a href="#DefaultIfEmpty" class="headerlink" title="DefaultIfEmpty"></a>DefaultIfEmpty</h2><p>返回 IEnumerable<T>的元素;如果序列为空，则返回默认值单一实例集合。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Pet</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Age &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DefaultIfEmptyEx1</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    List&lt;Pet&gt; pets =</span><br><span class="line">        <span class="keyword">new</span> List&lt;Pet&gt;&#123; <span class="keyword">new</span> Pet &#123; Name=<span class="string">&quot;Barley&quot;</span>, Age=<span class="number">8</span> &#125;,</span><br><span class="line">                       <span class="keyword">new</span> Pet &#123; Name=<span class="string">&quot;Boots&quot;</span>, Age=<span class="number">4</span> &#125;,</span><br><span class="line">                       <span class="keyword">new</span> Pet &#123; Name=<span class="string">&quot;Whiskers&quot;</span>, Age=<span class="number">1</span> &#125; &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">foreach</span> (Pet pet <span class="keyword">in</span> pets.DefaultIfEmpty())</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(pet.Name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> This code produces the following output:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> Barley</span></span><br><span class="line"><span class="comment"> Boots</span></span><br><span class="line"><span class="comment"> Whiskers</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">List&lt;<span class="built_in">int</span>&gt; numbers = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> (<span class="built_in">int</span> number <span class="keyword">in</span> numbers.DefaultIfEmpty())</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(number);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> This code produces the following output:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> 0</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Pet</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Age &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DefaultIfEmptyEx2</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    Pet defaultPet = <span class="keyword">new</span> Pet &#123; Name = <span class="string">&quot;Default Pet&quot;</span>, Age = <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">    List&lt;Pet&gt; pets1 =</span><br><span class="line">        <span class="keyword">new</span> List&lt;Pet&gt;&#123; <span class="keyword">new</span> Pet &#123; Name=<span class="string">&quot;Barley&quot;</span>, Age=<span class="number">8</span> &#125;,</span><br><span class="line">                       <span class="keyword">new</span> Pet &#123; Name=<span class="string">&quot;Boots&quot;</span>, Age=<span class="number">4</span> &#125;,</span><br><span class="line">                       <span class="keyword">new</span> Pet &#123; Name=<span class="string">&quot;Whiskers&quot;</span>, Age=<span class="number">1</span> &#125; &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">foreach</span> (Pet pet <span class="keyword">in</span> pets1.DefaultIfEmpty(defaultPet))</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Name: &#123;0&#125;&quot;</span>, pet.Name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    List&lt;Pet&gt; pets2 = <span class="keyword">new</span> List&lt;Pet&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">foreach</span> (Pet pet <span class="keyword">in</span> pets2.DefaultIfEmpty(defaultPet))</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;\nName: &#123;0&#125;&quot;</span>, pet.Name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> This code produces the following output:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> Name: Barley</span></span><br><span class="line"><span class="comment"> Name: Boots</span></span><br><span class="line"><span class="comment"> Name: Whiskers</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> Name: Default Pet</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="Distinct"><a href="#Distinct" class="headerlink" title="Distinct"></a>Distinct</h2><p>返回序列中的非重复元素。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">List&lt;<span class="built_in">int</span>&gt; ages = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt; &#123; <span class="number">21</span>, <span class="number">46</span>, <span class="number">46</span>, <span class="number">55</span>, <span class="number">17</span>, <span class="number">21</span>, <span class="number">55</span>, <span class="number">55</span> &#125;;</span><br><span class="line"></span><br><span class="line">IEnumerable&lt;<span class="built_in">int</span>&gt; distinctAges = ages.Distinct();</span><br><span class="line"></span><br><span class="line">Console.WriteLine(<span class="string">&quot;Distinct ages:&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> (<span class="built_in">int</span> age <span class="keyword">in</span> distinctAges)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> This code produces the following output:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> Distinct ages:</span></span><br><span class="line"><span class="comment"> 21</span></span><br><span class="line"><span class="comment"> 46</span></span><br><span class="line"><span class="comment"> 55</span></span><br><span class="line"><span class="comment"> 17</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyProduct</span> : <span class="title">IEquatable</span>&lt;<span class="title">MyProduct</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Code &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">Equals</span>(<span class="params">MyProduct other</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//Check whether the compared object is null.</span></span><br><span class="line">        <span class="keyword">if</span> (Object.ReferenceEquals(other, <span class="literal">null</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Check whether the compared object references the same data.</span></span><br><span class="line">        <span class="keyword">if</span> (Object.ReferenceEquals(<span class="keyword">this</span>, other)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Check whether the products&#x27; properties are equal.</span></span><br><span class="line">        <span class="keyword">return</span> Code.Equals(other.Code) &amp;&amp; Name.Equals(other.Name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If Equals() returns true for a pair of objects</span></span><br><span class="line">    <span class="comment">// then GetHashCode() must return the same value for these objects.</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">int</span> <span class="title">GetHashCode</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Get hash code for the Name field if it is not null.</span></span><br><span class="line">        <span class="built_in">int</span> hashProductName = Name == <span class="literal">null</span> ? <span class="number">0</span> : Name.GetHashCode();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Get hash code for the Code field.</span></span><br><span class="line">        <span class="built_in">int</span> hashProductCode = Code.GetHashCode();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Calculate the hash code for the product.</span></span><br><span class="line">        <span class="keyword">return</span> hashProductName ^ hashProductCode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyProduct[] products = &#123; <span class="keyword">new</span> MyProduct &#123; Name = <span class="string">&quot;apple&quot;</span>, Code = <span class="number">9</span> &#125;,</span><br><span class="line">                       <span class="keyword">new</span> MyProduct &#123; Name = <span class="string">&quot;orange&quot;</span>, Code = <span class="number">4</span> &#125;,</span><br><span class="line">                       <span class="keyword">new</span> MyProduct &#123; Name = <span class="string">&quot;apple&quot;</span>, Code = <span class="number">9</span> &#125;,</span><br><span class="line">                       <span class="keyword">new</span> MyProduct &#123; Name = <span class="string">&quot;lemon&quot;</span>, Code = <span class="number">12</span> &#125; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Exclude duplicates.</span></span><br><span class="line"></span><br><span class="line">IEnumerable&lt;MyProduct&gt; noduplicates =</span><br><span class="line">    products.Distinct();</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> product <span class="keyword">in</span> noduplicates)</span><br><span class="line">    Console.WriteLine(product.Name + <span class="string">&quot; &quot;</span> + product.Code);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    This code produces the following output:</span></span><br><span class="line"><span class="comment">    apple 9</span></span><br><span class="line"><span class="comment">    orange 4</span></span><br><span class="line"><span class="comment">    lemon 12</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="ElementAt"><a href="#ElementAt" class="headerlink" title="ElementAt"></a>ElementAt</h2><p>返回序列中指定索引处的元素。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span>[] names =</span><br><span class="line">    &#123; <span class="string">&quot;Hartono, Tommy&quot;</span>, <span class="string">&quot;Adams, Terry&quot;</span>, <span class="string">&quot;Andersen, Henriette Thaulow&quot;</span>,</span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;Hedlund, Magnus&quot;</span>, <span class="string">&quot;Ito, Shu&quot;</span> &#125;;</span><br><span class="line">Random random = <span class="keyword">new</span> Random(DateTime.Now.Millisecond);</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> name = names.ElementAt(random.Next(<span class="number">0</span>, names.Length));</span><br><span class="line"></span><br><span class="line">Console.WriteLine(<span class="string">&quot;The name chosen at random is &#x27;&#123;0&#125;&#x27;.&quot;</span>, name);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> This code produces output similar to the following:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> The name chosen at random is &#x27;Ito, Shu&#x27;.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="ElementAtOrDefault"><a href="#ElementAtOrDefault" class="headerlink" title="ElementAtOrDefault"></a>ElementAtOrDefault</h2><p>返回序列中指定索引处的元素；如果索引超出范围，则返回默认值。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span>[] names =</span><br><span class="line">    &#123; <span class="string">&quot;Hartono, Tommy&quot;</span>, <span class="string">&quot;Adams, Terry&quot;</span>, <span class="string">&quot;Andersen, Henriette Thaulow&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Hedlund, Magnus&quot;</span>, <span class="string">&quot;Ito, Shu&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> index = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> name = names.ElementAtOrDefault(index);</span><br><span class="line"></span><br><span class="line">Console.WriteLine(</span><br><span class="line">    <span class="string">&quot;The name chosen at index &#123;0&#125; is &#x27;&#123;1&#125;&#x27;.&quot;</span>,</span><br><span class="line">    index,</span><br><span class="line">    String.IsNullOrEmpty(name) ? <span class="string">&quot;&lt;no name at this index&gt;&quot;</span> : name);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> This code produces the following output:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> The name chosen at index 20 is &#x27;&lt;no name at this index&gt;&#x27;.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="Empty"><a href="#Empty" class="headerlink" title="Empty"></a>Empty</h2><p>返回具有指定类型参数的空 IEnumerable<T>。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span>[] names1 = &#123; <span class="string">&quot;Hartono, Tommy&quot;</span> &#125;;</span><br><span class="line"><span class="built_in">string</span>[] names2 = &#123; <span class="string">&quot;Adams, Terry&quot;</span>, <span class="string">&quot;Andersen, Henriette Thaulow&quot;</span>,</span><br><span class="line">                      <span class="string">&quot;Hedlund, Magnus&quot;</span>, <span class="string">&quot;Ito, Shu&quot;</span> &#125;;</span><br><span class="line"><span class="built_in">string</span>[] names3 = &#123; <span class="string">&quot;Solanki, Ajay&quot;</span>, <span class="string">&quot;Hoeing, Helge&quot;</span>,</span><br><span class="line">                      <span class="string">&quot;Andersen, Henriette Thaulow&quot;</span>,</span><br><span class="line">                      <span class="string">&quot;Potra, Cristina&quot;</span>, <span class="string">&quot;Iallo, Lucio&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line">List&lt;<span class="built_in">string</span>[]&gt; namesList =</span><br><span class="line">    <span class="keyword">new</span> List&lt;<span class="built_in">string</span>[]&gt; &#123; names1, names2, names3 &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Only include arrays that have four or more elements</span></span><br><span class="line">IEnumerable&lt;<span class="built_in">string</span>&gt; allNames =</span><br><span class="line">    namesList.Aggregate(Enumerable.Empty&lt;<span class="built_in">string</span>&gt;(),</span><br><span class="line">    (current, next) =&gt; next.Length &gt; <span class="number">3</span> ? current.Union(next) : current);</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> (<span class="built_in">string</span> name <span class="keyword">in</span> allNames)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> This code produces the following output:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> Adams, Terry</span></span><br><span class="line"><span class="comment"> Andersen, Henriette Thaulow</span></span><br><span class="line"><span class="comment"> Hedlund, Magnus</span></span><br><span class="line"><span class="comment"> Ito, Shu</span></span><br><span class="line"><span class="comment"> Solanki, Ajay</span></span><br><span class="line"><span class="comment"> Hoeing, Helge</span></span><br><span class="line"><span class="comment"> Potra, Cristina</span></span><br><span class="line"><span class="comment"> Iallo, Lucio</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="Except"><a href="#Except" class="headerlink" title="Except"></a>Except</h2><p>生成两个序列的差集。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">double</span>[] numbers1 = &#123; <span class="number">2.0</span>, <span class="number">2.0</span>, <span class="number">2.1</span>, <span class="number">2.2</span>, <span class="number">2.3</span>, <span class="number">2.3</span>, <span class="number">2.4</span>, <span class="number">2.5</span> &#125;;</span><br><span class="line"><span class="built_in">double</span>[] numbers2 = &#123; <span class="number">2.2</span> &#125;;</span><br><span class="line"></span><br><span class="line">IEnumerable&lt;<span class="built_in">double</span>&gt; onlyInFirstSet = numbers1.Except(numbers2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> (<span class="built_in">double</span> number <span class="keyword">in</span> onlyInFirstSet)</span><br><span class="line">    Console.WriteLine(number);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> This code produces the following output:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> 2</span></span><br><span class="line"><span class="comment"> 2.1</span></span><br><span class="line"><span class="comment"> 2.3</span></span><br><span class="line"><span class="comment"> 2.4</span></span><br><span class="line"><span class="comment"> 2.5</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ProductA</span> : <span class="title">IEquatable</span>&lt;<span class="title">ProductA</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Code &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">Equals</span>(<span class="params">ProductA other</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (other <span class="keyword">is</span> <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.Name == other.Name &amp;&amp; <span class="keyword">this</span>.Code == other.Code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">bool</span> <span class="title">Equals</span>(<span class="params"><span class="built_in">object</span> obj</span>)</span> =&gt; Equals(obj <span class="keyword">as</span> ProductA);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">int</span> <span class="title">GetHashCode</span>()</span> =&gt; (Name, Code).GetHashCode();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ProductA[] fruits1 = &#123; <span class="keyword">new</span> ProductA &#123; Name = <span class="string">&quot;apple&quot;</span>, Code = <span class="number">9</span> &#125;,</span><br><span class="line">                       <span class="keyword">new</span> ProductA &#123; Name = <span class="string">&quot;orange&quot;</span>, Code = <span class="number">4</span> &#125;,</span><br><span class="line">                        <span class="keyword">new</span> ProductA &#123; Name = <span class="string">&quot;lemon&quot;</span>, Code = <span class="number">12</span> &#125; &#125;;</span><br><span class="line"></span><br><span class="line">ProductA[] fruits2 = &#123; <span class="keyword">new</span> ProductA &#123; Name = <span class="string">&quot;apple&quot;</span>, Code = <span class="number">9</span> &#125; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get all the elements from the first array</span></span><br><span class="line"><span class="comment">// except for the elements from the second array.</span></span><br><span class="line"></span><br><span class="line">IEnumerable&lt;ProductA&gt; except =</span><br><span class="line">    fruits1.Except(fruits2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> product <span class="keyword">in</span> except)</span><br><span class="line">    Console.WriteLine(product.Name + <span class="string">&quot; &quot;</span> + product.Code);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  This code produces the following output:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  orange 4</span></span><br><span class="line"><span class="comment">  lemon 12</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Product</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Code &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Custom comparer for the Product class</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">ProductComparer</span> : <span class="title">IEqualityComparer</span>&lt;<span class="title">Product</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Products are equal if their names and product numbers are equal.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">Equals</span>(<span class="params">Product x, Product y</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Check whether the compared objects reference the same data.</span></span><br><span class="line">        <span class="keyword">if</span> (Object.ReferenceEquals(x, y)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Check whether any of the compared objects is null.</span></span><br><span class="line">        <span class="keyword">if</span> (Object.ReferenceEquals(x, <span class="literal">null</span>) || Object.ReferenceEquals(y, <span class="literal">null</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Check whether the products&#x27; properties are equal.</span></span><br><span class="line">        <span class="keyword">return</span> x.Code == y.Code &amp;&amp; x.Name == y.Name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If Equals() returns true for a pair of objects</span></span><br><span class="line">    <span class="comment">// then GetHashCode() must return the same value for these objects.</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">GetHashCode</span>(<span class="params">Product product</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//Check whether the object is null</span></span><br><span class="line">        <span class="keyword">if</span> (Object.ReferenceEquals(product, <span class="literal">null</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Get hash code for the Name field if it is not null.</span></span><br><span class="line">        <span class="built_in">int</span> hashProductName = product.Name == <span class="literal">null</span> ? <span class="number">0</span> : product.Name.GetHashCode();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Get hash code for the Code field.</span></span><br><span class="line">        <span class="built_in">int</span> hashProductCode = product.Code.GetHashCode();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Calculate the hash code for the product.</span></span><br><span class="line">        <span class="keyword">return</span> hashProductName ^ hashProductCode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Product[] fruits1 = &#123; <span class="keyword">new</span> Product &#123; Name = <span class="string">&quot;apple&quot;</span>, Code = <span class="number">9</span> &#125;,</span><br><span class="line">                       <span class="keyword">new</span> Product &#123; Name = <span class="string">&quot;orange&quot;</span>, Code = <span class="number">4</span> &#125;,</span><br><span class="line">                        <span class="keyword">new</span> Product &#123; Name = <span class="string">&quot;lemon&quot;</span>, Code = <span class="number">12</span> &#125; &#125;;</span><br><span class="line"></span><br><span class="line">Product[] fruits2 = &#123; <span class="keyword">new</span> Product &#123; Name = <span class="string">&quot;apple&quot;</span>, Code = <span class="number">9</span> &#125; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get all the elements from the first array</span></span><br><span class="line"><span class="comment">// except for the elements from the second array.</span></span><br><span class="line"></span><br><span class="line">IEnumerable&lt;Product&gt; except =</span><br><span class="line">    fruits1.Except(fruits2, <span class="keyword">new</span> ProductComparer());</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> product <span class="keyword">in</span> except)</span><br><span class="line">    Console.WriteLine(product.Name + <span class="string">&quot; &quot;</span> + product.Code);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  This code produces the following output:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  orange 4</span></span><br><span class="line"><span class="comment">  lemon 12</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="First"><a href="#First" class="headerlink" title="First"></a>First</h2><p>返回序列中的第一个元素。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span>[] numbers = &#123; <span class="number">9</span>, <span class="number">34</span>, <span class="number">65</span>, <span class="number">92</span>, <span class="number">87</span>, <span class="number">435</span>, <span class="number">3</span>, <span class="number">54</span>,</span><br><span class="line">                    <span class="number">83</span>, <span class="number">23</span>, <span class="number">87</span>, <span class="number">435</span>, <span class="number">67</span>, <span class="number">12</span>, <span class="number">19</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> first = numbers.First();</span><br><span class="line"></span><br><span class="line">Console.WriteLine(first);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> This code produces the following output:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> 9</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span>[] numbers = &#123; <span class="number">9</span>, <span class="number">34</span>, <span class="number">65</span>, <span class="number">92</span>, <span class="number">87</span>, <span class="number">435</span>, <span class="number">3</span>, <span class="number">54</span>,</span><br><span class="line">                    <span class="number">83</span>, <span class="number">23</span>, <span class="number">87</span>, <span class="number">435</span>, <span class="number">67</span>, <span class="number">12</span>, <span class="number">19</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> first = numbers.First(number =&gt; number &gt; <span class="number">80</span>);</span><br><span class="line"></span><br><span class="line">Console.WriteLine(first);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> This code produces the following output:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> 92</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="FirstOrDefault"><a href="#FirstOrDefault" class="headerlink" title="FirstOrDefault"></a>FirstOrDefault</h2><p>返回序列中的第一个元素；如果未找到该元素，则返回默认值。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span>[] names = &#123; <span class="string">&quot;Hartono, Tommy&quot;</span>, <span class="string">&quot;Adams, Terry&quot;</span>,</span><br><span class="line">                     <span class="string">&quot;Andersen, Henriette Thaulow&quot;</span>,</span><br><span class="line">                     <span class="string">&quot;Hedlund, Magnus&quot;</span>, <span class="string">&quot;Ito, Shu&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> firstLongName = names.FirstOrDefault(name =&gt; name.Length &gt; <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">Console.WriteLine(<span class="string">&quot;The first long name is &#x27;&#123;0&#125;&#x27;.&quot;</span>, firstLongName);</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> firstVeryLongName = names.FirstOrDefault(name =&gt; name.Length &gt; <span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">Console.WriteLine(</span><br><span class="line">    <span class="string">&quot;There is &#123;0&#125; name longer than 30 characters.&quot;</span>,</span><br><span class="line">    <span class="built_in">string</span>.IsNullOrEmpty(firstVeryLongName) ? <span class="string">&quot;not a&quot;</span> : <span class="string">&quot;a&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> This code produces the following output:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> The first long name is &#x27;Andersen, Henriette Thaulow&#x27;.</span></span><br><span class="line"><span class="comment"> There is not a name longer than 30 characters.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span>[] numbers = &#123; &#125;;</span><br><span class="line"><span class="built_in">int</span> first = numbers.FirstOrDefault();</span><br><span class="line">Console.WriteLine(first);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> This code produces the following output:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> 0</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">List&lt;<span class="built_in">int</span>&gt; months = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt; &#123; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Setting the default value to 1 after the query.</span></span><br><span class="line"><span class="built_in">int</span> firstMonth1 = months.FirstOrDefault();</span><br><span class="line"><span class="keyword">if</span> (firstMonth1 == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    firstMonth1 = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">Console.WriteLine(<span class="string">&quot;The value of the firstMonth1 variable is &#123;0&#125;&quot;</span>, firstMonth1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Setting the default value to 1 by using DefaultIfEmpty() in the query.</span></span><br><span class="line"><span class="built_in">int</span> firstMonth2 = months.DefaultIfEmpty(<span class="number">1</span>).First();</span><br><span class="line">Console.WriteLine(<span class="string">&quot;The value of the firstMonth2 variable is &#123;0&#125;&quot;</span>, firstMonth2);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> This code produces the following output:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> The value of the firstMonth1 variable is 1</span></span><br><span class="line"><span class="comment"> The value of the firstMonth2 variable is 1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="GroupBy"><a href="#GroupBy" class="headerlink" title="GroupBy"></a>GroupBy</h2><p>对序列中的元素进行分组。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Pet</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">double</span> Age &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">GroupByEx4</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Create a list of pets.</span></span><br><span class="line">    List&lt;Pet&gt; petsList =</span><br><span class="line">        <span class="keyword">new</span> List&lt;Pet&gt;&#123; <span class="keyword">new</span> Pet &#123; Name=<span class="string">&quot;Barley&quot;</span>, Age=<span class="number">8.3</span> &#125;,</span><br><span class="line">                       <span class="keyword">new</span> Pet &#123; Name=<span class="string">&quot;Boots&quot;</span>, Age=<span class="number">4.9</span> &#125;,</span><br><span class="line">                       <span class="keyword">new</span> Pet &#123; Name=<span class="string">&quot;Whiskers&quot;</span>, Age=<span class="number">1.5</span> &#125;,</span><br><span class="line">                       <span class="keyword">new</span> Pet &#123; Name=<span class="string">&quot;Daisy&quot;</span>, Age=<span class="number">4.3</span> &#125; &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Group Pet.Age values by the Math.Floor of the age.</span></span><br><span class="line">    <span class="comment">// Then project an anonymous type from each group</span></span><br><span class="line">    <span class="comment">// that consists of the key, the count of the group&#x27;s</span></span><br><span class="line">    <span class="comment">// elements, and the minimum and maximum age in the group.</span></span><br><span class="line">    <span class="keyword">var</span> query = petsList.GroupBy(</span><br><span class="line">        pet =&gt; Math.Floor(pet.Age),</span><br><span class="line">        pet =&gt; pet.Age,</span><br><span class="line">        (baseAge, ages) =&gt; <span class="keyword">new</span></span><br><span class="line">        &#123;</span><br><span class="line">            Key = baseAge,</span><br><span class="line">            Count = ages.Count(),</span><br><span class="line">            Min = ages.Min(),</span><br><span class="line">            Max = ages.Max()</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Iterate over each anonymous type.</span></span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> result <span class="keyword">in</span> query)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;\nAge group: &quot;</span> + result.Key);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Number of pets in this age group: &quot;</span> + result.Count);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Minimum age: &quot;</span> + result.Min);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Maximum age: &quot;</span> + result.Max);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*  This code produces the following output:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        Age group: 8</span></span><br><span class="line"><span class="comment">        Number of pets in this age group: 1</span></span><br><span class="line"><span class="comment">        Minimum age: 8.3</span></span><br><span class="line"><span class="comment">        Maximum age: 8.3</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        Age group: 4</span></span><br><span class="line"><span class="comment">        Number of pets in this age group: 2</span></span><br><span class="line"><span class="comment">        Minimum age: 4.3</span></span><br><span class="line"><span class="comment">        Maximum age: 4.9</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        Age group: 1</span></span><br><span class="line"><span class="comment">        Number of pets in this age group: 1</span></span><br><span class="line"><span class="comment">        Minimum age: 1.5</span></span><br><span class="line"><span class="comment">        Maximum age: 1.5</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Pet</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Age &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Uses method-based query syntax.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">GroupByEx1</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Create a list of pets.</span></span><br><span class="line">    List&lt;Pet&gt; pets =</span><br><span class="line">        <span class="keyword">new</span> List&lt;Pet&gt;&#123; <span class="keyword">new</span> Pet &#123; Name=<span class="string">&quot;Barley&quot;</span>, Age=<span class="number">8</span> &#125;,</span><br><span class="line">                       <span class="keyword">new</span> Pet &#123; Name=<span class="string">&quot;Boots&quot;</span>, Age=<span class="number">4</span> &#125;,</span><br><span class="line">                       <span class="keyword">new</span> Pet &#123; Name=<span class="string">&quot;Whiskers&quot;</span>, Age=<span class="number">1</span> &#125;,</span><br><span class="line">                       <span class="keyword">new</span> Pet &#123; Name=<span class="string">&quot;Daisy&quot;</span>, Age=<span class="number">4</span> &#125; &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Group the pets using Age as the key value</span></span><br><span class="line">    <span class="comment">// and selecting only the pet&#x27;s Name for each value.</span></span><br><span class="line">    IEnumerable&lt;IGrouping&lt;<span class="built_in">int</span>, <span class="built_in">string</span>&gt;&gt; query =</span><br><span class="line">        pets.GroupBy(pet =&gt; pet.Age, pet =&gt; pet.Name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Iterate over each IGrouping in the collection.</span></span><br><span class="line">    <span class="keyword">foreach</span> (IGrouping&lt;<span class="built_in">int</span>, <span class="built_in">string</span>&gt; petGroup <span class="keyword">in</span> query)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Print the key value of the IGrouping.</span></span><br><span class="line">        Console.WriteLine(petGroup.Key);</span><br><span class="line">        <span class="comment">// Iterate over each value in the</span></span><br><span class="line">        <span class="comment">// IGrouping and print the value.</span></span><br><span class="line">        <span class="keyword">foreach</span> (<span class="built_in">string</span> name <span class="keyword">in</span> petGroup)</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;  &#123;0&#125;&quot;</span>, name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> This code produces the following output:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> 8</span></span><br><span class="line"><span class="comment">   Barley</span></span><br><span class="line"><span class="comment"> 4</span></span><br><span class="line"><span class="comment">   Boots</span></span><br><span class="line"><span class="comment">   Daisy</span></span><br><span class="line"><span class="comment"> 1</span></span><br><span class="line"><span class="comment">   Whiskers</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Pet</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">double</span> Age &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">GroupByEx3</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Create a list of pets.</span></span><br><span class="line">    List&lt;Pet&gt; petsList =</span><br><span class="line">        <span class="keyword">new</span> List&lt;Pet&gt;&#123; <span class="keyword">new</span> Pet &#123; Name=<span class="string">&quot;Barley&quot;</span>, Age=<span class="number">8.3</span> &#125;,</span><br><span class="line">                       <span class="keyword">new</span> Pet &#123; Name=<span class="string">&quot;Boots&quot;</span>, Age=<span class="number">4.9</span> &#125;,</span><br><span class="line">                       <span class="keyword">new</span> Pet &#123; Name=<span class="string">&quot;Whiskers&quot;</span>, Age=<span class="number">1.5</span> &#125;,</span><br><span class="line">                       <span class="keyword">new</span> Pet &#123; Name=<span class="string">&quot;Daisy&quot;</span>, Age=<span class="number">4.3</span> &#125; &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Group Pet objects by the Math.Floor of their age.</span></span><br><span class="line">    <span class="comment">// Then project an anonymous type from each group</span></span><br><span class="line">    <span class="comment">// that consists of the key, the count of the group&#x27;s</span></span><br><span class="line">    <span class="comment">// elements, and the minimum and maximum age in the group.</span></span><br><span class="line">    <span class="keyword">var</span> query = petsList.GroupBy(</span><br><span class="line">        pet =&gt; Math.Floor(pet.Age),</span><br><span class="line">        (age, pets) =&gt; <span class="keyword">new</span></span><br><span class="line">        &#123;</span><br><span class="line">            Key = age,</span><br><span class="line">            Count = pets.Count(),</span><br><span class="line">            Min = pets.Min(pet =&gt; pet.Age),</span><br><span class="line">            Max = pets.Max(pet =&gt; pet.Age)</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Iterate over each anonymous type.</span></span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> result <span class="keyword">in</span> query)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;\nAge group: &quot;</span> + result.Key);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Number of pets in this age group: &quot;</span> + result.Count);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Minimum age: &quot;</span> + result.Min);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Maximum age: &quot;</span> + result.Max);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*  This code produces the following output:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        Age group: 8</span></span><br><span class="line"><span class="comment">        Number of pets in this age group: 1</span></span><br><span class="line"><span class="comment">        Minimum age: 8.3</span></span><br><span class="line"><span class="comment">        Maximum age: 8.3</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        Age group: 4</span></span><br><span class="line"><span class="comment">        Number of pets in this age group: 2</span></span><br><span class="line"><span class="comment">        Minimum age: 4.3</span></span><br><span class="line"><span class="comment">        Maximum age: 4.9</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        Age group: 1</span></span><br><span class="line"><span class="comment">        Number of pets in this age group: 1</span></span><br><span class="line"><span class="comment">        Minimum age: 1.5</span></span><br><span class="line"><span class="comment">        Maximum age: 1.5</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="GroupJoin"><a href="#GroupJoin" class="headerlink" title="GroupJoin"></a>GroupJoin</h2><p>基于键值等同性将两个序列的元素进行关联，并对结果进行分组。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Pet</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> Person Owner &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">GroupJoinEx1</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    Person magnus = <span class="keyword">new</span> Person &#123; Name = <span class="string">&quot;Hedlund, Magnus&quot;</span> &#125;;</span><br><span class="line">    Person terry = <span class="keyword">new</span> Person &#123; Name = <span class="string">&quot;Adams, Terry&quot;</span> &#125;;</span><br><span class="line">    Person charlotte = <span class="keyword">new</span> Person &#123; Name = <span class="string">&quot;Weiss, Charlotte&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line">    Pet barley = <span class="keyword">new</span> Pet &#123; Name = <span class="string">&quot;Barley&quot;</span>, Owner = terry &#125;;</span><br><span class="line">    Pet boots = <span class="keyword">new</span> Pet &#123; Name = <span class="string">&quot;Boots&quot;</span>, Owner = terry &#125;;</span><br><span class="line">    Pet whiskers = <span class="keyword">new</span> Pet &#123; Name = <span class="string">&quot;Whiskers&quot;</span>, Owner = charlotte &#125;;</span><br><span class="line">    Pet daisy = <span class="keyword">new</span> Pet &#123; Name = <span class="string">&quot;Daisy&quot;</span>, Owner = magnus &#125;;</span><br><span class="line"></span><br><span class="line">    List&lt;Person&gt; people = <span class="keyword">new</span> List&lt;Person&gt; &#123; magnus, terry, charlotte &#125;;</span><br><span class="line">    List&lt;Pet&gt; pets = <span class="keyword">new</span> List&lt;Pet&gt; &#123; barley, boots, whiskers, daisy &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create a list where each element is an anonymous</span></span><br><span class="line">    <span class="comment">// type that contains a person&#x27;s name and</span></span><br><span class="line">    <span class="comment">// a collection of names of the pets they own.</span></span><br><span class="line">    <span class="keyword">var</span> query =</span><br><span class="line">        people.GroupJoin(pets,</span><br><span class="line">                         person =&gt; person,</span><br><span class="line">                         pet =&gt; pet.Owner,</span><br><span class="line">                         (person, petCollection) =&gt;</span><br><span class="line">                             <span class="keyword">new</span></span><br><span class="line">                             &#123;</span><br><span class="line">                                 OwnerName = person.Name,</span><br><span class="line">                                 Pets = petCollection.Select(pet =&gt; pet.Name)</span><br><span class="line">                             &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> obj <span class="keyword">in</span> query)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Output the owner&#x27;s name.</span></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;&#123;0&#125;:&quot;</span>, obj.OwnerName);</span><br><span class="line">        <span class="comment">// Output each of the owner&#x27;s pet&#x27;s names.</span></span><br><span class="line">        <span class="keyword">foreach</span> (<span class="built_in">string</span> pet <span class="keyword">in</span> obj.Pets)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;  &#123;0&#125;&quot;</span>, pet);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> This code produces the following output:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> Hedlund, Magnus:</span></span><br><span class="line"><span class="comment">   Daisy</span></span><br><span class="line"><span class="comment"> Adams, Terry:</span></span><br><span class="line"><span class="comment">   Barley</span></span><br><span class="line"><span class="comment">   Boots</span></span><br><span class="line"><span class="comment"> Weiss, Charlotte:</span></span><br><span class="line"><span class="comment">   Whiskers</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="Intersect"><a href="#Intersect" class="headerlink" title="Intersect"></a>Intersect</h2><p>生成两个序列的交集。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span>[] id1 = &#123; <span class="number">44</span>, <span class="number">26</span>, <span class="number">92</span>, <span class="number">30</span>, <span class="number">71</span>, <span class="number">38</span> &#125;;</span><br><span class="line"><span class="built_in">int</span>[] id2 = &#123; <span class="number">39</span>, <span class="number">59</span>, <span class="number">83</span>, <span class="number">47</span>, <span class="number">26</span>, <span class="number">4</span>, <span class="number">30</span> &#125;;</span><br><span class="line"></span><br><span class="line">IEnumerable&lt;<span class="built_in">int</span>&gt; both = id1.Intersect(id2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> (<span class="built_in">int</span> id <span class="keyword">in</span> both)</span><br><span class="line">    Console.WriteLine(id);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> This code produces the following output:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> 26</span></span><br><span class="line"><span class="comment"> 30</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ProductA</span> : <span class="title">IEquatable</span>&lt;<span class="title">ProductA</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Code &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">Equals</span>(<span class="params">ProductA other</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (other <span class="keyword">is</span> <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.Name == other.Name &amp;&amp; <span class="keyword">this</span>.Code == other.Code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">bool</span> <span class="title">Equals</span>(<span class="params"><span class="built_in">object</span> obj</span>)</span> =&gt; Equals(obj <span class="keyword">as</span> ProductA);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">int</span> <span class="title">GetHashCode</span>()</span> =&gt; (Name, Code).GetHashCode();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ProductA[] store1 = &#123; <span class="keyword">new</span> ProductA &#123; Name = <span class="string">&quot;apple&quot;</span>, Code = <span class="number">9</span> &#125;,</span><br><span class="line">                       <span class="keyword">new</span> ProductA &#123; Name = <span class="string">&quot;orange&quot;</span>, Code = <span class="number">4</span> &#125; &#125;;</span><br><span class="line"></span><br><span class="line">ProductA[] store2 = &#123; <span class="keyword">new</span> ProductA &#123; Name = <span class="string">&quot;apple&quot;</span>, Code = <span class="number">9</span> &#125;,</span><br><span class="line">                       <span class="keyword">new</span> ProductA &#123; Name = <span class="string">&quot;lemon&quot;</span>, Code = <span class="number">12</span> &#125; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get the products from the first array</span></span><br><span class="line"><span class="comment">// that have duplicates in the second array.</span></span><br><span class="line"></span><br><span class="line">IEnumerable&lt;ProductA&gt; duplicates =</span><br><span class="line">    store1.Intersect(store2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> product <span class="keyword">in</span> duplicates)</span><br><span class="line">    Console.WriteLine(product.Name + <span class="string">&quot; &quot;</span> + product.Code);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    This code produces the following output:</span></span><br><span class="line"><span class="comment">    apple 9</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Product</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Code &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Custom comparer for the Product class</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">ProductComparer</span> : <span class="title">IEqualityComparer</span>&lt;<span class="title">Product</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Products are equal if their names and product numbers are equal.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">Equals</span>(<span class="params">Product x, Product y</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Check whether the compared objects reference the same data.</span></span><br><span class="line">        <span class="keyword">if</span> (Object.ReferenceEquals(x, y)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Check whether any of the compared objects is null.</span></span><br><span class="line">        <span class="keyword">if</span> (Object.ReferenceEquals(x, <span class="literal">null</span>) || Object.ReferenceEquals(y, <span class="literal">null</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Check whether the products&#x27; properties are equal.</span></span><br><span class="line">        <span class="keyword">return</span> x.Code == y.Code &amp;&amp; x.Name == y.Name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If Equals() returns true for a pair of objects</span></span><br><span class="line">    <span class="comment">// then GetHashCode() must return the same value for these objects.</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">GetHashCode</span>(<span class="params">Product product</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//Check whether the object is null</span></span><br><span class="line">        <span class="keyword">if</span> (Object.ReferenceEquals(product, <span class="literal">null</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Get hash code for the Name field if it is not null.</span></span><br><span class="line">        <span class="built_in">int</span> hashProductName = product.Name == <span class="literal">null</span> ? <span class="number">0</span> : product.Name.GetHashCode();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Get hash code for the Code field.</span></span><br><span class="line">        <span class="built_in">int</span> hashProductCode = product.Code.GetHashCode();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Calculate the hash code for the product.</span></span><br><span class="line">        <span class="keyword">return</span> hashProductName ^ hashProductCode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Product[] store1 = &#123; <span class="keyword">new</span> Product &#123; Name = <span class="string">&quot;apple&quot;</span>, Code = <span class="number">9</span> &#125;,</span><br><span class="line">                       <span class="keyword">new</span> Product &#123; Name = <span class="string">&quot;orange&quot;</span>, Code = <span class="number">4</span> &#125; &#125;;</span><br><span class="line"></span><br><span class="line">Product[] store2 = &#123; <span class="keyword">new</span> Product &#123; Name = <span class="string">&quot;apple&quot;</span>, Code = <span class="number">9</span> &#125;,</span><br><span class="line">                       <span class="keyword">new</span> Product &#123; Name = <span class="string">&quot;lemon&quot;</span>, Code = <span class="number">12</span> &#125; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get the products from the first array</span></span><br><span class="line"><span class="comment">// that have duplicates in the second array.</span></span><br><span class="line"></span><br><span class="line">IEnumerable&lt;Product&gt; duplicates =</span><br><span class="line">    store1.Intersect(store2, <span class="keyword">new</span> ProductComparer());</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> product <span class="keyword">in</span> duplicates)</span><br><span class="line">    Console.WriteLine(product.Name + <span class="string">&quot; &quot;</span> + product.Code);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    This code produces the following output:</span></span><br><span class="line"><span class="comment">    apple 9</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="Join"><a href="#Join" class="headerlink" title="Join"></a>Join</h2><p>基于匹配键对两个序列的元素进行关联。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Pet</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> Person Owner &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">JoinEx1</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    Person magnus = <span class="keyword">new</span> Person &#123; Name = <span class="string">&quot;Hedlund, Magnus&quot;</span> &#125;;</span><br><span class="line">    Person terry = <span class="keyword">new</span> Person &#123; Name = <span class="string">&quot;Adams, Terry&quot;</span> &#125;;</span><br><span class="line">    Person charlotte = <span class="keyword">new</span> Person &#123; Name = <span class="string">&quot;Weiss, Charlotte&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line">    Pet barley = <span class="keyword">new</span> Pet &#123; Name = <span class="string">&quot;Barley&quot;</span>, Owner = terry &#125;;</span><br><span class="line">    Pet boots = <span class="keyword">new</span> Pet &#123; Name = <span class="string">&quot;Boots&quot;</span>, Owner = terry &#125;;</span><br><span class="line">    Pet whiskers = <span class="keyword">new</span> Pet &#123; Name = <span class="string">&quot;Whiskers&quot;</span>, Owner = charlotte &#125;;</span><br><span class="line">    Pet daisy = <span class="keyword">new</span> Pet &#123; Name = <span class="string">&quot;Daisy&quot;</span>, Owner = magnus &#125;;</span><br><span class="line"></span><br><span class="line">    List&lt;Person&gt; people = <span class="keyword">new</span> List&lt;Person&gt; &#123; magnus, terry, charlotte &#125;;</span><br><span class="line">    List&lt;Pet&gt; pets = <span class="keyword">new</span> List&lt;Pet&gt; &#123; barley, boots, whiskers, daisy &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create a list of Person-Pet pairs where</span></span><br><span class="line">    <span class="comment">// each element is an anonymous type that contains a</span></span><br><span class="line">    <span class="comment">// Pet&#x27;s name and the name of the Person that owns the Pet.</span></span><br><span class="line">    <span class="keyword">var</span> query =</span><br><span class="line">        people.Join(pets,</span><br><span class="line">                    person =&gt; person,</span><br><span class="line">                    pet =&gt; pet.Owner,</span><br><span class="line">                    (person, pet) =&gt;</span><br><span class="line">                        <span class="keyword">new</span> &#123; OwnerName = person.Name, Pet = pet.Name &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> obj <span class="keyword">in</span> query)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(</span><br><span class="line">            <span class="string">&quot;&#123;0&#125; - &#123;1&#125;&quot;</span>,</span><br><span class="line">            obj.OwnerName,</span><br><span class="line">            obj.Pet);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> This code produces the following output:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> Hedlund, Magnus - Daisy</span></span><br><span class="line"><span class="comment"> Adams, Terry - Barley</span></span><br><span class="line"><span class="comment"> Adams, Terry - Boots</span></span><br><span class="line"><span class="comment"> Weiss, Charlotte - Whiskers</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="Last"><a href="#Last" class="headerlink" title="Last"></a>Last</h2><p>返回序列的最后一个元素。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span>[] numbers = &#123; <span class="number">9</span>, <span class="number">34</span>, <span class="number">65</span>, <span class="number">92</span>, <span class="number">87</span>, <span class="number">435</span>, <span class="number">3</span>, <span class="number">54</span>,</span><br><span class="line">                    <span class="number">83</span>, <span class="number">23</span>, <span class="number">87</span>, <span class="number">67</span>, <span class="number">12</span>, <span class="number">19</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> last = numbers.Last();</span><br><span class="line"></span><br><span class="line">Console.WriteLine(last);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> This code produces the following output:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> 19</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span>[] numbers = &#123; <span class="number">9</span>, <span class="number">34</span>, <span class="number">65</span>, <span class="number">92</span>, <span class="number">87</span>, <span class="number">435</span>, <span class="number">3</span>, <span class="number">54</span>,</span><br><span class="line">                    <span class="number">83</span>, <span class="number">23</span>, <span class="number">87</span>, <span class="number">67</span>, <span class="number">12</span>, <span class="number">19</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> last = numbers.Last(num =&gt; num &gt; <span class="number">80</span>);</span><br><span class="line"></span><br><span class="line">Console.WriteLine(last);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> This code produces the following output:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> 87</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="LastOrDefault"><a href="#LastOrDefault" class="headerlink" title="LastOrDefault"></a>LastOrDefault</h2><p>返回序列中的最后一个元素；如果未找到该元素，则返回默认值。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span>[] fruits = &#123; &#125;;</span><br><span class="line"><span class="built_in">string</span> last = fruits.LastOrDefault();</span><br><span class="line">Console.WriteLine(</span><br><span class="line">    String.IsNullOrEmpty(last) ? <span class="string">&quot;&lt;string is null or empty&gt;&quot;</span> : last);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> This code produces the following output:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> &lt;string is null or empty&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">List&lt;<span class="built_in">int</span>&gt; daysOfMonth = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt; &#123; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Setting the default value to 1 after the query.</span></span><br><span class="line"><span class="built_in">int</span> lastDay1 = daysOfMonth.LastOrDefault();</span><br><span class="line"><span class="keyword">if</span> (lastDay1 == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    lastDay1 = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">Console.WriteLine(<span class="string">&quot;The value of the lastDay1 variable is &#123;0&#125;&quot;</span>, lastDay1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Setting the default value to 1 by using DefaultIfEmpty() in the query.</span></span><br><span class="line"><span class="built_in">int</span> lastDay2 = daysOfMonth.DefaultIfEmpty(<span class="number">1</span>).Last();</span><br><span class="line">Console.WriteLine(<span class="string">&quot;The value of the lastDay2 variable is &#123;0&#125;&quot;</span>, lastDay2);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> This code produces the following output:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> The value of the lastDay1 variable is 1</span></span><br><span class="line"><span class="comment"> The value of the lastDay2 variable is 1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">double</span>[] numbers = &#123; <span class="number">49.6</span>, <span class="number">52.3</span>, <span class="number">51.0</span>, <span class="number">49.4</span>, <span class="number">50.2</span>, <span class="number">48.3</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">double</span> last50 = numbers.LastOrDefault(n =&gt; Math.Round(n) == <span class="number">50.0</span>);</span><br><span class="line"></span><br><span class="line">Console.WriteLine(<span class="string">&quot;The last number that rounds to 50 is &#123;0&#125;.&quot;</span>, last50);</span><br><span class="line"></span><br><span class="line"><span class="built_in">double</span> last40 = numbers.LastOrDefault(n =&gt; Math.Round(n) == <span class="number">40.0</span>);</span><br><span class="line"></span><br><span class="line">Console.WriteLine(</span><br><span class="line">    <span class="string">&quot;The last number that rounds to 40 is &#123;0&#125;.&quot;</span>,</span><br><span class="line">    last40 == <span class="number">0.0</span> ? <span class="string">&quot;&lt;DOES NOT EXIST&gt;&quot;</span> : last40.ToString());</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> This code produces the following output:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> The last number that rounds to 50 is 50.2.</span></span><br><span class="line"><span class="comment"> The last number that rounds to 40 is &lt;DOES NOT EXIST&gt;.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="LongCount"><a href="#LongCount" class="headerlink" title="LongCount"></a>LongCount</h2><p>返回表示序列中的元素数量的 Int64。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span>[] fruits = &#123; <span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;mango&quot;</span>,</span><br><span class="line">                      <span class="string">&quot;orange&quot;</span>, <span class="string">&quot;passionfruit&quot;</span>, <span class="string">&quot;grape&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">long</span> count = fruits.LongCount();</span><br><span class="line"></span><br><span class="line">Console.WriteLine(<span class="string">&quot;There are &#123;0&#125; fruits in the collection.&quot;</span>, count);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> This code produces the following output:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> There are 6 fruits in the collection.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Pet</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Age &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">LongCountEx2</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    Pet[] pets = &#123; <span class="keyword">new</span> Pet &#123; Name=<span class="string">&quot;Barley&quot;</span>, Age=<span class="number">8</span> &#125;,</span><br><span class="line">                   <span class="keyword">new</span> Pet &#123; Name=<span class="string">&quot;Boots&quot;</span>, Age=<span class="number">4</span> &#125;,</span><br><span class="line">                   <span class="keyword">new</span> Pet &#123; Name=<span class="string">&quot;Whiskers&quot;</span>, Age=<span class="number">1</span> &#125; &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">int</span> Age = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">long</span> count = pets.LongCount(pet =&gt; pet.Age &gt; Age);</span><br><span class="line"></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;There are &#123;0&#125; animals over age &#123;1&#125;.&quot;</span>, count, Age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> This code produces the following output:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> There are 2 animals over age 3.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="Max"><a href="#Max" class="headerlink" title="Max"></a>Max</h2><p>返回值序列中的最大值。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">double</span>?[] doubles = &#123; <span class="literal">null</span>, <span class="number">1.5E+104</span>, <span class="number">9E+103</span>, <span class="number">-2E+103</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">double</span>? max = doubles.Max();</span><br><span class="line"></span><br><span class="line">Console.WriteLine(<span class="string">&quot;The largest number is &#123;0&#125;.&quot;</span>, max);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> This code produces the following output:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> The largest number is 1.5E+104.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">List&lt;<span class="built_in">long</span>&gt; longs = <span class="keyword">new</span> List&lt;<span class="built_in">long</span>&gt; &#123; <span class="number">4294967296L</span>, <span class="number">466855135L</span>, <span class="number">81125L</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">long</span> max = longs.Max();</span><br><span class="line"></span><br><span class="line">Console.WriteLine(<span class="string">&quot;The largest number is &#123;0&#125;.&quot;</span>, max);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> This code produces the following output:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> The largest number is 4294967296.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Pet</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Age &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MaxEx4</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    Pet[] pets = &#123; <span class="keyword">new</span> Pet &#123; Name=<span class="string">&quot;Barley&quot;</span>, Age=<span class="number">8</span> &#125;,</span><br><span class="line">                   <span class="keyword">new</span> Pet &#123; Name=<span class="string">&quot;Boots&quot;</span>, Age=<span class="number">4</span> &#125;,</span><br><span class="line">                   <span class="keyword">new</span> Pet &#123; Name=<span class="string">&quot;Whiskers&quot;</span>, Age=<span class="number">1</span> &#125; &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> max = pets.Max(pet =&gt; pet.Age + pet.Name.Length);</span><br><span class="line"></span><br><span class="line">    Console.WriteLine(</span><br><span class="line">        <span class="string">&quot;The maximum pet age plus name length is &#123;0&#125;.&quot;</span>,</span><br><span class="line">        max);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> This code produces the following output:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> The maximum pet age plus name length is 14.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> This class implements IComparable to be able to</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> compare one Pet to another Pet.</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Pet</span> : <span class="title">IComparable</span>&lt;<span class="title">Pet</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Age &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> Compares this Pet to another Pet by</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> summing each Pet&#x27;s age and name length.</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;other&quot;&gt;</span>The Pet to compare this Pet to.<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>-1 if this Pet is &#x27;less&#x27; than the other Pet,</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 0 if they are equal,</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> or 1 if this Pet is &#x27;greater&#x27; than the other Pet.<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">    <span class="built_in">int</span> IComparable&lt;Pet&gt;.CompareTo(Pet other)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> sumOther = other.Age + other.Name.Length;</span><br><span class="line">        <span class="built_in">int</span> sumThis = <span class="keyword">this</span>.Age + <span class="keyword">this</span>.Name.Length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sumOther &gt; sumThis)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (sumOther == sumThis)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MaxEx3</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    Pet[] pets = &#123; <span class="keyword">new</span> Pet &#123; Name=<span class="string">&quot;Barley&quot;</span>, Age=<span class="number">8</span> &#125;,</span><br><span class="line">                   <span class="keyword">new</span> Pet &#123; Name=<span class="string">&quot;Boots&quot;</span>, Age=<span class="number">4</span> &#125;,</span><br><span class="line">                   <span class="keyword">new</span> Pet &#123; Name=<span class="string">&quot;Whiskers&quot;</span>, Age=<span class="number">1</span> &#125; &#125;;</span><br><span class="line"></span><br><span class="line">    Pet max = pets.Max();</span><br><span class="line"></span><br><span class="line">    Console.WriteLine(</span><br><span class="line">        <span class="string">&quot;The &#x27;maximum&#x27; animal is &#123;0&#125;.&quot;</span>,</span><br><span class="line">        max.Name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> This code produces the following output:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> The &#x27;maximum&#x27; animal is Barley.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="Min"><a href="#Min" class="headerlink" title="Min"></a>Min</h2><p>返回值序列中的最小值。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span>?[] grades = &#123; <span class="number">78</span>, <span class="number">92</span>, <span class="literal">null</span>, <span class="number">99</span>, <span class="number">37</span>, <span class="number">81</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span>? min = grades.Min();</span><br><span class="line"></span><br><span class="line">Console.WriteLine(<span class="string">&quot;The lowest grade is &#123;0&#125;.&quot;</span>, min);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> This code produces the following output:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> The lowest grade is 37.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">double</span>[] doubles = &#123; <span class="number">1.5E+104</span>, <span class="number">9E+103</span>, <span class="number">-2E+103</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">double</span> min = doubles.Min();</span><br><span class="line"></span><br><span class="line">Console.WriteLine(<span class="string">&quot;The smallest number is &#123;0&#125;.&quot;</span>, min);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> This code produces the following output:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> The smallest number is -2E+103.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Pet</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Age &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MinEx4</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    Pet[] pets = &#123; <span class="keyword">new</span> Pet &#123; Name=<span class="string">&quot;Barley&quot;</span>, Age=<span class="number">8</span> &#125;,</span><br><span class="line">                   <span class="keyword">new</span> Pet &#123; Name=<span class="string">&quot;Boots&quot;</span>, Age=<span class="number">4</span> &#125;,</span><br><span class="line">                   <span class="keyword">new</span> Pet &#123; Name=<span class="string">&quot;Whiskers&quot;</span>, Age=<span class="number">1</span> &#125; &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> min = pets.Min(pet =&gt; pet.Age);</span><br><span class="line"></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;The youngest animal is age &#123;0&#125;.&quot;</span>, min);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> This code produces the following output:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> The youngest animal is age 1.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> This class implements IComparable in order to</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> be able to compare different Pet objects.</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Pet</span> : <span class="title">IComparable</span>&lt;<span class="title">Pet</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Age &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> Compares this Pet&#x27;s age to another Pet&#x27;s age.</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;other&quot;&gt;</span>The Pet to compare this Pet to.<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>-1 if this Pet&#x27;s age is smaller,</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 0 if the Pets&#x27; ages are equal, or</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 1 if this Pet&#x27;s age is greater.<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">    <span class="built_in">int</span> IComparable&lt;Pet&gt;.CompareTo(Pet other)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (other.Age &gt; <span class="keyword">this</span>.Age)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (other.Age == <span class="keyword">this</span>.Age)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MinEx3</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    Pet[] pets = &#123; <span class="keyword">new</span> Pet &#123; Name=<span class="string">&quot;Barley&quot;</span>, Age=<span class="number">8</span> &#125;,</span><br><span class="line">                   <span class="keyword">new</span> Pet &#123; Name=<span class="string">&quot;Boots&quot;</span>, Age=<span class="number">4</span> &#125;,</span><br><span class="line">                   <span class="keyword">new</span> Pet &#123; Name=<span class="string">&quot;Whiskers&quot;</span>, Age=<span class="number">1</span> &#125; &#125;;</span><br><span class="line"></span><br><span class="line">    Pet min = pets.Min();</span><br><span class="line"></span><br><span class="line">    Console.WriteLine(</span><br><span class="line">        <span class="string">&quot;The &#x27;minimum&#x27; animal is &#123;0&#125;.&quot;</span>,</span><br><span class="line">        min.Name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> This code produces the following output:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> The &#x27;minimum&#x27; animal is Whiskers.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="OfType"><a href="#OfType" class="headerlink" title="OfType"></a>OfType</h2><p>根据指定类型筛选 IEnumerable 的元素。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">System.Collections.ArrayList fruits = <span class="keyword">new</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;Mango&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Orange&quot;</span>,</span><br><span class="line">    <span class="literal">null</span>,</span><br><span class="line">    <span class="string">&quot;Apple&quot;</span>,</span><br><span class="line">    <span class="number">3.0</span>,</span><br><span class="line">    <span class="string">&quot;Banana&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Apply OfType() to the ArrayList.</span></span><br><span class="line">IEnumerable&lt;<span class="built_in">string</span>&gt; query1 = fruits.OfType&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line"></span><br><span class="line">Console.WriteLine(<span class="string">&quot;Elements of type &#x27;string&#x27; are:&quot;</span>);</span><br><span class="line"><span class="keyword">foreach</span> (<span class="built_in">string</span> fruit <span class="keyword">in</span> query1)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(fruit);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The following query shows that the standard query operators such as</span></span><br><span class="line"><span class="comment">// Where() can be applied to the ArrayList type after calling OfType().</span></span><br><span class="line">IEnumerable&lt;<span class="built_in">string</span>&gt; query2 =</span><br><span class="line">    fruits.OfType&lt;<span class="built_in">string</span>&gt;().Where(fruit =&gt;</span><br><span class="line">    fruit.Contains(<span class="string">&#x27;n&#x27;</span>, StringComparison.CurrentCultureIgnoreCase));</span><br><span class="line"></span><br><span class="line">Console.WriteLine(<span class="string">&quot;\nThe following strings contain &#x27;n&#x27;:&quot;</span>);</span><br><span class="line"><span class="keyword">foreach</span> (<span class="built_in">string</span> fruit <span class="keyword">in</span> query2)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(fruit);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This code produces the following output:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Elements of type &#x27;string&#x27; are:</span></span><br><span class="line"><span class="comment">// Mango</span></span><br><span class="line"><span class="comment">// Orange</span></span><br><span class="line"><span class="comment">// Apple</span></span><br><span class="line"><span class="comment">// Banana</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The following strings contain &#x27;n&#x27;:</span></span><br><span class="line"><span class="comment">// Mango</span></span><br><span class="line"><span class="comment">// Orange</span></span><br><span class="line"><span class="comment">// Banana</span></span><br></pre></td></tr></table></figure>

<h2 id="OrderBy"><a href="#OrderBy" class="headerlink" title="OrderBy"></a>OrderBy</h2><p>按升序对序列的元素进行排序。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Pet</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Age &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">OrderByEx1</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    Pet[] pets = &#123; <span class="keyword">new</span> Pet &#123; Name=<span class="string">&quot;Barley&quot;</span>, Age=<span class="number">8</span> &#125;,</span><br><span class="line">                   <span class="keyword">new</span> Pet &#123; Name=<span class="string">&quot;Boots&quot;</span>, Age=<span class="number">4</span> &#125;,</span><br><span class="line">                   <span class="keyword">new</span> Pet &#123; Name=<span class="string">&quot;Whiskers&quot;</span>, Age=<span class="number">1</span> &#125; &#125;;</span><br><span class="line"></span><br><span class="line">    IEnumerable&lt;Pet&gt; query = pets.OrderBy(pet =&gt; pet.Age);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">foreach</span> (Pet pet <span class="keyword">in</span> query)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;&#123;0&#125; - &#123;1&#125;&quot;</span>, pet.Name, pet.Age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> This code produces the following output:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> Whiskers - 1</span></span><br><span class="line"><span class="comment"> Boots - 4</span></span><br><span class="line"><span class="comment"> Barley - 8</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="OrderByDescending"><a href="#OrderByDescending" class="headerlink" title="OrderByDescending"></a>OrderByDescending</h2><p>按降序对序列的元素排序。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> This IComparer class sorts by the fractional part of the decimal number.</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SpecialComparer</span> : <span class="title">IComparer</span>&lt;<span class="title">decimal</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> Compare two decimal numbers by their fractional parts.</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;d1&quot;&gt;</span>The first decimal to compare.<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;d2&quot;&gt;</span>The second decimal to compare.<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>1 if the first decimal&#x27;s fractional part</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> is greater than the second decimal&#x27;s fractional part,</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> -1 if the first decimal&#x27;s fractional</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> part is less than the second decimal&#x27;s fractional part,</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> or the result of calling Decimal.Compare()</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> if the fractional parts are equal.<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Compare</span>(<span class="params"><span class="built_in">decimal</span> d1, <span class="built_in">decimal</span> d2</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">decimal</span> fractional1, fractional2;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Get the fractional part of the first number.</span></span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            fractional1 = <span class="built_in">decimal</span>.Remainder(d1, <span class="built_in">decimal</span>.Floor(d1));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (DivideByZeroException)</span><br><span class="line">        &#123;</span><br><span class="line">            fractional1 = d1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Get the fractional part of the second number.</span></span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            fractional2 = <span class="built_in">decimal</span>.Remainder(d2, <span class="built_in">decimal</span>.Floor(d2));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (DivideByZeroException)</span><br><span class="line">        &#123;</span><br><span class="line">            fractional2 = d2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (fractional1 == fractional2)</span><br><span class="line">            <span class="keyword">return</span> Decimal.Compare(d1, d2);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (fractional1 &gt; fractional2)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">OrderByDescendingEx1</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    List&lt;<span class="built_in">decimal</span>&gt; decimals =</span><br><span class="line">        <span class="keyword">new</span> List&lt;<span class="built_in">decimal</span>&gt; &#123; <span class="number">6.2</span>m, <span class="number">8.3</span>m, <span class="number">0.5</span>m, <span class="number">1.3</span>m, <span class="number">6.3</span>m, <span class="number">9.7</span>m &#125;;</span><br><span class="line"></span><br><span class="line">    IEnumerable&lt;<span class="built_in">decimal</span>&gt; query =</span><br><span class="line">        decimals.OrderByDescending(num =&gt;</span><br><span class="line">                                       num, <span class="keyword">new</span> SpecialComparer());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">foreach</span> (<span class="built_in">decimal</span> num <span class="keyword">in</span> query)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> This code produces the following output:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> 9.7</span></span><br><span class="line"><span class="comment"> 0.5</span></span><br><span class="line"><span class="comment"> 8.3</span></span><br><span class="line"><span class="comment"> 6.3</span></span><br><span class="line"><span class="comment"> 1.3</span></span><br><span class="line"><span class="comment"> 6.2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="Range"><a href="#Range" class="headerlink" title="Range"></a>Range</h2><p>生成指定范围内的整数的序列。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Generate a sequence of integers from 1 to 10</span></span><br><span class="line"><span class="comment">// and then select their squares.</span></span><br><span class="line">IEnumerable&lt;<span class="built_in">int</span>&gt; squares = Enumerable.Range(<span class="number">1</span>, <span class="number">10</span>).Select(x =&gt; x * x);</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> (<span class="built_in">int</span> num <span class="keyword">in</span> squares)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> This code produces the following output:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> 1</span></span><br><span class="line"><span class="comment"> 4</span></span><br><span class="line"><span class="comment"> 9</span></span><br><span class="line"><span class="comment"> 16</span></span><br><span class="line"><span class="comment"> 25</span></span><br><span class="line"><span class="comment"> 36</span></span><br><span class="line"><span class="comment"> 49</span></span><br><span class="line"><span class="comment"> 64</span></span><br><span class="line"><span class="comment"> 81</span></span><br><span class="line"><span class="comment"> 100</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="Repeat"><a href="#Repeat" class="headerlink" title="Repeat"></a>Repeat</h2><p>生成包含一个重复值的序列。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">IEnumerable&lt;<span class="built_in">string</span>&gt; strings =</span><br><span class="line">    Enumerable.Repeat(<span class="string">&quot;I like programming.&quot;</span>, <span class="number">15</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> (String str <span class="keyword">in</span> strings)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> This code produces the following output:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> I like programming.</span></span><br><span class="line"><span class="comment"> I like programming.</span></span><br><span class="line"><span class="comment"> I like programming.</span></span><br><span class="line"><span class="comment"> I like programming.</span></span><br><span class="line"><span class="comment"> I like programming.</span></span><br><span class="line"><span class="comment"> I like programming.</span></span><br><span class="line"><span class="comment"> I like programming.</span></span><br><span class="line"><span class="comment"> I like programming.</span></span><br><span class="line"><span class="comment"> I like programming.</span></span><br><span class="line"><span class="comment"> I like programming.</span></span><br><span class="line"><span class="comment"> I like programming.</span></span><br><span class="line"><span class="comment"> I like programming.</span></span><br><span class="line"><span class="comment"> I like programming.</span></span><br><span class="line"><span class="comment"> I like programming.</span></span><br><span class="line"><span class="comment"> I like programming.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="Reverse"><a href="#Reverse" class="headerlink" title="Reverse"></a>Reverse</h2><p>反转序列中元素的顺序。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">char</span>[] apple = &#123; <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;p&#x27;</span>, <span class="string">&#x27;p&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;e&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">char</span>[] reversed = apple.Reverse().ToArray();</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> (<span class="built_in">char</span> chr <span class="keyword">in</span> reversed)</span><br><span class="line">&#123;</span><br><span class="line">    Console.Write(chr + <span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">Console.WriteLine();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> This code produces the following output:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> e l p p a</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="Select"><a href="#Select" class="headerlink" title="Select"></a>Select</h2><p>将序列中的每个元素投影到新表单。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span>[] fruits = &#123; <span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;mango&quot;</span>, <span class="string">&quot;orange&quot;</span>,</span><br><span class="line">                      <span class="string">&quot;passionfruit&quot;</span>, <span class="string">&quot;grape&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> query =</span><br><span class="line">    fruits.Select((fruit, index) =&gt;</span><br><span class="line">                      <span class="keyword">new</span> &#123; index, str = fruit.Substring(<span class="number">0</span>, index) &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> obj <span class="keyword">in</span> query)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;&#123;0&#125;&quot;</span>, obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> This code produces the following output:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> &#123; index = 0, str =  &#125;</span></span><br><span class="line"><span class="comment"> &#123; index = 1, str = b &#125;</span></span><br><span class="line"><span class="comment"> &#123; index = 2, str = ma &#125;</span></span><br><span class="line"><span class="comment"> &#123; index = 3, str = ora &#125;</span></span><br><span class="line"><span class="comment"> &#123; index = 4, str = pass &#125;</span></span><br><span class="line"><span class="comment"> &#123; index = 5, str = grape &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">IEnumerable&lt;<span class="built_in">int</span>&gt; squares =</span><br><span class="line">    Enumerable.Range(<span class="number">1</span>, <span class="number">10</span>).Select(x =&gt; x * x);</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> (<span class="built_in">int</span> num <span class="keyword">in</span> squares)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> This code produces the following output:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> 1</span></span><br><span class="line"><span class="comment"> 4</span></span><br><span class="line"><span class="comment"> 9</span></span><br><span class="line"><span class="comment"> 16</span></span><br><span class="line"><span class="comment"> 25</span></span><br><span class="line"><span class="comment"> 36</span></span><br><span class="line"><span class="comment"> 49</span></span><br><span class="line"><span class="comment"> 64</span></span><br><span class="line"><span class="comment"> 81</span></span><br><span class="line"><span class="comment"> 100</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="SelectMany"><a href="#SelectMany" class="headerlink" title="SelectMany"></a>SelectMany</h2><p>将序列的每个元素投影到 IEnumerable<T> 并将结果序列合并为一个序列。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">PetOwner</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> List&lt;<span class="built_in">string</span>&gt; Pets &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SelectManyEx3</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    PetOwner[] petOwners =</span><br><span class="line">        &#123; <span class="keyword">new</span> PetOwner &#123; Name=<span class="string">&quot;Higa&quot;</span>,</span><br><span class="line">              Pets = <span class="keyword">new</span> List&lt;<span class="built_in">string</span>&gt;&#123; <span class="string">&quot;Scruffy&quot;</span>, <span class="string">&quot;Sam&quot;</span> &#125; &#125;,</span><br><span class="line">          <span class="keyword">new</span> PetOwner &#123; Name=<span class="string">&quot;Ashkenazi&quot;</span>,</span><br><span class="line">              Pets = <span class="keyword">new</span> List&lt;<span class="built_in">string</span>&gt;&#123; <span class="string">&quot;Walker&quot;</span>, <span class="string">&quot;Sugar&quot;</span> &#125; &#125;,</span><br><span class="line">          <span class="keyword">new</span> PetOwner &#123; Name=<span class="string">&quot;Price&quot;</span>,</span><br><span class="line">              Pets = <span class="keyword">new</span> List&lt;<span class="built_in">string</span>&gt;&#123; <span class="string">&quot;Scratches&quot;</span>, <span class="string">&quot;Diesel&quot;</span> &#125; &#125;,</span><br><span class="line">          <span class="keyword">new</span> PetOwner &#123; Name=<span class="string">&quot;Hines&quot;</span>,</span><br><span class="line">              Pets = <span class="keyword">new</span> List&lt;<span class="built_in">string</span>&gt;&#123; <span class="string">&quot;Dusty&quot;</span> &#125; &#125; &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Project the pet owner&#x27;s name and the pet&#x27;s name.</span></span><br><span class="line">    <span class="keyword">var</span> query =</span><br><span class="line">        petOwners</span><br><span class="line">        .SelectMany(petOwner =&gt; petOwner.Pets, (petOwner, petName) =&gt; <span class="keyword">new</span> &#123; petOwner, petName &#125;)</span><br><span class="line">        .Where(ownerAndPet =&gt; ownerAndPet.petName.StartsWith(<span class="string">&quot;S&quot;</span>))</span><br><span class="line">        .Select(ownerAndPet =&gt;</span><br><span class="line">                <span class="keyword">new</span></span><br><span class="line">                &#123;</span><br><span class="line">                    Owner = ownerAndPet.petOwner.Name,</span><br><span class="line">                    Pet = ownerAndPet.petName</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Print the results.</span></span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> obj <span class="keyword">in</span> query)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This code produces the following output:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// &#123;Owner=Higa, Pet=Scruffy&#125;</span></span><br><span class="line"><span class="comment">// &#123;Owner=Higa, Pet=Sam&#125;</span></span><br><span class="line"><span class="comment">// &#123;Owner=Ashkenazi, Pet=Sugar&#125;</span></span><br><span class="line"><span class="comment">// &#123;Owner=Price, Pet=Scratches&#125;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">PetOwner</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; Pets &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SelectManyEx1</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    PetOwner[] petOwners =</span><br><span class="line">        &#123; <span class="keyword">new</span> PetOwner &#123; Name=<span class="string">&quot;Higa, Sidney&quot;</span>,</span><br><span class="line">              Pets = <span class="keyword">new</span> List&lt;<span class="built_in">string</span>&gt;&#123; <span class="string">&quot;Scruffy&quot;</span>, <span class="string">&quot;Sam&quot;</span> &#125; &#125;,</span><br><span class="line">          <span class="keyword">new</span> PetOwner &#123; Name=<span class="string">&quot;Ashkenazi, Ronen&quot;</span>,</span><br><span class="line">              Pets = <span class="keyword">new</span> List&lt;<span class="built_in">string</span>&gt;&#123; <span class="string">&quot;Walker&quot;</span>, <span class="string">&quot;Sugar&quot;</span> &#125; &#125;,</span><br><span class="line">          <span class="keyword">new</span> PetOwner &#123; Name=<span class="string">&quot;Price, Vernette&quot;</span>,</span><br><span class="line">              Pets = <span class="keyword">new</span> List&lt;<span class="built_in">string</span>&gt;&#123; <span class="string">&quot;Scratches&quot;</span>, <span class="string">&quot;Diesel&quot;</span> &#125; &#125; &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Query using SelectMany().</span></span><br><span class="line">    IEnumerable&lt;<span class="built_in">string</span>&gt; query1 = petOwners.SelectMany(petOwner =&gt; petOwner.Pets);</span><br><span class="line"></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Using SelectMany():&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Only one foreach loop is required to iterate</span></span><br><span class="line">    <span class="comment">// through the results since it is a</span></span><br><span class="line">    <span class="comment">// one-dimensional collection.</span></span><br><span class="line">    <span class="keyword">foreach</span> (<span class="built_in">string</span> pet <span class="keyword">in</span> query1)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(pet);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This code shows how to use Select()</span></span><br><span class="line">    <span class="comment">// instead of SelectMany().</span></span><br><span class="line">    IEnumerable&lt;List&lt;String&gt;&gt; query2 =</span><br><span class="line">        petOwners.Select(petOwner =&gt; petOwner.Pets);</span><br><span class="line"></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;\nUsing Select():&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Notice that two foreach loops are required to</span></span><br><span class="line">    <span class="comment">// iterate through the results</span></span><br><span class="line">    <span class="comment">// because the query returns a collection of arrays.</span></span><br><span class="line">    <span class="keyword">foreach</span> (List&lt;String&gt; petList <span class="keyword">in</span> query2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="built_in">string</span> pet <span class="keyword">in</span> petList)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(pet);</span><br><span class="line">        &#125;</span><br><span class="line">        Console.WriteLine();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> This code produces the following output:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> Using SelectMany():</span></span><br><span class="line"><span class="comment"> Scruffy</span></span><br><span class="line"><span class="comment"> Sam</span></span><br><span class="line"><span class="comment"> Walker</span></span><br><span class="line"><span class="comment"> Sugar</span></span><br><span class="line"><span class="comment"> Scratches</span></span><br><span class="line"><span class="comment"> Diesel</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> Using Select():</span></span><br><span class="line"><span class="comment"> Scruffy</span></span><br><span class="line"><span class="comment"> Sam</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> Walker</span></span><br><span class="line"><span class="comment"> Sugar</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> Scratches</span></span><br><span class="line"><span class="comment"> Diesel</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">PetOwner</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> List&lt;<span class="built_in">string</span>&gt; Pets &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SelectManyEx2</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    PetOwner[] petOwners =</span><br><span class="line">        &#123; <span class="keyword">new</span> PetOwner &#123; Name=<span class="string">&quot;Higa, Sidney&quot;</span>,</span><br><span class="line">              Pets = <span class="keyword">new</span> List&lt;<span class="built_in">string</span>&gt;&#123; <span class="string">&quot;Scruffy&quot;</span>, <span class="string">&quot;Sam&quot;</span> &#125; &#125;,</span><br><span class="line">          <span class="keyword">new</span> PetOwner &#123; Name=<span class="string">&quot;Ashkenazi, Ronen&quot;</span>,</span><br><span class="line">              Pets = <span class="keyword">new</span> List&lt;<span class="built_in">string</span>&gt;&#123; <span class="string">&quot;Walker&quot;</span>, <span class="string">&quot;Sugar&quot;</span> &#125; &#125;,</span><br><span class="line">          <span class="keyword">new</span> PetOwner &#123; Name=<span class="string">&quot;Price, Vernette&quot;</span>,</span><br><span class="line">              Pets = <span class="keyword">new</span> List&lt;<span class="built_in">string</span>&gt;&#123; <span class="string">&quot;Scratches&quot;</span>, <span class="string">&quot;Diesel&quot;</span> &#125; &#125;,</span><br><span class="line">          <span class="keyword">new</span> PetOwner &#123; Name=<span class="string">&quot;Hines, Patrick&quot;</span>,</span><br><span class="line">              Pets = <span class="keyword">new</span> List&lt;<span class="built_in">string</span>&gt;&#123; <span class="string">&quot;Dusty&quot;</span> &#125; &#125; &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Project the items in the array by appending the index</span></span><br><span class="line">    <span class="comment">// of each PetOwner to each pet&#x27;s name in that petOwner&#x27;s</span></span><br><span class="line">    <span class="comment">// array of pets.</span></span><br><span class="line">    IEnumerable&lt;<span class="built_in">string</span>&gt; query =</span><br><span class="line">        petOwners.SelectMany((petOwner, index) =&gt;</span><br><span class="line">                                 petOwner.Pets.Select(pet =&gt; index + pet));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">foreach</span> (<span class="built_in">string</span> pet <span class="keyword">in</span> query)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(pet);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This code produces the following output:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 0Scruffy</span></span><br><span class="line"><span class="comment">// 0Sam</span></span><br><span class="line"><span class="comment">// 1Walker</span></span><br><span class="line"><span class="comment">// 1Sugar</span></span><br><span class="line"><span class="comment">// 2Scratches</span></span><br><span class="line"><span class="comment">// 2Diesel</span></span><br><span class="line"><span class="comment">// 3Dusty</span></span><br></pre></td></tr></table></figure>

<h2 id="SequenceEqual"><a href="#SequenceEqual" class="headerlink" title="SequenceEqual"></a>SequenceEqual</h2><p>根据相等比较器确定两个序列是否相等。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Pet</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Age &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SequenceEqualEx1</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    Pet pet1 = <span class="keyword">new</span> Pet &#123; Name = <span class="string">&quot;Turbo&quot;</span>, Age = <span class="number">2</span> &#125;;</span><br><span class="line">    Pet pet2 = <span class="keyword">new</span> Pet &#123; Name = <span class="string">&quot;Peanut&quot;</span>, Age = <span class="number">8</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create two lists of pets.</span></span><br><span class="line">    List&lt;Pet&gt; pets1 = <span class="keyword">new</span> List&lt;Pet&gt; &#123; pet1, pet2 &#125;;</span><br><span class="line">    List&lt;Pet&gt; pets2 = <span class="keyword">new</span> List&lt;Pet&gt; &#123; pet1, pet2 &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">bool</span> equal = pets1.SequenceEqual(pets2);</span><br><span class="line"></span><br><span class="line">    Console.WriteLine(</span><br><span class="line">        <span class="string">&quot;The lists &#123;0&#125; equal.&quot;</span>,</span><br><span class="line">        equal ? <span class="string">&quot;are&quot;</span> : <span class="string">&quot;are not&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> This code produces the following output:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> The lists are equal.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Pet</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Age &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SequenceEqualEx2</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    Pet pet1 = <span class="keyword">new</span> Pet() &#123; Name = <span class="string">&quot;Turbo&quot;</span>, Age = <span class="number">2</span> &#125;;</span><br><span class="line">    Pet pet2 = <span class="keyword">new</span> Pet() &#123; Name = <span class="string">&quot;Peanut&quot;</span>, Age = <span class="number">8</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create two lists of pets.</span></span><br><span class="line">    List&lt;Pet&gt; pets1 = <span class="keyword">new</span> List&lt;Pet&gt; &#123; pet1, pet2 &#125;;</span><br><span class="line">    List&lt;Pet&gt; pets2 =</span><br><span class="line">        <span class="keyword">new</span> List&lt;Pet&gt; &#123; <span class="keyword">new</span> Pet &#123; Name = <span class="string">&quot;Turbo&quot;</span>, Age = <span class="number">2</span> &#125;,</span><br><span class="line">                        <span class="keyword">new</span> Pet &#123; Name = <span class="string">&quot;Peanut&quot;</span>, Age = <span class="number">8</span> &#125; &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">bool</span> equal = pets1.SequenceEqual(pets2);</span><br><span class="line"></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;The lists &#123;0&#125; equal.&quot;</span>, equal ? <span class="string">&quot;are&quot;</span> : <span class="string">&quot;are not&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">序列包含相同的数据，但由于它们包含的对象具有不同的引用，因此序列不被视为相等。</span></span><br><span class="line"><span class="comment"> This code produces the following output:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> The lists are not equal.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ProductA</span> : <span class="title">IEquatable</span>&lt;<span class="title">ProductA</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Code &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">Equals</span>(<span class="params">ProductA other</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (other <span class="keyword">is</span> <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.Name == other.Name &amp;&amp; <span class="keyword">this</span>.Code == other.Code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">bool</span> <span class="title">Equals</span>(<span class="params"><span class="built_in">object</span> obj</span>)</span> =&gt; Equals(obj <span class="keyword">as</span> ProductA);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">int</span> <span class="title">GetHashCode</span>()</span> =&gt; (Name, Code).GetHashCode();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ProductA[] storeA = &#123; <span class="keyword">new</span> ProductA &#123; Name = <span class="string">&quot;apple&quot;</span>, Code = <span class="number">9</span> &#125;,</span><br><span class="line">                       <span class="keyword">new</span> ProductA &#123; Name = <span class="string">&quot;orange&quot;</span>, Code = <span class="number">4</span> &#125; &#125;;</span><br><span class="line"></span><br><span class="line">ProductA[] storeB = &#123; <span class="keyword">new</span> ProductA &#123; Name = <span class="string">&quot;apple&quot;</span>, Code = <span class="number">9</span> &#125;,</span><br><span class="line">                       <span class="keyword">new</span> ProductA &#123; Name = <span class="string">&quot;orange&quot;</span>, Code = <span class="number">4</span> &#125; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">bool</span> equalAB = storeA.SequenceEqual(storeB);</span><br><span class="line"></span><br><span class="line">Console.WriteLine(<span class="string">&quot;Equal? &quot;</span> + equalAB);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    This code produces the following output:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Equal? True</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Product</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Code &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Custom comparer for the Product class</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">ProductComparer</span> : <span class="title">IEqualityComparer</span>&lt;<span class="title">Product</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Products are equal if their names and product numbers are equal.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">Equals</span>(<span class="params">Product x, Product y</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Check whether the compared objects reference the same data.</span></span><br><span class="line">        <span class="keyword">if</span> (Object.ReferenceEquals(x, y)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Check whether any of the compared objects is null.</span></span><br><span class="line">        <span class="keyword">if</span> (Object.ReferenceEquals(x, <span class="literal">null</span>) || Object.ReferenceEquals(y, <span class="literal">null</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Check whether the products&#x27; properties are equal.</span></span><br><span class="line">        <span class="keyword">return</span> x.Code == y.Code &amp;&amp; x.Name == y.Name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If Equals() returns true for a pair of objects</span></span><br><span class="line">    <span class="comment">// then GetHashCode() must return the same value for these objects.</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">GetHashCode</span>(<span class="params">Product product</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//Check whether the object is null</span></span><br><span class="line">        <span class="keyword">if</span> (Object.ReferenceEquals(product, <span class="literal">null</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Get hash code for the Name field if it is not null.</span></span><br><span class="line">        <span class="built_in">int</span> hashProductName = product.Name == <span class="literal">null</span> ? <span class="number">0</span> : product.Name.GetHashCode();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Get hash code for the Code field.</span></span><br><span class="line">        <span class="built_in">int</span> hashProductCode = product.Code.GetHashCode();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Calculate the hash code for the product.</span></span><br><span class="line">        <span class="keyword">return</span> hashProductName ^ hashProductCode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Product[] storeA = &#123; <span class="keyword">new</span> Product &#123; Name = <span class="string">&quot;apple&quot;</span>, Code = <span class="number">9</span> &#125;,</span><br><span class="line">                       <span class="keyword">new</span> Product &#123; Name = <span class="string">&quot;orange&quot;</span>, Code = <span class="number">4</span> &#125; &#125;;</span><br><span class="line"></span><br><span class="line">Product[] storeB = &#123; <span class="keyword">new</span> Product &#123; Name = <span class="string">&quot;apple&quot;</span>, Code = <span class="number">9</span> &#125;,</span><br><span class="line">                       <span class="keyword">new</span> Product &#123; Name = <span class="string">&quot;orange&quot;</span>, Code = <span class="number">4</span> &#125; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">bool</span> equalAB = storeA.SequenceEqual(storeB, <span class="keyword">new</span> ProductComparer());</span><br><span class="line"></span><br><span class="line">Console.WriteLine(<span class="string">&quot;Equal? &quot;</span> + equalAB);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    This code produces the following output:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Equal? True</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="Single"><a href="#Single" class="headerlink" title="Single"></a>Single</h2><p>返回序列中的单个特定元素。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span>[] fruits = &#123; <span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;mango&quot;</span>,</span><br><span class="line">                      <span class="string">&quot;orange&quot;</span>, <span class="string">&quot;passionfruit&quot;</span>, <span class="string">&quot;grape&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> fruit1 = fruits.Single(fruit =&gt; fruit.Length &gt; <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">Console.WriteLine(fruit1);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> This code produces the following output:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> passionfruit</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> fruit2 = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    fruit2 = fruits.Single(fruit =&gt; fruit.Length &gt; <span class="number">15</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (System.InvalidOperationException)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">@&quot;The collection does not contain exactly</span></span><br><span class="line"><span class="string">                    one element whose length is greater than 15.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Console.WriteLine(fruit2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// This code produces the following output:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The collection does not contain exactly</span></span><br><span class="line"><span class="comment">// one element whose length is greater than 15.</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span>[] fruits1 = &#123; <span class="string">&quot;orange&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> fruit1 = fruits1.Single();</span><br><span class="line"></span><br><span class="line">Console.WriteLine(fruit1);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> This code produces the following output:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> orange</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span>[] fruits2 = &#123; <span class="string">&quot;orange&quot;</span>, <span class="string">&quot;apple&quot;</span> &#125;;</span><br><span class="line"><span class="built_in">string</span> fruit2 = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    fruit2 = fruits2.Single();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (System.InvalidOperationException)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;The collection does not contain exactly one element.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Console.WriteLine(fruit2);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> This code produces the following output:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> The collection does not contain exactly one element.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="SingleOrDefault"><a href="#SingleOrDefault" class="headerlink" title="SingleOrDefault"></a>SingleOrDefault</h2><p>返回序列中的单个特定元素；如果未找到该元素，则返回默认值。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span>[] fruits1 = &#123; <span class="string">&quot;orange&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> fruit1 = fruits1.SingleOrDefault();</span><br><span class="line"></span><br><span class="line">Console.WriteLine(fruit1);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> This code produces the following output:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> orange</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span>[] fruits2 = &#123; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> fruit2 = fruits2.SingleOrDefault();</span><br><span class="line"></span><br><span class="line">Console.WriteLine(</span><br><span class="line">    String.IsNullOrEmpty(fruit2) ? <span class="string">&quot;No such string!&quot;</span> : fruit2);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> This code produces the following output:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> No such string!</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span>[] pageNumbers = &#123; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Setting the default value to 1 after the query.</span></span><br><span class="line"><span class="built_in">int</span> pageNumber1 = pageNumbers.SingleOrDefault();</span><br><span class="line"><span class="keyword">if</span> (pageNumber1 == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    pageNumber1 = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">Console.WriteLine(<span class="string">&quot;The value of the pageNumber1 variable is &#123;0&#125;&quot;</span>, pageNumber1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Setting the default value to 1 by using DefaultIfEmpty() in the query.</span></span><br><span class="line"><span class="built_in">int</span> pageNumber2 = pageNumbers.DefaultIfEmpty(<span class="number">1</span>).Single();</span><br><span class="line">Console.WriteLine(<span class="string">&quot;The value of the pageNumber2 variable is &#123;0&#125;&quot;</span>, pageNumber2);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> This code produces the following output:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> The value of the pageNumber1 variable is 1</span></span><br><span class="line"><span class="comment"> The value of the pageNumber2 variable is 1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span>[] fruits = &#123; <span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;mango&quot;</span>,</span><br><span class="line">                      <span class="string">&quot;orange&quot;</span>, <span class="string">&quot;passionfruit&quot;</span>, <span class="string">&quot;grape&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> fruit1 = fruits.SingleOrDefault(fruit =&gt; fruit.Length &gt; <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">Console.WriteLine(fruit1);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> This code produces the following output:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> passionfruit</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> fruit2 =</span><br><span class="line">    fruits.SingleOrDefault(fruit =&gt; fruit.Length &gt; <span class="number">15</span>);</span><br><span class="line"></span><br><span class="line">Console.WriteLine(</span><br><span class="line">    String.IsNullOrEmpty(fruit2) ? <span class="string">&quot;No such string!&quot;</span> : fruit2);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> This code produces the following output:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> No such string!</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="Skip"><a href="#Skip" class="headerlink" title="Skip"></a>Skip</h2><p>跳过序列中指定数量的元素，然后返回剩余的元素。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span>[] grades = &#123; <span class="number">59</span>, <span class="number">82</span>, <span class="number">70</span>, <span class="number">56</span>, <span class="number">92</span>, <span class="number">98</span>, <span class="number">85</span> &#125;;</span><br><span class="line"></span><br><span class="line">Console.WriteLine(<span class="string">&quot;All grades except the first three:&quot;</span>);</span><br><span class="line"><span class="keyword">foreach</span> (<span class="built_in">int</span> grade <span class="keyword">in</span> grades.Skip(<span class="number">3</span>))</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(grade);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> This code produces the following output:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">All grades except the first three:</span></span><br><span class="line"><span class="comment"> 56</span></span><br><span class="line"><span class="comment"> 92</span></span><br><span class="line"><span class="comment"> 98</span></span><br><span class="line"><span class="comment"> 85</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="SkipWhile"><a href="#SkipWhile" class="headerlink" title="SkipWhile"></a>SkipWhile</h2><p>如果指定的条件为 true，则跳过序列中的元素，然后返回剩余的元素。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span>[] grades = &#123; <span class="number">59</span>, <span class="number">82</span>, <span class="number">70</span>, <span class="number">56</span>, <span class="number">92</span>, <span class="number">98</span>, <span class="number">85</span> &#125;;</span><br><span class="line"></span><br><span class="line">IEnumerable&lt;<span class="built_in">int</span>&gt; lowerGrades =</span><br><span class="line">    grades</span><br><span class="line">    .OrderByDescending(grade =&gt; grade)</span><br><span class="line">    .SkipWhile(grade =&gt; grade &gt;= <span class="number">80</span>);</span><br><span class="line"></span><br><span class="line">Console.WriteLine(<span class="string">&quot;All grades below 80:&quot;</span>);</span><br><span class="line"><span class="keyword">foreach</span> (<span class="built_in">int</span> grade <span class="keyword">in</span> lowerGrades)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(grade);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> This code produces the following output:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> All grades below 80:</span></span><br><span class="line"><span class="comment"> 70</span></span><br><span class="line"><span class="comment"> 59</span></span><br><span class="line"><span class="comment"> 56</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span>[] amounts = &#123; <span class="number">5000</span>, <span class="number">2500</span>, <span class="number">9000</span>, <span class="number">8000</span>,</span><br><span class="line">                    <span class="number">6500</span>, <span class="number">4000</span>, <span class="number">1500</span>, <span class="number">5500</span> &#125;;</span><br><span class="line"></span><br><span class="line">IEnumerable&lt;<span class="built_in">int</span>&gt; query =</span><br><span class="line">    amounts.SkipWhile((amount, index) =&gt; amount &gt; index * <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> (<span class="built_in">int</span> amount <span class="keyword">in</span> query)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(amount);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> This code produces the following output:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> 4000</span></span><br><span class="line"><span class="comment"> 1500</span></span><br><span class="line"><span class="comment"> 5500</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="Sum"><a href="#Sum" class="headerlink" title="Sum"></a>Sum</h2><p>计算数值序列的和。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">List&lt;<span class="built_in">float</span>&gt; numbers = <span class="keyword">new</span> List&lt;<span class="built_in">float</span>&gt; &#123; <span class="number">43.68F</span>, <span class="number">1.25F</span>, <span class="number">583.7F</span>, <span class="number">6.5F</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">float</span> sum = numbers.Sum();</span><br><span class="line"></span><br><span class="line">Console.WriteLine(<span class="string">&quot;The sum of the numbers is &#123;0&#125;.&quot;</span>, sum);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> This code produces the following output:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> The sum of the numbers is 635.13.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">float</span>?[] points = &#123; <span class="literal">null</span>, <span class="number">0</span>, <span class="number">92.83F</span>, <span class="literal">null</span>, <span class="number">100.0F</span>, <span class="number">37.46F</span>, <span class="number">81.1F</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">float</span>? sum = points.Sum();</span><br><span class="line"></span><br><span class="line">Console.WriteLine(<span class="string">&quot;Total points earned: &#123;0&#125;&quot;</span>, sum);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> This code produces the following output:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> Total points earned: 311.39</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Package</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Company &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">double</span> Weight &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SumEx1</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    List&lt;Package&gt; packages =</span><br><span class="line">        <span class="keyword">new</span> List&lt;Package&gt;</span><br><span class="line">            &#123; <span class="keyword">new</span> Package &#123; Company = <span class="string">&quot;Coho Vineyard&quot;</span>, Weight = <span class="number">25.2</span> &#125;,</span><br><span class="line">              <span class="keyword">new</span> Package &#123; Company = <span class="string">&quot;Lucerne Publishing&quot;</span>, Weight = <span class="number">18.7</span> &#125;,</span><br><span class="line">              <span class="keyword">new</span> Package &#123; Company = <span class="string">&quot;Wingtip Toys&quot;</span>, Weight = <span class="number">6.0</span> &#125;,</span><br><span class="line">              <span class="keyword">new</span> Package &#123; Company = <span class="string">&quot;Adventure Works&quot;</span>, Weight = <span class="number">33.8</span> &#125; &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">double</span> totalWeight = packages.Sum(pkg =&gt; pkg.Weight);</span><br><span class="line"></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;The total weight of the packages is: &#123;0&#125;&quot;</span>, totalWeight);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> This code produces the following output:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> The total weight of the packages is: 83.7</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="Take"><a href="#Take" class="headerlink" title="Take"></a>Take</h2><p>从序列的开头返回指定数量的相邻元素。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span>[] grades = &#123; <span class="number">59</span>, <span class="number">82</span>, <span class="number">70</span>, <span class="number">56</span>, <span class="number">92</span>, <span class="number">98</span>, <span class="number">85</span> &#125;;</span><br><span class="line"></span><br><span class="line">IEnumerable&lt;<span class="built_in">int</span>&gt; topThreeGrades =</span><br><span class="line">    grades.OrderByDescending(grade =&gt; grade).Take(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">Console.WriteLine(<span class="string">&quot;The top three grades are:&quot;</span>);</span><br><span class="line"><span class="keyword">foreach</span> (<span class="built_in">int</span> grade <span class="keyword">in</span> topThreeGrades)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(grade);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> This code produces the following output:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> The top three grades are:</span></span><br><span class="line"><span class="comment"> 98</span></span><br><span class="line"><span class="comment"> 92</span></span><br><span class="line"><span class="comment"> 85</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="TakeWhile"><a href="#TakeWhile" class="headerlink" title="TakeWhile"></a>TakeWhile</h2><p>如果指定的条件为 true，则返回序列中的元素，然后跳过剩余的元素。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span>[] fruits = &#123; <span class="string">&quot;apple&quot;</span>, <span class="string">&quot;passionfruit&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;mango&quot;</span>,</span><br><span class="line">                      <span class="string">&quot;orange&quot;</span>, <span class="string">&quot;blueberry&quot;</span>, <span class="string">&quot;grape&quot;</span>, <span class="string">&quot;strawberry&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line">IEnumerable&lt;<span class="built_in">string</span>&gt; query =</span><br><span class="line">    fruits.TakeWhile((fruit, index) =&gt; fruit.Length &gt;= index);</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> (<span class="built_in">string</span> fruit <span class="keyword">in</span> query)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(fruit);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> This code produces the following output:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> apple</span></span><br><span class="line"><span class="comment"> passionfruit</span></span><br><span class="line"><span class="comment"> banana</span></span><br><span class="line"><span class="comment"> mango</span></span><br><span class="line"><span class="comment"> orange</span></span><br><span class="line"><span class="comment"> blueberry</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="ThenBy"><a href="#ThenBy" class="headerlink" title="ThenBy"></a>ThenBy</h2><p>按升序对序列中的元素执行后续排序。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span>[] fruits = &#123; <span class="string">&quot;grape&quot;</span>, <span class="string">&quot;passionfruit&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;mango&quot;</span>,</span><br><span class="line">                      <span class="string">&quot;orange&quot;</span>, <span class="string">&quot;raspberry&quot;</span>, <span class="string">&quot;apple&quot;</span>, <span class="string">&quot;blueberry&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sort the strings first by their length and then</span></span><br><span class="line"><span class="comment">//alphabetically by passing the identity selector function.</span></span><br><span class="line">IEnumerable&lt;<span class="built_in">string</span>&gt; query =</span><br><span class="line">    fruits.OrderBy(fruit =&gt; fruit.Length).ThenBy(fruit =&gt; fruit);</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> (<span class="built_in">string</span> fruit <span class="keyword">in</span> query)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(fruit);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    This code produces the following output:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    apple</span></span><br><span class="line"><span class="comment">    grape</span></span><br><span class="line"><span class="comment">    mango</span></span><br><span class="line"><span class="comment">    banana</span></span><br><span class="line"><span class="comment">    orange</span></span><br><span class="line"><span class="comment">    blueberry</span></span><br><span class="line"><span class="comment">    raspberry</span></span><br><span class="line"><span class="comment">    passionfruit</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="ThenByDescending"><a href="#ThenByDescending" class="headerlink" title="ThenByDescending"></a>ThenByDescending</h2><p>按降序对序列中的元素执行后续排序。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CaseInsensitiveComparer</span> : <span class="title">IComparer</span>&lt;<span class="title">string</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Compare</span>(<span class="params"><span class="built_in">string</span> x, <span class="built_in">string</span> y</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">string</span>.Compare(x, y, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ThenByDescendingEx1</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span>[] fruits = &#123; <span class="string">&quot;apPLe&quot;</span>, <span class="string">&quot;baNanA&quot;</span>, <span class="string">&quot;apple&quot;</span>, <span class="string">&quot;APple&quot;</span>, <span class="string">&quot;orange&quot;</span>, <span class="string">&quot;BAnana&quot;</span>, <span class="string">&quot;ORANGE&quot;</span>, <span class="string">&quot;apPLE&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Sort the strings first ascending by their length and</span></span><br><span class="line">    <span class="comment">// then descending using a custom case insensitive comparer.</span></span><br><span class="line">    IEnumerable&lt;<span class="built_in">string</span>&gt; query =</span><br><span class="line">        fruits</span><br><span class="line">        .OrderBy(fruit =&gt; fruit.Length)</span><br><span class="line">        .ThenByDescending(fruit =&gt; fruit, <span class="keyword">new</span> CaseInsensitiveComparer());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">foreach</span> (<span class="built_in">string</span> fruit <span class="keyword">in</span> query)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(fruit);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    This code produces the following output:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    apPLe</span></span><br><span class="line"><span class="comment">    apple</span></span><br><span class="line"><span class="comment">    APple</span></span><br><span class="line"><span class="comment">    apPLE</span></span><br><span class="line"><span class="comment">    orange</span></span><br><span class="line"><span class="comment">    ORANGE</span></span><br><span class="line"><span class="comment">    baNanA</span></span><br><span class="line"><span class="comment">    BAnana</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="ToArray"><a href="#ToArray" class="headerlink" title="ToArray"></a>ToArray</h2><p>从 IEnumerable<T> 中创建数组。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Package</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Company &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">double</span> Weight &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ToArrayEx1</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    List&lt;Package&gt; packages =</span><br><span class="line">        <span class="keyword">new</span> List&lt;Package&gt;</span><br><span class="line">            &#123; <span class="keyword">new</span> Package &#123; Company = <span class="string">&quot;Coho Vineyard&quot;</span>, Weight = <span class="number">25.2</span> &#125;,</span><br><span class="line">              <span class="keyword">new</span> Package &#123; Company = <span class="string">&quot;Lucerne Publishing&quot;</span>, Weight = <span class="number">18.7</span> &#125;,</span><br><span class="line">              <span class="keyword">new</span> Package &#123; Company = <span class="string">&quot;Wingtip Toys&quot;</span>, Weight = <span class="number">6.0</span> &#125;,</span><br><span class="line">              <span class="keyword">new</span> Package &#123; Company = <span class="string">&quot;Adventure Works&quot;</span>, Weight = <span class="number">33.8</span> &#125; &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span>[] companies = packages.Select(pkg =&gt; pkg.Company).ToArray();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">foreach</span> (<span class="built_in">string</span> company <span class="keyword">in</span> companies)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(company);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> This code produces the following output:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> Coho Vineyard</span></span><br><span class="line"><span class="comment"> Lucerne Publishing</span></span><br><span class="line"><span class="comment"> Wingtip Toys</span></span><br><span class="line"><span class="comment"> Adventure Works</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="ToDictionary"><a href="#ToDictionary" class="headerlink" title="ToDictionary"></a>ToDictionary</h2><p>从 IEnumerable<T> 创建一个 Dictionary&lt;TKey,TValue&gt;。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Package</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Company &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">double</span> Weight &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">long</span> TrackingNumber &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ToDictionaryEx1</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    List&lt;Package&gt; packages =</span><br><span class="line">        <span class="keyword">new</span> List&lt;Package&gt;</span><br><span class="line">            &#123; <span class="keyword">new</span> Package &#123; Company = <span class="string">&quot;Coho Vineyard&quot;</span>, Weight = <span class="number">25.2</span>, TrackingNumber = <span class="number">89453312L</span> &#125;,</span><br><span class="line">              <span class="keyword">new</span> Package &#123; Company = <span class="string">&quot;Lucerne Publishing&quot;</span>, Weight = <span class="number">18.7</span>, TrackingNumber = <span class="number">89112755L</span> &#125;,</span><br><span class="line">              <span class="keyword">new</span> Package &#123; Company = <span class="string">&quot;Wingtip Toys&quot;</span>, Weight = <span class="number">6.0</span>, TrackingNumber = <span class="number">299456122L</span> &#125;,</span><br><span class="line">              <span class="keyword">new</span> Package &#123; Company = <span class="string">&quot;Adventure Works&quot;</span>, Weight = <span class="number">33.8</span>, TrackingNumber = <span class="number">4665518773L</span> &#125; &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create a Dictionary of Package objects,</span></span><br><span class="line">    <span class="comment">// using TrackingNumber as the key.</span></span><br><span class="line">    Dictionary&lt;<span class="built_in">long</span>, Package&gt; dictionary =</span><br><span class="line">        packages.ToDictionary(p =&gt; p.TrackingNumber);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">foreach</span> (KeyValuePair&lt;<span class="built_in">long</span>, Package&gt; kvp <span class="keyword">in</span> dictionary)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(</span><br><span class="line">            <span class="string">&quot;Key &#123;0&#125;: &#123;1&#125;, &#123;2&#125; pounds&quot;</span>,</span><br><span class="line">            kvp.Key,</span><br><span class="line">            kvp.Value.Company,</span><br><span class="line">            kvp.Value.Weight);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> This code produces the following output:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> Key 89453312: Coho Vineyard, 25.2 pounds</span></span><br><span class="line"><span class="comment"> Key 89112755: Lucerne Publishing, 18.7 pounds</span></span><br><span class="line"><span class="comment"> Key 299456122: Wingtip Toys, 6 pounds</span></span><br><span class="line"><span class="comment"> Key 4665518773: Adventure Works, 33.8 pounds</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="ToList"><a href="#ToList" class="headerlink" title="ToList"></a>ToList</h2><p>从 IEnumerable<T> 创建一个 List<T>。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span>[] fruits = &#123; <span class="string">&quot;apple&quot;</span>, <span class="string">&quot;passionfruit&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;mango&quot;</span>,</span><br><span class="line">                      <span class="string">&quot;orange&quot;</span>, <span class="string">&quot;blueberry&quot;</span>, <span class="string">&quot;grape&quot;</span>, <span class="string">&quot;strawberry&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line">List&lt;<span class="built_in">int</span>&gt; lengths = fruits.Select(fruit =&gt; fruit.Length).ToList();</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> (<span class="built_in">int</span> length <span class="keyword">in</span> lengths)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> This code produces the following output:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> 5</span></span><br><span class="line"><span class="comment"> 12</span></span><br><span class="line"><span class="comment"> 6</span></span><br><span class="line"><span class="comment"> 5</span></span><br><span class="line"><span class="comment"> 6</span></span><br><span class="line"><span class="comment"> 9</span></span><br><span class="line"><span class="comment"> 5</span></span><br><span class="line"><span class="comment"> 10</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="ToLookup"><a href="#ToLookup" class="headerlink" title="ToLookup"></a>ToLookup</h2><p>从 IEnumerable<T> 生成一个泛型 Lookup&lt;TKey,TElement&gt;。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Package</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Company &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">double</span> Weight &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">long</span> TrackingNumber &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ToLookupEx1</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Create a list of Packages.</span></span><br><span class="line">    List&lt;Package&gt; packages =</span><br><span class="line">        <span class="keyword">new</span> List&lt;Package&gt;</span><br><span class="line">            &#123; <span class="keyword">new</span> Package &#123; Company = <span class="string">&quot;Coho Vineyard&quot;</span>,</span><br><span class="line">                  Weight = <span class="number">25.2</span>, TrackingNumber = <span class="number">89453312L</span> &#125;,</span><br><span class="line">              <span class="keyword">new</span> Package &#123; Company = <span class="string">&quot;Lucerne Publishing&quot;</span>,</span><br><span class="line">                  Weight = <span class="number">18.7</span>, TrackingNumber = <span class="number">89112755L</span> &#125;,</span><br><span class="line">              <span class="keyword">new</span> Package &#123; Company = <span class="string">&quot;Wingtip Toys&quot;</span>,</span><br><span class="line">                  Weight = <span class="number">6.0</span>, TrackingNumber = <span class="number">299456122L</span> &#125;,</span><br><span class="line">              <span class="keyword">new</span> Package &#123; Company = <span class="string">&quot;Contoso Pharmaceuticals&quot;</span>,</span><br><span class="line">                  Weight = <span class="number">9.3</span>, TrackingNumber = <span class="number">670053128L</span> &#125;,</span><br><span class="line">              <span class="keyword">new</span> Package &#123; Company = <span class="string">&quot;Wide World Importers&quot;</span>,</span><br><span class="line">                  Weight = <span class="number">33.8</span>, TrackingNumber = <span class="number">4665518773L</span> &#125; &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create a Lookup to organize the packages.</span></span><br><span class="line">    <span class="comment">// Use the first character of Company as the key value.</span></span><br><span class="line">    <span class="comment">// Select Company appended to TrackingNumber</span></span><br><span class="line">    <span class="comment">// as the element values of the Lookup.</span></span><br><span class="line">    ILookup&lt;<span class="built_in">char</span>, <span class="built_in">string</span>&gt; lookup =</span><br><span class="line">        packages</span><br><span class="line">        .ToLookup(p =&gt; p.Company[<span class="number">0</span>],</span><br><span class="line">                  p =&gt; p.Company + <span class="string">&quot; &quot;</span> + p.TrackingNumber);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Iterate through each IGrouping in the Lookup.</span></span><br><span class="line">    <span class="keyword">foreach</span> (IGrouping&lt;<span class="built_in">char</span>, <span class="built_in">string</span>&gt; packageGroup <span class="keyword">in</span> lookup)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Print the key value of the IGrouping.</span></span><br><span class="line">        Console.WriteLine(packageGroup.Key);</span><br><span class="line">        <span class="comment">// Iterate through each value in the</span></span><br><span class="line">        <span class="comment">// IGrouping and print its value.</span></span><br><span class="line">        <span class="keyword">foreach</span> (<span class="built_in">string</span> str <span class="keyword">in</span> packageGroup)</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;    &#123;0&#125;&quot;</span>, str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> This code produces the following output:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> C</span></span><br><span class="line"><span class="comment">     Coho Vineyard 89453312</span></span><br><span class="line"><span class="comment">     Contoso Pharmaceuticals 670053128</span></span><br><span class="line"><span class="comment"> L</span></span><br><span class="line"><span class="comment">     Lucerne Publishing 89112755</span></span><br><span class="line"><span class="comment"> W</span></span><br><span class="line"><span class="comment">     Wingtip Toys 299456122</span></span><br><span class="line"><span class="comment">     Wide World Importers 4665518773</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="Union"><a href="#Union" class="headerlink" title="Union"></a>Union</h2><p>生成两个序列的并集。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span>[] ints1 = &#123; <span class="number">5</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">7</span> &#125;;</span><br><span class="line"><span class="built_in">int</span>[] ints2 = &#123; <span class="number">8</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">IEnumerable&lt;<span class="built_in">int</span>&gt; union = ints1.Union(ints2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> (<span class="built_in">int</span> num <span class="keyword">in</span> union)</span><br><span class="line">&#123;</span><br><span class="line">    Console.Write(<span class="string">&quot;&#123;0&#125; &quot;</span>, num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> This code produces the following output:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> 5 3 9 7 8 6 4 1 0</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ProductA</span> : <span class="title">IEquatable</span>&lt;<span class="title">ProductA</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Code &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">Equals</span>(<span class="params">ProductA other</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (other <span class="keyword">is</span> <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.Name == other.Name &amp;&amp; <span class="keyword">this</span>.Code == other.Code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">bool</span> <span class="title">Equals</span>(<span class="params"><span class="built_in">object</span> obj</span>)</span> =&gt; Equals(obj <span class="keyword">as</span> ProductA);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">int</span> <span class="title">GetHashCode</span>()</span> =&gt; (Name, Code).GetHashCode();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ProductA[] store1 = &#123; <span class="keyword">new</span> ProductA &#123; Name = <span class="string">&quot;apple&quot;</span>, Code = <span class="number">9</span> &#125;,</span><br><span class="line">                       <span class="keyword">new</span> ProductA &#123; Name = <span class="string">&quot;orange&quot;</span>, Code = <span class="number">4</span> &#125; &#125;;</span><br><span class="line"></span><br><span class="line">ProductA[] store2 = &#123; <span class="keyword">new</span> ProductA &#123; Name = <span class="string">&quot;apple&quot;</span>, Code = <span class="number">9</span> &#125;,</span><br><span class="line">                       <span class="keyword">new</span> ProductA &#123; Name = <span class="string">&quot;lemon&quot;</span>, Code = <span class="number">12</span> &#125; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Get the products from the both arrays</span></span><br><span class="line"><span class="comment">//excluding duplicates.</span></span><br><span class="line"></span><br><span class="line">IEnumerable&lt;ProductA&gt; union =</span><br><span class="line">  store1.Union(store2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> product <span class="keyword">in</span> union)</span><br><span class="line">    Console.WriteLine(product.Name + <span class="string">&quot; &quot;</span> + product.Code);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    This code produces the following output:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    apple 9</span></span><br><span class="line"><span class="comment">    orange 4</span></span><br><span class="line"><span class="comment">    lemon 12</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Product</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Code &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Custom comparer for the Product class</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">ProductComparer</span> : <span class="title">IEqualityComparer</span>&lt;<span class="title">Product</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Products are equal if their names and product numbers are equal.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">Equals</span>(<span class="params">Product x, Product y</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Check whether the compared objects reference the same data.</span></span><br><span class="line">        <span class="keyword">if</span> (Object.ReferenceEquals(x, y)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Check whether any of the compared objects is null.</span></span><br><span class="line">        <span class="keyword">if</span> (Object.ReferenceEquals(x, <span class="literal">null</span>) || Object.ReferenceEquals(y, <span class="literal">null</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Check whether the products&#x27; properties are equal.</span></span><br><span class="line">        <span class="keyword">return</span> x.Code == y.Code &amp;&amp; x.Name == y.Name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If Equals() returns true for a pair of objects</span></span><br><span class="line">    <span class="comment">// then GetHashCode() must return the same value for these objects.</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">GetHashCode</span>(<span class="params">Product product</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//Check whether the object is null</span></span><br><span class="line">        <span class="keyword">if</span> (Object.ReferenceEquals(product, <span class="literal">null</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Get hash code for the Name field if it is not null.</span></span><br><span class="line">        <span class="built_in">int</span> hashProductName = product.Name == <span class="literal">null</span> ? <span class="number">0</span> : product.Name.GetHashCode();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Get hash code for the Code field.</span></span><br><span class="line">        <span class="built_in">int</span> hashProductCode = product.Code.GetHashCode();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Calculate the hash code for the product.</span></span><br><span class="line">        <span class="keyword">return</span> hashProductName ^ hashProductCode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Product[] store10 = &#123; <span class="keyword">new</span> Product &#123; Name = <span class="string">&quot;apple&quot;</span>, Code = <span class="number">9</span> &#125;,</span><br><span class="line">                       <span class="keyword">new</span> Product &#123; Name = <span class="string">&quot;orange&quot;</span>, Code = <span class="number">4</span> &#125; &#125;;</span><br><span class="line"></span><br><span class="line">Product[] store20 = &#123; <span class="keyword">new</span> Product &#123; Name = <span class="string">&quot;apple&quot;</span>, Code = <span class="number">9</span> &#125;,</span><br><span class="line">                       <span class="keyword">new</span> Product &#123; Name = <span class="string">&quot;lemon&quot;</span>, Code = <span class="number">12</span> &#125; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Get the products from the both arrays</span></span><br><span class="line"><span class="comment">//excluding duplicates.</span></span><br><span class="line"></span><br><span class="line">IEnumerable&lt;Product&gt; union =</span><br><span class="line">  store10.Union(store20, <span class="keyword">new</span> ProductComparer());</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> (Product product <span class="keyword">in</span> union)</span><br><span class="line">    Console.WriteLine(product.Name + <span class="string">&quot; &quot;</span> + product.Code);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    This code produces the following output:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    apple 9</span></span><br><span class="line"><span class="comment">    orange 4</span></span><br><span class="line"><span class="comment">    lemon 12</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="Where"><a href="#Where" class="headerlink" title="Where"></a>Where</h2><p>基于谓词筛选值序列。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">List&lt;<span class="built_in">string</span>&gt; fruits =</span><br><span class="line">    <span class="keyword">new</span> List&lt;<span class="built_in">string</span>&gt; &#123; <span class="string">&quot;apple&quot;</span>, <span class="string">&quot;passionfruit&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;mango&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;orange&quot;</span>, <span class="string">&quot;blueberry&quot;</span>, <span class="string">&quot;grape&quot;</span>, <span class="string">&quot;strawberry&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line">IEnumerable&lt;<span class="built_in">string</span>&gt; query = fruits.Where(fruit =&gt; fruit.Length &lt; <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> (<span class="built_in">string</span> fruit <span class="keyword">in</span> query)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(fruit);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> This code produces the following output:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> apple</span></span><br><span class="line"><span class="comment"> mango</span></span><br><span class="line"><span class="comment"> grape</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span>[] numbers = &#123; <span class="number">0</span>, <span class="number">30</span>, <span class="number">20</span>, <span class="number">15</span>, <span class="number">90</span>, <span class="number">85</span>, <span class="number">40</span>, <span class="number">75</span> &#125;;</span><br><span class="line"></span><br><span class="line">IEnumerable&lt;<span class="built_in">int</span>&gt; query =</span><br><span class="line">    numbers.Where((number, index) =&gt; number &lt;= index * <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> (<span class="built_in">int</span> number <span class="keyword">in</span> query)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(number);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> This code produces the following output:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> 0</span></span><br><span class="line"><span class="comment"> 20</span></span><br><span class="line"><span class="comment"> 15</span></span><br><span class="line"><span class="comment"> 40</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>LINQ</tag>
      </tags>
  </entry>
  <entry>
    <title>Autodesk.Revit.DB Opening</title>
    <url>/2024/12/10/RevitApi%E5%90%88%E9%9B%86/Autodesk.Revit.DB%20Opening/</url>
    <content><![CDATA[<h1 id="Autodesk-Revit-DB-Opening"><a href="#Autodesk-Revit-DB-Opening" class="headerlink" title="Autodesk.Revit.DB Opening"></a><a href="https://www.revitapidocs.com/2018/720de864-9f4e-c606-c7f4-2e7a0b2da46f.htm">Autodesk.Revit.DB Opening</a></h1><p>Autodesk Revit项目或族文档中的洞口。</p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Opening</span> : <span class="title">Element</span></span><br></pre></td></tr></table></figure>

<h2 id="附注"><a href="#附注" class="headerlink" title="附注"></a>附注</h2><p><strong>该对象表示各种不同类型的洞口：</strong></p>
<ul>
<li>墙中由修订项目中的两个边界点创建的矩形洞口。</li>
<li>由应用于屋顶、楼板、天花板、梁、支撑或柱的一组曲线创建的洞口。</li>
<li>一个垂直的竖井开口延伸到一个或多个水平。</li>
<li>在族文档中的墙或天花板上创建的简单洞口。</li>
</ul>
<p>根据打开的类型，此类的某些属性将不可用。</p>
<p><strong>这个对象派生自Element基对象，并且支持该对象的所有方法，例如检索该对象的参数的能力。此对象还支持访问结构分析模型，但此功能仅适用于Autodesk Revit Structure。</strong></p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="meta">### private void Getinfo_Opening(Opening opening)</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> message = <span class="string">&quot;Opening:&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//get the host element of this opening</span></span><br><span class="line">    message += <span class="string">&quot;\nThe id of the opening&#x27;s host element is : &quot;</span> + opening.Host.Id.IntegerValue;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//get the information whether the opening has a rect boundary</span></span><br><span class="line">    <span class="comment">//If the opening has a rect boundary, we can get the geometry information from BoundaryRect property.</span></span><br><span class="line">    <span class="comment">//Otherwise we should get the geometry information from BoundaryCurves property</span></span><br><span class="line">    <span class="keyword">if</span> (opening.IsRectBoundary)</span><br><span class="line">    &#123;</span><br><span class="line">        message += <span class="string">&quot;\nThe opening has a rectangular boundary.&quot;</span>;</span><br><span class="line">        <span class="comment">//array contains two XYZ objects: the max and min coords of boundary</span></span><br><span class="line">        IList&lt;XYZ&gt; boundaryRect = opening.BoundaryRect;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//get the coordinate value of the min coordinate point</span></span><br><span class="line">        XYZ point = opening.BoundaryRect[<span class="number">0</span>];</span><br><span class="line">        message += <span class="string">&quot;\nMin coordinate point:(&quot;</span> + point.X + <span class="string">&quot;, &quot;</span></span><br><span class="line">                                + point.Y + <span class="string">&quot;, &quot;</span> + point.Z + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//get the coordinate value of the Max coordinate point</span></span><br><span class="line">        point = opening.BoundaryRect[<span class="number">1</span>];</span><br><span class="line">        message += <span class="string">&quot;\nMax coordinate point: (&quot;</span> + point.X + <span class="string">&quot;, &quot;</span></span><br><span class="line">                                + point.Y + <span class="string">&quot;, &quot;</span> + point.Z + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        message += <span class="string">&quot;\nThe opening doesn&#x27;t have a rectangular boundary.&quot;</span>;</span><br><span class="line">        <span class="comment">// Get curve number</span></span><br><span class="line">        <span class="built_in">int</span> curves = opening.BoundaryCurves.Size;</span><br><span class="line">        message += <span class="string">&quot;\nNumber of curves is : &quot;</span> + curves;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; curves; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Autodesk.Revit.DB.Curve curve = opening.BoundaryCurves.get_Item(i);</span><br><span class="line">            <span class="comment">// Get curve start point</span></span><br><span class="line">            message += <span class="string">&quot;\nCurve start point: &quot;</span> + XYZToString(curve.GetEndPoint(<span class="number">0</span>));</span><br><span class="line">            <span class="comment">// Get curve end point</span></span><br><span class="line">            message += <span class="string">&quot;; Curve end point: &quot;</span> + XYZToString(curve.GetEndPoint(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>,message);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// output the point&#x27;s three coordinates</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">XYZToString</span>(<span class="params">XYZ point</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;(&quot;</span> + point.X + <span class="string">&quot;, &quot;</span> + point.Y + <span class="string">&quot;, &quot;</span> + point.Z + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="继承层次结构"><a href="#继承层次结构" class="headerlink" title="继承层次结构"></a>继承层次结构</h2><p><a href="http://msdn2.microsoft.com/en-us/library/e5kfa45b">System Object</a></p>
<p>​	<a href="https://www.revitapidocs.com/2018/eb16114f-69ea-f4de-0d0d-f7388b105a16.htm">Autodesk.Revit.DB Element</a></p>
<p>​		Autodesk.Revit.DB Opening</p>
<h2 id="另见"><a href="#另见" class="headerlink" title="另见"></a>另见</h2><p><a href="https://www.revitapidocs.com/2018/44d5feb7-de14-3339-7cc2-aa5319c6e353.htm">Opening Members</a></p>
<p><a href="https://www.revitapidocs.com/2018/87546ba7-461b-c646-cbb1-2cb8f5bff8b2.htm">Autodesk.Revit.DB Namespace</a></p>
<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><h3 id="BoundaryCurves"><a href="#BoundaryCurves" class="headerlink" title="BoundaryCurves"></a>BoundaryCurves</h3><p>项目文档中非矩形洞口或族文档中所有洞口的几何图形信息。</p>
<h3 id="BoundaryRect"><a href="#BoundaryRect" class="headerlink" title="BoundaryRect"></a>BoundaryRect</h3><p>如果开口边界是矩形，则检索几何体信息。</p>
<h3 id="Host"><a href="#Host" class="headerlink" title="Host"></a>Host</h3><p>检索此洞口的宿主元素。</p>
<h3 id="IsRectBoundary"><a href="#IsRectBoundary" class="headerlink" title="IsRectBoundary"></a>IsRectBoundary</h3><p>检索洞口是否具有矩形边界的信息。</p>
<h3 id="IsoburrentIn3D"><a href="#IsoburrentIn3D" class="headerlink" title="IsoburrentIn3D"></a>IsoburrentIn3D</h3><p>指示洞口在载入到项目中时在三维视图中是否透明。</p>
<h3 id="IsTransparentInElevation"><a href="#IsTransparentInElevation" class="headerlink" title="IsTransparentInElevation"></a>IsTransparentInElevation</h3><p>指示洞口载入到项目中时在立面视图中是否透明。</p>
<h2 id="注：翻译自Revit-Api-docs-2018"><a href="#注：翻译自Revit-Api-docs-2018" class="headerlink" title="注：翻译自Revit Api docs 2018"></a><em><strong>注：</strong></em>翻译自<a href="https://www.revitapidocs.com/2018">Revit Api docs 2018</a></h2>]]></content>
      <categories>
        <category>RevitApi</category>
      </categories>
      <tags>
        <tag>Revit</tag>
      </tags>
  </entry>
  <entry>
    <title>Autodesk.Revit.DB Document</title>
    <url>/2024/10/30/RevitApi%E5%90%88%E9%9B%86/Autodesk.Revit.DB%20Document/</url>
    <content><![CDATA[<h1 id="Autodesk-Revit-DB-Document"><a href="#Autodesk-Revit-DB-Document" class="headerlink" title="Autodesk.Revit.DB Document"></a><a href="https://www.revitapidocs.com/2018/db03274b-a107-aa32-9034-f3e0df4bb1ec.htm">Autodesk.Revit.DB Document</a></h1><p>表示打开的 Autodesk Revit 项目的对象。</p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Document : IDisposable</span><br></pre></td></tr></table></figure>



<h2 id="附注"><a href="#附注" class="headerlink" title="附注"></a>附注</h2><p>Document 对象表示 Autodesk Revit 项目。Revit 可以打开多个项目，并打开这些项目的多个视图。活动视图或最顶层视图将是活动项目，因此是可从 Application 对象获得的活动文档。</p>
<h2 id="继承层次结构"><a href="#继承层次结构" class="headerlink" title="继承层次结构"></a>继承层次结构</h2><ul>
<li>System Object</li>
<li>Autodesk.Revit.DB Document</li>
<li>Autodesk.Revit.DB.Macros DocumentEntryPoint</li>
</ul>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="AcquireCoordinates"><a href="#AcquireCoordinates" class="headerlink" title="AcquireCoordinates"></a>AcquireCoordinates</h3><ul>
<li>不知道是啥，API没给描述</li>
</ul>
<h3 id="AutoJoinElements"><a href="#AutoJoinElements" class="headerlink" title="AutoJoinElements"></a>AutoJoinElements</h3><ul>
<li>强制 Revit 文档中的图元在适当的情况下自动连接到其相邻图元。</li>
</ul>
<h3 id="CanEnableWorksharing"><a href="#CanEnableWorksharing" class="headerlink" title="CanEnableWorksharing"></a>CanEnableWorksharing</h3><ul>
<li>检查是否可以在文档中启用工作共享。</li>
</ul>
<h3 id="Close"><a href="#Close" class="headerlink" title="Close"></a>Close</h3><ul>
<li>关闭文档，保存更改（如果有）。</li>
</ul>
<h3 id="Close-Boolean"><a href="#Close-Boolean" class="headerlink" title="Close(Boolean)"></a>Close(Boolean)</h3><ul>
<li>关闭文档，并带有保存选项。</li>
</ul>
<h3 id="CombineElements"><a href="#CombineElements" class="headerlink" title="CombineElements"></a>CombineElements</h3><ul>
<li>将一组可组合元素组合成一个几何组合。</li>
</ul>
<h3 id="ConvertDetailToModelCurves"><a href="#ConvertDetailToModelCurves" class="headerlink" title="ConvertDetailToModelCurves"></a>ConvertDetailToModelCurves</h3><ul>
<li>将一组 DetailCurves（细节曲线）转换为等效的 ModelCurves（模型曲线）。</li>
</ul>
<h3 id="ConvertModelToDetailCurves"><a href="#ConvertModelToDetailCurves" class="headerlink" title="ConvertModelToDetailCurves"></a>ConvertModelToDetailCurves</h3><ul>
<li>将一组 ModelCurves（模型曲线）转换为等效的 DetailCurves（细节曲线）。</li>
</ul>
<h3 id="ConvertModelToSymbolicCurves"><a href="#ConvertModelToSymbolicCurves" class="headerlink" title="ConvertModelToSymbolicCurves"></a>ConvertModelToSymbolicCurves</h3><ul>
<li>将一组 ModelCurves 转换为等效的 SymbolicCurves。</li>
</ul>
<h3 id="ConvertSymbolicToModelCurves"><a href="#ConvertSymbolicToModelCurves" class="headerlink" title="ConvertSymbolicToModelCurves"></a>ConvertSymbolicToModelCurves</h3><ul>
<li>将一组 SymbolicCurves 转换为等效的 ModelCurves。</li>
</ul>
<h3 id="Delete-ElementId"><a href="#Delete-ElementId" class="headerlink" title="Delete(ElementId)"></a>Delete(ElementId)</h3><ul>
<li>从文档中删除给定该元素 id 的元素。</li>
</ul>
<h3 id="Delete-ICollection-ElementId"><a href="#Delete-ICollection-ElementId" class="headerlink" title="Delete(ICollection ElementId )"></a>Delete(ICollection ElementId )</h3><ul>
<li>从文档中删除一组元素。</li>
</ul>
<h3 id="Dispose"><a href="#Dispose" class="headerlink" title="Dispose"></a>Dispose</h3><h3 id="EditFamily"><a href="#EditFamily" class="headerlink" title="EditFamily"></a>EditFamily</h3><ul>
<li>获取要编辑的载入族的文档。</li>
</ul>
<h3 id="EnableWorksharing"><a href="#EnableWorksharing" class="headerlink" title="EnableWorksharing"></a>EnableWorksharing</h3><ul>
<li>在文档中启用工作共享。</li>
</ul>
<h3 id="Export-String-String-MassGBXMLExportOptions"><a href="#Export-String-String-MassGBXMLExportOptions" class="headerlink" title="Export(String, String, MassGBXMLExportOptions)"></a>Export(String, String, MassGBXMLExportOptions)</h3><ul>
<li>从体量模型文档导出 gbXML 文件。</li>
</ul>
<h3 id="Export-String-String-GBXMLExportOptions"><a href="#Export-String-String-GBXMLExportOptions" class="headerlink" title="Export(String, String, GBXMLExportOptions)"></a>Export(String, String, GBXMLExportOptions)</h3><ul>
<li>以 gbXML（绿色建筑）格式导出模型。</li>
</ul>
<h3 id="xport-String-String-IFCExportOptions"><a href="#xport-String-String-IFCExportOptions" class="headerlink" title="xport(String, String, IFCExportOptions)"></a>xport(String, String, IFCExportOptions)</h3><ul>
<li>将文档导出为行业标准类 （IFC） 格式。</li>
</ul>
<h3 id="Export-String-String-NavisworksExportOptions"><a href="#Export-String-String-NavisworksExportOptions" class="headerlink" title="Export(String, String, NavisworksExportOptions)"></a>Export(String, String, NavisworksExportOptions)</h3><ul>
<li>将 Revit 项目导出为 Navisworks .nwc 格式。</li>
</ul>
<h3 id="Export-String-String-ViewSet-DWFExportOptions"><a href="#Export-String-String-ViewSet-DWFExportOptions" class="headerlink" title="Export(String, String, ViewSet, DWFExportOptions)"></a>Export(String, String, ViewSet, DWFExportOptions)</h3><ul>
<li>以 DWF 格式导出当前视图或选定的视图。</li>
</ul>
<h3 id="Export-String-String-ViewSet-DWFXExportOptions"><a href="#Export-String-String-ViewSet-DWFXExportOptions" class="headerlink" title="Export(String, String, ViewSet, DWFXExportOptions)"></a>Export(String, String, ViewSet, DWFXExportOptions)</h3><ul>
<li>以 DWFX 格式导出当前视图或所选视图。</li>
</ul>
<h3 id="Export-String-String-ViewSet-FBXExportOptions"><a href="#Export-String-String-ViewSet-FBXExportOptions" class="headerlink" title="Export(String, String, ViewSet, FBXExportOptions)"></a>Export(String, String, ViewSet, FBXExportOptions)</h3><ul>
<li>以 3D-Studio Max （FBX） 格式导出文档。</li>
</ul>
<h3 id="Export-String-String-ICollection-ElementId-DGNExportOptions"><a href="#Export-String-String-ICollection-ElementId-DGNExportOptions" class="headerlink" title="Export(String, String, ICollection ElementId , DGNExportOptions)"></a>Export(String, String, ICollection ElementId , DGNExportOptions)</h3><ul>
<li>以 DGN 格式导出所选视图。</li>
</ul>
<h3 id="Export-String-String-ICollection-ElementId-DWGExportOptions"><a href="#Export-String-String-ICollection-ElementId-DWGExportOptions" class="headerlink" title="Export(String, String, ICollection ElementId , DWGExportOptions)"></a>Export(String, String, ICollection ElementId , DWGExportOptions)</h3><ul>
<li>以 DWG 格式导出所选视图。</li>
</ul>
<h3 id="Export-String-String-ICollection-ElementId-DXFExportOptions"><a href="#Export-String-String-ICollection-ElementId-DXFExportOptions" class="headerlink" title="Export(String, String, ICollection ElementId , DXFExportOptions)"></a>Export(String, String, ICollection ElementId , DXFExportOptions)</h3><ul>
<li>以 DXF 格式导出所选视图。</li>
</ul>
<h3 id="Export-String-String-ICollection-ElementId-SATExportOptions"><a href="#Export-String-String-ICollection-ElementId-SATExportOptions" class="headerlink" title="Export(String, String, ICollection ElementId , SATExportOptions)"></a>Export(String, String, ICollection ElementId , SATExportOptions)</h3><ul>
<li>以 SAT 格式导出当前视图或所选视图。</li>
</ul>
<h3 id="Export-String-String-View3D-ViewPlan-BuildingSiteExportOptions"><a href="#Export-String-String-View3D-ViewPlan-BuildingSiteExportOptions" class="headerlink" title="Export(String, String, View3D, ViewPlan, BuildingSiteExportOptions)"></a>Export(String, String, View3D, ViewPlan, BuildingSiteExportOptions)</h3><ul>
<li>以 Civil Engineering 设计应用程序的格式导出文档。</li>
</ul>
<h3 id="ExportImage"><a href="#ExportImage" class="headerlink" title="ExportImage"></a>ExportImage</h3><ul>
<li>将一个视图或一组视图导出到图像文件中。</li>
</ul>
<h3 id="GetDefaultElementTypeId"><a href="#GetDefaultElementTypeId" class="headerlink" title="GetDefaultElementTypeId"></a>GetDefaultElementTypeId</h3><ul>
<li>获取具有给定 DefaultElementType ID 的默认元素类型 ID。</li>
</ul>
<h3 id="GetDefaultFamilyTypeId"><a href="#GetDefaultFamilyTypeId" class="headerlink" title="GetDefaultFamilyTypeId"></a>GetDefaultFamilyTypeId</h3><ul>
<li>获取具有给定族类别 ID 的默认族类型 ID。</li>
</ul>
<h3 id="GetDocumentPreviewSettings"><a href="#GetDocumentPreviewSettings" class="headerlink" title="GetDocumentPreviewSettings"></a>GetDocumentPreviewSettings</h3><ul>
<li>返回给定文档的预览设置。</li>
</ul>
<h3 id="GetDocumentVersion"><a href="#GetDocumentVersion" class="headerlink" title="GetDocumentVersion"></a>GetDocumentVersion</h3><ul>
<li>获取与文档对应的 DocumentVersion。</li>
</ul>
<h3 id="GetElement-String"><a href="#GetElement-String" class="headerlink" title="GetElement(String)"></a>GetElement(String)</h3><ul>
<li>获取唯一 id 字符串引用的 Element。</li>
</ul>
<h3 id="GetElement-ElementId"><a href="#GetElement-ElementId" class="headerlink" title="GetElement(ElementId)"></a>GetElement(ElementId)</h3><ul>
<li>获取输入字符串名称引用的 Element。</li>
</ul>
<h3 id="GetElement-Reference"><a href="#GetElement-Reference" class="headerlink" title="GetElement(Reference)"></a>GetElement(Reference)</h3><ul>
<li>获取输入引用引用的 Element。</li>
</ul>
<h3 id="GetPaintedMaterial"><a href="#GetPaintedMaterial" class="headerlink" title="GetPaintedMaterial"></a>GetPaintedMaterial</h3><ul>
<li>获取在元素面上绘制的材质。如果未绘制面部，则返回 invalidElementId。</li>
</ul>
<h3 id="GetPrintSettingIds"><a href="#GetPrintSettingIds" class="headerlink" title="GetPrintSettingIds"></a>GetPrintSettingIds</h3><ul>
<li>检索当前项目的所有打印设置。</li>
</ul>
<h3 id="GetRoomAtPoint-XYZ"><a href="#GetRoomAtPoint-XYZ" class="headerlink" title="GetRoomAtPoint(XYZ)"></a>GetRoomAtPoint(XYZ)</h3><ul>
<li>获取包含点的 room。</li>
</ul>
<h3 id="GetRoomAtPoint-XYZ-Phase"><a href="#GetRoomAtPoint-XYZ-Phase" class="headerlink" title="GetRoomAtPoint(XYZ, Phase)"></a>GetRoomAtPoint(XYZ, Phase)</h3><ul>
<li>Gets a room containing the point.</li>
</ul>
<h3 id="GetSpaceAtPoint-XYZ"><a href="#GetSpaceAtPoint-XYZ" class="headerlink" title="GetSpaceAtPoint(XYZ)"></a>GetSpaceAtPoint(XYZ)</h3><ul>
<li>获取包含点的空间。</li>
</ul>
<h3 id="GetSpaceAtPoint-XYZ-Phase"><a href="#GetSpaceAtPoint-XYZ-Phase" class="headerlink" title="GetSpaceAtPoint(XYZ, Phase)"></a>GetSpaceAtPoint(XYZ, Phase)</h3><ul>
<li>获取包含点的空间。</li>
</ul>
<h3 id="GetSubelement-String"><a href="#GetSubelement-String" class="headerlink" title="GetSubelement(String)"></a>GetSubelement(String)</h3><ul>
<li>获取唯一 ID 字符串引用的子元素。</li>
</ul>
<h3 id="GetSubelement-Reference"><a href="#GetSubelement-Reference" class="headerlink" title="GetSubelement(Reference)"></a>GetSubelement(Reference)</h3><ul>
<li>获取输入引用引用的子元素。</li>
</ul>
<h3 id="GetUnits"><a href="#GetUnits" class="headerlink" title="GetUnits"></a>GetUnits</h3><ul>
<li>获取 Units 对象。</li>
</ul>
<h3 id="GetWarnings"><a href="#GetWarnings" class="headerlink" title="GetWarnings"></a>GetWarnings</h3><ul>
<li>返回从文档中累积的持续 （可审阅） 警告生成的失败消息列表。</li>
</ul>
<h3 id="GetWorksetId"><a href="#GetWorksetId" class="headerlink" title="GetWorksetId"></a>GetWorksetId</h3><ul>
<li>获取拥有该元素的工作集的 ID。</li>
</ul>
<h3 id="GetWorksetTable"><a href="#GetWorksetTable" class="headerlink" title="GetWorksetTable"></a>GetWorksetTable</h3><ul>
<li>获取此文档的 WorksetTable。</li>
</ul>
<h3 id="GetWorksharingCentralModelPath"><a href="#GetWorksharingCentralModelPath" class="headerlink" title="GetWorksharingCentralModelPath"></a>GetWorksharingCentralModelPath</h3><ul>
<li>获取工作共享模型的中心模型路径。</li>
</ul>
<h3 id="HasAllChangesFromCentral"><a href="#HasAllChangesFromCentral" class="headerlink" title="HasAllChangesFromCentral"></a>HasAllChangesFromCentral</h3><ul>
<li>返回当前会话中的模型是否与 central 保持同步。</li>
</ul>
<h3 id="Import-String-GBXMLImportOptions"><a href="#Import-String-GBXMLImportOptions" class="headerlink" title="Import(String, GBXMLImportOptions)"></a>Import(String, GBXMLImportOptions)</h3><ul>
<li>将 Green-Building XML 文件导入到文档中。</li>
</ul>
<h3 id="Import-String-SATImportOptions-View"><a href="#Import-String-SATImportOptions-View" class="headerlink" title="Import(String, SATImportOptions, View)"></a>Import(String, SATImportOptions, View)</h3><ul>
<li>将 SAT 文件导入到文档中。</li>
</ul>
<h3 id="Import-String-SKPImportOptions-View"><a href="#Import-String-SKPImportOptions-View" class="headerlink" title="Import(String, SKPImportOptions, View)"></a>Import(String, SKPImportOptions, View)</h3><ul>
<li>将 SKP 文件导入到文档中。</li>
</ul>
<h3 id="Import-String-DGNImportOptions-View-ElementId"><a href="#Import-String-DGNImportOptions-View-ElementId" class="headerlink" title="Import(String, DGNImportOptions, View, ElementId )"></a>Import(String, DGNImportOptions, View, ElementId )</h3><ul>
<li>将 DGN 文件导入到文档中。</li>
</ul>
<h3 id="Import-String-DWGImportOptions-View-ElementId"><a href="#Import-String-DWGImportOptions-View-ElementId" class="headerlink" title="Import(String, DWGImportOptions, View, ElementId )"></a>Import(String, DWGImportOptions, View, ElementId )</h3><ul>
<li>将 DWG 或 DXF 文件导入到文档中。</li>
</ul>
<h3 id="Import-String-ImageImportOptions-View-Element"><a href="#Import-String-ImageImportOptions-View-Element" class="headerlink" title="Import(String, ImageImportOptions, View, Element )"></a>Import(String, ImageImportOptions, View, Element )</h3><ul>
<li>将图像（位图）导入到文档中。</li>
</ul>
<h3 id="IsDefaultElementTypeIdValid"><a href="#IsDefaultElementTypeIdValid" class="headerlink" title="IsDefaultElementTypeIdValid"></a>IsDefaultElementTypeIdValid</h3><ul>
<li>检查元素类型 id 是否对给定的 DefaultElmentType id 有效。</li>
</ul>
<h3 id="IsDefaultFamilyTypeIdValid"><a href="#IsDefaultFamilyTypeIdValid" class="headerlink" title="IsDefaultFamilyTypeIdValid"></a>IsDefaultFamilyTypeIdValid</h3><ul>
<li>检查族类型 ID 是否对给定的family 类别有效。</li>
</ul>
<h3 id="IsPainted"><a href="#IsPainted" class="headerlink" title="IsPainted"></a>IsPainted</h3><ul>
<li>检查元素的表面是否使用材质绘制。</li>
</ul>
<h3 id="Link-String-DWFImportOptions"><a href="#Link-String-DWFImportOptions" class="headerlink" title="Link(String, DWFImportOptions)"></a>Link(String, DWFImportOptions)</h3><ul>
<li>将 DWF 文件中的标记链接到文档。</li>
</ul>
<h3 id="Link-String-SATImportOptions-View"><a href="#Link-String-SATImportOptions-View" class="headerlink" title="Link(String, SATImportOptions, View)"></a>Link(String, SATImportOptions, View)</h3><ul>
<li>将 SAT 文件链接到文档中。</li>
</ul>
<h3 id="Link-String-SKPImportOptions-View"><a href="#Link-String-SKPImportOptions-View" class="headerlink" title="Link(String, SKPImportOptions, View)"></a>Link(String, SKPImportOptions, View)</h3><ul>
<li>将 SKP 文件链接到文档中。</li>
</ul>
<h3 id="Link-String-DGNImportOptions-View-ElementId"><a href="#Link-String-DGNImportOptions-View-ElementId" class="headerlink" title="Link(String, DGNImportOptions, View, ElementId )"></a>Link(String, DGNImportOptions, View, ElementId )</h3><ul>
<li>将 DGN 文件链接到文档。</li>
</ul>
<h3 id="Link-String-DWGImportOptions-View-ElementId"><a href="#Link-String-DWGImportOptions-View-ElementId" class="headerlink" title="Link(String, DWGImportOptions, View, ElementId )"></a>Link(String, DWGImportOptions, View, ElementId )</h3><ul>
<li>将 DWG 或 DXF 文件链接到文档。</li>
</ul>
<h3 id="LoadFamily-String"><a href="#LoadFamily-String" class="headerlink" title="LoadFamily(String)"></a>LoadFamily(String)</h3><ul>
<li>将整个族及其所有类型&#x2F;符号加载到文档中。</li>
</ul>
<h3 id="LoadFamily-Document"><a href="#LoadFamily-Document" class="headerlink" title="LoadFamily(Document)"></a>LoadFamily(Document)</h3><ul>
<li>将此族文档的内容加载到另一个文档中。</li>
</ul>
<h3 id="LoadFamily-String-Family"><a href="#LoadFamily-String-Family" class="headerlink" title="LoadFamily(String, Family )"></a>LoadFamily(String, Family )</h3><ul>
<li>将整个族及其所有类型&#x2F;符号加载到文档中，并提供对载入族的引用。</li>
</ul>
<h3 id="LoadFamily-Document-IFamilyLoadOptions"><a href="#LoadFamily-Document-IFamilyLoadOptions" class="headerlink" title="LoadFamily(Document, IFamilyLoadOptions)"></a>LoadFamily(Document, IFamilyLoadOptions)</h3><ul>
<li>将此族文档的内容加载到另一个文档中。</li>
</ul>
<h3 id="LoadFamily-String-IFamilyLoadOptions-Family"><a href="#LoadFamily-String-IFamilyLoadOptions-Family" class="headerlink" title="LoadFamily(String, IFamilyLoadOptions, Family )"></a>LoadFamily(String, IFamilyLoadOptions, Family )</h3><ul>
<li>将整个族及其所有类型&#x2F;符号加载到文档中，并提供对载入族的引用。</li>
</ul>
<h3 id="LoadFamilySymbol-String-String"><a href="#LoadFamilySymbol-String-String" class="headerlink" title="LoadFamilySymbol(String, String)"></a>LoadFamilySymbol(String, String)</h3><ul>
<li>仅将指定的族类型&#x2F;符号从族文件加载到文档中。</li>
</ul>
<h3 id="LoadFamilySymbol-String-String-FamilySymbol"><a href="#LoadFamilySymbol-String-String-FamilySymbol" class="headerlink" title="LoadFamilySymbol(String, String, FamilySymbol )"></a>LoadFamilySymbol(String, String, FamilySymbol )</h3><ul>
<li>仅将指定的族类型&#x2F;符号从族文件加载到文档中，并提供对载入的族符号的引用。</li>
</ul>
<h3 id="LoadFamilySymbol-String-String-IFamilyLoadOptions-FamilySymbol"><a href="#LoadFamilySymbol-String-String-IFamilyLoadOptions-FamilySymbol" class="headerlink" title="LoadFamilySymbol(String, String, IFamilyLoadOptions, FamilySymbol )"></a>LoadFamilySymbol(String, String, IFamilyLoadOptions, FamilySymbol )</h3><ul>
<li>仅将指定的族类型&#x2F;符号从族文件加载到文档中，并提供对载入的族符号的引用。</li>
</ul>
<h3 id="MakeTransientElements"><a href="#MakeTransientElements" class="headerlink" title="MakeTransientElements"></a>MakeTransientElements</h3><ul>
<li>此方法封装了在文档中创建临时元素的过程。</li>
</ul>
<h3 id="Paint-ElementId-Face-ElementId"><a href="#Paint-ElementId-Face-ElementId" class="headerlink" title="Paint(ElementId, Face, ElementId)"></a>Paint(ElementId, Face, ElementId)</h3><ul>
<li>使用指定的材质绘制元素的面。</li>
</ul>
<h3 id="Paint-ElementId-Face-FamilyParameter"><a href="#Paint-ElementId-Face-FamilyParameter" class="headerlink" title="Paint(ElementId, Face, FamilyParameter)"></a>Paint(ElementId, Face, FamilyParameter)</h3><ul>
<li>使用指定的材质绘制元素的表面。</li>
</ul>
<h3 id="PostFailure"><a href="#PostFailure" class="headerlink" title="PostFailure"></a>PostFailure</h3><ul>
<li>将失败发布，以便在事务结束时向用户显示。</li>
</ul>
<h3 id="Print-ViewSet"><a href="#Print-ViewSet" class="headerlink" title="Print(ViewSet)"></a>Print(ViewSet)</h3><ul>
<li>使用默认视图样板和默认打印设置打印一组视图。</li>
</ul>
<h3 id="Print-ViewSet-View"><a href="#Print-ViewSet-View" class="headerlink" title="Print(ViewSet, View)"></a>Print(ViewSet, View)</h3><ul>
<li>使用指定的视图样板和默认打印设置打印一组视图。</li>
</ul>
<h3 id="Print-ViewSet-Boolean"><a href="#Print-ViewSet-Boolean" class="headerlink" title="Print(ViewSet, Boolean)"></a>Print(ViewSet, Boolean)</h3><ul>
<li>使用默认视图样板和默认打印设置打印一组视图。</li>
</ul>
<h3 id="Print-ViewSet-View-Boolean"><a href="#Print-ViewSet-View-Boolean" class="headerlink" title="Print(ViewSet, View, Boolean)"></a>Print(ViewSet, View, Boolean)</h3><ul>
<li>使用指定的视图样板和默认打印设置打印一组视图。</li>
</ul>
<h3 id="PublishCoordinates"><a href="#PublishCoordinates" class="headerlink" title="PublishCoordinates"></a>PublishCoordinates</h3><ul>
<li>将坐标发布到链接实例的指定 ProjectLocation。</li>
</ul>
<h3 id="Regenerate"><a href="#Regenerate" class="headerlink" title="Regenerate"></a>Regenerate</h3><ul>
<li>更新 Revit 文档中的图元以反映所有更改。</li>
</ul>
<h3 id="ReloadLatest"><a href="#ReloadLatest" class="headerlink" title="ReloadLatest"></a>ReloadLatest</h3><ul>
<li>从 central 获取更改 （由于与 central 的一个或多个同步） 并将它们合并到当前会话中。</li>
</ul>
<h3 id="RemovePaint"><a href="#RemovePaint" class="headerlink" title="RemovePaint"></a>RemovePaint</h3><ul>
<li>删除在元素面上绘制的材质。如果表面当前未上绘制，则不会执行任何操作。</li>
</ul>
<h3 id="Save"><a href="#Save" class="headerlink" title="Save"></a>Save</h3><ul>
<li>保存文档。</li>
</ul>
<h3 id="Save-SaveOptions"><a href="#Save-SaveOptions" class="headerlink" title="Save(SaveOptions)"></a>Save(SaveOptions)</h3><ul>
<li>保存文档。</li>
</ul>
<h3 id="SaveAs-String"><a href="#SaveAs-String" class="headerlink" title="SaveAs(String)"></a>SaveAs(String)</h3><ul>
<li>将文档保存到给定的文件路径。</li>
</ul>
<h3 id="SaveAs-String-SaveAsOptions"><a href="#SaveAs-String-SaveAsOptions" class="headerlink" title="SaveAs(String, SaveAsOptions)"></a>SaveAs(String, SaveAsOptions)</h3><ul>
<li>将文档保存到给定的文件路径。</li>
</ul>
<h3 id="SaveAs-ModelPath-SaveAsOptions"><a href="#SaveAs-ModelPath-SaveAsOptions" class="headerlink" title="SaveAs(ModelPath, SaveAsOptions)"></a>SaveAs(ModelPath, SaveAsOptions)</h3><ul>
<li>将文档保存到给定路径。</li>
</ul>
<h3 id="SaveToProjectAsImage"><a href="#SaveToProjectAsImage" class="headerlink" title="SaveToProjectAsImage"></a>SaveToProjectAsImage</h3><ul>
<li>从当前活动视图创建图像视图。</li>
</ul>
<h3 id="SeparateElements"><a href="#SeparateElements" class="headerlink" title="SeparateElements"></a>SeparateElements</h3><ul>
<li>将一组可组合元素从它们当前属于的组合中分离出来。</li>
</ul>
<h3 id="SetDefaultElementTypeId"><a href="#SetDefaultElementTypeId" class="headerlink" title="SetDefaultElementTypeId"></a>SetDefaultElementTypeId</h3><ul>
<li>设置给定 DefaultElementType ID 的默认元素类型 ID。</li>
</ul>
<h3 id="SetDefaultFamilyTypeId"><a href="#SetDefaultFamilyTypeId" class="headerlink" title="SetDefaultFamilyTypeId"></a>SetDefaultFamilyTypeId</h3><ul>
<li>设置给定族类别的默认族类型 ID。</li>
</ul>
<h3 id="SetUnits"><a href="#SetUnits" class="headerlink" title="SetUnits"></a>SetUnits</h3><ul>
<li>设置单位。</li>
</ul>
<h3 id="SynchronizeWithCentral"><a href="#SynchronizeWithCentral" class="headerlink" title="SynchronizeWithCentral"></a>SynchronizeWithCentral</h3><ul>
<li>执行 reload latest 直到当前会话中的模型是最新的，然后将更改保存回中心。即使未进行任何更改，也会执行保存到中心。</li>
</ul>
<h3 id="UnpostFailure"><a href="#UnpostFailure" class="headerlink" title="UnpostFailure"></a>UnpostFailure</h3><ul>
<li>删除与给定 FailureMessageKey 关联的已发布失败消息。</li>
</ul>
<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><h3 id="ActiveProjectLocation"><a href="#ActiveProjectLocation" class="headerlink" title="ActiveProjectLocation"></a>ActiveProjectLocation</h3><ul>
<li>检索活动项目位置。</li>
</ul>
<h3 id="ActiveView"><a href="#ActiveView" class="headerlink" title="ActiveView"></a>ActiveView</h3><ul>
<li>文档的活动视图。</li>
</ul>
<h3 id="Application"><a href="#Application" class="headerlink" title="Application"></a>Application</h3><ul>
<li>返回 Document 所在的 Application。</li>
</ul>
<h3 id="Create"><a href="#Create" class="headerlink" title="Create"></a>Create</h3><ul>
<li>可用于在项目中创建 Autodesk Revit API 元素的新实例的对象。</li>
</ul>
<h3 id="DisplayUnitSystem"><a href="#DisplayUnitSystem" class="headerlink" title="DisplayUnitSystem"></a>DisplayUnitSystem</h3><ul>
<li>提供对文档中 的显示单位类型的访问。</li>
</ul>
<h3 id="FamilyCreate"><a href="#FamilyCreate" class="headerlink" title="FamilyCreate"></a>FamilyCreate</h3><ul>
<li>可用于在族文档中创建 Autodesk Revit API 元素的新实例的对象。</li>
</ul>
<h3 id="FamilyManager"><a href="#FamilyManager" class="headerlink" title="FamilyManager"></a>FamilyManager</h3><ul>
<li>族管理器对象提供对族类型和参数的访问。</li>
</ul>
<h3 id="IsDetached"><a href="#IsDetached" class="headerlink" title="IsDetached"></a>IsDetached</h3><ul>
<li>标识工作共享文档是否已分离。另请参阅 IsWorkshared</li>
</ul>
<h3 id="IsFamilyDocument"><a href="#IsFamilyDocument" class="headerlink" title="IsFamilyDocument"></a>IsFamilyDocument</h3><ul>
<li>标识当前文档是否为族文档。</li>
</ul>
<h3 id="IsLinked"><a href="#IsLinked" class="headerlink" title="IsLinked"></a>IsLinked</h3><ul>
<li>标识文档是否为链接的 RVT。</li>
</ul>
<h3 id="IsModifiable"><a href="#IsModifiable" class="headerlink" title="IsModifiable"></a>IsModifiable</h3><ul>
<li>文档的可修改性状态。</li>
</ul>
<h3 id="IsModified"><a href="#IsModified" class="headerlink" title="IsModified"></a>IsModified</h3><ul>
<li>对文档所做更改的状态。</li>
</ul>
<h3 id="IsReadOnly"><a href="#IsReadOnly" class="headerlink" title="IsReadOnly"></a>IsReadOnly</h3><ul>
<li>标识文档是只读的还是可以修改的。</li>
</ul>
<h3 id="IsReadOnlyFile"><a href="#IsReadOnlyFile" class="headerlink" title="IsReadOnlyFile"></a>IsReadOnlyFile</h3><ul>
<li>指示文档是否从只读文件打开。</li>
</ul>
<h3 id="IsValidObject"><a href="#IsValidObject" class="headerlink" title="IsValidObject"></a>IsValidObject</h3><ul>
<li>指定 .NET 对象是否表示有效的 Revit 实体。</li>
</ul>
<h3 id="IsWorkshared"><a href="#IsWorkshared" class="headerlink" title="IsWorkshared"></a>IsWorkshared</h3><ul>
<li>标识是否已在文档中启用工作共享（即编辑权限和多个工作集）。另请参阅 IsDetached</li>
</ul>
<h3 id="MassDisplayTemporaryOverride"><a href="#MassDisplayTemporaryOverride" class="headerlink" title="MassDisplayTemporaryOverride"></a>MassDisplayTemporaryOverride</h3><ul>
<li>此设置控制在具有质量类别或子类别的对象的视图中的临时显示。</li>
</ul>
<h3 id="MullionTypes"><a href="#MullionTypes" class="headerlink" title="MullionTypes"></a>MullionTypes</h3><ul>
<li>此属性用于检索当前系统中的所有竖梃类型。</li>
</ul>
<h3 id="OwnerFamily"><a href="#OwnerFamily" class="headerlink" title="OwnerFamily"></a>OwnerFamily</h3><ul>
<li>获取此族文档的 Family 。</li>
</ul>
<h3 id="PanelTypes"><a href="#PanelTypes" class="headerlink" title="PanelTypes"></a>PanelTypes</h3><ul>
<li>检索一组 PanelType 对象，其中包含当前加载到项目中的所有面板类型。</li>
</ul>
<h3 id="ParameterBindings"><a href="#ParameterBindings" class="headerlink" title="ParameterBindings"></a>ParameterBindings</h3><ul>
<li>检索可从中找到参数定义和类别之间的映射的对象。</li>
</ul>
<h3 id="PathName"><a href="#PathName" class="headerlink" title="PathName"></a>PathName</h3><ul>
<li>文档磁盘文件的完全限定路径。</li>
</ul>
<h3 id="Phases"><a href="#Phases" class="headerlink" title="Phases"></a>Phases</h3><ul>
<li>检索表示项目中阶段的所有对象。</li>
</ul>
<h3 id="PlanTopologies"><a href="#PlanTopologies" class="headerlink" title="PlanTopologies"></a>PlanTopologies</h3><ul>
<li>获取最后阶段当前项目的 PlanTopologies。</li>
</ul>
<h3 id="PlanTopologies-Phase"><a href="#PlanTopologies-Phase" class="headerlink" title="PlanTopologies Phase"></a>PlanTopologies Phase</h3><ul>
<li>获取给定阶段中当前项目的 PlanTopologies。</li>
</ul>
<h3 id="PlanTopology-Level"><a href="#PlanTopology-Level" class="headerlink" title="PlanTopology Level"></a>PlanTopology Level</h3><ul>
<li>在最后阶段获取给定级别的 PlanTopology。</li>
</ul>
<h3 id="PlanTopology-Level-Phase"><a href="#PlanTopology-Level-Phase" class="headerlink" title="PlanTopology Level, Phase"></a>PlanTopology Level, Phase</h3><ul>
<li>获取给定阶段中给定级别的 PlanTopology。</li>
</ul>
<h3 id="PrintManager"><a href="#PrintManager" class="headerlink" title="PrintManager"></a>PrintManager</h3><ul>
<li>检索当前项目的 PrintManager。</li>
</ul>
<h3 id="ProjectInformation"><a href="#ProjectInformation" class="headerlink" title="ProjectInformation"></a>ProjectInformation</h3><ul>
<li>返回当前项目的 Project Information。</li>
</ul>
<h3 id="ProjectLocations"><a href="#ProjectLocations" class="headerlink" title="ProjectLocations"></a>ProjectLocations</h3><ul>
<li>检索与此工程关联的所有工程位置</li>
</ul>
<h3 id="ReactionsAreUpToDate"><a href="#ReactionsAreUpToDate" class="headerlink" title="ReactionsAreUpToDate"></a>ReactionsAreUpToDate</h3><ul>
<li>报告分析模型是否已在具有反作用载荷的文档中重新生成。</li>
</ul>
<h3 id="Settings"><a href="#Settings" class="headerlink" title="Settings"></a>Settings</h3><ul>
<li>提供对常规应用程序设置（如 Categories）的访问。</li>
</ul>
<h3 id="SiteLocation"><a href="#SiteLocation" class="headerlink" title="SiteLocation"></a>SiteLocation</h3><ul>
<li>返回站点位置信息。</li>
</ul>
<h3 id="Title"><a href="#Title" class="headerlink" title="Title"></a>Title</h3><ul>
<li>文档的标题。</li>
</ul>
<h3 id="TypeOfStorage"><a href="#TypeOfStorage" class="headerlink" title="TypeOfStorage"></a>TypeOfStorage</h3><ul>
<li>获取指定 BuiltInParameter 的存储类型。</li>
</ul>
<h3 id="WorksharingCentralGUID"><a href="#WorksharingCentralGUID" class="headerlink" title="WorksharingCentralGUID"></a>WorksharingCentralGUID</h3><ul>
<li>基于服务器的模型的中心 GUID。</li>
</ul>
<h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><h3 id="DocumentClosing"><a href="#DocumentClosing" class="headerlink" title="DocumentClosing"></a>DocumentClosing</h3><ul>
<li>订阅 DocumentClosing 事件，以便在 Revit 即将关闭文档时收到通知。</li>
</ul>
<h3 id="DocumentPrinted"><a href="#DocumentPrinted" class="headerlink" title="DocumentPrinted"></a>DocumentPrinted</h3><ul>
<li>订阅 DocumentPrinted 事件，以便在 Revit 打印完文档的视图或 ViewSet 后立即收到通知。</li>
</ul>
<h3 id="DocumentPrinting"><a href="#DocumentPrinting" class="headerlink" title="DocumentPrinting"></a>DocumentPrinting</h3><ul>
<li>订阅 DocumentPrinting 事件，以便在 Revit 即将打印文档的视图或 ViewSet 时收到通知。</li>
</ul>
<h3 id="DocumentSaved"><a href="#DocumentSaved" class="headerlink" title="DocumentSaved"></a>DocumentSaved</h3><ul>
<li>订阅 DocumentSaved 事件，以便在 Revit 完成保存文档后立即收到通知。</li>
</ul>
<h3 id="DocumentSavedAs"><a href="#DocumentSavedAs" class="headerlink" title="DocumentSavedAs"></a>DocumentSavedAs</h3><ul>
<li>订阅 DocumentSavedAs 事件，以便在 Revit 使用新文件名完成保存文档后立即收到通知。</li>
</ul>
<h3 id="DocumentSaving"><a href="#DocumentSaving" class="headerlink" title="DocumentSaving"></a>DocumentSaving</h3><ul>
<li>订阅 DocumentSaving 事件，以便在 Revit 即将保存文档时收到通知。</li>
</ul>
<h3 id="DocumentSavingAs"><a href="#DocumentSavingAs" class="headerlink" title="DocumentSavingAs"></a>DocumentSavingAs</h3><ul>
<li>订阅 DocumentSavingAs 事件，以便在 Revit 即将使用新文件名保存文档时收到通知。</li>
</ul>
<h3 id="ViewPrinted"><a href="#ViewPrinted" class="headerlink" title="ViewPrinted"></a>ViewPrinted</h3><ul>
<li>订阅 ViewPrinted 事件，以便在 Revit 打印完文档视图后立即收到通知。</li>
</ul>
<h3 id="ViewPrinting"><a href="#ViewPrinting" class="headerlink" title="ViewPrinting"></a>ViewPrinting</h3><ul>
<li>订阅 ViewPrinting 事件，以便在 Revit 即将打印文档视图时收到通知。</li>
</ul>
<h2 id="注：翻译自Revit-Api-docs-2018"><a href="#注：翻译自Revit-Api-docs-2018" class="headerlink" title="注：翻译自Revit Api docs 2018"></a><em><strong>注：</strong></em>翻译自<a href="https://www.revitapidocs.com/2018">Revit Api docs 2018</a></h2>]]></content>
      <categories>
        <category>RevitApi</category>
      </categories>
      <tags>
        <tag>Revit</tag>
      </tags>
  </entry>
  <entry>
    <title>Autodesk.Revit.DB ElementTransformUtils</title>
    <url>/2024/12/20/RevitApi%E5%90%88%E9%9B%86/Autodesk.%20Revit.DB%20ElementTransformUtils/</url>
    <content><![CDATA[<h1 id="Autodesk-Revit-DB-ElementTransformUtils"><a href="#Autodesk-Revit-DB-ElementTransformUtils" class="headerlink" title="Autodesk. Revit.DB ElementTransformUtils"></a><a href="https://www.revitapidocs.com/2018/82e737d5-fda4-bc10-6099-88999cd51300.htm">Autodesk. Revit.DB ElementTransformUtils</a></h1><p>允许元素转换的实用程序集合（例如移动，旋转，镜像和复制）。</p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">ElementTransformUtils</span></span><br></pre></td></tr></table></figure>



<h2 id="继承层次结构"><a href="#继承层次结构" class="headerlink" title="继承层次结构"></a>继承层次结构</h2><ul>
<li><h3 id="System-Object"><a href="#System-Object" class="headerlink" title="System Object"></a>System Object</h3></li>
<li><p>Autodesk.Revit.DB ElementTransformUtils</p>
</li>
</ul>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="CanMirrorElement"><a href="#CanMirrorElement" class="headerlink" title="CanMirrorElement"></a>CanMirrorElement</h3><p>确定是否可以镜像元素。</p>
<h3 id="CanMirrorElements"><a href="#CanMirrorElements" class="headerlink" title="CanMirrorElements"></a>CanMirrorElements</h3><p>确定是否可以镜像元素。</p>
<h3 id="CopyElement"><a href="#CopyElement" class="headerlink" title="CopyElement"></a>CopyElement</h3><p>复制元素并将副本放置在给定转换指示的位置。</p>
<h3 id="CopyElements-Document-ICollection-ElementId-XYZ"><a href="#CopyElements-Document-ICollection-ElementId-XYZ" class="headerlink" title="CopyElements(Document, ICollection ElementId , XYZ)"></a>CopyElements(Document, ICollection ElementId , XYZ)</h3><p>复制一组元素，并将副本放置在给定指示的位置。</p>
<h3 id="CopyElements-Document-ICollection-ElementId-Document-Transform-CopyPasteOptions"><a href="#CopyElements-Document-ICollection-ElementId-Document-Transform-CopyPasteOptions" class="headerlink" title="CopyElements(Document, ICollection ElementId , Document, Transform, CopyPasteOptions)"></a>CopyElements(Document, ICollection ElementId , Document, Transform, CopyPasteOptions)</h3><p>将一组元素从源文档复制到目标文档。</p>
<h3 id="CopyElements-View-ICollection-ElementId-View-Transform-CopyPasteOptions"><a href="#CopyElements-View-ICollection-ElementId-View-Transform-CopyPasteOptions" class="headerlink" title="CopyElements(View, ICollection ElementId , View, Transform, CopyPasteOptions)"></a>CopyElements(View, ICollection ElementId , View, Transform, CopyPasteOptions)</h3><p>将一组元素从源视图复制到目标视图。</p>
<h3 id="GetTransformFromViewToView"><a href="#GetTransformFromViewToView" class="headerlink" title="GetTransformFromViewToView"></a>GetTransformFromViewToView</h3><p>返回从一个视图复制到另一个视图时应用于元素的转换。</p>
<h3 id="MirrorElement"><a href="#MirrorElement" class="headerlink" title="MirrorElement"></a>MirrorElement</h3><p>围绕给定平面创建图元的镜像副本。</p>
<h3 id="MirrorElements"><a href="#MirrorElements" class="headerlink" title="MirrorElements"></a>MirrorElements</h3><p>围绕给定平面镜像一组元素。</p>
<h3 id="MoveElement"><a href="#MoveElement" class="headerlink" title="MoveElement"></a>MoveElement</h3><p>按给定的变换移动一个元素。</p>
<h3 id="MoveElements"><a href="#MoveElements" class="headerlink" title="MoveElements"></a>MoveElements</h3><p>通过给定的转换移动一组元素。</p>
<h3 id="RotateElement"><a href="#RotateElement" class="headerlink" title="RotateElement"></a>RotateElement</h3><p>围绕给定的轴和角度旋转元素。</p>
<h3 id="RotateElements"><a href="#RotateElements" class="headerlink" title="RotateElements"></a>RotateElements</h3><p>围绕给定的轴和角度旋转一组元素。</p>
<h2 id="注：翻译自Revit-Api-docs-2018"><a href="#注：翻译自Revit-Api-docs-2018" class="headerlink" title="注：翻译自Revit Api docs 2018"></a><em><strong>注：</strong></em>翻译自<a href="https://www.revitapidocs.com/2018">Revit Api docs 2018</a></h2>]]></content>
      <categories>
        <category>RevitApi</category>
      </categories>
      <tags>
        <tag>Revit</tag>
      </tags>
  </entry>
  <entry>
    <title>Autodesk.Revit.DB CurveArray</title>
    <url>/2024/11/18/RevitApi%E5%90%88%E9%9B%86/Autodesk.Revit.DB%20CurveArray/</url>
    <content><![CDATA[<h1 id="Autodesk-Revit-DB-CurveArray"><a href="#Autodesk-Revit-DB-CurveArray" class="headerlink" title="Autodesk.Revit.DB CurveArray"></a><a href="https://www.revitapidocs.com/2018/55103aad-38fd-45d2-6bf7-67a5203e99f3.htm">Autodesk.Revit.DB CurveArray</a></h1><p>可以包含曲线的数组。</p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CurveArray</span> : <span class="title">APIObject</span>, <span class="title">IEnumerable</span></span><br></pre></td></tr></table></figure>

<h2 id="继承层次结构"><a href="#继承层次结构" class="headerlink" title="继承层次结构"></a>继承层次结构</h2><p><a href="http://msdn2.microsoft.com/en-us/library/e5kfa45b">System Object</a></p>
<p>​	<a href="https://www.revitapidocs.com/2018/beb86ef5-39ad-3f0d-0cd9-0c929387a2bb.htm">Autodesk.Revit.DB APIObject</a></p>
<p>​		Autodesk.Revit.DB CurveArray</p>
<h2 id="另见"><a href="#另见" class="headerlink" title="另见"></a>另见</h2><p><a href="https://www.revitapidocs.com/2018/1035487e-6ef9-94b4-ff6d-fb3ae5c14154.htm">CurveArray Members</a></p>
<p><a href="https://www.revitapidocs.com/2018/87546ba7-461b-c646-cbb1-2cb8f5bff8b2.htm">Autodesk.Revit.DB Namespace</a></p>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><h3 id="CurveArray"><a href="#CurveArray" class="headerlink" title="CurveArray"></a>CurveArray</h3><p>创建CurveArray类的新实例</p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="Append"><a href="#Append" class="headerlink" title="Append"></a>Append</h3><p>将曲线添加到数组的末尾。</p>
<h3 id="Clear"><a href="#Clear" class="headerlink" title="Clear"></a>Clear</h3><p>从数组中删除每条曲线，使其为空。</p>
<h3 id="ForwardIterator"><a href="#ForwardIterator" class="headerlink" title="ForwardIterator"></a>ForwardIterator</h3><p>将一个向前移动的迭代器添加到数组中。</p>
<h3 id="GetEnumerator"><a href="#GetEnumerator" class="headerlink" title="GetEnumerator"></a>GetEnumerator</h3><p>将一个向前移动的迭代器添加到数组中。</p>
<h3 id="Insert"><a href="#Insert" class="headerlink" title="Insert"></a>Insert</h3><p>将指定的曲线插入数组。</p>
<h3 id="ReverseIterator"><a href="#ReverseIterator" class="headerlink" title="ReverseIterator"></a>ReverseIterator</h3><p>返回一个向后移动的迭代器到数组。</p>
<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><h3 id="IsEmpty"><a href="#IsEmpty" class="headerlink" title="IsEmpty"></a>IsEmpty</h3><p>测试数组是否为空。</p>
<h3 id="Item"><a href="#Item" class="headerlink" title="Item"></a>Item</h3><p>获取或设置数组中指定索引处的曲线。</p>
<h3 id="Size"><a href="#Size" class="headerlink" title="Size"></a>Size</h3><p>返回数组中的曲线数。</p>
<h2 id="注：翻译自Revit-Api-docs-2018"><a href="#注：翻译自Revit-Api-docs-2018" class="headerlink" title="注：翻译自Revit Api docs 2018"></a><em><strong>注：</strong></em>翻译自<a href="https://www.revitapidocs.com/2018">Revit Api docs 2018</a></h2>]]></content>
      <categories>
        <category>RevitApi</category>
      </categories>
      <tags>
        <tag>Revit</tag>
      </tags>
  </entry>
  <entry>
    <title>Autodesk.Revit.UI.Selection</title>
    <url>/2024/12/19/RevitApi%E5%90%88%E9%9B%86/Autodesk.Revit.UI.Selection%20Namespace/</url>
    <content><![CDATA[<h1 id="Autodesk-Revit-UI-Selection"><a href="#Autodesk-Revit-UI-Selection" class="headerlink" title="Autodesk.Revit.UI.Selection"></a><a href="https://www.revitapidocs.com/2018/11785869-cc9e-03fc-97db-767a59af10a1.htm">Autodesk.Revit.UI.Selection</a></h1><h2 id="Classes"><a href="#Classes" class="headerlink" title="Classes"></a>Classes</h2><h3 id="PickedBox"><a href="#PickedBox" class="headerlink" title="PickedBox"></a>PickedBox</h3><p>包含两个 XYZ 点的类，表示屏幕上的选取框。</p>
<ul>
<li><p>Properties</p>
<ul>
<li><p>Max</p>
<p>最大坐标数（拾取框的右上角）。</p>
</li>
<li><p>Min</p>
<p>最小坐标（拾取框的左下角）。</p>
</li>
</ul>
</li>
</ul>
<h3 id="SelectableInViewFilter"><a href="#SelectableInViewFilter" class="headerlink" title="SelectableInViewFilter"></a>SelectableInViewFilter</h3><p>一个过滤器，用于传递在给定视图中可选的元素。</p>
<ul>
<li><p>Constructors</p>
<ul>
<li><p>SelectableInViewFilter  (Document, ElementId)</p>
<p>构造 SelectableInViewFilter 的新实例。</p>
</li>
<li><p>SelectableInViewFilter (Document, ElementId, Boolean)</p>
<p>构造 SelectableInViewFilter 的新实例，并可选择传递所有不可选择的元素。</p>
</li>
</ul>
</li>
<li><p>Methods</p>
<ul>
<li><p>PassesFilter(Element)</p>
<p>将筛选器应用于给定元素。</p>
</li>
<li><p>PassesFilter(Document, ElementId)</p>
<p>将筛选器应用于给定元素。</p>
</li>
</ul>
</li>
</ul>
<h3 id="Selection"><a href="#Selection" class="headerlink" title="Selection"></a>Selection</h3><p>包含项目中当前用户选择的元素。</p>
<ul>
<li><p>Methods</p>
<ul>
<li><p>Dispose</p>
<p>释放 Selection 使用的所有资源</p>
</li>
<li><p>GetElementIds</p>
<p>返回当前选定元素的 ID。</p>
</li>
<li><p>PickBox×2</p>
<ul>
<li><p>PickBox(PickBoxStyle)</p>
<p>调用一个通用的双击编辑器，该编辑器允许用户在屏幕上指定一个矩形区域。</p>
</li>
<li><p>PickBox(PickBoxStyle, String)</p>
<p>调用一个通用的双击编辑器，该编辑器允许用户在屏幕上指定一个矩形区域。string为状态栏上显示的消息。</p>
</li>
</ul>
</li>
<li><p>PickElementsByRectangle×4</p>
<ul>
<li><p>PickElementsByRectangle</p>
<p>通过绘制矩形来提示用户选择多个元素。</p>
</li>
<li><p>PickElementsByRectangle(String)</p>
<p>通过绘制矩形来提示用户选择多个元素，同时显示自定义状态提示字符串。</p>
</li>
<li><p>PickElementsByRectangle(ISelectionFilter)</p>
<p>通过绘制一个矩形来提示用户选择多个元素，该矩形通过用户过滤器。</p>
</li>
<li><p>PickElementsByRectangle(ISelectionFilter, String)</p>
<p>通过绘制一个矩形来提示用户选择多个元素，该矩形通过客户过滤器，同时显示自定义状态提示字符串。</p>
</li>
</ul>
</li>
<li><p>PickObject×4</p>
<ul>
<li><p>PickObject(ObjectType)</p>
<p>提示用户选择一个对象。</p>
</li>
<li><p>PickObject(ObjectType, ISelectionFilter)</p>
<p>提示用户选择一个通过自定义过滤器的对象。</p>
</li>
<li><p>PickObject(ObjectType, String)</p>
<p>提示用户选择一个对象，同时显示自定义状态提示字符串。</p>
</li>
<li><p>PickObject(ObjectType, ISelectionFilter, String)</p>
<p>提示用户选择一个对象，该对象通过自定义筛选器，同时显示自定义状态提示字符串。</p>
</li>
</ul>
</li>
<li><p>PickObjects×5</p>
<ul>
<li><p>PickObjects(ObjectType)</p>
<p>提示用户选择多个对象。</p>
</li>
<li><p>PickObjects(ObjectType, ISelectionFilter)</p>
<p>提示用户选择多个对象，这些对象通过客户筛选器。</p>
</li>
<li><p>PickObjects(ObjectType, String)</p>
<p>提示用户选择多个对象，同时显示自定义状态提示字符串。</p>
</li>
<li><p>PickObjects(ObjectType, ISelectionFilter, String)</p>
<p>提示用户选择多个对象，这些对象通过自定义筛选器，同时显示自定义状态提示字符串。</p>
</li>
<li><p>PickObjects(ObjectType, ISelectionFilter, String, IList Reference )</p>
<p>提示用户选择多个对象，这些对象通过自定义筛选器，同时显示自定义状态提示字符串。可以提供一组预选对象，并将在选择开始时选择。</p>
</li>
</ul>
</li>
<li><p>PickPoint×4</p>
<ul>
<li><p>PickPoint</p>
<p>提示用户在活动工作平面上选取一个点。</p>
</li>
<li><p>PickPoint(String)</p>
<p>提示用户在活动工作平面上选取一个点，同时显示自定义状态提示字符串。</p>
</li>
<li><p>PickPoint(ObjectSnapTypes)</p>
<p>提示用户使用指定的捕捉设置在活动工作平面上选取一个点。</p>
</li>
<li><p>PickPoint(ObjectSnapTypes, String)</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Interfaces"><a href="#Interfaces" class="headerlink" title="Interfaces"></a>Interfaces</h2><h3 id="ISelectionFilter"><a href="#ISelectionFilter" class="headerlink" title="ISelectionFilter"></a>ISelectionFilter</h3><p>一个接口，提供在选择操作期间筛选对象的功能。</p>
<ul>
<li><p>Examples</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">- - <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IList&lt;Element&gt; <span class="title">GetManyRefByRectangle</span>(<span class="params">UIDocument doc</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">    ReferenceArray ra = <span class="keyword">new</span> ReferenceArray();</span><br><span class="line">    ISelectionFilter selFilter = <span class="keyword">new</span> MassSelectionFilter();</span><br><span class="line">    IList&lt;Element&gt; eList = doc.Selection.PickElementsByRectangle(selFilter, </span><br><span class="line">        <span class="string">&quot;Select multiple faces&quot;</span>) <span class="keyword">as</span> IList&lt;Element&gt;;</span><br><span class="line">    <span class="keyword">return</span> eList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MassSelectionFilter</span> : <span class="title">ISelectionFilter</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">AllowElement</span>(<span class="params">Element element</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (element.Category.Name == <span class="string">&quot;Mass&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">AllowReference</span>(<span class="params">Reference refer, XYZ point</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Methods</p>
<ul>
<li><p>AllowElement</p>
<p>重写此预筛选方法以指定是否应允许选择该元素。</p>
</li>
<li><p>AllowReference</p>
<p>重写此后过滤方法以指定是否允许选择对几何图形的引用。</p>
</li>
</ul>
</li>
</ul>
<h2 id="Enumerations"><a href="#Enumerations" class="headerlink" title="Enumerations"></a>Enumerations</h2><h3 id="ObjectSnapTypes"><a href="#ObjectSnapTypes" class="headerlink" title="ObjectSnapTypes"></a>ObjectSnapTypes</h3><p>此枚举类型包含在 PickPoint 操作期间允许设置的对象捕捉类型。</p>
<h3 id="ObjectType"><a href="#ObjectType" class="headerlink" title="ObjectType"></a>ObjectType</h3><p>此枚举类型包含在选择操作期间允许选择的对象类型。</p>
<h3 id="PickBoxStyle"><a href="#PickBoxStyle" class="headerlink" title="PickBoxStyle"></a>PickBoxStyle</h3><p>控制选取框样式的枚举。</p>
<h2 id="注：翻译自Revit-API-Docs-2018"><a href="#注：翻译自Revit-API-Docs-2018" class="headerlink" title="注：翻译自Revit API Docs 2018"></a><em><strong>注：</strong></em>翻译自<a href="https://www.revitapidocs.com/2018/">Revit API Docs 2018</a></h2>]]></content>
      <categories>
        <category>RevitApi</category>
      </categories>
      <tags>
        <tag>Revit</tag>
      </tags>
  </entry>
  <entry>
    <title>Autodesk.Revit.DB ReferenceIntersector</title>
    <url>/2024/12/10/RevitApi%E5%90%88%E9%9B%86/Autodesk.Revit.DB%20ReferenceIntersector/</url>
    <content><![CDATA[<h1 id="Autodesk-Revit-DB-ReferenceIntersector"><a href="#Autodesk-Revit-DB-ReferenceIntersector" class="headerlink" title="Autodesk.Revit.DB ReferenceIntersector"></a><a href="https://www.revitapidocs.com/2018/36f82b40-1065-2305-e260-18fc618e756f.htm">Autodesk.Revit.DB ReferenceIntersector</a></h1><p>用于查找和返回与从原点和方向创建的射线相交的元素的类。</p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ReferenceIntersector</span> : <span class="title">IDisposable</span></span><br></pre></td></tr></table></figure>



<h2 id="附注"><a href="#附注" class="headerlink" title="附注"></a>附注</h2><p>可以构造此类的实例，以返回与由原点和方向创建的射线，或者基于过滤和标志返回元素的子集。 调用者可以选择使用ElementFilter过滤结果，或者通过应用特定的可接受的元素。 调用方还可以指定要返回的对象的类型， 整个元素、几何体对象或其组合。 在所有情况下，要求调用者提供 用于评估的3D视图;输入视图上的视图和可见性设置将确定 返回特定元素（例如，此工具永远不会返回隐藏元素、 和几何图形位于视图剖面框之外的元素）。</p>
<p>该类配置为可以构建单个实例，并用于对多个不同光线进行多次评估。在同一个 ReferenceIntersector 上的调用之间，评估结果不会被保留。</p>
<p>该类还提供了一个选项，用于返回在Revit链接中遇到的图元结果。 当设置 FindReferencesInRevitLinks 标志 则结果可能包括宿主文档和遇到的任何RevitLinkInstance中的元素，具体取决于其他设置的标志。 请参阅 FindReferencesInRevitLinks 的备注，了解标志如何影响从链接获得的结果。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">F <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">RayProjection</span> : <span class="title">IExternalCommand</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">Execute</span>(<span class="params">ExternalCommandData revit, <span class="keyword">ref</span> <span class="built_in">string</span> message, ElementSet elements</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Document doc = revit.Application.ActiveUIDocument.Document;</span><br><span class="line"></span><br><span class="line">        ICollection&lt;ElementId&gt; selectedIds = revit.Application.ActiveUIDocument.Selection.GetElementIds();</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// If skylight is selected, process it.</span></span><br><span class="line">        FamilyInstance skylight = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (selectedIds.Count == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">foreach</span> (ElementId id <span class="keyword">in</span> selectedIds)</span><br><span class="line">            &#123;</span><br><span class="line">                Element e = doc.GetElement(id);</span><br><span class="line">                <span class="keyword">if</span> (e <span class="keyword">is</span> FamilyInstance)</span><br><span class="line">                &#123;</span><br><span class="line">                    FamilyInstance instance = e <span class="keyword">as</span> FamilyInstance;</span><br><span class="line">                    <span class="built_in">bool</span> isWindow = (instance.Category.Id.IntegerValue == (<span class="built_in">int</span>)BuiltInCategory.OST_Windows);</span><br><span class="line">                    <span class="built_in">bool</span> isHostedByRoof = (instance.Host.Category.Id.IntegerValue == (<span class="built_in">int</span>)BuiltInCategory.OST_Roofs);</span><br><span class="line">    </span><br><span class="line">                    <span class="keyword">if</span> (isWindow &amp;&amp; isHostedByRoof)</span><br><span class="line">                    &#123;</span><br><span class="line">                        skylight = instance;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> (skylight == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            message = <span class="string">&quot;Please select one skylight.&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span> Result.Cancelled;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// Calculate the height</span></span><br><span class="line">        Line line = CalculateLineAboveFloor(doc, skylight);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// Create a model curve to show the distance</span></span><br><span class="line">        Plane plane = Plane.CreateByNormalAndOrigin(<span class="keyword">new</span> XYZ(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>), line.GetEndPoint(<span class="number">0</span>));</span><br><span class="line">        SketchPlane sketchPlane = SketchPlane.Create(doc, plane);</span><br><span class="line">    </span><br><span class="line">        ModelCurve curve = doc.Create.NewModelCurve(line, sketchPlane);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// Show a message with the length value</span></span><br><span class="line">        TaskDialog.Show(<span class="string">&quot;Distance&quot;</span>, <span class="string">&quot;Distance to floor: &quot;</span> + String.Format(<span class="string">&quot;&#123;0:f2&#125;&quot;</span>, line.Length));</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> Result.Succeeded;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> Determines the line segment that connects the skylight to the nearest floor.</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>The line segment.<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Line <span class="title">CalculateLineAboveFloor</span>(<span class="params">Document doc, FamilyInstance skylight</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Find a 3D view to use for the ReferenceIntersector constructor</span></span><br><span class="line">        FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(doc);</span><br><span class="line">        Func&lt;View3D, <span class="built_in">bool</span>&gt; isNotTemplate = v3 =&gt; !(v3.IsTemplate);</span><br><span class="line">        View3D view3D = collector.OfClass(<span class="keyword">typeof</span>(View3D)).Cast&lt;View3D&gt;().First&lt;View3D&gt;(isNotTemplate);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// Use the center of the skylight bounding box as the start point.</span></span><br><span class="line">        BoundingBoxXYZ box = skylight.get_BoundingBox(view3D);</span><br><span class="line">        XYZ center = box.Min.Add(box.Max).Multiply(<span class="number">0.5</span>);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// Project in the negative Z direction down to the floor.</span></span><br><span class="line">        XYZ rayDirection = <span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>);</span><br><span class="line">    </span><br><span class="line">        ElementClassFilter filter = <span class="keyword">new</span> ElementClassFilter(<span class="keyword">typeof</span>(Floor));</span><br><span class="line">    </span><br><span class="line">        ReferenceIntersector refIntersector = <span class="keyword">new</span> ReferenceIntersector(filter, FindReferenceTarget.Face, view3D);</span><br><span class="line">        ReferenceWithContext referenceWithContext = refIntersector.FindNearest(center, rayDirection);</span><br><span class="line">    </span><br><span class="line">        Reference reference = referenceWithContext.GetReference();</span><br><span class="line">        XYZ intersection = reference.GlobalPoint;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// Create line segment from the start point and intersection point.</span></span><br><span class="line">        Line result = Line.CreateBound(center, intersection);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="继承层次结构"><a href="#继承层次结构" class="headerlink" title="继承层次结构"></a>继承层次结构</h2><p>System Object</p>
<p>Autodesk.Revit.DB ReferenceIntersector</p>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><h3 id="ReferenceIntersector-View3D"><a href="#ReferenceIntersector-View3D" class="headerlink" title="ReferenceIntersector(View3D)"></a>ReferenceIntersector(View3D)</h3><ul>
<li>构造一个ReferenceIntersector，它被设置为返回所有元素的交集，并表示所有引用目标类型。</li>
</ul>
<h3 id="ReferenceIntersector-ElementFilter-FindReferenceTarget-View3D"><a href="#ReferenceIntersector-ElementFilter-FindReferenceTarget-View3D" class="headerlink" title="ReferenceIntersector(ElementFilter, FindReferenceTarget, View3D)"></a>ReferenceIntersector(ElementFilter, FindReferenceTarget, View3D)</h3><ul>
<li>构造一个ReferenceIntersector，它被设置为从任何通过输入过滤器的元素返回交集。</li>
</ul>
<h3 id="ReferenceIntersector-ElementId-FindReferenceTarget-View3D"><a href="#ReferenceIntersector-ElementId-FindReferenceTarget-View3D" class="headerlink" title="ReferenceIntersector(ElementId, FindReferenceTarget, View3D)"></a>ReferenceIntersector(ElementId, FindReferenceTarget, View3D)</h3><ul>
<li>构造一个ReferenceIntersector，它被设置为仅返回来自单个目标元素的交集。</li>
</ul>
<h3 id="ReferenceIntersector-ICollection-ElementId-FindReferenceTarget-View3D"><a href="#ReferenceIntersector-ICollection-ElementId-FindReferenceTarget-View3D" class="headerlink" title="ReferenceIntersector(ICollection ElementId , FindReferenceTarget, View3D)"></a>ReferenceIntersector(ICollection ElementId , FindReferenceTarget, View3D)</h3><ul>
<li>构造一个ReferenceIntersector，它被设置为返回一组目标元素中任何一个的交集。</li>
</ul>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="Dispose"><a href="#Dispose" class="headerlink" title="Dispose"></a>Dispose</h3><ul>
<li>释放ReferenceIntersector使用的所有资源</li>
</ul>
<h3 id="Find"><a href="#Find" class="headerlink" title="Find"></a>Find</h3><ul>
<li>从原点沿给定方向投射一条射线，并返回所有与 ReferenceIntersector 标准匹配的相交元素的引用。</li>
</ul>
<h3 id="FindNearest"><a href="#FindNearest" class="headerlink" title="FindNearest"></a>FindNearest</h3><ul>
<li>从原点沿给定方向投射一条射线，并返回与 ReferenceIntersector 标准匹配的相交元素中最接近的引用。</li>
</ul>
<h3 id="GetFilter"><a href="#GetFilter" class="headerlink" title="GetFilter"></a>GetFilter</h3><ul>
<li>获取用于交集测试的 ElementFilter。</li>
</ul>
<h3 id="GetTargetElementIds"><a href="#GetTargetElementIds" class="headerlink" title="GetTargetElementIds"></a>GetTargetElementIds</h3><ul>
<li>从交集测试中获取要测试的 ElementIds 集合。</li>
</ul>
<h3 id="SetFilter"><a href="#SetFilter" class="headerlink" title="SetFilter"></a>SetFilter</h3><ul>
<li>设置用于交集测试的 ElementFilter。</li>
</ul>
<h3 id="SetTargetElementIds"><a href="#SetTargetElementIds" class="headerlink" title="SetTargetElementIds"></a>SetTargetElementIds</h3><ul>
<li>设置交集测试中用于测试的 ElementIds 集合。</li>
</ul>
<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><h3 id="FindReferencesInRevitLinks"><a href="#FindReferencesInRevitLinks" class="headerlink" title="FindReferencesInRevitLinks"></a>FindReferencesInRevitLinks</h3><ul>
<li>确定是否应在 Revit 链接内查找引用。</li>
</ul>
<h3 id="IsValidObject"><a href="#IsValidObject" class="headerlink" title="IsValidObject"></a>IsValidObject</h3><ul>
<li>指定.NET 对象是否表示有效的 Revit 实体。</li>
</ul>
<h3 id="TargetType"><a href="#TargetType" class="headerlink" title="TargetType"></a>TargetType</h3><ul>
<li>要查找的引用类型。</li>
</ul>
<h3 id="ViewId"><a href="#ViewId" class="headerlink" title="ViewId"></a>ViewId</h3><ul>
<li>用于评估的 3D 视图的 ID。</li>
</ul>
<h2 id="注：翻译自Revit-Api-docs-2018"><a href="#注：翻译自Revit-Api-docs-2018" class="headerlink" title="注：翻译自Revit Api docs 2018"></a><em><strong>注：</strong></em>翻译自<a href="https://www.revitapidocs.com/2018">Revit Api docs 2018</a></h2>]]></content>
      <categories>
        <category>RevitApi</category>
      </categories>
      <tags>
        <tag>Revit</tag>
      </tags>
  </entry>
  <entry>
    <title>Autodesk.Revit.DB Transform</title>
    <url>/2024/12/20/RevitApi%E5%90%88%E9%9B%86/Autodesk.Revit.DB%20Transform/</url>
    <content><![CDATA[<h1 id="Autodesk-Revit-DB-Transform"><a href="#Autodesk-Revit-DB-Transform" class="headerlink" title="Autodesk.Revit.DB Transform"></a><a href="https://www.revitapidocs.com/2018/58dd01c8-b3fc-7142-e4f3-c524079a282d.htm">Autodesk.Revit.DB Transform</a></h1><p>仿射三维空间的一个变换。</p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><h3 id="public-class-Transform-APIObject"><a href="#public-class-Transform-APIObject" class="headerlink" title="public class Transform : APIObject"></a>public class Transform : APIObject</h3><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="meta">### public static XYZ TransformPoint(XYZ point, Transform transform)</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">double</span> x = point.X;</span><br><span class="line">    <span class="built_in">double</span> y = point.Y;</span><br><span class="line">    <span class="built_in">double</span> z = point.Z;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//transform basis of the old coordinate system in the new coordinate // system</span></span><br><span class="line">    XYZ b0 = transform.get_Basis(<span class="number">0</span>);</span><br><span class="line">    XYZ b1 = transform.get_Basis(<span class="number">1</span>);</span><br><span class="line">    XYZ b2 = transform.get_Basis(<span class="number">2</span>);</span><br><span class="line">    XYZ origin = transform.Origin;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//transform the origin of the old coordinate system in the new </span></span><br><span class="line">    <span class="comment">//coordinate system</span></span><br><span class="line">    <span class="built_in">double</span> xTemp = x * b0.X + y * b1.X + z * b2.X + origin.X;</span><br><span class="line">    <span class="built_in">double</span> yTemp = x * b0.Y + y * b1.Y + z * b2.Y + origin.Y;</span><br><span class="line">    <span class="built_in">double</span> zTemp = x * b0.Z + y * b1.Z + z * b2.Z + origin.Z;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> XYZ(xTemp, yTemp, zTemp);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="继承层次结构"><a href="#继承层次结构" class="headerlink" title="继承层次结构"></a>继承层次结构</h2><ul>
<li>System Object</li>
<li>Autodesk.Revit.DB APIObject</li>
<li>Autodesk.Revit.DB Transform</li>
</ul>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="AlmostEqual"><a href="#AlmostEqual" class="headerlink" title="AlmostEqual"></a>AlmostEqual</h3><ul>
<li>确定此变换和指定的变换在公差范围内是否相同（1.0e-09）。</li>
</ul>
<h3 id="CreateReflection"><a href="#CreateReflection" class="headerlink" title="CreateReflection"></a>CreateReflection</h3><ul>
<li>创建表示给定平面上的反射的变换。</li>
</ul>
<h3 id="CreateRotation"><a href="#CreateRotation" class="headerlink" title="CreateRotation"></a>CreateRotation</h3><ul>
<li>创建表示绕给定轴在（0，0，0）处旋转的变换。</li>
</ul>
<h3 id="CreateTranslation"><a href="#CreateTranslation" class="headerlink" title="CreateTranslation"></a>CreateTranslation</h3><ul>
<li>创建表示通过指定向量的平移的转换。</li>
</ul>
<h3 id="Multiply"><a href="#Multiply" class="headerlink" title="Multiply"></a>Multiply</h3><ul>
<li>将此转换乘以指定的转换并返回结果。</li>
</ul>
<h3 id="OfPoint"><a href="#OfPoint" class="headerlink" title="OfPoint"></a>OfPoint</h3><ul>
<li>将转换为点并返回结果。</li>
</ul>
<h3 id="OfVector"><a href="#OfVector" class="headerlink" title="OfVector"></a>OfVector</h3><ul>
<li>将变换转换为向量</li>
</ul>
<h3 id="ScaleBasis"><a href="#ScaleBasis" class="headerlink" title="ScaleBasis"></a>ScaleBasis</h3><ul>
<li>缩放此转换的基向量并返回结果。</li>
</ul>
<h3 id="ScaleBasisAndOrigin"><a href="#ScaleBasisAndOrigin" class="headerlink" title="ScaleBasisAndOrigin"></a>ScaleBasisAndOrigin</h3><ul>
<li>缩放此变换的基向量和原点并返回结果。</li>
</ul>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h3 id="Multiply-1"><a href="#Multiply-1" class="headerlink" title="Multiply"></a>Multiply</h3><ul>
<li>将两个指定的变换相乘。</li>
</ul>
<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><h3 id="Basis"><a href="#Basis" class="headerlink" title="Basis"></a>Basis</h3><ul>
<li>定义旧坐标系在新坐标系中的基础。</li>
</ul>
<h3 id="BasisX"><a href="#BasisX" class="headerlink" title="BasisX"></a>BasisX</h3><ul>
<li>此变换的X轴的基础。</li>
</ul>
<h3 id="BasisY"><a href="#BasisY" class="headerlink" title="BasisY"></a>BasisY</h3><ul>
<li>此变换的Y轴的基础。</li>
</ul>
<h3 id="BasisZ"><a href="#BasisZ" class="headerlink" title="BasisZ"></a>BasisZ</h3><ul>
<li>此变换的Z轴的基础。</li>
</ul>
<h3 id="Determinant"><a href="#Determinant" class="headerlink" title="Determinant"></a>Determinant</h3><ul>
<li>这种转变的决定因素。</li>
</ul>
<h3 id="HasReflection"><a href="#HasReflection" class="headerlink" title="HasReflection"></a>HasReflection</h3><ul>
<li>指示此转换是否产生反射的布尔值。</li>
</ul>
<h3 id="Identity"><a href="#Identity" class="headerlink" title="Identity"></a>Identity</h3><ul>
<li>单位矩阵</li>
</ul>
<h3 id="Inverse"><a href="#Inverse" class="headerlink" title="Inverse"></a>Inverse</h3><ul>
<li>这种变换的逆变换</li>
</ul>
<h3 id="IsConformal"><a href="#IsConformal" class="headerlink" title="IsConformal"></a>IsConformal</h3><ul>
<li>指示此变换是否为保形的布尔值。</li>
</ul>
<h3 id="IsIdentity"><a href="#IsIdentity" class="headerlink" title="IsIdentity"></a>IsIdentity</h3><ul>
<li>指示此转换是否为单位矩阵的布尔值。</li>
</ul>
<h3 id="IsTranslation"><a href="#IsTranslation" class="headerlink" title="IsTranslation"></a>IsTranslation</h3><ul>
<li>指示此转换是否为转换的布尔值。</li>
</ul>
<h3 id="Origin"><a href="#Origin" class="headerlink" title="Origin"></a>Origin</h3><ul>
<li>在新坐标系中定义旧坐标系的原点。</li>
</ul>
<h3 id="Scale"><a href="#Scale" class="headerlink" title="Scale"></a>Scale</h3><ul>
<li>表示转换比例的真实的数字。</li>
</ul>
<h2 id="注：翻译自Revit-Api-docs-2018"><a href="#注：翻译自Revit-Api-docs-2018" class="headerlink" title="注：翻译自Revit Api docs 2018"></a><em><strong>注：</strong></em>翻译自<a href="https://www.revitapidocs.com/2018">Revit Api docs 2018</a></h2>]]></content>
      <categories>
        <category>RevitApi</category>
      </categories>
      <tags>
        <tag>Revit</tag>
      </tags>
  </entry>
  <entry>
    <title>Autodesk.RevitAddIns Namespace</title>
    <url>/2024/11/18/RevitApi%E5%90%88%E9%9B%86/Autodesk.RevitAddIns%20Namespace/</url>
    <content><![CDATA[<h1 id="Autodesk-RevitAddIns-Namespace"><a href="#Autodesk-RevitAddIns-Namespace" class="headerlink" title="Autodesk.RevitAddIns Namespace"></a>Autodesk.RevitAddIns Namespace</h1><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><h3 id="AddInManifestUtility"><a href="#AddInManifestUtility" class="headerlink" title="AddInManifestUtility"></a>AddInManifestUtility</h3><p>此静态类提供从 Revit .addin 文件中读取清单内容的访问。 </p>
<ul>
<li><p>方法</p>
<ul>
<li><p>GetRevitAddInBundleManifests</p>
</li>
<li><p>GetRevitAddInManifest</p>
</li>
<li><p>GetRevitAddInManifests</p>
</li>
</ul>
</li>
</ul>
<h3 id="RevitAddInApplication"><a href="#RevitAddInApplication" class="headerlink" title="RevitAddInApplication"></a>RevitAddInApplication</h3><p>表示 Revit 外部应用程序。</p>
<ul>
<li><p>构造器</p>
<ul>
<li><p>RevitAddInApplication</p>
<p>创建 external application info 类的新实例。</p>
</li>
</ul>
</li>
<li><p>属性</p>
<ul>
<li><p>Name</p>
<p> Application name</p>
</li>
</ul>
</li>
<li><p>继承关系</p>
<ul>
<li>System.Object<br>  Autodesk.RevitAddIns.RevitAddInItem<br>  Autodesk.RevitAddIns.RevitAddInApplication</li>
</ul>
</li>
</ul>
<h3 id="RevitAddInCommand"><a href="#RevitAddInCommand" class="headerlink" title="RevitAddInCommand"></a>RevitAddInCommand</h3><p>表示 Revit 外部命令。</p>
<ul>
<li><p>构造器</p>
<ul>
<li><p>RevitAddInCommand</p>
<p>创建 Add-In Command info 类的新实例。</p>
</li>
</ul>
</li>
<li><p>属性</p>
<ul>
<li><p>AvailabilityClassName</p>
<p>提供决定此命令可用性的入口点的类的完整类名。</p>
</li>
<li><p>Description</p>
<p>命令的简短描述和简短工具提示。 </p>
</li>
<li><p>Discipline</p>
<p>外部命令可见的模式。</p>
</li>
<li><p>LanguageType</p>
<p>语言类型</p>
</li>
<li><p>LargeImage</p>
<p>命令按钮的大图像的路径。</p>
</li>
<li><p>LongDescription</p>
<p>扩展命令工具提示中显示的文本。</p>
</li>
<li><p>Text</p>
<p>外部命令按钮上显示的文本。</p>
</li>
<li><p>TooltipImage</p>
<p>扩展命令 tooltip 中显示的图像。</p>
</li>
<li><p>VisibilityMode</p>
<p>外部命令可见的模式。</p>
</li>
</ul>
</li>
<li><p>继承关系</p>
<ul>
<li>System.Object<br>  Autodesk.RevitAddIns.RevitAddInItem<br>  Autodesk.RevitAddIns.RevitAddInCommand</li>
</ul>
</li>
</ul>
<h3 id="RevitAddInDBApplication"><a href="#RevitAddInDBApplication" class="headerlink" title="RevitAddInDBApplication"></a>RevitAddInDBApplication</h3><p>表示 Revit DB 外部应用程序。</p>
<ul>
<li><p>构造器</p>
<ul>
<li><p>RevitAddInDBApplication</p>
<p>创建外部 DB Application info 类的新实例。</p>
</li>
</ul>
</li>
<li><p>属性</p>
<ul>
<li><p>LoadInRevitWorker</p>
<p>指示 RevitWorker 进程是否将加载此附加模块。</p>
</li>
<li><p>Name</p>
<p>DB Application名字</p>
</li>
</ul>
</li>
<li><p>继承关系</p>
<ul>
<li>System.Object<br>  Autodesk.RevitAddIns.RevitAddInItem<br>  Autodesk.RevitAddIns.RevitAddInDBApplication</li>
</ul>
</li>
</ul>
<h3 id="RevitAddInItem"><a href="#RevitAddInItem" class="headerlink" title="RevitAddInItem"></a>RevitAddInItem</h3><p>表示单个 Revit 附加模块。 </p>
<ul>
<li><p>属性</p>
<ul>
<li><p>AddInId</p>
<p>加载项的 ID。必须为每个加载项分配一个唯一标识符。</p>
</li>
<li><p>AllowLoadingIntoExistingSession</p>
<p>加载权限的标志。</p>
</li>
<li><p>Assembly</p>
<p>定义加载项的程序集的文件路径。 </p>
</li>
<li><p>FullClassName</p>
<p>提供加载项入口点的类的完整类名。</p>
</li>
<li><p>ProductDescription</p>
<p>产品描述。</p>
</li>
<li><p>ProductImage</p>
<p>产品图像。</p>
</li>
<li><p>ProductVersion</p>
<p>产品版本。</p>
</li>
<li><p>SuppressedWarning</p>
<p>启动失败，如果发生启动失败，将禁止用户访问。 </p>
</li>
<li><p>VendorDescription</p>
<p>供应商描述。</p>
</li>
<li><p>VendorId</p>
<p>供应商 ID。</p>
</li>
</ul>
</li>
<li><p>继承关系</p>
<ul>
<li>System.Object<br>  Autodesk.RevitAddIns.RevitAddInItem<br>  Autodesk.RevitAddIns.RevitAddInApplication<br>  Autodesk.RevitAddIns.RevitAddInCommand<br>  Autodesk.RevitAddIns.RevitAddInDBApplication</li>
</ul>
</li>
</ul>
<h3 id="RevitAddInManifest"><a href="#RevitAddInManifest" class="headerlink" title="RevitAddInManifest"></a>RevitAddInManifest</h3><p> 表示单个 .addin 文件的内容。</p>
<ul>
<li><p>构造器</p>
<ul>
<li><p>RevitAddInManifest</p>
<p>构造一个新的空清单。</p>
</li>
</ul>
</li>
<li><p>方法</p>
<ul>
<li><p>Save</p>
</li>
<li><p>SaveAs</p>
</li>
</ul>
</li>
<li><p>属性</p>
<ul>
<li><p>AddInApplications</p>
<p>清单中所有外部应用程序的集合。</p>
</li>
<li><p>AddInCommands</p>
<p>清单中所有外部命令的集合。</p>
</li>
<li><p>AddInDBApplications</p>
<p>清单中所有外部数据库应用程序的集合。</p>
</li>
<li><p>FullName</p>
<p>与清单关联的完整路径和文件名。</p>
</li>
<li><p>Name</p>
<p>与清单关联的文件名。</p>
</li>
</ul>
</li>
</ul>
<h3 id="RevitProduct"><a href="#RevitProduct" class="headerlink" title="RevitProduct"></a>RevitProduct</h3><p>表示本地计算机上已安装的 Revit 实例。 </p>
<ul>
<li><p>方法</p>
<ul>
<li><p>GetInstalledLanguages</p>
<p>获取已安装的语言类型。</p>
</li>
</ul>
</li>
<li><p>属性</p>
<ul>
<li><p>AllUsersAddInFolder</p>
<p>此产品与所有用户关联的 .addin 文件所在的文件夹路径。</p>
</li>
<li><p>Architecture</p>
<p>此 Revit 产品安装的系统建筑</p>
</li>
<li><p>CurrentUserAddInFolder</p>
<p>此产品与当前用户关联的 .addin 文件所在的文件夹路径。</p>
</li>
<li><p>InstallLocation</p>
<p>安装此 Revit 产品的文件夹路径。</p>
</li>
<li><p>IsSubscriptionUpdate</p>
<p>Obsolete。<br>如果此版本的 Revit 是固定期限的使用许可更新，则为 True。</p>
</li>
<li><p>Name</p>
<p>此 Revit 产品的用户可见名称。例如：“Autodesk Revit Architecture 2010”</p>
</li>
<li><p>Product</p>
<p>产品类型。 </p>
</li>
<li><p>ProductCode</p>
<p>用于从注册表中查找和标识 Revit 产品的 ID。</p>
</li>
<li><p>ReleaseSubVersion</p>
<p>发布子版本的字符串。</p>
</li>
<li><p>Subversion</p>
<p>发布版本</p>
</li>
<li><p>Version</p>
<p>此 Revit 产品的版本。例如：’2010’。</p>
</li>
</ul>
</li>
</ul>
<h3 id="RevitProductUtility"><a href="#RevitProductUtility" class="headerlink" title="RevitProductUtility"></a>RevitProductUtility</h3><p>提供对本地计算机上已安装的 Revit 版本的访问权限。 </p>
<ul>
<li><p>方法</p>
<ul>
<li><p>GetAllInstalledRevitProducts</p>
<p>获取此计算机上安装的 Revit 产品的列表。</p>
</li>
</ul>
</li>
</ul>
<h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><h3 id="AddInArchitecture"><a href="#AddInArchitecture" class="headerlink" title="AddInArchitecture"></a>AddInArchitecture</h3><p>定义 Add-In 实用程序识别的操作系统体系结构。 </p>
<ul>
<li><p>OS32bit  </p>
<p>32位操作系统</p>
</li>
<li><p>OS64bit </p>
<p>64位操作系统</p>
</li>
</ul>
<h3 id="Discipline"><a href="#Discipline" class="headerlink" title="Discipline"></a>Discipline</h3><p>描述特定外部命令在 Revit UI 中可见的条件。 </p>
<ul>
<li><p>Any</p>
<p>命令在所有可能的学科中都可用。</p>
</li>
<li><p>Architecture</p>
<p>该命令在建筑领域中可用。</p>
</li>
<li><p>Structure</p>
<p>该命令在结构领域中可用。</p>
</li>
<li><p>StructuralAnalysis</p>
<p>该命令在结构分析领域中可用。</p>
</li>
<li><p>MassingAndSite</p>
<p>该命令在体量与场地领域中可用。</p>
</li>
<li><p>EnergyAnalysis</p>
<p>该命令在能量分析领域中可用。</p>
</li>
<li><p>Mechanical</p>
<p>该命令在机械领域中可用。 </p>
</li>
<li><p>Electrical</p>
<p>该命令在电力领域中可用。 </p>
</li>
<li><p>Piping</p>
<p>该命令在管道设计领域中可用。</p>
</li>
<li><p>MechanicalAnalysis</p>
<p>该命令在 机械分析领域中可用。 </p>
</li>
<li><p>PipingAnalysis</p>
<p>该命令在管道分析领域中可用。 </p>
</li>
<li><p>ElectricalAnalysis</p>
<p>该命令在 电力分析领域中可用。</p>
</li>
</ul>
<h3 id="LanguageType"><a href="#LanguageType" class="headerlink" title="LanguageType"></a>LanguageType</h3><p>定义 Revit 附加模块的语言类型。</p>
<ul>
<li><p>Unknown</p>
</li>
<li><p>English_USA</p>
</li>
<li><p>German</p>
</li>
<li><p>Spanish</p>
</li>
<li><p>French</p>
</li>
<li><p>Italian</p>
</li>
<li><p>Dutch</p>
</li>
<li><p>Chinese_Simplified</p>
</li>
<li><p>Chinese_Traditional</p>
</li>
<li><p>Japanese</p>
</li>
<li><p>Korean</p>
</li>
<li><p>Russian</p>
</li>
<li><p>Czech</p>
</li>
<li><p>Polish</p>
</li>
<li><p>Hungarian</p>
</li>
<li><p>Brazilian_Portuguese</p>
</li>
<li><p>English_GB</p>
</li>
</ul>
<h3 id="ProductType"><a href="#ProductType" class="headerlink" title="ProductType"></a>ProductType</h3><p>包含可能的 Revit 产品类型的枚举类型。</p>
<ul>
<li><p>Architecture</p>
</li>
<li><p>Structure</p>
</li>
<li><p>MEP</p>
</li>
<li><p>Revit</p>
</li>
<li><p>Unknown</p>
</li>
</ul>
<h3 id="RevitVersion"><a href="#RevitVersion" class="headerlink" title="RevitVersion"></a>RevitVersion</h3><p>定义附加模块实用程序支持的 Revit 版本。 </p>
<ul>
<li><p>Unknown</p>
</li>
<li><p>……</p>
</li>
<li><p>Revit2016</p>
</li>
<li><p>Revit2018</p>
</li>
<li><p>……</p>
</li>
</ul>
<h3 id="VisibilityMode"><a href="#VisibilityMode" class="headerlink" title="VisibilityMode"></a>VisibilityMode</h3><p>描述特定外部命令在 Revit UI 中可见的条件。 </p>
<ul>
<li><p>AlwaysVisible</p>
<p>该命令在 Revit API 支持的所有可能模式下都可用。</p>
</li>
<li><p>NotVisibleInProject</p>
<p>当项目文档处于活动状态时，该命令是不可见的。</p>
</li>
<li><p>NotVisibleInFamily</p>
<p>当有活动的族文档时，该命令是不可见的。</p>
</li>
<li><p>NotVisibleWhenNoActiveDocument</p>
<p>当没有活动文档时，该命令不可见。</p>
</li>
</ul>
<h3 id="WarningType"><a href="#WarningType" class="headerlink" title="WarningType"></a>WarningType</h3><p>发出的与附加模块失败相关的警告类型。</p>
<ul>
<li><p>NoWarning</p>
<p>此插件中没有警告。</p>
</li>
<li><p>ClassNotFound</p>
<p>在程序集文件中找不到指示的类。</p>
</li>
<li><p>WrongAssemblyPath</p>
<p>找不到程序集文件。</p>
</li>
<li><p>UncaughtException</p>
<p>执行 AddIn 时捕获到未经处理的异常。</p>
</li>
<li><p>GUIDConflict</p>
<p>还有另一个注册了相同 ID （GUID） 的加载项。</p>
</li>
<li><p>NoFullClassName</p>
<p>缺少 FullClassName 节点的必需值。</p>
</li>
<li><p>NoClientId</p>
<p>缺少 ClientId 节点的必需值。</p>
</li>
<li><p>NoAssembly</p>
<p>缺少 Assembly 节点的必需值。</p>
</li>
<li><p>NoApplicationName</p>
<p>缺少应用程序加载项的 Name 节点的必需值。</p>
</li>
<li><p>InvalidFormatClientId</p>
<p>无法交互</p>
</li>
<li><p>WrongAvailabilityClass</p>
<p>无法正确调用 IExternalCommandAvailability。</p>
</li>
<li><p>UncaughtExceptionInAvailabilityClass</p>
<p>在执行可用性命令时捕获到未经处理的异常。</p>
</li>
<li><p>InvalidTransactionAttributeError</p>
<p>不是有效的事务属性。</p>
</li>
<li><p>InvalidRegenerationAttributeError</p>
<p>不是有效的重新生成属性。 </p>
</li>
<li><p>NoVendorId</p>
<p>缺少 VendorId 节点的必需值。</p>
</li>
</ul>
<h2 id="注：翻译自RevitAddInUtility-2018"><a href="#注：翻译自RevitAddInUtility-2018" class="headerlink" title="注：翻译自RevitAddInUtility 2018"></a><em><strong>注：</strong></em>翻译自RevitAddInUtility 2018</h2>]]></content>
      <categories>
        <category>RevitApi</category>
      </categories>
      <tags>
        <tag>Revit</tag>
      </tags>
  </entry>
  <entry>
    <title>01开始</title>
    <url>/2024/11/23/Revit%E4%BA%8C%E5%BC%80%E6%8C%87%E5%8D%97/01%E5%BC%80%E5%A7%8B/</url>
    <content><![CDATA[<h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a><a href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_Introduction_Getting_Started_html">开始</a></h1><p>Revit 平台 API 可通过与 Microsoft .NET Framework 4.5.2 或 4.6 兼容的任何语言（如 Visual C# 或 Visual Basic .NET （VB.NET））进行完全访问。Visual C# 和 VB.NET 通常用于开发 Revit 平台 API 应用程序。但是，本手册的重点是使用 Visual C# 开发应用程序。</p>
<h2 id="欢迎使用-Revit-Platform-API"><a href="#欢迎使用-Revit-Platform-API" class="headerlink" title="欢迎使用 Revit Platform API"></a>欢迎使用 Revit Platform API</h2><p>所有基于 Autodesk Revit 的产品都是参数化建筑信息模型 （BIM） 工具。这样的工具可以看作是用于构建 3D 模型的 CAD 程序，而不是一组单独的图纸文件。Autodesk Revit 建模是通过柱、墙、门和窗等真实世界的元素完成的。用户可以创建模型的视图，包括平面图、剖面图和详图索引。所有这些视图都是直接从 3D 物理模型生成的，因此在一个视图中所做的更改将自动传播到所有其他视图。此过程几乎消除了在模型中进行更改时更新多个图纸和细节的需要。</p>
<p>Autodesk Revit API 旨在反映与程序的图形用户界面相同的用户交互范例。因此，了解 API 的第一步是学习如何使用该程序。如果您是 Autodesk Revit 新手，我们建议您首先阅读教程，您可以通过程序的“帮助”菜单访问这些教程。您可能还会发现，参加当地 Autodesk 经销商提供的培训课程会很有帮助。这将帮助您快速掌握该程序</p>
<h3 id="Revit-平台-API-简介"><a href="#Revit-平台-API-简介" class="headerlink" title="Revit 平台 API 简介"></a>Revit 平台 API 简介</h3><p>Revit .NET API 允许您使用任何符合 .NET 的语言（包括 Visual Basic.NET、C# 和 C++&#x2F;CLI）进行编程。Autodesk Revit 提供了一个 API，旨在允许高级用户和外部应用程序开发人员将其应用程序与 Autodesk Revit 集成。强烈建议您在尝试使用 Autodesk Revit API 之前熟悉 Autodesk Revit 及其功能。可以通过 Autodesk Developer Network （ADN） 找到培训。</p>
<p>学习 Revit 可以帮助您：</p>
<ul>
<li>与 Revit UI 和命令保持一致。无缝设计您的插件应用程序。</li>
<li>高效且有效地掌握 API 类和类成员。</li>
<li>如果您不熟悉 Revit 或 BIM，请在 <a href="http://www.autodesk.com/revit">www.autodesk.com/revit</a> 的 Revit 产品中心了解更多信息。</li>
</ul>
<h3 id="您可以使用-Revit-Platform-API-做什么？"><a href="#您可以使用-Revit-Platform-API-做什么？" class="headerlink" title="您可以使用 Revit Platform API 做什么？"></a>您可以使用 Revit Platform API 做什么？</h3><p>以下是 API 适用的一般区域：</p>
<ul>
<li>在 Autodesk Revit 用户界面中创建附加模块和宏以自动执行重复性任务。</li>
<li>通过自动检查错误来执行项目设计标准。</li>
<li>提取项目数据进行分析并生成报告。</li>
<li>导入外部数据以创建新元素或参数值。</li>
<li>将其他应用程序（包括分析应用程序）集成到 Autodesk Revit 产品中。</li>
<li>自动创建 Autodesk Revit 项目文档。</li>
</ul>
<h3 id="开始需要什么"><a href="#开始需要什么" class="headerlink" title="开始需要什么"></a>开始需要什么</h3><ul>
<li><p>对 Autodesk Revit 有深入的了解。</p>
</li>
<li><p>基于 Autodesk Revit 的产品的安装，包括软件开发工具包。</p>
</li>
<li><p>MS Visual Studio 2015 Express Edition（C# 或 VB.NET）。但是，建议使用 Microsoft Visual Studio 2015 Professional，因为 Express 版本不支持 DLL 调试。或者，您也可以使用 Revit 中内置的 SharpDevelop 开发环境。</p>
</li>
<li><p>具有一定的基于 .NET 的开发语言经验。（Autodesk Revit API 示例以 C# 和 Visual Basic.NET 提供。</p>
</li>
</ul>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>Autodesk Revit API 随基于 Autodesk Revit 的产品的默认安装一起自动安装。任何基于 .NET 的应用程序都将引用位于 Revit Program 目录中的 RevitAPI.dll 和 RevitAPIUI.dll。该RevitAPI.dll包含用于在数据库级别访问 Revit 的应用程序、文档、图元和参数的方法。RevitAPIUI.dll包含与 Revit 用户界面的操作和自定义相关的界面。</p>
<p>请注意，RevitAPIIFC.dll、RevitAPIMacros.dll 和 RevitAPIUIMacros.dll 中存在其他 API 功能，这些功能也随 Revit 一起安装，但这些部件并非立即需要开始使用。</p>
<p>Autodesk Revit API 软件开发工具包 （SDK） 从 Autodesk Revit 安装的“工具和实用程序”部分安装。</p>
<h3 id="开发要求"><a href="#开发要求" class="headerlink" title="开发要求"></a>开发要求</h3><p>Autodesk Revit API 需要 Microsoft .NET Framework 4.5.2 或 4.6。Revit 的二进制文件是使用 .NET 4.5.2 构建的。但是，Revit 使用 .NET 4.6 中的运行时。</p>
<p>要编辑和调试 API 应用程序，您需要一个交互式开发环境，例如 Microsoft Visual Studio 2015 Professional 或适用于 C# 或 Visual Basic.NET 的 MS Visual Studio Express Editions 之一。（建议使用 Visual Studio Professional，因为 Express 版本不支持 DLL 调试。使用 Autodesk Revit API 进行开发时，请确保您的项目引用 Autodesk Revit Program 目录中包含的两个 DLL：RevitAPI.dll 和 RevitAPIUI.dll。</p>
<p>需要一些编程技能才能有效地使用 API。如果您是编程初学者，我们强烈建议您学习 Visual Studio 2015 Microsoft 以及 C# 或 Visual Basic.NET 等兼容语言之一。有很多好书和课程可以帮助你入门。</p>
<h3 id="用户使用手册"><a href="#用户使用手册" class="headerlink" title="用户使用手册"></a>用户使用手册</h3><p>本文档是 Revit SDK 的一部分。它介绍了如何使用 Revit Platform API 实现 Revit 附加模块应用程序。</p>
<p>在创建 Revit Platform API 附加模块应用程序之前，请通读手册并尝试示例代码。如果您已经对 Revit Platform API 有一定的经验，您可能只想查看“注释”和“疑难解答”部分。</p>
<ul>
<li><p>Revit Platform API 简介</p>
<p>前两章介绍了 Revit Platform API，并概述了用户手册。<br>欢迎使用 Revit 平台 API - 在创建第一个附加模块之前，介绍 Revit 平台 API 的简介和必要的必备知识。<br>入门 - 使用 Visual Studio 2010 创建第一个 Hello World 加载项应用程序的分步说明，以及涵盖主要加载项功能的其他四个演练。</p>
</li>
<li><p>基础主题</p>
<p>这些章节介绍了 Revit Platform API 的基本机制和功能。<br>附加模块集成 - 讨论如何将附加模块集成到 Revit UI 中，并由用户命令或特定 Revit 事件（如程序启动）调用。<br>应用程序和文档 - 应用程序和文档类分别表示 Revit 平台 API 中的 Revit 应用程序和项目文件。本章介绍基本概念以及相关章节的链接。<br>元素要点 - Revit 项目中的大部分数据位于元素集合中。本章讨论基本的 Element 机制、分类和功能。<br>筛选 - 筛选用于从文档中获取一组元素。<br>选择 - 使用文档中的选定元素集。<br>参数- 大多数元素信息都存储为参数。本章讨论参数功能。<br>集合- 实用程序集合类型，如 Array、Map、Set 集合和相关的迭代器。</p>
</li>
<li><p>元素主题</p>
<p>元素是根据元素分类引入的。在阅读各个元素之前，请确保先阅读元素要点和参数章节。<br>编辑元素 - 了解如何移动、旋转、删除、镜像、分组和阵列元素。<br>墙、地板、天花板、屋顶和洞口 - 讨论元素、它们对应的 ElementType（表示内置位置构造）以及 API 中不同类型的洞口。<br>族实例 - 了解族和族实例、族和族实例特征之间的关系，以及如何加载或创建它们。<br>族创建 - 了解如何创建和修改 Revit 族文档。<br>概念设计 - 讨论如何在 Revit 概念体量文档中创建复杂的几何图形和形状。<br>基准和信息元素 - 了解如何设置网格、添加标高、使用设计选项等。<br>注释元素 - 讨论文档注释，包括添加尺寸、详图曲线、标记和注释符号。<br>草图绘制 - 草图函数包括 2D 和 3D 草图类，例如 SketchPlane、ModelCurve、GenericForm 等。<br>视图 - 了解查看模型和组件的不同方式，以及如何在 API 中操作视图。<br>材质 - 材质数据是一个元素，用于标识项目中使用的物理材质以及纹理、颜色等。</p>
</li>
<li><p>高级主题</p>
<p>几何图形 - 讨论 API 中用于描述模型的图形表示的图形相关类型，包括描述和存储几何图形信息的三个类。<br>地点和位置 - 定义项目位置，包括城市、国家&#x2F;地区、纬度和经度。<br>共享参数 - 共享参数是包含参数规范的外部文本文件。本章介绍如何通过 Revit Platform API 访问共享参数。<br>事务 - 介绍 Transaction 的两种用途以及使用 Transaction 时必须考虑的限制。<br>事件 - 讨论如何利用 Revit 事件。<br>动态模型更新 - 了解如何使用更新程序修改模型以响应文档中的更改。<br>失败提交和处理 - 了解如何提交失败并与 Revit 的失败处理机制进行交互。<br>分析可视化 - 如何在 Revit 项目中显示分析结果。</p>
</li>
<li><p>特定学科</p>
<p>Revit 包括用于建筑、结构工程和 MEP 工程的特定于领域的功能。某些 API 仅适用于特定功能集。<br>建筑设计- 讨论特定于 Revit 的建筑功能的 API。<br>结构工程 - 讨论特定于 Revit 的结构工程功能的 API。<br>MEP工程 - 讨论特定于 Revit 的机械、电气和卫浴功能的 API。</p>
</li>
<li><p>其他</p>
<p>词汇表 - 本文档中使用的术语定义。<br>附录 - 其他信息，如常见问题、使用 Visual Basic.Net 进行编程等。</p>
</li>
</ul>
<h3 id="文档约定"><a href="#文档约定" class="headerlink" title="文档约定"></a>文档约定</h3><p>本文档包含命名空间格式的类名，例如 Autodesk.Revit.DB.Element。在 C++&#x2F;CLI 中，Autodesk.Revit.Element 是 Autodesk::Revit::DB::Element。由于本手册中仅使用 C# 作为示例代码，因此默认命名空间为 Autodesk.Revit.DB。如果要在 Visual Basic 中查看代码，可以在 SDK 示例目录中找到几个 VB.NET 应用程序。</p>
<ul>
<li>索引属性</li>
</ul>
<p>  某些 Revit Platform API 类特性已“编入索引”，或在 API 帮助文件 （RevitAPI.chm） 中描述为过载。例如，Element.Geometry 属性。在本文档的文本中，这些属性称为属性，尽管您可以通过在属性名称前面加上“get_”或“set_”来访问它们，就好像它们是 C# 代码中的方法一样。例如，若要使用 Element.Geometry（Options） 属性，请使用 Element.get_Geometry（Options）。</p>
<h3 id="此版本中的新增功能"><a href="#此版本中的新增功能" class="headerlink" title="此版本中的新增功能"></a>此版本中的新增功能</h3><p>有关更改和新功能的信息，请参见 RevitAPI.chm（包含在 Revit API SDK 中）中的“新特性”部分。</p>
<h2 id="使用-Autodesk-Revit-API"><a href="#使用-Autodesk-Revit-API" class="headerlink" title="使用 Autodesk Revit API"></a>使用 Autodesk Revit API</h2><p>Autodesk Revit API 软件开发工具包 （SDK） 从 Autodesk Revit 安装的“工具和实用程序”部分安装。在 SDK 中，有一些示例文件可帮助您更好地了解 API 及其用法。每个示例文件都有一个示例 .addin 清单文件，其中包含您需要编辑并放入相应文件夹的信息，Autodesk Revit 将在启动时访问该文件夹。</p>
<p>RevitAPI.chm 是 Autodesk Revit API 参考文档帮助 chm 文件，包含在 SDK 包的 \Revit 2018 SDK\ 文件夹中。</p>
<h3 id="部署选项"><a href="#部署选项" class="headerlink" title="部署选项"></a>部署选项</h3><p>Autodesk Revit API 仅支持进程内 DLL。这意味着您的 API 应用程序将被编译为加载到 Autodesk Revit 进程中的 DLL。<br>Autodesk Revit API 仅支持单线程访问。这意味着您的 API 应用程序必须在主线程中执行所有 Autodesk Revit API 调用（由 Autodesk Revit 进程在各种 API 入口点调用），并且您的 API 应用程序无法维护其他线程中的操作，并期望它们能够随时调用 Autodesk Revit。（有关可能的例外情况，请参阅高级主题 External_Events）。</p>
<p>可以使用 Autodesk Revit API 创建两种类型的 DLL：外部命令和外部应用程序。</p>
<ul>
<li><p>外部命令</p>
<p>Autodesk Revit API 允许您向 Autodesk Revit 的用户界面添加新命令。这些命令将出现在 ‘External Tools’ 下拉菜单下的 Add-ins 选项卡中，如图 1 所示。通过 API，外部工具命令可以访问 Autodesk Revit 数据库以及当前选定的图元。<br><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/HelloWorldCommand.png"><br>图 1：添加到 Revit 的外部工具</p>
</li>
<li><p>外部应用程序</p>
<p>Autodesk Revit API 还允许您添加外部应用程序。这些应用程序在 Autodesk Revit 启动和关闭期间调用。他们可以在 Add-ins 选项卡中创建新面板，如图 2 所示。他们还可以注册处理程序，以便对 Autodesk Revit 用户界面中发生的事件做出反应。<br><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/HelloWorldRibbonPanel.png"><br>图 2：Revit 中添加了新面板和控件</p>
</li>
<li><p>REX 插件</p>
<p>REX （Revit Extensions） 是一个 API 框架，它允许您在 .NET 中为 Revit 构建应用程序，类似于实现 IExternalCommand 的类。REX 旨在通过内置资源为您提供更高级的开发环境，例如：<br>自动对话框创建和显。<br>用于处理单位和几何图形的库。<br>内置基于命令的架构，使菜单和工具栏开发更加容易。<br>用于访问对 Revit 应用程序对象的引用的标准机制。<br>自动部署和安装插件，便于调试。有关更多详细信息，请参见“\Revit 2018 SDK\REX SDK\”文件夹。</p>
</li>
</ul>
<h3 id="插件注册"><a href="#插件注册" class="headerlink" title="插件注册"></a>插件注册</h3><p>Revit API 提供了通过 .addin 清单文件注册 API 应用程序的功能。<br>当清单文件放置在用户系统上的两个位置之一时，Revit 将自动读取这些文件：</p>
<ul>
<li>C：\ProgramData\Autodesk\Revit\Addins\2018\</li>
<li>C：\Users\AppData\Roaming\Autodesk\Revit\Addins\2018\ 在启动期间，Revit 将读取和处理这些位置中名为 .addin 的所有文件。</li>
</ul>
<p>添加一个 ExternalCommand 的基本文件如下所示：</p>
<p>代码区域：ExternalCommand 的基本清单文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-16&quot; standalone=&quot;no&quot;?&gt;</span><br><span class="line"></span><br><span class="line">c:\MyProgram\MyProgram.dll</span><br><span class="line">76eb700a-2c85-4888-a78d-31429ecae9ed</span><br><span class="line">Revit.Samples.SampleCommand</span><br><span class="line">Sample command</span><br><span class="line">NotVisibleInFamily</span><br><span class="line">NotVisibleInMEP</span><br><span class="line">Revit.Samples.SampleAccessibilityCheck </span><br></pre></td></tr></table></figure>

<p>添加一个 ExternalApplication 的基本文件如下所示：</p>
<p>代码区域：ExternalApplication 的基本清单文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-16&quot; standalone=&quot;no&quot;?&gt;</span><br><span class="line"></span><br><span class="line">My sample application</span><br><span class="line">c:\MyProgram\MyProgram.dll</span><br><span class="line">604B1052-F742-4951-8576-C261D1993107</span><br><span class="line">Revit.Samples.SampleApplication</span><br></pre></td></tr></table></figure>

<p>单个清单文件中可以添加多个 AddIn 元素。</p>
<p>请参阅插件注册以了解有关 .addin 文件的可用 XML 标签的更多信息。</p>
<h3 id="外部命令"><a href="#外部命令" class="headerlink" title="外部命令"></a>外部命令</h3><p>从技术上讲，外部命令是支持 Autodesk.Revit.UI.IExternalCommand 接口的公开 .NET 对象。此外，在相应的目录中必须有一个 .addin 清单文件，每个此类对象都有一个条目，以便 Revit 能够“看到”并使用命令。</p>
<ul>
<li><p>IExternalCommand 接口</p>
<p>接口的声明 （VB.NET） 如下：<br>代码区域：VB.NET IExternalCommand 接口</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Function Execute(ByVal commandData As Autodesk.Revit.UI.ExternalCommandData,</span><br><span class="line">ByRef message As String,</span><br><span class="line">ByVal elements As Autodesk.Revit.DB.ElementSet)</span><br><span class="line">As Result</span><br></pre></td></tr></table></figure>
<ul>
<li><p>Parameters 参数</p>
<p>commandData ：此参数中传递的对象包含对正在执行命令的重要信息。此数据包括 Autodesk Revit Application 对象以及当前活动的视图。<br>message ：可以设置消息字符串，以便在命令终止时向用户提供特定消息。此消息的显示方式取决于函数的返回值。有关更多详细信息，请参阅备注部分。<br>elemtnts：最初，这是一个可以包含 Autodesk Revit 元素的空集。当命令终止时，可能会根据返回值显示此集中的元素。有关更多详细信息，请参阅备注部分。</p>
</li>
<li><p>Return value 返回值</p>
<p>result：返回值可以是以下值之一：<br>Success ：如果命令按预期成功且没有任何未处理的错误情况，则返回。外部命令将在 Autodesk Revit 用户界面中显示为可撤消的操作。<br>Cancelled ：此值指定用户请求取消命令。在执行外部命令期间对 Autodesk Revit 对象所做的任何更改都将被撤消。可能会发布一条消息，请参阅 备注 部分。<br>Failure ：失败表示外部命令以某种方式失败，无法恢复。在执行外部命令期间对 Autodesk Revit 对象所做的任何更改都将被撤消。将发布一条消息，请参阅 备注 部分。</p>
</li>
<li><p>Remarks 备注</p>
<p>如果命令被取消或失败，则使用 message 和 elements 参数。<br>Cancelled:外部命令已取消，并且消息参数由外部命令设置，则在将执行返回给 Autodesk Revit 时，将显示该消息。如果未设置 message 参数，则不会显示任何消息，并且命令将静默退出。<br>Failed: 如果外部命令失败，则将显示 message 参数的内容。如果元素集包含 Autodesk Revit 元素，则在显示错误消息时，这些元素将高亮显示，从而使开发人员能够向用户显示有问题的元素。</p>
</li>
</ul>
</li>
<li><p>使用 Autodesk Revit API 外部命令</p>
<p>用户在 Autodesk Revit 中打开&#x2F;创建项目<br>用户从 Add-ins 选项卡上的 External Tools 下拉菜单中选择外部命令。<br>用户可以选择在调用外部工具程序之前选择多个 Autodesk Revit 图元。如果这样做，程序可以决定仅对所选成员执行其功能。<br>API 程序从 Autodesk Revit 获取焦点并执行所需的任务。通常，在应用程序完成其工作之前，可能需要一个对话框来获取用户输入。<br>一旦插件工具完成其功能或被用户关闭，程序将根据需要更新 Autodesk Revit 模型并从外部命令返回，从而将焦点重新放在 Autodesk Revit 上。</p>
</li>
<li><p>外部命令对象生存期</p>
<p>当 Autodesk Revit 中没有其他命令或编辑模式处于活动状态时，已注册的外部命令将变为启用状态。选取后，将创建 command 对象并调用 Execute 方法。此方法返回 Autodesk Revit 后，命令对象将被销毁。由于这种销毁，数据无法在命令执行之间保留在对象中。如果您希望数据持久保存，您可以使用外部文件或数据库来实现。如果您希望数据保留在 Autodesk Revit 项目中，您可以使用共享参数机制来存储此数据。</p>
</li>
</ul>
<h3 id="外部应用程序"><a href="#外部应用程序" class="headerlink" title="外部应用程序"></a>外部应用程序</h3><p>从技术上讲，外部应用程序是支持 Autodesk.Revit.IExternalApplication 接口的公开 .NET 对象。此外，在相应的目录中必须有一个 .addin 清单文件，每个此类对象都有一个条目，以便 Autodesk Revit 能够在 Autodesk Revit 启动时加载这些应用程序。</p>
<ul>
<li><p>IExternalApplication 接口</p>
<p>接口的声明 （C#） 如下所示：<br>代码区域：IExternalApplication 接口</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Autodesk.Revit.UI.IExternalApplication.Result OnShutdown(Autodesk.Revit.UIControlledApplication application)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>Parameters 参数</p>
<p>application：在此参数中传递的对象包含对正在调用的命令 OnStartup 和 OnShutdown 非常重要的信息。此对象提供 Autodesk Revit Application 的有限访问方法，如 VersionName、VersionNumber;以及某些事件的委托，例如 OnDocumentOpened、OnDocumentSaved</p>
</li>
<li><p>Return Value 返回值</p>
<p>result：返回值可以是以下值之一：<br>Success：如果外部应用程序按预期成功且没有任何未处理的错误情况，则返回此结果。<br>Failure: ：失败表示外部应用程序以某种方式失败，无法从中恢复。<br>Cancelled：此值指定取消外部应用程序。</p>
</li>
</ul>
</li>
<li><p>外部应用程序对象生存期</p>
<p>当 Autodesk Revit 启动时，将创建外部应用程序对象并调用 OnStartup 方法。此方法成功返回到 Autodesk Revit 后，外部应用程序对象将在整个 Autodesk Revit 会话期间保留。当 Autodesk Revit 关闭时，将调用 OnShutdown 方法。</p>
</li>
</ul>
<h3 id="在-Microsoft-Visual-Studio-中调试应用程序"><a href="#在-Microsoft-Visual-Studio-中调试应用程序" class="headerlink" title="在 Microsoft Visual Studio 中调试应用程序"></a>在 Microsoft Visual Studio 中调试应用程序</h3><p>以下说明适用于 Visual Studio Professional。相关选项在 Visual Studio Express 版本中不可用。<br>调试独立应用程序 （EXE） 与需要其他程序来启动它的外部应用程序 （DLL） 之间存在一些差异。要调试使用 Autodesk Revit API 的应用程序，需要由 Autodesk Revit 激活该应用程序。要在开发人员环境中进行调试时执行此操作，您需要：</p>
<ul>
<li>打开或新建一个Revit项目</li>
<li>打开 API 应用程序的 Visual Studio 项目。（例如，Samples 文件夹中的 AnalyticalSupportData_Info.csproj）</li>
<li>在Visual Studio 的调试中选则附加到进程，选择revit.exe</li>
</ul>
<h3 id="单位系统"><a href="#单位系统" class="headerlink" title="单位系统"></a>单位系统</h3><p>Revit 单位系统使用以下基本单位：</p>
<table>
<thead>
<tr>
<th><strong>基本单位</strong></th>
<th><strong>Revit中的单位</strong></th>
<th><strong>单位制</strong></th>
</tr>
</thead>
<tbody><tr>
<td>长度</td>
<td>Feet (ft) 英尺</td>
<td>Imperial 英制</td>
</tr>
<tr>
<td>角度</td>
<td>Radian 弧度</td>
<td>Metric 公制</td>
</tr>
<tr>
<td>质量</td>
<td>Kilogram (kg)</td>
<td>Metric 公制</td>
</tr>
<tr>
<td>时间</td>
<td>Seconds (s)</td>
<td>Metric 公制</td>
</tr>
<tr>
<td>电流</td>
<td>Ampere (A)</td>
<td>Metric 公制</td>
</tr>
<tr>
<td>温度</td>
<td>Kelvin (K)</td>
<td>Metric 公制</td>
</tr>
<tr>
<td>发光强度</td>
<td>Candela (cd)</td>
<td>Metric 公制</td>
</tr>
</tbody></table>
<h3 id="存储和访问应用程序的自定义数据"><a href="#存储和访问应用程序的自定义数据" class="headerlink" title="存储和访问应用程序的自定义数据"></a>存储和访问应用程序的自定义数据</h3><p>通常，链接到 Autodesk Revit 的程序需要的信息不被Autodesk Revit 模型数据库使用。用户可以通过多种方式输入此类附加信息。信息的输入方式和位置取决于其用途：</p>
<ul>
<li>如果信息是常规类型，并且用户希望在 Autodesk Revit 中查看和编辑它，则应将其存储为可见的项目或共享参数。</li>
<li>如果信息需要在 Autodesk Revit 模型不断发展时保留在 Autodesk Revit 模型中，但不需要可见，则可以将其作为不可见的项目或共享参数或使用可扩展存储存储在 Autodesk Revit 模型中。</li>
<li>如果信息特定于单个附加程序，并且太大而无法实际存储在 Autodesk Revit 模型中，例如可能会更改的大量建筑产品的规格，则最佳解决方案可能是创建一个并发模型数据库来存储程序特定信息。在这种情况下，使用每个元素的元素 UniqueId 属性作为数据库的键可能很有用，因为元素的 UniqueId 在模型中是稳定的。</li>
</ul>
<h2 id="演练"><a href="#演练" class="headerlink" title="演练"></a>演练</h2><p>如果您不熟悉 Revit Platform API，则以下主题是帮助您了解该产品的良好起点。演练提供了常见方案的分步说明，可帮助您了解产品或特定功能。以下演练将帮助您开始使用 Revit Platform API：</p>
<ul>
<li>演练：Hello World - 演示如何使用 Revit 平台 API 创建附加模块。</li>
<li>演练：添加 Hello World 功能区面板 - 演示如何添加自定义功能区面板。</li>
<li>演练：检索选定元素 - 演示如何检索选定元素。</li>
<li>演练：检索筛选的元素 -演示如何根据筛选条件检索元素。</li>
</ul>
<h2 id="演练：Hello-World"><a href="#演练：Hello-World" class="headerlink" title="演练：Hello World"></a><a href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_Introduction_Getting_Started_Walkthrough_Hello_World_html">演练：Hello World</a></h2><p>使用 Revit 平台 API 和 C# 按照提供的说明创建 Hello World 程序。有关如何使用 VB.NET 创建加载项应用程序的信息，请参阅 Hello World for VB.NET 。</p>
<p>Hello World 演练涵盖以下主题：</p>
<ul>
<li>Create a new project. 创建新项目。</li>
<li>Add references. 添加引用。</li>
<li>Change the class name. 更改类名。</li>
<li>Write the code 编写代码</li>
<li>Debug the add-in. 调试插件。</li>
</ul>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/HelloWorldCommand.png"></p>
<h2 id="演练：添加-Hello-World-功能区面板"><a href="#演练：添加-Hello-World-功能区面板" class="headerlink" title="演练：添加 Hello World 功能区面板"></a><a href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_Introduction_Getting_Started_Walkthrough_Add_Hello_World_Ribbon_Panel_html">演练：添加 Hello World 功能区面板</a></h2><p>在“演练：Hello World”部分中，您将了解如何创建附加模块应用程序并在 Revit 中调用它。您还将学习如何创建 .addin 清单文件，以将 Add-in 应用程序注册为外部工具。在 Revit 中调用附加模块应用程序的另一种方法是通过自定义功能区面板。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-8EBB8680-BCD5-4983-829F-55288BBC16B6-low.png"></p>
<h2 id="演练：检索选定元素"><a href="#演练：检索选定元素" class="headerlink" title="演练：检索选定元素"></a><a href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_Introduction_Getting_Started_Walkthrough_Retrieve_Selected_Elements_html">演练：检索选定元素</a></h2><p>本节将向您介绍一个附加模块应用程序，该应用程序可从 Revit 中获取选定的图元。<br>获取所选元素后，您可以获取元素的属性或参数。更多信息，请参见参数。</p>
<h2 id="演练：检索筛选的元素"><a href="#演练：检索筛选的元素" class="headerlink" title="演练：检索筛选的元素"></a><a href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_Introduction_Getting_Started_Walkthrough_Retrieve_Filtered_Elements_html">演练：检索筛选的元素</a></h2><p>您可以使用过滤器仅选择满足特定条件的元素。有关创建和使用元素过滤器的更多信息，请参阅元素检索。<br>此示例检索文档中的所有门，并返回门元素列表。</p>
<h2 id="注：翻译自Revit-API-Developers-Guide"><a href="#注：翻译自Revit-API-Developers-Guide" class="headerlink" title="注：翻译自Revit API Developers Guide"></a><em><strong>注：</strong></em>翻译自<a href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_html">Revit API Developers Guide</a></h2>]]></content>
      <categories>
        <category>Revit二次开发人员指南</category>
      </categories>
      <tags>
        <tag>Revit</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo+Butterfly代码块水平滚动条</title>
    <url>/2025/01/08/%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE/Hexo+Butterfly%E4%BB%A3%E7%A0%81%E5%9D%97%E6%B0%B4%E5%B9%B3%E6%BB%9A%E5%8A%A8%E6%9D%A1/</url>
    <content><![CDATA[<h1 id="Hexo-Butterfly代码块水平滚动条"><a href="#Hexo-Butterfly代码块水平滚动条" class="headerlink" title="Hexo+Butterfly代码块水平滚动条"></a>Hexo+Butterfly代码块水平滚动条</h1><p>虽然Butterfly主题有滚动条，但是极其不明显。文档里也没找到配置方式，索性自己整一个。</p>
<iframe src="/iframe/%E4%BF%AE%E6%94%B9%E5%89%8D.gif" width="700" height="650" frameborder="0" loading="lazy" allowfullscreen></iframe>

<p>blog\themes\butterfly\source下新建一个scrollbar.css文件，写入以下内容。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 滚动条 */</span></span><br><span class="line">::-webkit-scrollbar-thumb &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#ebdccf</span> <span class="meta">!important</span>;  </span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">3em</span>;</span><br><span class="line">&#125;</span><br><span class="line">::-webkit-scrollbar-track &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#292d3e</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">3em</span>;</span><br><span class="line">&#125;</span><br><span class="line">::-webkit-scrollbar &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">5px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">8px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在_config.butterfly.yml找到</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">inject:</span><br><span class="line">   head:       </span><br><span class="line">      # - &lt;link rel=<span class="string">&quot;stylesheet&quot;</span> href=<span class="string">&quot;/xxx.css&quot;</span>&gt;</span><br><span class="line">   bottom:</span><br><span class="line">     # - &lt;script src=<span class="string">&quot;xxxx&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>在head处加上这个</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">- &lt;link rel=&quot;stylesheet&quot; href=&quot;/css/scrollbar<span class="selector-class">.css</span>&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>效果：</p>
<iframe src="/iframe/%E4%BF%AE%E6%94%B9%E5%90%8E.gif" width="700" height="650" frameborder="0" loading="lazy" allowfullscreen></iframe>

]]></content>
      <categories>
        <category>样式设置</category>
      </categories>
      <tags>
        <tag>博客配置</tag>
      </tags>
  </entry>
  <entry>
    <title>02插件集成</title>
    <url>/2024/11/23/Revit%E4%BA%8C%E5%BC%80%E6%8C%87%E5%8D%97/02%E6%8F%92%E4%BB%B6%E9%9B%86%E6%88%90/</url>
    <content><![CDATA[<h1 id="插件集成"><a href="#插件集成" class="headerlink" title="插件集成"></a><a href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_Introduction_Add_In_Integration_html">插件集成</a></h1><p>开发人员通过创建和实现 External Commands 和 External Applications 来添加功能。Revit 使用 .addin 清单文件标识新命令和应用程序。外部命令显示在 Add-Ins 选项卡上的 External Tools 菜单按钮下。外部应用程序在 Revit 启动时调用，在 Revit 关闭时卸载。</p>
<p>本章重点介绍以下内容：</p>
<ul>
<li>了解如何使用 External Commands 和 External Applications 添加功能。</li>
<li>如何访问 Revit 事件。</li>
<li>如何自定义 Revit UI。</li>
</ul>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Revit 平台 API 基于 Revit 应用程序功能。Revit 平台 API 由两个类库组成，这两个类库仅在 Revit 运行时工作。</p>
<p>RevitAPI.dll包含用于在数据库级别访问 Revit 的应用程序、文档、图元和参数的方法。它还包含 IExternalDBApplication 和相关接口。</p>
<p>RevitAPIUI.dll包含与 Revit 用户界面的操作和自定义相关的所有 API 接口，包括：</p>
<ul>
<li>IExternalCommand 和 External Command 相关接口</li>
<li>IExternalApplication 和相关接口</li>
<li>Selection 选择</li>
<li>RibbonPanel、RibbonItem 和子类</li>
<li>TaskDialogs 任务对话框</li>
</ul>
<p>如下图所示，Revit Architecture、Revit Structure 和 Revit MEP 分别特定于 Architecture、Structure 和 MEP。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-EADE225A-E8F2-4EB8-BB94-00CA8759C1E9-low.png" alt="[]()"></p>
<p>要创建基于 RevitAPI 的插件，必须在插件 DLL 中提供特定的入口点类型。这些入口点类实现接口IExternalCommand、IExternalApplication 或 IExternalDBApplication。通过这种方式，加载项在某些事件上自动运行，或者在 IExternalCommand 和 IExternalApplication 的情况下，从“外部工具”菜单按钮手动运行。</p>
<p>本章介绍了 IExternalCommand、IExternalApplication、IExternalDBApplication 和其他可用于附加模块集成的 Revit 事件。</p>
<h2 id="外部命令"><a href="#外部命令" class="headerlink" title="外部命令"></a>外部命令</h2><p>开发人员可以通过实现 External Tools 菜单按钮中显示的 External Commands 来添加功能。</p>
<h3 id="加载和运行外部命令"><a href="#加载和运行外部命令" class="headerlink" title="加载和运行外部命令"></a>加载和运行外部命令</h3><p>当 Revit 中没有其他命令或编辑模式处于活动状态时，将启用已注册的外部命令。选择命令后，将创建一个命令对象并调用其 Execute() 方法。此方法返回到 Revit 后，命令对象将被销毁。因此，在命令执行之间，数据无法保留在对象中。但是，还有其他方法可以在命令执行之间保存数据;例如，可以使用 Revit 共享参数机制将数据存储在 Revit 项目中。</p>
<p>您可以将外部命令添加到“外部工具”菜单按钮下的“外部工具面板”中，或者作为“插件”选项卡、“分析”选项卡或新的自定义功能区选项卡上的自定义功能区面板。有关这两种方法的示例，请参阅演练：Hello World 和演练：添加 Hello World 功能区面板。<br>外部工具、功能区选项卡和功能区面板在启动时进行初始化。初始化步骤如下：</p>
<ul>
<li>Revit 读取清单文件并识别：</li>
<li>可调用的外部应用程序。</li>
<li>可添加到 Revit 外部工具菜单按钮的外部工具。</li>
<li>外部应用程序会话将面板和内容添加到“加载项”选项卡中。</li>
</ul>
<h3 id="IExternalCommand"><a href="#IExternalCommand" class="headerlink" title="IExternalCommand"></a>IExternalCommand</h3><p>通过创建实现 IExternalCommand 接口的对象，可以创建外部命令。IExternalCommand 接口有一个抽象方法 Execute，它是外部命令的主要方法。</p>
<p>Execute() 方法有三个参数：</p>
<ul>
<li>commandData (ExternalCommandData）</li>
<li>message (String) </li>
<li>elements (ElementSet)</li>
</ul>
<p>ExternalCommandData 对象包含外部命令所需的对 Application 和 View 的引用。所有 Revit 数据都是从外部命令中的此参数直接或间接检索的。</p>
<p>例如，以下语句说明了如何从 commandData 参数检索 Autodesk.Revit.Document：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Document doc = commandData.Application.ActiveUIDocument.Document;</span><br></pre></td></tr></table></figure>

<p>下表说明了 ExternalCommandData </p>
<p>公共属性表 1：ExternalCommandData 公共属性</p>
<table>
<thead>
<tr>
<th><strong>Property 成员</strong></th>
<th><strong>Description 描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Application (Autodesk.Revit.UI.UIApplication)</td>
<td>检索表示当前 UIApplication for external 命令的对象。</td>
</tr>
<tr>
<td>JournalData (IDictionary&lt;String, String&gt;)</td>
<td>可用于将数据读取和写入 Revit 日志文件的数据映射。</td>
</tr>
<tr>
<td>View (Autodesk.Revit.DB.View)</td>
<td>检索表示 View 外部命令处理的对象。</td>
</tr>
</tbody></table>
<p>message (String):错误消息由外部命令使用输出参数 message 返回。string-type 参数在外部命令进程中设置。返回 Autodesk.Revit.UI.Result.Failed 或 Autodesk.Revit.UI.Result.Cancelled 并设置消息参数时，会显示一个错误对话框。<br>以下代码示例说明了如何使用 message 参数。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">IExternalCommand_message</span> : <span class="title">IExternalCommand</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">public</span> Autodesk.Revit.UI.<span class="function">Result <span class="title">Execute</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">                Autodesk.Revit.ExternalCommandData commandData, <span class="keyword">ref</span> <span class="built_in">string</span> message,</span></span></span><br><span class="line"><span class="params"><span class="function">                Autodesk.Revit.ElementSet elements</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">                message = <span class="string">&quot;Could not locate walls for analysis.&quot;</span>;</span><br><span class="line">                <span class="keyword">return</span> Autodesk.Revit.UI.Result.Failed;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实施前面的 external 命令会导致出现以下对话框：</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-6E76ABBE-ED74-437E-B2FC-D92C9955C035-low.png"></p>
<p>elements（ElementSet）：每当返回 Autodesk.Revit.UI.Result.Failed 或 Autodesk.Revit.UI.Result.Canceled 且参数消息不为空时，都会显示错误或警告对话框。此外，如果向 elements 参数添加了任何元素，则这些元素将在屏幕上突出显示。每当命令失败时，无论是否还返回元素，最好设置 message 参数。 以下代码高亮显示预先选择的墙：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">IExternalcommand_elements</span> : <span class="title">IExternalCommand</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Result <span class="title">Execute</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">                Autodesk.Revit.UI.ExternalCommandData commandData, <span class="keyword">ref</span> <span class="built_in">string</span> message,</span></span></span><br><span class="line"><span class="params"><span class="function">                Autodesk.Revit.DB.ElementSet elements</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">                message = <span class="string">&quot;Please note the highlighted Walls.&quot;</span>;</span><br><span class="line">                FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(commandData.Application.ActiveUIDocument.Document);</span><br><span class="line">                ICollection collection = collector.OfClass(<span class="keyword">typeof</span>(Wall)).ToElements();</span><br><span class="line">                <span class="keyword">foreach</span> (Element e <span class="keyword">in</span> collection)</span><br><span class="line">                &#123;</span><br><span class="line">                        elements.Insert(e);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> Result.Failed;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Return 返回:Return 结果表示执行失败、成功或被用户取消。如果不成功，Revit 将撤消外部命令所做的更改。</p>
<p><strong>表 2：IExternalCommand.Result</strong></p>
<table>
<thead>
<tr>
<th><strong>Member Name 成员名称</strong></th>
<th><strong>Description 描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Autodesk.Revit.UI.Result.Succeeded</td>
<td>外部命令已成功完成。Revit 保留由外部命令所做的所有更改。</td>
</tr>
<tr>
<td>Autodesk.Revit.UI.Result.Failed</td>
<td>外部命令未能完成任务。Revit 将撤消由外部命令执行的操作。如果设置了 Execute 的消息参数，Revit 将显示一个对话框，其中包含文本“错误 - 无法忽略”。</td>
</tr>
<tr>
<td>Autodesk.Revit.UI.Result.Cancelled</td>
<td>Revit 将撤消由外部命令所做的更改。如果设置了 Execute 的消息参数，Revit 将显示一个对话框，其中包含文本“警告 - 可以忽略”。</td>
</tr>
</tbody></table>
<p>以下示例显示问候消息，并允许用户选择返回值。使用 Execute() 方法作为 Revit 应用程序的入口。<br>代码区域 3-4：提示用户</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Autodesk.Revit.UI.<span class="function">Result <span class="title">Execute</span>(<span class="params">ExternalCommandData commandData,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">ref</span> <span class="built_in">string</span> message, ElementSet elements</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        Document doc = commandData.Application.ActiveUIDocument.Document;</span><br><span class="line">        UIDocument uidoc = commandData.Application.ActiveUIDocument;</span><br><span class="line">        <span class="comment">// Delete selected elements</span></span><br><span class="line"></span><br><span class="line">        ICollection&lt;Autodesk.Revit.DB.ElementId&gt; ids =</span><br><span class="line">            doc.Delete(uidoc.Selection.GetElementIds());</span><br><span class="line">    </span><br><span class="line">        TaskDialog taskDialog = <span class="keyword">new</span> TaskDialog(<span class="string">&quot;Revit&quot;</span>); </span><br><span class="line">        taskDialog.MainContent = </span><br><span class="line">            (<span class="string">&quot;Click Yes to return Succeeded. Selected members will be deleted.\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;Click No to return Failed.  Selected members will not be deleted.\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;Click Cancel to return Cancelled.  Selected members will not be deleted.&quot;</span>);</span><br><span class="line">        TaskDialogCommonButtons buttons = TaskDialogCommonButtons.Yes | </span><br><span class="line">            TaskDialogCommonButtons.No | TaskDialogCommonButtons.Cancel;</span><br><span class="line">        taskDialog.CommonButtons = buttons;</span><br><span class="line">        TaskDialogResult taskDialogResult = taskDialog.Show();</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> (taskDialogResult == TaskDialogResult.Yes)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> Autodesk.Revit.UI.Result.Succeeded;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (taskDialogResult == TaskDialogResult.No)</span><br><span class="line">        &#123;</span><br><span class="line">            ICollection selectedElementIds = uidoc.Selection.GetElementIds();</span><br><span class="line">            <span class="keyword">foreach</span> (ElementId id <span class="keyword">in</span> selectedElementIds)</span><br><span class="line">            &#123;</span><br><span class="line">                elements.Insert( doc.GetElement(id) );</span><br><span class="line">            &#125;</span><br><span class="line">            message = <span class="string">&quot;Failed to delete selection.&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span> Autodesk.Revit.UI.Result.Failed;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> Autodesk.Revit.UI.Result.Cancelled;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span></span><br><span class="line">    &#123;</span><br><span class="line">        message = <span class="string">&quot;Unexpected Exception thrown.&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> Autodesk.Revit.UI.Result.Failed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>IExternalCommandAvailability</p>
<p>此界面允许您控制是否可以按下外部命令按钮。IsCommandAvailable 接口方法将应用程序和一组与 Revit 中选定项目的类别匹配的类别传递给您的实现。典型用途是检查所选类别，以查看它们是否满足要运行命令的条件。</p>
<p>在此示例中，辅助功能检查允许在没有活动选择或至少选择了一面墙时单击按钮：</p>
<p>代码区域 3-5：设置命令可用性</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SampleAccessibilityCheck</span> : <span class="title">IExternalCommandAvailability</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">IsCommandAvailable</span>(<span class="params">AutodeskAutodesk.Revit.UI.UIApplication applicationData,</span></span></span><br><span class="line"><span class="params"><span class="function">                CategorySet selectedCategories</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">                <span class="comment">// Allow button click if there is no active selection</span></span><br><span class="line">                <span class="keyword">if</span> (selectedCategories.IsEmpty)</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="comment">// Allow button click if there is at least one wall selected</span></span><br><span class="line">                <span class="keyword">foreach</span> (Category c <span class="keyword">in</span> selectedCategories)</span><br><span class="line">                &#123;</span><br><span class="line">                        <span class="keyword">if</span> (c.Id.IntegerValue == (<span class="built_in">int</span>)BuiltInCategory.OST_Walls)</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h2 id="外部应用程序"><a href="#外部应用程序" class="headerlink" title="外部应用程序"></a>外部应用程序</h2><p>开发人员可以通过外部应用程序和外部命令添加功能。功能区选项卡和功能区面板使用外部应用程序进行自定义。功能区面板按钮绑定到外部命令。</p>
<h3 id="IExternalApplication"><a href="#IExternalApplication" class="headerlink" title="IExternalApplication"></a>IExternalApplication</h3><p>若要将外部应用程序添加到 Revit，请创建一个实现 IExternalApplication 接口的对象。IExternalApplication 接口有两个抽象方法，即 OnStartup() 和 OnShutdown()，您可以在外部应用程序中重写它们。Revit 在启动时调用 OnStartup()，在关闭时调用 OnShutdown()。</p>
<p>这是 OnStartup() 和 OnShutdown() 抽象定义：</p>
<p>代码区域 3-6：OnShutdown() 和 OnStartup()</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IExternalApplication</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">public</span> Autodesk.Revit.UI.<span class="function">Result <span class="title">OnStartup</span>(<span class="params">UIControlledApplication application</span>)</span>;</span><br><span class="line">        <span class="keyword">public</span> Autodesk.Revit.UI.<span class="function">Result <span class="title">OnShutdown</span>(<span class="params">UIControlledApplication application</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>UIControlledApplication 参数提供对某些 Revit 事件的访问，并允许自定义功能区面板和控件以及添加功能区选项卡。例如，UIControlledApplication 的公共事件 DialogBoxShowing 可用于捕获正在显示的对话框的事件。以下代码段注册了在显示对话框之前调用的处理函数。</p>
<p>代码区域 3-7：DialogBoxShowing 事件</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">application.DialogBoxShowing += <span class="keyword">new</span> </span><br><span class="line">        EventHandler&lt;Autodesk.Revit.Events.DialogBoxShowingEventArgs&gt;(AppDialogShowing);</span><br></pre></td></tr></table></figure>

<p>下面的代码示例说明了如何使用 UIControlledApplication 类型注册事件处理程序并在事件发生时处理事件。</p>
<p>代码区域 3-8：使用 ControlledApplication</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Application_DialogBoxShowing</span> : <span class="title">IExternalApplication</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">// Implement the OnStartup method to register events when Revit starts.</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Result <span class="title">OnStartup</span>(<span class="params">UIControlledApplication application</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">                <span class="comment">// Register related events</span></span><br><span class="line">                application.DialogBoxShowing += </span><br><span class="line">        <span class="keyword">new</span> EventHandler&lt;Autodesk.Revit.UI.Events.DialogBoxShowingEventArgs&gt;(AppDialogShowing);</span><br><span class="line">                <span class="keyword">return</span> Result.Succeeded;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Implement this method to unregister the subscribed events when Revit exits.</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Result <span class="title">OnShutdown</span>(<span class="params">UIControlledApplication application</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">    </span><br><span class="line">                <span class="comment">// unregister events</span></span><br><span class="line">                application.DialogBoxShowing -= </span><br><span class="line">        <span class="keyword">new</span> EventHandler&lt;Autodesk.Revit.UI.Events.DialogBoxShowingEventArgs&gt;(AppDialogShowing);</span><br><span class="line">                <span class="keyword">return</span> Result.Succeeded;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// The DialogBoxShowing event handler, which allow you to </span></span><br><span class="line">        <span class="comment">// do some work before the dialog shows</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">AppDialogShowing</span>(<span class="params"><span class="built_in">object</span> sender, DialogBoxShowingEventArgs <span class="keyword">args</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Get the help id of the showing dialog</span></span><br><span class="line">            <span class="built_in">string</span> dialogId = <span class="keyword">args</span>.DialogId;</span><br><span class="line">    </span><br><span class="line">            <span class="comment">// return if the dialog has no DialogId (such as with a Task Dialog)</span></span><br><span class="line">            <span class="keyword">if</span> (dialogId == <span class="string">&quot;&quot;</span>)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">            <span class="comment">// Show the prompt message and allow the user to close the dialog directly.</span></span><br><span class="line">            TaskDialog taskDialog = <span class="keyword">new</span> TaskDialog(<span class="string">&quot;Revit&quot;</span>);</span><br><span class="line">            taskDialog.MainContent = <span class="string">&quot;A Revit dialog is about to be opened.\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;The DialogId of this dialog is &quot;</span> + dialogId + <span class="string">&quot;\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;Press &#x27;Cancel&#x27; to immediately dismiss the dialog&quot;</span>;</span><br><span class="line">            taskDialog.CommonButtons = TaskDialogCommonButtons.Ok |</span><br><span class="line">                                         TaskDialogCommonButtons.Cancel;</span><br><span class="line">            TaskDialogResult result = taskDialog.Show();</span><br><span class="line">            <span class="keyword">if</span> (TaskDialogResult.Cancel == result)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// dismiss the Revit dialog </span></span><br><span class="line">                <span class="keyword">args</span>.OverrideResult(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h2 id="插件注册"><a href="#插件注册" class="headerlink" title="插件注册"></a>插件注册</h2><p>需要注册外部命令和外部应用程序才能显示在 Revit 中。可以通过将它们添加到 .addin 清单文件来注册它们。外部命令和应用程序在 Revit 中的列出顺序取决于 Revit 启动时的读入顺序。</p>
<h3 id="清单文件"><a href="#清单文件" class="headerlink" title="清单文件"></a>清单文件</h3><p>Revit API 应用程序通过 .addin 清单文件注册到 Revit。将清单文件放置在用户系统上的两个位置之一时，Revit 会自动读取这些文件：</p>
<ul>
<li>C:\ProgramData\Autodesk\Revit\Addins\Revit 2018\</li>
<li>C:\Users\AppData\Roaming\Autodesk\Revit\Addins\Revit 2018\</li>
</ul>
<p>在启动期间，Revit 将读取和处理这些位置中名为 .addin 的所有文件。用户特定位置和所有用户位置中的所有文件都被视为一起，并按字母顺序加载。如果所有用户清单文件与特定于用户的清单文件同名，则忽略所有用户清单文件。在每个清单文件中，外部命令和外部应用程序将按照它们的列出顺序加载。</p>
<p>添加一个 ExternalCommand 的基本文件如下所示：</p>
<p>代码区域 3-9：清单 .addin ExternalCommand</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span> standalone=<span class="string">&quot;no&quot;</span>?&gt;</span><br><span class="line">&lt;RevitAddIns&gt;</span><br><span class="line">        &lt;AddIn Type=<span class="string">&quot;Command&quot;</span>&gt;</span><br><span class="line">                &lt;Assembly&gt;c:\MyProgram\MyProgram.dll&lt;/Assembly&gt;</span><br><span class="line">                &lt;AddInId&gt;<span class="number">76</span>eb700a<span class="number">-2</span>c85<span class="number">-4888</span>-a78d<span class="number">-31429</span>ecae9ed&lt;/AddInId&gt;</span><br><span class="line">                &lt;FullClassName&gt;Revit.Samples.SampleCommand&lt;/FullClassName&gt;</span><br><span class="line">                &lt;Text&gt;Sample command&lt;/Text&gt;</span><br><span class="line">                &lt;VendorId&gt;ADSK&lt;/VendorId&gt;</span><br><span class="line">                &lt;VendorDescription&gt;Autodesk, www.autodesk.com&lt;/VendorDescription&gt; </span><br><span class="line">                &lt;VisibilityMode&gt;NotVisibleInFamily&lt;/VisibilityMode&gt;</span><br><span class="line">                &lt;Discipline&gt;Structure&lt;/Discipline&gt;</span><br><span class="line">                &lt;Discipline&gt;Architecture&lt;/Discipline&gt;</span><br><span class="line">                &lt;AvailabilityClassName&gt;Revit.Samples.SampleAccessibilityCheck&lt;/AvailabilityClassName&gt;</span><br><span class="line">                &lt;LongDescription&gt;</span><br><span class="line">                        This <span class="keyword">is</span> the <span class="built_in">long</span> description <span class="keyword">for</span> my command.</span><br><span class="line">                        This <span class="keyword">is</span> another descriptive paragraph, <span class="keyword">with</span> notes about how to use the command properly.</span><br><span class="line">                &lt;/LongDescription&gt;</span><br><span class="line">                &lt;TooltipImage&gt;c:\MyProgram\Autodesk.png&lt;/TooltipImage&gt;</span><br><span class="line">                &lt;LargeImage&gt;c:\MyProgram\MyProgramIcon.png&lt;/LargeImage&gt;</span><br><span class="line">        &lt;/AddIn&gt;</span><br><span class="line">&lt;/RevitAddIns&gt;</span><br></pre></td></tr></table></figure>

<p>添加一个 ExternalApplication 的基本文件如下所示：</p>
<p>代码区域 3-10：清单 .addin ExternalApplication</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span> standalone=<span class="string">&quot;no&quot;</span>?&gt;</span><br><span class="line">&lt;RevitAddIns&gt;</span><br><span class="line">&lt;AddIn Type=<span class="string">&quot;Application&quot;</span>&gt;</span><br><span class="line">                &lt;Name&gt;SampleApplication&lt;/Name&gt;</span><br><span class="line">                &lt;Assembly&gt;c:\MyProgram\MyProgram.dll&lt;/Assembly&gt;</span><br><span class="line">                &lt;AddInId&gt;<span class="number">604B</span>1052-F742<span class="number">-4951</span><span class="number">-8576</span>-C261D1993107&lt;/AddInId&gt;</span><br><span class="line">                &lt;FullClassName&gt;Revit.Samples.SampleApplication&lt;/FullClassName&gt;</span><br><span class="line">                &lt;VendorId&gt;ADSK&lt;/VendorId&gt;</span><br><span class="line">                &lt;VendorDescription&gt;Autodesk, www.autodesk.com&lt;/VendorDescription&gt;</span><br><span class="line">&lt;/AddIn&gt;</span><br><span class="line">&lt;/RevitAddIns&gt;</span><br></pre></td></tr></table></figure>

<p>添加一个 DB 级 External Application 的基本文件如下所示：</p>
<p>代码区域：manifest .addin ExternalDBApplication</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span> standalone=<span class="string">&quot;no&quot;</span>?&gt;</span><br><span class="line">&lt;RevitAddIns&gt;</span><br><span class="line">&lt;AddIn Type=<span class="string">&quot;DBApplication&quot;</span>&gt;</span><br><span class="line">                &lt;Assembly&gt;c:\MyDBLevelApplication\MyDBLevelApplication.dll&lt;/Assembly&gt;</span><br><span class="line">                &lt;AddInId&gt;DA3D570A<span class="number">-1</span>AB3<span class="number">-4</span>a4b-B09F<span class="number">-8</span>C15DFEC6BF0&lt;/AddInId&gt;</span><br><span class="line"></span><br><span class="line">                &lt;FullClassName&gt;MyCompany.MyDBLevelAddIn&lt;/FullClassName&gt;</span><br><span class="line">    </span><br><span class="line">                &lt;Name&gt;My DB-Level AddIn&lt;/Name&gt;                    </span><br><span class="line">                &lt;VendorId&gt;ADSK&lt;/VendorId&gt;</span><br><span class="line">                &lt;VendorDescription&gt;Autodesk, www.autodesk.com&lt;/VendorDescription&gt;</span><br><span class="line"></span><br><span class="line">&lt;/AddIn&gt;</span><br><span class="line">&lt;/RevitAddIns&gt;</span><br></pre></td></tr></table></figure>

<p>单个清单文件中可以提供多个 AddIn 元素。</p>
<p>下表描述了可用的 XML 标记：</p>
<table>
<thead>
<tr>
<th><strong>Tag 标记</strong></th>
<th><strong>Description 描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Assembly 程序集</td>
<td>附加模块程序集文件的完整路径。所有 ExternalCommands 和 ExternalApplications 都需要。</td>
</tr>
<tr>
<td>FullClassName 类的全名</td>
<td>程序集文件中实现 IExternalCommand 或 IExternalApplication 的类的全名。所有 ExternalCommands 和 ExternalApplications 都需要。</td>
</tr>
<tr>
<td>AddInId</td>
<td>一个 GUID，表示此特定应用程序的 ID。AddInIds 对于 Revit 的给定会话必须是唯一的。Autodesk 建议您为每个已注册的应用程序或命令生成唯一的 GUID。所有 ExternalCommands 和 ExternalApplications 都需要。</td>
</tr>
<tr>
<td>Name 名字</td>
<td>应用程序的名称。必填;仅适用于 ExternalApplications。</td>
</tr>
<tr>
<td>Text</td>
<td>按钮的名称。自选;仅将此标记用于 ExternalCommands。默认值为 “External Tool”。</td>
</tr>
<tr>
<td>VendorId 供应商 ID</td>
<td>Revit 中的某些操作（例如，可扩展存储的标识）可能使用的唯一供应商标识符。这必须是唯一的，因此我们建议使用域名的反向版本，例如 com.autodesk 或 uk.co.autodesk。</td>
</tr>
<tr>
<td>VendorDescription 供应商描述</td>
<td>包含供应商的法定名称和&#x2F;或其他相关信息的描述。自选。</td>
</tr>
<tr>
<td>Description 描述</td>
<td>命令的简短描述将用作按钮工具提示。自选;仅将此标记用于 ExternalCommands。默认值为仅包含命令文本的工具提示。</td>
</tr>
<tr>
<td>VisibilityMode 可见性模式</td>
<td>外部命令可见的模式。可以为此选项设置多个值。自选;仅将此标记用于 ExternalCommands。默认情况下，在所有模式下显示命令，包括当没有活动文档时。以前编写的需要针对活动文档运行的外部命令应进行修改，以确保代码在没有活动文档时处理命令的调用，或者应用 NotVisibleWhenNoActiveDocument 模式。有关更多信息，请参阅下表。</td>
</tr>
<tr>
<td>Discipline 学科</td>
<td>外部命令将在其中可见的学科。可以为此选项设置多个值。自选;仅将此标记用于 ExternalCommands。默认情况下，在所有领域中显示该命令。如果列出了任何特定领域，则该命令将仅在这些领域中可见。有关更多信息，请参阅下表。</td>
</tr>
<tr>
<td>AvailabilityClassName 可用性类名称</td>
<td>程序集文件中实现 IExternalCommandAvailability 的类的全名。此类允许根据上下文有选择地将命令按钮灰显。自选;仅将此标记用于 ExternalCommands。默认命令是只要可见就可用的命令。</td>
</tr>
<tr>
<td>LargeImage 大图像</td>
<td>用于 External Tools 下拉菜单中的按钮的图标。自选;仅将此标记用于 ExternalCommands。默认情况下，显示不带图标的按钮。</td>
</tr>
<tr>
<td>SmallImage 小图像</td>
<td>按钮提升到快速访问工具栏时使用的图标。自选;仅将此标记用于 ExternalCommands。默认情况下，显示不带图标的快速访问工具栏按钮，这可能会使用户感到困惑。</td>
</tr>
<tr>
<td>LongDescription 长描述</td>
<td>命令的详细说明将用作按钮扩展工具提示的一部分，当鼠标悬停在命令上较长时间时显示。自选;仅将此标记用于 ExternalCommands。如果未提供此属性和 TooltipImage，则按钮将没有扩展的工具提示。</td>
</tr>
<tr>
<td>TooltipImage Tooltip图像</td>
<td>作为按钮扩展工具提示的一部分显示的图像文件，当鼠标悬停在命令上较长时间时显示。自选;仅将此标记用于 ExternalCommands。如果未提供此属性和 TooltipImage，则按钮将没有扩展的工具提示。</td>
</tr>
<tr>
<td>LanguageType 语言类型</td>
<td>外部工具按钮的 Text、Description、LargeImage、LongDescription 和 TooltipImage 的本地化设置。Revit 将从指定的语言资源 dll 加载资源值。该值可以是 Revit 支持的 11 种语言之一。如果未指定 LanguageType，则将自动加载当前 Revit 会话使用的语言资源。有关更多详细信息，请参阅本地化部分。</td>
</tr>
<tr>
<td>AllowLoadIntoExistingSession</td>
<td>加载权限的标志。设置为 false 可防止 Revit 在不重新启动的情况下自动加载新添加的 .addin 清单文件中的附加模块。自选。默认情况下。Revit 将自动从新添加的 .addin 清单文件加载附加模块，而无需重新启动 Revit。</td>
</tr>
</tbody></table>
<p>VisibilityMode 成员</p>
<table>
<thead>
<tr>
<th><strong>Member Name 成员名称</strong></th>
<th><strong>Description 描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>AlwaysVisible 始终可见</td>
<td>该命令在 Revit API 支持的所有可能模式下都可用。</td>
</tr>
<tr>
<td>NotVisibleInProject 项目中不可见</td>
<td>当项目文档处于活动状态时，该命令是不可见的。</td>
</tr>
<tr>
<td>NotVisibleInFamily 族项目中不可见</td>
<td>当族文档处于活动状态时，该命令不可见。</td>
</tr>
<tr>
<td>NotVisibleWhenNoActiveDocument 无活动视图不可见</td>
<td>当没有活动文档时，该命令是不可见的。</td>
</tr>
</tbody></table>
<p>学科成员</p>
<table>
<thead>
<tr>
<th><strong>Member Name 会员名称</strong></th>
<th><strong>Description 描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Any 任何</td>
<td>该命令在 Revit API 支持的所有可能领域中均可用。</td>
</tr>
<tr>
<td>Architecture 建筑</td>
<td>该命令在 Autodesk Revit Architecture 中可见。</td>
</tr>
<tr>
<td>Structure 结构</td>
<td>该命令在 Autodesk Revit Structure 中可见。</td>
</tr>
<tr>
<td>StructuralAnalysis 结构分析</td>
<td>当 Structural Analysis 领域编辑工具可用时，该命令可见。</td>
</tr>
<tr>
<td>MassingAndSite 体量与现场</td>
<td>当 体量 和 场地 领域 编辑工具可用时，该命令可见。</td>
</tr>
<tr>
<td>EnergyAnalysis 能量分析</td>
<td>当 Energy Analysis 领域编辑工具可用时，该命令可见。</td>
</tr>
<tr>
<td>Mechanical 机械</td>
<td>当 Mechanical 领域编辑工具可用时（例如，在 Autodesk Revit MEP 中），该命令可见。</td>
</tr>
<tr>
<td>Electrical 电气</td>
<td>当 Electrical 领域编辑工具可用时（例如，在 Autodesk Revit MEP 中），该命令可见。</td>
</tr>
<tr>
<td>Piping 管道</td>
<td>当管道领域编辑工具可用时（例如，在 Autodesk Revit MEP 中），该命令可见。</td>
</tr>
<tr>
<td>MechanicalAnalysis 机械分析</td>
<td>当 Mechanical Analysis 领域编辑工具可用时，该命令可见。</td>
</tr>
<tr>
<td>PipingAnalysis 管道分析</td>
<td>当“管道分析”领域编辑工具可用时，该命令可见。</td>
</tr>
<tr>
<td>ElectricalAnalysis 电气分析</td>
<td>当 Electrical Analysis 领域编辑工具可用时，该命令可见。</td>
</tr>
</tbody></table>
<p>用于清单文件的 .NET Add-in Utility</p>
<p>代码区域 3-11：创建和编辑清单文件</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//create a new addin manifest</span></span><br><span class="line">RevitAddInManifest Manifest = <span class="keyword">new</span> RevitAddInManifest();</span><br><span class="line"></span><br><span class="line"><span class="comment">//create an external command</span></span><br><span class="line">RevitAddInCommand command1 = <span class="keyword">new</span> RevitAddInCommand(<span class="string">&quot;full path\assemblyName.dll&quot;</span>, </span><br><span class="line">     Guid.NewGuid(), <span class="string">&quot;namespace.className&quot;</span>);</span><br><span class="line">command1.Description = <span class="string">&quot;description&quot;</span>;</span><br><span class="line">command1.Text = <span class="string">&quot;display text&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// this command only visible in Revit MEP, Structure, and only visible </span></span><br><span class="line"><span class="comment">// in Project document or when no document at all</span></span><br><span class="line">command1.Discipline = Discipline.Mechanical | Discipline.Electrical |</span><br><span class="line">                        Discipline.Piping | Discipline.Structure;</span><br><span class="line">command1.VisibilityMode = VisibilityMode.NotVisibleInFamily;</span><br><span class="line"></span><br><span class="line"><span class="comment">//create an external application</span></span><br><span class="line">RevitAddInApplication application1 = <span class="keyword">new</span> RevitAddInApplication(<span class="string">&quot;appName&quot;</span>,</span><br><span class="line">    <span class="string">&quot;full path\assemblyName.dll&quot;</span>, Guid.NewGuid(), <span class="string">&quot;namespace.className&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//add both command(s) and application(s) into manifest</span></span><br><span class="line">Manifest.AddInCommands.Add(command1);</span><br><span class="line">Manifest.AddInApplications.Add(application1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//save manifest to a file</span></span><br><span class="line">RevitProduct revitProduct1 = RevitProductUtility.GetAllInstalledRevitProducts()[<span class="number">0</span>];</span><br><span class="line">Manifest.SaveAs(revitProduct1.AllUsersAddInFolder + <span class="string">&quot;\RevitAddInUtilitySample.addin&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>代码区域 3-12：读取现有清单文件</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">RevitProduct revitProduct1 = RevitProductUtility.GetAllInstalledRevitProducts()[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">RevitAddInManifest revitAddInManifest = </span><br><span class="line">     Autodesk.RevitAddIns.AddInManifestUtility.GetRevitAddInManifest(</span><br><span class="line">          revitProduct1.AllUsersAddInFolder + <span class="string">&quot;\RevitAddInUtilitySample.addin&quot;</span>);</span><br></pre></td></tr></table></figure>



<h2 id="对-Revit-插件进行数字签名"><a href="#对-Revit-插件进行数字签名" class="headerlink" title="对 Revit 插件进行数字签名"></a>对 Revit 插件进行数字签名</h2><p>Revit 会检查插件的安全凭据。如果插件未使用受信任的证书颁发机构颁发的证书进行数字签名，则 Revit 会在打开时弹出一个对话框，询问用户确认他&#x2F;她是否要加载应用程序。下图显示了检测到未签名的加载项时的安全警告对话框示例。用户可以选择：1） 允许从现在开始始终加载同一插件，2） 仅加载这次并下次再次询问，以及 3） 不允许加载插件。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/UnsignedAddIn.png"></p>
<p>如果您是专业开发人员，并且您的应用程序已由受信任的证书颁发机构进行数字签名，则您的附加模块已与 Revit 中的数字签名检入兼容。以下部分适用于编写附加模块但不熟悉 Revit 中的数字签名的开发人员。</p>
<h3 id="对应用程序进行数字签名"><a href="#对应用程序进行数字签名" class="headerlink" title="对应用程序进行数字签名"></a>对应用程序进行数字签名</h3><p>如果您是 Revit 附加模块的发布者，则必须使用自己的证书对附加模块进行签名。</p>
<p>要使用自己的证书对加载项进行签名，您首先需要从数字证书供应商处购买数字签名。获取证书 （cer） 或个人信息交换 （pfx） 文件后，您可以使用 signtool 对 DLL 进行签名。或者，您也可以使用在线 Authenticode 签名服务，例如 Symantec 的 Secure App Service - <a href="https://www.symantec.com/code-signing/secure-app-service/%E3%80%82">https://www.symantec.com/code-signing/secure-app-service/。</a></p>
<ul>
<li><p>数字证书供应商</p>
<p>以下是提供数字证书的供应商的非详尽列表：<br>Symantec - <a href="http://www.symantec.com/">www.symantec.com</a><br>DigiCert - <a href="http://www.digicert.com/">www.digicert.com</a><br>VERISIGN - <a href="http://www.verisign.com/">www.verisign.com</a><br>Thawte - <a href="http://www.thawte.com/">www.thawte.com</a></p>
</li>
<li><p>使用 “signtool” 进行签名</p>
<p>您可以使用 signtool.exe.ASPX） 工具对 .NET dll 进行签名。该工具会自动随 Visual Studio 一起安装。要运行该工具，请使用 Developer Command Prompt。以下是命令行参数的格式：<br>命令区域：使用 signtool</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">signtool.exe sign /fd SHA256 /f &lt;.pfx-file-name&gt; /p  .dl</span><br></pre></td></tr></table></figure>

<p>其中 &#x2F;fd 是要使用的文件摘要算法的标志。这里我们使用 SHA256。（SHA 代表安全哈希算法。signtool 默认值为 SHA1。我们建议使用 SHA256，这是一个更新、更安全的版本。&lt;.pfx-file-name&gt; 是您从供应商处获取的 .pfx（个人信息交换）文件的名称。是您在获取 PFX 文件时指定的密码。.dll 是要签名的 DLL 的名称。</p>
<p>例如，如果您在任意文件夹中运行命令，则上述命令可能如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;C:\Program Files (x86)\Windows Kits\8.1\bin\x64\signtool&quot; sign /fd SHA256 /f &quot;C:/Dev/MyCert.pfx&quot; /p &quot;password123&quot; “C:/Dev/HelloRevit.dll”</span><br></pre></td></tr></table></figure>

<p>注意：signtool 的确切位置在您的环境中可能有所不同。<br>使用授权证书对 DLL 进行签名后，Revit 在加载附加模块时将不再弹出安全警告对话框。<br>您还可以在 Visual Studio 的 Post-Built Event 部分包含该命令，以用于应用程序项目属性。<br>命令区域：构建后事件签名</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;C:\Program Files\Microsoft SDKs\Windows\v7.1\Bin\signtool.exe&quot; /fd SHA256 sign /f</span><br><span class="line">&quot;C:\Autodesk\MyCert.pfx&quot; /p MyPassword &quot;$(TargetDir)$(TargetFileName)&quot;</span><br></pre></td></tr></table></figure>

<p>在签名时添加时间戳也是值得的（signtool.exe 中的 &#x2F;td 和 &#x2F;tr 开关）;否则，当证书过期时，应用程序将变得不受信任。添加时间戳可确保应用程序在过期之前签名，就永远受信任（除非证书被吊销）：<br>命令区域：添加时间戳</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">signtool.exe timestamp /td sha256 /tr  .dll</span><br></pre></td></tr></table></figure>

<p>例如，以下代码使用 verisign 时间戳服务器：<br>命令区域：时间戳示例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">signtool.exe timestamp /td sha256 /tr &quot;http://sha256timestamp.ws.symantec.com/sha256/&quot; HelloRevit.dll</span><br></pre></td></tr></table></figure>

<p>注意：上例中使用的 &#x2F;td sha256 和 &#x2F;tr 开关用于使用 sha256 时间戳进行签名。从 2017 年 1 月 1 日开始，Microsoft 会将 SHA1 时间戳视为未签名。有关更多详细信息，请参阅这篇文章。</p>
</li>
</ul>
<h3 id="制作自己的证书以供测试和内部使用"><a href="#制作自己的证书以供测试和内部使用" class="headerlink" title="制作自己的证书以供测试和内部使用"></a>制作自己的证书以供测试和内部使用</h3><p>您可以制作自己的数字证书，以便在公司内部进行测试或使用。</p>
<p>创建自己的数字证书</p>
<ul>
<li>使用 MakeCert.exe. ASPX)工具创建数字证书。</li>
<li>使用 Pvk2Pfx.exe 工具创建个人信息交换 （pfx） 文件。</li>
<li>对应用程序进行数字签名。</li>
<li>将数字证书导入 Windows 证书存储区。（CertMgr.msc 或 CertUtil.exe.aspx</li>
</ul>
<p>1、创建数字证书</p>
<p>您可以使用 MakeCert.exe.ASPX)工具制作您自己的数字证书以供测试和内部使用。以下是命令格式：</p>
<p>命令区域：创建证书命令格式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MakeCert.exe -r -sv .pvk -n &quot;CN=&quot; .cer -b  -e </span><br></pre></td></tr></table></figure>

<p>其中 是你创建的 pvk 文件的名称，是你分配给 pvk 文件的密码。是认证文件或 .cer 文件的名称。是 .pfx 的名称。是要分配给 .pfx 文件的密码。</p>
<p>例如：</p>
<p>命令区域：MakeCert.exe示例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;C:\Program Files\Microsoft SDKs\Windows\v7.1\Bin\MakeCert.exe&quot; -r -sv MyCert.pvk -n &quot;CN=DevABC&quot; MyCert.cer -b 01/01/2016 -e 12/31/2016</span><br></pre></td></tr></table></figure>

<p>或:</p>
<p>命令区域：MakeCert.exe示例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;C:\Program Files (x86)\Windows Kits\8.1\bin\x64\makecert.exe&quot; -r -sv MyCert.pvk -n &quot;CN=DevABC&quot; MyCert.cer -b 01/01/2016 -e 12/31/2016</span><br></pre></td></tr></table></figure>

<p>此命令将弹出“创建私钥密码”对话框。在对话框中输入私钥密码。如果系统要求输入密码，请再次输入。完成所有操作后，您将在命令窗口中看到一条消息“成功”，并创建 .cer 和 .pvk 文件。</p>
<p>2、转换为 PFX</p>
<p>下一步是使用 pvk2pfx.exe 工具将数字证书转换为个人信息交换 （pfx） 文件。在此步骤中，您需要在上述步骤中创建的 .pvk 文件、.cer 文件和密码。命令格式如下所示：</p>
<p>命令区域：转换为 PFX 命令格式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> pvk2pfx.exe&quot; -pvk .pvk -pi  -spc .cer </span><br><span class="line">-pfx  -po </span><br></pre></td></tr></table></figure>

<p>其中 是存储私钥的文件的名称，是开发者的名字，是证书文件的名称，是证书生效的日期（格式为 mm&#x2F;dd&#x2F;yyyy），是证书的有效期结束的日期。 </p>
<p>例如：</p>
<p>命令区域：转换为 PFX 示例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;C:\Program Files (x86)\Windows Kits\8.1\bin\x64\pvk2pfx.exe&quot; -pvk MyCert.pvk -pi password123 -spc MyCert.cer -pfx MyCert.pfx -po password234</span><br></pre></td></tr></table></figure>

<p>操作成功后，命令结束，不显示错误消息，并将创建一个 .pfx 文件。</p>
<p>3、拥有 pfx 文件后，您可以对应用程序进行数字签名。</p>
<p>4、将数字证书导入 Windows 证书存储区</p>
<p>制作自己的数字证书时，还需要执行的另一个步骤是将其导入计算机。您可以在 Certificate Manager （CertMgr.msc.ASPX）） 或 CertUtils.exe 工具。这里我们使用 UI 工具。请参阅此处了解替代方案。</p>
<ul>
<li>从开始 &gt;&gt; 运行 &gt;&gt; CertMgr.msc。（或在 Windows 8.1&#x2F;10 上，右键单击“开始”&gt;&gt; 运行 &gt;&gt; CertMgr.msc）CertMgr 打开。<br>在 CertMgr 对话框中，右键单击 Trusted Publishers &gt;&gt; All Tasks &gt;&gt; Import …</li>
<li>按照证书导入向导中的说明进行操作。单击 Next。</li>
<li>在询问“Files to Import”的对话框中，选择要导入的 pfx 文件。</li>
<li>在 “Password” 对话框中，输入密码。保持“包括所有扩展属性”的选中状态。</li>
<li>选择“将所有证书放在以下存储中”，然后单击下一步。</li>
<li>确认并完成。</li>
</ul>
<p>如果您看到“Import a new Private signature key（导入新的私有签名密钥）”对话框，请单击“确定”。（这部分可能因您的环境而异。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/certmgr.png"></p>
<p>对 Trusted Root Certification Authorities 重复相同的步骤。此步骤用于验证数字签名的二进制文件。</p>
<h3 id="数字签名参考"><a href="#数字签名参考" class="headerlink" title="数字签名参考"></a>数字签名参考</h3><ul>
<li><p>The following references provide more information on digitally signing apps.<br>以下参考资料提供了有关对应用程序进行数字签名的更多信息。</p>
<h2 id="Revit-Help-Revit-帮助"><a href="#Revit-Help-Revit-帮助" class="headerlink" title="Revit Help Revit 帮助"></a>Revit Help Revit 帮助</h2><ul>
<li><p><a href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=GUID-1C5947F2-4525-4B9F-9764-4D83D9FD2157">About Digital Signatures 关于数字签名</a></p>
</li>
<li><p><a href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=GUID-900A3EBF-A809-4A0E-96ED-5EEC965A2728">Security: Signed File or Add-In<br>安全性：签名文件或加载项</a></p>
</li>
<li><p><a href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=GUID-36D29367-A540-4CFD-9773-4995BF1DF08A">Security: Unsigned File or Add-In<br>安全性：未签名的文件或加载项</a></p>
</li>
<li><p><a href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=GUID-A5654402-D25A-4993-9059-0486B36AA708">Security: Invalid Signature<br>安全性：签名无效</a></p>
<h2 id="Microsoft-and-Other-Sites-Microsoft-和其他网站"><a href="#Microsoft-and-Other-Sites-Microsoft-和其他网站" class="headerlink" title="Microsoft and Other Sites Microsoft 和其他网站"></a>Microsoft and Other Sites Microsoft 和其他网站</h2></li>
<li><p><a href="https://msdn.microsoft.com/en-us/library/windows/desktop/jj835835(v=vs.85).aspx?f=255&mspperror=-2147217396">How to sign an app package using SignTool</a><br><a href="https://msdn.microsoft.com/en-us/library/windows/desktop/jj835835(v=vs.85">如何使用 SignTool 对应用程序包进行签名</a>.aspx？f&#x3D;255&amp;mspperror&#x3D;-2147217396）</p>
</li>
<li><p><a href="http://stackoverflow.com/questions/5510063/makecert-exe-missing-in-windows-7-how-to-get-it-and-use-it/9153635#9153635#9153635">makecert.exe missing in windows 7, how to get it and use it<br>Windows 7 中缺少makecert.exe，如何获取和使用它</a></p>
</li>
<li><p>The truth about SHA1, SHA-256 and Code Signing Certificates<br>关于 SHA1、SHA-256 和代码签名证书的真相</p>
<h2 id="AutoCAD-references-AutoCAD-参考"><a href="#AutoCAD-references-AutoCAD-参考" class="headerlink" title="AutoCAD references AutoCAD 参考"></a>AutoCAD references AutoCAD 参考</h2></li>
</ul>
<p><strong>AutoCAD Blog AutoCAD 博客</strong></p>
<ul>
<li><p><a href="http://adndevblog.typepad.com/autocad/2015/01/digitally-signing-plug-in-files.html">http://adndevblog.typepad.com/autocad/2015/01/digitally-signing-plug-in-files.html</a></p>
</li>
<li><p><a href="http://through-the-interface.typepad.com/through_the_interface/2015/05/signing-your-application-modules-for-autocad-2016-part-1.html">http://through-the-interface.typepad.com/through_the_interface/2015/05/signing-your-application-modules-for-autocad-2016-part-1.html</a></p>
<p><strong>AutoCAD Help AutoCAD 帮助</strong></p>
</li>
<li><p><a href="http://help-staging.autodesk.com/view/ACD/2016/ENU/?guid=GUID-3DA95353-9EF3-4E29-9671-6AEB7704EBE6">To Digitally Sign a Binary (ObjectARX or Managed .NET) File<br>对二进制（ObjectARX 或托管 .NET）文件进行数字签名</a></p>
</li>
<li><p><a href="http://help-staging.autodesk.com/view/ACD/2016/ENU/?guid=GUID-AA7BBBED-98D0-4003-8C80-D66173664DBA">To Digitally Sign a Binary (ObjectARX or Managed .NET) File with a Post-Build Event in Microsoft Visual Studio<br>在 Microsoft Visual Studio 中使用构建后事件对二进制（ObjectARX 或托管 .NET）文件进行数字签名</a></p>
</li>
<li><p><a href="http://help-staging.autodesk.com/view/ACD/2016/ENU/?guid=GUID-26D7B31C-4165-410C-9FC4-2D556749D517">To Make a Digital Certificate<br>制作数字证书</a></p>
</li>
<li><p><a href="http://help-staging.autodesk.com/view/ACD/2016/ENU/?guid=GUID-DC1B25FE-E063-486C-B90C-565AB5E87BBC">To Create A Personal Information Exchange (PFX) File<br>创建个人信息交换 （PFX） 文件</a></p>
</li>
<li><p><a href="http://help-staging.autodesk.com/view/ACD/2016/ENU/?guid=GUID-19D6716A-0AD1-4A7A-82BA-A067E6D65F66">To Import a Digital Certificate<br>导入数字证书</a></p>
</li>
</ul>
</li>
</ul>
<h2 id="本地化"><a href="#本地化" class="headerlink" title="本地化"></a>本地化</h2><p>您可以让 Revit 本地化外部命令按钮的用户可见资源（包括文字、大图标图像、长短描述以及工具提示图像）。您需要创建一个 .NET Satellite DLL，其中包含按钮的字符串、图像和图标。然后更改 .addin 文件中的标签值，使其与 Satellite dll 中的资源名称相对应，但前面要加上 @character。所以标签：</p>
<p>代码区域 3-13：非本地化文本输入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Extension Manager</span><br></pre></td></tr></table></figure>

<p>成为：</p>
<p>代码区域 3-14：本地化文本输入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@ExtensionText</span><br></pre></td></tr></table></figure>

<p>其中 ExtensionText 是在附属 DLL 中找到的资源的名称。</p>
<p>附属 DLL 应位于具有语言区域性语言名称的目录中，例如 en 或 en-US。该目录应位于包含加载项程序集的目录中。请参阅 <a href="http://msdn.microsoft.com/en-us/library/e9zazcx5.aspx">http://msdn.microsoft.com/en-us/library/e9zazcx5.aspx</a> 以创建托管的附属 DLL。</p>
<p>通过使用 LanguageType 标记显式指定语言和区域性，可以强制 Revit 使用特定语言资源 DLL，而不管 Revit 会话的语言如何。</p>
<p>代码区域 3-15：使用 LanguageType 标记</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">English_USA</span><br></pre></td></tr></table></figure>

<p>例如，上面的条目将强制 Revit 始终加载 en-US Satellite 中的值，并在考虑外部命令清单文件的可本地化成员时忽略当前的 Revit 语言和区域性设置。</p>
<p>Revit 支持 Autodesk.Revit.ApplicationServices.LanguageType 枚举类型中定义的 11 种语言：English_USA、德语、西班牙语、法语、意大利语、荷兰语、Chinese_Simplified语、Chinese_Traditional、日语、韩语和俄语。</p>
<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><p>Revit API 提供了多个用于配置 ExternalCommand 和 ExternalApplication 行为的特性。</p>
<h3 id="TransactionAttribute"><a href="#TransactionAttribute" class="headerlink" title="TransactionAttribute"></a>TransactionAttribute</h3><p>自定义属性 Autodesk.Revit.Attributes.TransactionMode 必须应用于 IExternalCommand 接口的实现类，以控制外部命令的事务行为。此选项没有默认值。此模式控制 API 框架在调用命令时预期如何使用事务。支持的值为：</p>
<p>TransactionMode.Manual - Revit 不会创建事务（但如果外部命令返回失败，它将创建一个外部事务组以回滚所有更改）。相反，您可以根据需要使用 Transactions、SubTransaction 和 TransactionGroups 的组合。您必须遵守有关使用交易和相关类的所有规则。您必须为您的交易命名，这些名称将出现在 Undo 菜单中。Revit 将检查从外部命令返回时，所有事务（包括组和子事务）是否已正确关闭。否则，Revit 将放弃对模型所做的所有更改。</p>
<p>TransactionMode.ReadOnly - 不会创建任何事务 （或组） ，并且在命令的生存期内不得创建任何事务。External Command 只能使用从模型中读取的方法。如果命令尝试启动事务（或组）或尝试写入模型，则会引发异常。</p>
<p>在任一模式下，TransactionMode 仅适用于活动文档。您可以在执行命令的过程中打开其他文档，并且可以完全控制在这些其他文档上创建和使用 Transactions、SubTransactions 和 TransactionGroups（即使在 ReadOnly 模式下也是如此）。<br>例如，要将外部命令设置为使用手动事务模式：</p>
<p>代码区域 3-18：TransactionAttribute</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">Transaction(TransactionMode.Manual)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Command</span> : <span class="title">IExternalCommand</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">public</span> Autodesk.Revit.IExternalCommand.<span class="function">Result <span class="title">Execute</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">                Autodesk.Revit.ExternalCommandData commandData,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="keyword">ref</span> <span class="built_in">string</span> message, Autodesk.Revit.DB.ElementSet elements</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">                <span class="comment">// Command implementation, which modifies the active document directly </span></span><br><span class="line">                <span class="comment">// after starting a new transaction</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请参阅 事务。</p>
<h3 id="JournalingAttribute"><a href="#JournalingAttribute" class="headerlink" title="JournalingAttribute"></a>JournalingAttribute</h3><p>可以选择将自定义属性 Autodesk.Revit.Attributes.JournalingAttribute 应用于 IExternalCommand 接口的实现类，以控制外部命令执行期间的日记行为。日记有两个选项： </p>
<p>JournalMode.NoCommandData - ExternalCommandData.JournalData 映射的内容未写入 Revit 日志。此选项允许 Revit API 调用根据需要写入日志。此选项允许调用 Revit UI 进行选择或响应任务对话框的命令正确重放。</p>
<p>JournalMode.UsingCommandData - 使用命令数据中提供的 IDictionary&lt;String,String&gt;。这将隐藏外部命令调用与 IDictionary&lt;String,String&gt;条目之间的所有 Revit 日志条目。调用 Revit UI 进行选择或响应任务对话框的命令可能无法正确重放。如果未指定 JournalingAttribute，则这是默认值。</p>
<p>代码区域 3-19：JournalingAttribute</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Journaling(JournalingMode.UsingCommandData)]</span><br><span class="line">public class Command : IExternalCommand</span><br><span class="line">&#123;</span><br><span class="line">        public Autodesk.Revit.IExternalCommand.Result Execute(</span><br><span class="line">                Autodesk.Revit.ExternalCommandData commandData, </span><br><span class="line">                ref string message, Autodesk.Revit.DB.ElementSet elements)</span><br><span class="line">        &#123;</span><br><span class="line">                return Autodesk.Revit.UI.Result.Succeeded;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Revit-异常"><a href="#Revit-异常" class="headerlink" title="Revit 异常"></a>Revit 异常</h2><p>当 API 方法遇到非致命错误时，它们会引发异常。Revit附加模块应捕获异常。Revit API 帮助文件指定了特定方法通常遇到的异常。所有 Revit API 方法都会引发 Autodesk.Revit.Exceptions.ApplicationException 的子类。这些异常与标准 .NET 异常非常相似，例如：</p>
<ul>
<li>ArgumentException ArgumentException（参数异常）</li>
<li>InvalidOperationException</li>
<li>FileNotFoundException</li>
</ul>
<p>但是，其中一些子类对于 Revit 是唯一的：</p>
<ul>
<li>AutoJoinFailedException</li>
<li>RegenerationFailedException</li>
<li>ModificationOutsideTransactionException</li>
</ul>
<p>此外，还有一种称为 InternalException 的特殊异常类型，它表示未预料到的失败路径。此类异常会附带额外的诊断信息，这些信息可以传回 Autodesk 进行诊断。</p>
<h2 id="功能区面板和控件"><a href="#功能区面板和控件" class="headerlink" title="功能区面板和控件"></a>功能区面板和控件</h2><p>Revit 提供了 API 解决方案来集成自定义功能区面板和控件。</p>
<p>这些 API 与 IExternalApplication 一起使用。自定义功能区面板可以添加到“加载项”选项卡、“分析”选项卡或新的自定义功能区选项卡中。</p>
<p>面板可以包括大按钮和小按钮，这些按钮可以是简单的按钮、包含多个命令的下拉按钮，也可以是拆分按钮，这些按钮是附加了默认按钮的下拉按钮。除了按钮之外，面板还可以包括单选按钮组、组合框和文本框。面板还可以包含垂直分隔符，以帮助将命令分隔到逻辑组中。最后，面板可以包含一个滑出控件，可通过单击面板底部来访问该控件。</p>
<p>有关开发符合 Autodesk 所用标准的用户界面的信息，请参见 API 用户界面指南部分中的功能区指南。</p>
<h3 id="创建新的-Ribbon-选项卡"><a href="#创建新的-Ribbon-选项卡" class="headerlink" title="创建新的 Ribbon 选项卡"></a>创建新的 Ribbon 选项卡</h3><p>虽然可以将功能区面板添加到“加载项”或“分析”选项卡中，但也可以将其添加到新的自定义功能区选项卡中。仅在必要时才应使用此选项。为确保标准 Revit 功能区选项卡保持可见，自定义功能区选项卡限制为 20 个。下图显示了一个新的功能区选项卡，其中包含一个功能区面板和一些简单的控件。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/NewRibbonTab.jpg" alt="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/NewRibbonTab.jpg"></p>
<p>下面是生成上述功能区选项卡的代码。</p>
<p>代码区域：“新建功能区”选项卡</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public Result OnStartup(UIControlledApplication application)</span><br><span class="line">&#123;</span><br><span class="line">    // Create a custom ribbon tab</span><br><span class="line">    String tabName = &quot;This Tab Name&quot;;</span><br><span class="line">    application.CreateRibbonTab(tabName);</span><br><span class="line"></span><br><span class="line">    // Create two push buttons</span><br><span class="line">    PushButtonData button1 = new PushButtonData(&quot;Button1&quot;, &quot;My Button #1&quot;,</span><br><span class="line">        @&quot;C:\ExternalCommands.dll&quot;, &quot;Revit.Test.Command1&quot;);</span><br><span class="line">    PushButtonData button2 = new PushButtonData(&quot;Button2&quot;, &quot;My Button #2&quot;,</span><br><span class="line">        @&quot;C:\ExternalCommands.dll&quot;, &quot;Revit.Test.Command2&quot;);</span><br><span class="line">    </span><br><span class="line">    // Create a ribbon panel</span><br><span class="line">    RibbonPanel m_projectPanel = application.CreateRibbonPanel(tabName, &quot;This Panel Name&quot;); </span><br><span class="line">    </span><br><span class="line">    // Add the buttons to the panel</span><br><span class="line">    List projectButtons = new List();</span><br><span class="line">    projectButtons.AddRange(m_projectPanel.AddStackedItems(button1, button2));</span><br><span class="line">    </span><br><span class="line">    return Result.Succeeded;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="创建新的-Ribbon-面板和控件"><a href="#创建新的-Ribbon-面板和控件" class="headerlink" title="创建新的 Ribbon 面板和控件"></a>创建新的 Ribbon 面板和控件</h3><p>下图显示了使用各种功能区面板控件的 Add-Ins （加载项） 选项卡上的功能区面板。以下部分更详细地介绍了这些控件，并提供了用于创建功能区每个部分的代码示例。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-EC547A32-2941-4731-A9C9-135CEDAB4DF0-low.png" alt="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-EC547A32-2941-4731-A9C9-135CEDAB4DF0-low.png"></p>
<p>图 14：新的功能区面板和控件</p>
<p>以下代码概述了创建如上图所示的功能区面板所采取的步骤。此示例中调用的每个函数将在本节后面的后续示例中提供。这些示例假定有一个位于 D：\ Sample\HelloWorld\bin\Debug\Hello.dll 的程序集，其中包含外部命令类型：</p>
<ul>
<li>Hello.HelloButton</li>
<li>Hello.HelloOne </li>
<li>Hello.HelloTwo</li>
<li>Hello.HelloThree </li>
<li>Hello.HelloA </li>
<li>Hello.HelloB </li>
<li>Hello.HelloC </li>
<li>Hello.HelloRed </li>
<li>Hello.HelloBlue</li>
<li>Hello.HelloGreen</li>
</ul>
<p>代码区域：功能区面板和控件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public Result OnStartup(Autodesk.Revit.UI.UIControlledApplication app)</span><br><span class="line">&#123;</span><br><span class="line">        RibbonPanel panel = app.CreateRibbonPanel(&quot;New Ribbon Panel&quot;);</span><br><span class="line"></span><br><span class="line">        AddRadioGroup(panel);</span><br><span class="line">        panel.AddSeparator();</span><br><span class="line">        AddPushButton(panel);</span><br><span class="line">        AddSplitButton(panel);</span><br><span class="line">        AddStackedButtons(panel);</span><br><span class="line">        AddSlideOut(panel);</span><br><span class="line">    </span><br><span class="line">        return Result.Succeeded;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h3 id="Ribbon-Panel-功能区面板"><a href="#Ribbon-Panel-功能区面板" class="headerlink" title="Ribbon Panel 功能区面板"></a>Ribbon Panel 功能区面板</h3><p>自定义功能区面板可以添加到“加载项”选项卡（默认）或“分析”选项卡中，也可以添加到新的自定义功能区选项卡中。可以将各种类型的功能区控件添加到功能区面板中，下一节将更详细地讨论这些控件。所有功能区控件都具有一些通用属性和功能。<br>功能区控件类<br>每个功能区控件都有两个与之关联的类 - 一个派生自 RibbonItemData，用于创建控件（即 SplitButtonData）并将其添加到功能区面板，另一个派生自 RibbonItem（即 SplitButton），表示将项添加到面板后的项目。RibbonItemData（和派生类）中提供的属性也可从 RibbonItem（和相应的派生类）中获得。可以在将控件添加到面板之前设置这些属性，也可以在将控件添加到面板之后使用 RibbonItem 类进行设置。</p>
<h4 id="Tooltips-工具提示"><a href="#Tooltips-工具提示" class="headerlink" title="Tooltips 工具提示"></a>Tooltips 工具提示</h4><p>大多数控件都可以设置工具提示（使用 ToolTip 属性），当用户将鼠标移到控件上时，将显示该工具提示。当用户长时间将鼠标悬停在控件上时，将使用 LongDescription 和 ToolTipImage 属性显示扩展工具提示。如果 LongDescription 和 ToolTipImage 均未设置，则不会显示扩展的工具提示。如果未提供工具提示，则当鼠标移动到控件上时，将显示控件的文本 （RibbonItem.ItemText）。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-261A8653-F926-4D87-8352-E86BF03EC3D0-low.png" alt="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-261A8653-F926-4D87-8352-E86BF03EC3D0-low.png"></p>
<h4 id="Contextual-Help-上下文帮助"><a href="#Contextual-Help-上下文帮助" class="headerlink" title="Contextual Help 上下文帮助"></a>Contextual Help 上下文帮助</h4><p>控件可以具有与之关联的上下文帮助。当用户将鼠标悬停在控件上并按 F1 时，将触发上下文帮助。上下文帮助选项包括链接到外部 URL、启动本地安装的帮助 （chm） 文件或链接到 Autodesk 帮助 Wiki 上的主题。ContextualHelp 类用于创建一种上下文帮助类型，然后 RibbonItem.SetContextualHelp()（或 RibbonItemData.SetContextualHelp()）将其与控件相关联。当 ContextualHelp 实例与控件关联时，当鼠标悬停在控件上时，文本“按 F1 获取更多帮助”将出现在工具提示下方，如下所示。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/ContextualHelp.jpg" alt="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/ContextualHelp.jpg"></p>
<p>下面的示例将新的 ContextualHelp 与按钮控件相关联。将鼠标悬停在按钮上时按 F1 将在新的浏览器窗口中打开 Autodesk 主页。</p>
<p>代码区域：上下文帮助</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void AddPushButton(RibbonPanel panel)</span><br><span class="line">&#123;</span><br><span class="line">    PushButton pushButton = panel.AddItem(new PushButtonData(&quot;HelloWorld&quot;,</span><br><span class="line">        &quot;HelloWorld&quot;, @&quot;D:\Sample\HelloWorld\bin\Debug\HelloWorld.dll&quot;, &quot;HelloWorld.CsHelloWorld&quot;)) as PushButton;</span><br><span class="line"></span><br><span class="line">    // Set ToolTip and contextual help</span><br><span class="line">    pushButton.ToolTip = &quot;Say Hello World&quot;;</span><br><span class="line">    ContextualHelp contextHelp = new ContextualHelp(ContextualHelpType.Url,</span><br><span class="line">        &quot;http://www.autodesk.com&quot;);</span><br><span class="line">    pushButton.SetContextualHelp(contextHelp);</span><br><span class="line">    </span><br><span class="line">    // Set the large image shown on button</span><br><span class="line">    pushButton.LargeImage =</span><br><span class="line">        new BitmapImage(new Uri(@&quot;D:\Sample\HelloWorld\bin\Debug\39-Globe_32x32.png&quot;));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ContextualHelp 类具有一个 Launch() 方法，可以调用该方法来随时显示由此 ContextualHelp 对象的内容指定的帮助主题，这与在控件处于活动状态时按下 F1 键时相同。这允许将帮助主题与加载项应用程序创建的对话框中的用户界面组件相关联。<br>将图像与控件关联 </p>
<p>所有这些控件都可以使用 LargeImage 属性具有与其关联的图像。与大型控件（如非堆叠功能区和下拉按钮）关联的图像的最佳大小为 32×32 像素，但较大的图像将进行调整以适合按钮。堆叠按钮和小控件（如文本框和组合框）应具有 16×16 像素的图像集。大按钮还应为 Image 属性设置 16×16 像素的图像。如果命令移动到快速访问工具栏，则使用此图像。如果未设置 Image 属性，则当命令移动到快速访问工具栏时，将不显示任何图像。请注意，如果使用大于 16×16 像素的图像，则不会调整它以适应工具栏。 ToolTipImage 将显示在扩展工具提示中的 LongDescription 下方（如果提供）。此图像没有建议的大小。</p>
<h4 id="功能区控制可用性"><a href="#功能区控制可用性" class="headerlink" title="功能区控制可用性"></a>功能区控制可用性</h4><p> 可以使用 RibbonItem.Enabled 属性启用或禁用功能区控件，也可以使用 RibbonItem.Visible 属性使功能区控件可见或不可见。</p>
<h4 id="功能区控件"><a href="#功能区控件" class="headerlink" title="功能区控件"></a>功能区控件</h4><p> 除了以下控件之外，还可以将垂直分隔符添加到功能区面板，以对相关的控件集进行分组。</p>
<h5 id="按钮"><a href="#按钮" class="headerlink" title="按钮"></a>按钮</h5><p>您可以向面板添加三种类型的按钮：简单按钮、下拉按钮和拆分按钮。图 14 中的 HelloWorld 按钮是一个按钮。按下该按钮时，将触发相应的命令。 除了 Enabled 属性之外，PushButton 还具有 AvailabilityClassName 属性，该属性可用于设置 IExternalCommandAvailability 接口的名称，该接口控制命令何时可用。</p>
<p>代码区域：添加按钮</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void AddPushButton(RibbonPanel panel)</span><br><span class="line">&#123;</span><br><span class="line">        PushButton pushButton = panel.AddItem(new PushButtonData(&quot;HelloWorld&quot;,</span><br><span class="line">                &quot;HelloWorld&quot;, @&quot;D:\HelloWorld.dll&quot;, &quot;HelloWorld.CsHelloWorld&quot;)) as PushButton;</span><br><span class="line"></span><br><span class="line">        pushButton.ToolTip = &quot;Say Hello World&quot;;</span><br><span class="line">        // Set the large image shown on button</span><br><span class="line">        pushButton.LargeImage = </span><br><span class="line">                new BitmapImage(new Uri(@&quot;D:\Sample\HelloWorld\bin\Debug\39-Globe_32x32.png&quot;));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Drop-down-buttons-下拉按钮"><a href="#Drop-down-buttons-下拉按钮" class="headerlink" title="Drop-down buttons 下拉按钮"></a>Drop-down buttons 下拉按钮</h5><p>下拉按钮展开后，可在下拉菜单中显示两个或多个命令。在 Revit API 中，下拉按钮称为 PulldownButtons。可以在下拉菜单中的项目之间添加水平分隔符。</p>
<p>下拉菜单中的每个命令也可以具有关联的 LargeImage，如上面的示例所示。</p>
<p>Split buttons 拆分按钮</p>
<p>拆分按钮是附加了默认按钮的下拉按钮。按钮的上半部分类似于按钮，而下半部分用作下拉按钮。图 14 中的 Option One 按钮是一个拆分按钮。</p>
<p>最初，按钮将是下拉列表中的顶部项目。但是，通过使用 IsSynchronizedWithCurrentItem 属性，默认命令（显示为拆分按钮的上半部分）可以与上次使用的命令同步。默认情况下，它将同步。在上面图 14 的 split 按钮中选择选项 2 将产生：</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-FCBB9C72-5786-4B34-BF1F-E41A99F446C3-low.png" alt="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-FCBB9C72-5786-4B34-BF1F-E41A99F446C3-low.png"></p>
<p>图 16：与当前项目同步的 Split 按钮</p>
<p>请注意，将忽略 SplitButton 的 ToolTip、ToolTipImage 和 LongDescription 属性。而是显示当前按钮的工具提示。<br>代码区域：添加拆分按钮</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">AddSplitButton</span>(<span class="params">RibbonPanel panel</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="built_in">string</span> assembly = <span class="string">@&quot;D:\Sample\HelloWorld\bin\Debug\Hello.dll&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// create push buttons for split button drop down</span></span><br><span class="line">        PushButtonData bOne = <span class="keyword">new</span> PushButtonData(<span class="string">&quot;ButtonNameA&quot;</span>, <span class="string">&quot;Option One&quot;</span>,</span><br><span class="line">         assembly, <span class="string">&quot;Hello.HelloOne&quot;</span>);</span><br><span class="line">        bOne.LargeImage = </span><br><span class="line">                <span class="keyword">new</span> BitmapImage(<span class="keyword">new</span> Uri(<span class="string">@&quot;D:\Sample\HelloWorld\bin\Debug\One.bmp&quot;</span>));</span><br><span class="line">    </span><br><span class="line">        PushButtonData bTwo = <span class="keyword">new</span> PushButtonData(<span class="string">&quot;ButtonNameB&quot;</span>, <span class="string">&quot;Option Two&quot;</span>, </span><br><span class="line">                assembly, <span class="string">&quot;Hello.HelloTwo&quot;</span>);</span><br><span class="line">        bTwo.LargeImage =</span><br><span class="line">         <span class="keyword">new</span> BitmapImage(<span class="keyword">new</span> Uri(<span class="string">@&quot;D:\Sample\HelloWorld\bin\Debug\Two.bmp&quot;</span>));</span><br><span class="line">    </span><br><span class="line">        PushButtonData bThree = <span class="keyword">new</span> PushButtonData(<span class="string">&quot;ButtonNameC&quot;</span>, <span class="string">&quot;Option Three&quot;</span>,</span><br><span class="line">         assembly, <span class="string">&quot;Hello.HelloThree&quot;</span>);</span><br><span class="line">        bThree.LargeImage = </span><br><span class="line">                <span class="keyword">new</span> BitmapImage(<span class="keyword">new</span> Uri(<span class="string">@&quot;D:\Sample\HelloWorld\bin\Debug\Three.bmp&quot;</span>));</span><br><span class="line">    </span><br><span class="line">        SplitButtonData sb1 = <span class="keyword">new</span> SplitButtonData(<span class="string">&quot;splitButton1&quot;</span>, <span class="string">&quot;Split&quot;</span>);</span><br><span class="line">        SplitButton sb = panel.AddItem(sb1) <span class="keyword">as</span> SplitButton;</span><br><span class="line">        sb.AddPushButton(bOne);</span><br><span class="line">        sb.AddPushButton(bTwo);</span><br><span class="line">        sb.AddPushButton(bThree);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Radio-buttons-单选按钮"><a href="#Radio-buttons-单选按钮" class="headerlink" title="Radio buttons 单选按钮"></a>Radio buttons 单选按钮</h5><p>单选按钮组是一组互斥的切换按钮;一次只能选择一个。将 RadioButtonGroup 添加到面板后，使用 AddItem() 或 AddItems() 方法将切换按钮添加到该组。切换按钮派生自 PushButton。RadioButtonGroup.Current 属性可用于访问当前选定的按钮。</p>
<p>请注意，工具提示不适用于单选按钮组。相反，当鼠标移动到各个按钮上时，将显示每个切换按钮的工具提示。</p>
<p>代码区域：添加单选按钮组</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">AddRadioGroup</span>(<span class="params">RibbonPanel panel</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">// add radio button group</span></span><br><span class="line">        RadioButtonGroupData radioData = <span class="keyword">new</span> RadioButtonGroupData(<span class="string">&quot;radioGroup&quot;</span>);</span><br><span class="line">        RadioButtonGroup radioButtonGroup = panel.AddItem(radioData) <span class="keyword">as</span> RadioButtonGroup;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// create toggle buttons and add to radio button group</span></span><br><span class="line">        ToggleButtonData tb1 = <span class="keyword">new</span> ToggleButtonData(<span class="string">&quot;toggleButton1&quot;</span>, <span class="string">&quot;Red&quot;</span>);</span><br><span class="line">        tb1.ToolTip = <span class="string">&quot;Red Option&quot;</span>;</span><br><span class="line">        tb1.LargeImage = <span class="keyword">new</span> BitmapImage(<span class="keyword">new</span> Uri(<span class="string">@&quot;D:\Sample\HelloWorld\bin\Debug\Red.bmp&quot;</span>));</span><br><span class="line">        ToggleButtonData tb2 = <span class="keyword">new</span> ToggleButtonData(<span class="string">&quot;toggleButton2&quot;</span>, <span class="string">&quot;Green&quot;</span>);</span><br><span class="line">        tb2.ToolTip = <span class="string">&quot;Green Option&quot;</span>;</span><br><span class="line">        tb2.LargeImage = <span class="keyword">new</span> BitmapImage(<span class="keyword">new</span> Uri(<span class="string">@&quot;D:\Sample\HelloWorld\bin\Debug\Green.bmp&quot;</span>));</span><br><span class="line">        ToggleButtonData tb3 = <span class="keyword">new</span> ToggleButtonData(<span class="string">&quot;toggleButton3&quot;</span>, <span class="string">&quot;Blue&quot;</span>);</span><br><span class="line">        tb3.ToolTip = <span class="string">&quot;Blue Option&quot;</span>;</span><br><span class="line">        tb3.LargeImage = <span class="keyword">new</span> BitmapImage(<span class="keyword">new</span> Uri(<span class="string">@&quot;D:\Sample\HelloWorld\bin\Debug\Blue.bmp&quot;</span>));</span><br><span class="line">        radioButtonGroup.AddItem(tb1);</span><br><span class="line">        radioButtonGroup.AddItem(tb2);</span><br><span class="line">        radioButtonGroup.AddItem(tb3);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Text-box-文本框"><a href="#Text-box-文本框" class="headerlink" title="Text box 文本框"></a>Text box 文本框</h5><p>文本框是供用户输入文本的输入控件。通过将 ShowImageAsButton 属性设置为 true，可以将文本框的图像用作可单击的按钮。默认值为 false。当 ShowImageAsButton 为 false 时，图像显示在文本框的左侧，当它充当按钮时，图像显示在文本框的右端，如图 14 所示。仅当用户按 Enter 键或在图像显示为按钮时单击关联的图像时，才会接受在文本框中输入的文本。否则，文本将恢复为之前的值。<br>除了为文本框提供工具提示外，PromptText 属性还可用于向用户指示要在文本框中输入的信息类型。当文本框为空且没有键盘焦点时，将显示提示文本。此文本以斜体显示。图 14 中的文本框具有提示文本 “Enter a comment”。</p>
<p>可以使用 Width 属性设置文本框的宽度。默认值为 200 个与设备无关的单位。</p>
<p>当用户按 Enter 键时，或者当 ShowImageAsButton 设置为 true 时，当用户单击文本框的关联图像时，将触发 TextBox.EnterPressed 事件。在实现 EnterPressed 事件处理程序时，将 sender 对象强制转换为 TextBox 以获取用户输入的值，如以下示例所示。</p>
<p>代码区域：TextBox.EnterPressed 事件处理程序</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ProcessText</span>(<span class="params"><span class="built_in">object</span> sender, Autodesk.Revit.UI.Events.TextBoxEnterPressedEventArgs <span class="keyword">args</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">// cast sender as TextBox to retrieve text value</span></span><br><span class="line">        TextBox textBox = sender <span class="keyword">as</span> TextBox;</span><br><span class="line">        <span class="built_in">string</span> strText = textBox.Value <span class="keyword">as</span> <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继承的 ItemText 属性对 TextBox 没有影响。用户输入的文本可以从 Value 属性中获取，该属性必须转换为字符串。 有关将 TextBox 添加到功能区面板的示例，包括如何注册上述事件，请参阅堆叠功能区项部分。</p>
<h5 id="组合框"><a href="#组合框" class="headerlink" title="组合框"></a>组合框</h5><p> 组合框是包含一组可选项的下拉列表。将 ComboBox 添加到面板后，使用 AddItem() 或 AddItems() 方法将 ComboBoxMembers 添加到列表中。 还可以将分隔符添加到列表中的单独项中，或者可以选择使用 ComboBoxMember.GroupName 属性对成员进行分组。具有相同 GroupName 的所有成员将分组在一起，并显示组名称的标头。任何未分配 GroupName 的项目都将放置在列表顶部。请注意，在对项目进行分组时，不应使用分隔符，因为它们将放置在组的末尾，而不是按添加顺序放置。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-62DBB2D2-0D7B-4EDC-945B-DC86BAE6BF6F-low.png" alt="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-62DBB2D2-0D7B-4EDC-945B-DC86BAE6BF6F-low.png"></p>
<p>图 17：带分组的组合框 </p>
<p>ComboBox 有三个事件： </p>
<p>CurrentChanged - 当 ComboBox 的当前项发生更改时触发</p>
<p> DropDownClosed - 关闭 ComboBox 的下拉列表时触发  </p>
<p>DropDownClosed - 打开 ComboBox 的下拉菜单时触发 </p>
<p>有关将 ComboBox 添加到功能区面板的示例，请参阅以下有关堆叠功能区项的代码区域。</p>
<h5 id="堆叠面板项目"><a href="#堆叠面板项目" class="headerlink" title="堆叠面板项目"></a>堆叠面板项目</h5><p> 为了节省面板空间，您可以以 2 个或 3 个为一组的形式添加小面板项。堆栈中的每个项都可以是按钮、下拉按钮、组合框或文本框。单选按钮组和拆分按钮不能堆叠。堆叠按钮应具有通过其 Image 属性关联的图像，而不是 LargeImage。16×16 图像非常适合小型堆叠按钮。 以下示例生成图 14 中的堆叠文本框和组合框。</p>
<p>代码区域：将文本框和组合框添加为堆叠项</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">AddStackedButtons</span>(<span class="params">RibbonPanel panel</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        ComboBoxData cbData = <span class="keyword">new</span> ComboBoxData(<span class="string">&quot;comboBox&quot;</span>);</span><br><span class="line"></span><br><span class="line">        TextBoxData textData = <span class="keyword">new</span> TextBoxData(<span class="string">&quot;Text Box&quot;</span>);</span><br><span class="line">        textData.Image = </span><br><span class="line">                <span class="keyword">new</span> BitmapImage(<span class="keyword">new</span> Uri(<span class="string">@&quot;D:\Sample\HelloWorld\bin\Debug\39-Globe_16x16.png&quot;</span>));</span><br><span class="line">        textData.Name = <span class="string">&quot;Text Box&quot;</span>;</span><br><span class="line">        textData.ToolTip = <span class="string">&quot;Enter some text here&quot;</span>;</span><br><span class="line">        textData.LongDescription = <span class="string">&quot;This is text that will appear next to the image&quot;</span> </span><br><span class="line">                + <span class="string">&quot;when the user hovers the mouse over the control&quot;</span>;</span><br><span class="line">        textData.ToolTipImage = </span><br><span class="line">                <span class="keyword">new</span> BitmapImage(<span class="keyword">new</span> Uri(<span class="string">@&quot;D:\Sample\HelloWorld\bin\Debug\39-Globe_32x32.png&quot;</span>));</span><br><span class="line">    </span><br><span class="line">        IList stackedItems = panel.AddStackedItems(textData, cbData);</span><br><span class="line">        <span class="keyword">if</span> (stackedItems.Count &gt; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                TextBox tBox = stackedItems[<span class="number">0</span>] <span class="keyword">as</span> TextBox;</span><br><span class="line">                <span class="keyword">if</span> (tBox != <span class="literal">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                        tBox.PromptText = <span class="string">&quot;Enter a comment&quot;</span>;</span><br><span class="line">                        tBox.ShowImageAsButton = <span class="literal">true</span>;</span><br><span class="line">                        tBox.ToolTip = <span class="string">&quot;Enter some text&quot;</span>;</span><br><span class="line">                        <span class="comment">// Register event handler ProcessText</span></span><br><span class="line">                        tBox.EnterPressed += </span><br><span class="line">                <span class="keyword">new</span> EventHandler&lt;Autodesk.Revit.UI.Events.TextBoxEnterPressedEventArgs&gt;(ProcessText);</span><br><span class="line">                &#125;</span><br><span class="line">    </span><br><span class="line">                ComboBox cBox = stackedItems[<span class="number">1</span>] <span class="keyword">as</span> ComboBox;</span><br><span class="line">                <span class="keyword">if</span> (cBox != <span class="literal">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                        cBox.ItemText = <span class="string">&quot;ComboBox&quot;</span>;</span><br><span class="line">                        cBox.ToolTip = <span class="string">&quot;Select an Option&quot;</span>;</span><br><span class="line">                        cBox.LongDescription = <span class="string">&quot;Select a number or letter&quot;</span>;</span><br><span class="line">    </span><br><span class="line">                        ComboBoxMemberData cboxMemDataA = <span class="keyword">new</span> ComboBoxMemberData(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;Option A&quot;</span>);</span><br><span class="line">                        cboxMemDataA.Image = </span><br><span class="line">                                <span class="keyword">new</span> BitmapImage(<span class="keyword">new</span> Uri(<span class="string">@&quot;D:\Sample\HelloWorld\bin\Debug\A.bmp&quot;</span>));</span><br><span class="line">                        cboxMemDataA.GroupName = <span class="string">&quot;Letters&quot;</span>;</span><br><span class="line">                        cBox.AddItem(cboxMemDataA);</span><br><span class="line">    </span><br><span class="line">                        ComboBoxMemberData cboxMemDataB = <span class="keyword">new</span> ComboBoxMemberData(<span class="string">&quot;B&quot;</span>, <span class="string">&quot;Option B&quot;</span>);</span><br><span class="line">                        cboxMemDataB.Image = </span><br><span class="line">                                <span class="keyword">new</span> BitmapImage(<span class="keyword">new</span> Uri(<span class="string">@&quot;D:\Sample\HelloWorld\bin\Debug\B.bmp&quot;</span>));</span><br><span class="line">                        cboxMemDataB.GroupName = <span class="string">&quot;Letters&quot;</span>;</span><br><span class="line">                        cBox.AddItem(cboxMemDataB);</span><br><span class="line">    </span><br><span class="line">                        ComboBoxMemberData cboxMemData = <span class="keyword">new</span> ComboBoxMemberData(<span class="string">&quot;One&quot;</span>, <span class="string">&quot;Option 1&quot;</span>);</span><br><span class="line">                        cboxMemData.Image = </span><br><span class="line">                                <span class="keyword">new</span> BitmapImage(<span class="keyword">new</span> Uri(<span class="string">@&quot;D:\Sample\HelloWorld\bin\Debug\One.bmp&quot;</span>));</span><br><span class="line">                        cboxMemData.GroupName = <span class="string">&quot;Numbers&quot;</span>;</span><br><span class="line">                        cBox.AddItem(cboxMemData);</span><br><span class="line">                        ComboBoxMemberData cboxMemData2 = <span class="keyword">new</span> ComboBoxMemberData(<span class="string">&quot;Two&quot;</span>, <span class="string">&quot;Option 2&quot;</span>);</span><br><span class="line">                        cboxMemData2.Image = </span><br><span class="line">                                <span class="keyword">new</span> BitmapImage(<span class="keyword">new</span> Uri(<span class="string">@&quot;D:\Sample\HelloWorld\bin\Debug\Two.bmp&quot;</span>));</span><br><span class="line">                        cboxMemData2.GroupName = <span class="string">&quot;Numbers&quot;</span>;</span><br><span class="line">                        cBox.AddItem(cboxMemData2);</span><br><span class="line">                        ComboBoxMemberData cboxMemData3 = <span class="keyword">new</span> ComboBoxMemberData(<span class="string">&quot;Three&quot;</span>, <span class="string">&quot;Option 3&quot;</span>);</span><br><span class="line">                        cboxMemData3.Image = </span><br><span class="line">                                <span class="keyword">new</span> BitmapImage(<span class="keyword">new</span> Uri(<span class="string">@&quot;D:\Sample\HelloWorld\bin\Debug\Three.bmp&quot;</span>));</span><br><span class="line">                        cboxMemData3.GroupName = <span class="string">&quot;Numbers&quot;</span>;</span><br><span class="line">                        cBox.AddItem(cboxMemData3);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Slide-out-panel-滑出面板"><a href="#Slide-out-panel-滑出面板" class="headerlink" title="Slide-out panel 滑出面板"></a>Slide-out panel 滑出面板</h5><p>使用 RibbonPanel.AddSlideOut() 方法将幻灯片向功能区面板的底部添加。添加滑出后，面板底部会显示一个箭头，单击该箭头时将显示滑出。调用 AddSlideOut() 后，用于向面板添加新项的后续调用将添加到滑出式面板，因此必须在将所有其他控件添加到功能区面板后添加滑出式控件。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-5B17EB5F-D4B4-472D-9033-B11C35F7E40B-low.png" alt="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-5B17EB5F-D4B4-472D-9033-B11C35F7E40B-low.png"></p>
<p>图 18：滑出</p>
<p>以下示例生成上面所示的滑出：</p>
<p>代码区域：TextBox.EnterPressed 事件处理程序</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">AddSlideOut</span>(<span class="params">RibbonPanel panel</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="built_in">string</span> assembly = <span class="string">@&quot;D:\Sample\HelloWorld\bin\Debug\Hello.dll&quot;</span>;</span><br><span class="line"></span><br><span class="line">        panel.AddSlideOut();</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// create some controls for the slide out</span></span><br><span class="line">        PushButtonData b1 = <span class="keyword">new</span> PushButtonData(<span class="string">&quot;ButtonName1&quot;</span>, <span class="string">&quot;Button 1&quot;</span>, </span><br><span class="line">                assembly, <span class="string">&quot;Hello.HelloButton&quot;</span>);</span><br><span class="line">        b1.LargeImage = </span><br><span class="line">                <span class="keyword">new</span> BitmapImage(<span class="keyword">new</span> Uri(<span class="string">@&quot;D:\Sample\HelloWorld\bin\Debug\39-Globe_32x32.png&quot;</span>));</span><br><span class="line">        PushButtonData b2 = <span class="keyword">new</span> PushButtonData(<span class="string">&quot;ButtonName2&quot;</span>, <span class="string">&quot;Button 2&quot;</span>, </span><br><span class="line">                assembly, <span class="string">&quot;Hello.HelloTwo&quot;</span>);</span><br><span class="line">        b2.LargeImage =</span><br><span class="line">                <span class="keyword">new</span> BitmapImage(<span class="keyword">new</span> Uri(<span class="string">@&quot;D:\Sample\HelloWorld\bin\Debug\39-Globe_16x16.png&quot;</span>));</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// items added after call to AddSlideOut() are added to slide-out automatically</span></span><br><span class="line">        panel.AddItem(b1);</span><br><span class="line">        panel.AddItem(b2);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Revit-样式的任务对话框"><a href="#Revit-样式的任务对话框" class="headerlink" title="Revit 样式的任务对话框"></a>Revit 样式的任务对话框</h2><p>TaskDialog 是简单 Windows MessageBox 的 Revit 样式替代方案。它可用于显示信息和接收来自用户的简单输入。它具有一组通用的控件，这些控件按标准顺序排列，以确保与 Revit 的其余部分保持一致的外观。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-6D0C2A00-3CB5-4963-B108-515FA6924728-low.png" alt="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-6D0C2A00-3CB5-4963-B108-515FA6924728-low.png"></p>
<p>图 19：Revit 风格的任务对话框</p>
<p>有两种方法可以创建任务对话框并向用户显示。</p>
<p>第一个选项是构造 TaskDialog，单独设置其属性，并使用实例方法 Show() 向用户显示它。</p>
<p>第二种方法是使用静态 Show() 方法之一在一个步骤中构建和显示对话框。使用 static 方法时，只能指定选项的子集。<br>有关开发符合 Autodesk 使用的标准的任务对话框的信息，请参见 API 用户界面准则部分中的对话框准则。</p>
<p>以下示例显示如何创建和显示上面显示的任务对话框。</p>
<p>代码区域 3-27：显示 Revit 样式的 TaskDialog</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">Autodesk.Revit.Attributes.Transaction(Autodesk.Revit.Attributes.TransactionMode.ReadOnly)</span>]</span><br><span class="line"><span class="keyword">class</span> <span class="title">TaskDialogExample</span> : <span class="title">IExternalCommand</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">public</span> Autodesk.Revit.UI.<span class="function">Result <span class="title">Execute</span>(<span class="params">ExternalCommandData commandData, <span class="keyword">ref</span> <span class="built_in">string</span> message, Autodesk.Revit.DB.ElementSet elements</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">                <span class="comment">// Get the application and document from external command data.</span></span><br><span class="line">                Application app = commandData.Application.Application;</span><br><span class="line">                Document activeDoc = commandData.Application.ActiveUIDocument.Document;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Creates a Revit task dialog to communicate information to the user.</span></span><br><span class="line">                TaskDialog mainDialog = <span class="keyword">new</span> TaskDialog(<span class="string">&quot;Hello, Revit!&quot;</span>);</span><br><span class="line">                mainDialog.MainInstruction = <span class="string">&quot;Hello, Revit!&quot;</span>;</span><br><span class="line">                mainDialog.MainContent = </span><br><span class="line">                        <span class="string">&quot;This sample shows how to use a Revit task dialog to communicate with the user.&quot;</span> </span><br><span class="line">                        + <span class="string">&quot;The command links below open additional task dialogs with more information.&quot;</span>;</span><br><span class="line">    </span><br><span class="line">                <span class="comment">// Add commmandLink options to task dialog</span></span><br><span class="line">                mainDialog.AddCommandLink(TaskDialogCommandLinkId.CommandLink1,</span><br><span class="line">                         <span class="string">&quot;View information about the Revit installation&quot;</span>);</span><br><span class="line">                mainDialog.AddCommandLink(TaskDialogCommandLinkId.CommandLink2, </span><br><span class="line">                                <span class="string">&quot;View information about the active document&quot;</span>);</span><br><span class="line">    </span><br><span class="line">                <span class="comment">// Set common buttons and default button. If no CommonButton or CommandLink is added,</span></span><br><span class="line">                <span class="comment">// task dialog will show a Close button by default</span></span><br><span class="line">                mainDialog.CommonButtons = TaskDialogCommonButtons.Close;</span><br><span class="line">                mainDialog.DefaultButton = TaskDialogResult.Close;</span><br><span class="line">    </span><br><span class="line">                <span class="comment">// Set footer text. Footer text is usually used to link to the help document.</span></span><br><span class="line">                mainDialog.FooterText = </span><br><span class="line">                        <span class="string">&quot;&quot;</span>                          + <span class="string">&quot;Click here for the Revit API Developer Center&quot;</span>;</span><br><span class="line">    </span><br><span class="line">                TaskDialogResult tResult = mainDialog.Show();</span><br><span class="line">    </span><br><span class="line">                <span class="comment">// If the user clicks the first command link, a simple Task Dialog </span></span><br><span class="line">                <span class="comment">// with only a Close button shows information about the Revit installation. </span></span><br><span class="line">                <span class="keyword">if</span> (TaskDialogResult.CommandLink1 == tResult)</span><br><span class="line">                &#123;</span><br><span class="line">                        TaskDialog dialog_CommandLink1 = <span class="keyword">new</span> TaskDialog(<span class="string">&quot;Revit Build Information&quot;</span>);</span><br><span class="line">                        dialog_CommandLink1.MainInstruction = </span><br><span class="line">                                <span class="string">&quot;Revit Version Name is: &quot;</span> + app.VersionName + <span class="string">&quot;\n&quot;</span></span><br><span class="line">                         + <span class="string">&quot;Revit Version Number is: &quot;</span> + app.VersionNumber + <span class="string">&quot;\n&quot;</span> </span><br><span class="line">                                + <span class="string">&quot;Revit Version Build is: &quot;</span> + app.VersionBuild;</span><br><span class="line">    </span><br><span class="line">                        dialog_CommandLink1.Show();</span><br><span class="line">    </span><br><span class="line">                &#125;</span><br><span class="line">    </span><br><span class="line">                <span class="comment">// If the user clicks the second command link, a simple Task Dialog </span></span><br><span class="line">                <span class="comment">// created by static method shows information about the active document</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (TaskDialogResult.CommandLink2 == tResult)</span><br><span class="line">                &#123;</span><br><span class="line">                        TaskDialog.Show(<span class="string">&quot;Active Document Information&quot;</span>, </span><br><span class="line">                                <span class="string">&quot;Active document: &quot;</span> + activeDoc.Title + <span class="string">&quot;\n&quot;</span></span><br><span class="line">                         + <span class="string">&quot;Active view name: &quot;</span> + activeDoc.ActiveView.Name);</span><br><span class="line">                &#125;</span><br><span class="line">    </span><br><span class="line">                <span class="keyword">return</span> Autodesk.Revit.UI.Result.Succeeded;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="数据库级外部应用程序"><a href="#数据库级外部应用程序" class="headerlink" title="数据库级外部应用程序"></a>数据库级外部应用程序</h2><p>数据库级附加模块是外部应用程序，不会向 Revit UI 添加任何内容。当应用程序的目的是将事件和&#x2F;或更新程序分配给 Revit 会话时，可以使用数据库级外部应用程序。</p>
<p>要向 Revit 添加 DB 级外部应用程序，请创建一个实现 IExternalDBApplication 接口的对象。</p>
<p>IExternalDBApplication 接口有两个抽象方法：OnStartup() 和 OnShutdown()，您可以在 DB 级外部应用程序中重写它们。</p>
<p>Revit 在启动时调用 OnStartup()，在关闭时调用 OnShutdown()。这与 IExternalApplication 非常相似，但请注意，这些方法返回 Autodesk.Revit.DB.ExternalDBApplicationResult 而不是 Autodesk.Revit.UI.Result，并使用 ControlledApplication 而不是 UIControlledApplication。</p>
<p>代码区域：IExternalDBApplication OnShutdown() 和 OnStartup()</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IExternalDBApplication</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">public</span> Autodesk.Revit.DB.<span class="function">ExternalDBApplicationResult <span class="title">OnStartup</span>(<span class="params">ControlledApplication application</span>)</span>;</span><br><span class="line">        <span class="keyword">public</span> Autodesk.Revit.DB.<span class="function">ExternalDBApplicationResult <span class="title">OnShutdown</span>(<span class="params">ControlledApplication application</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ControlledApplication 参数提供对 Revit 数据库事件的访问。数据库级应用程序将响应的事件和更新程序可以在 OnStartup 方法中注册。</p>
<h2 id="注：翻译自Revit-API-Developers-Guide"><a href="#注：翻译自Revit-API-Developers-Guide" class="headerlink" title="注：翻译自Revit API Developers Guide"></a><em><strong>注：</strong></em>翻译自<a href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_html">Revit API Developers Guide</a></h2>]]></content>
      <categories>
        <category>Revit二次开发人员指南</category>
      </categories>
      <tags>
        <tag>Revit</tag>
      </tags>
  </entry>
  <entry>
    <title>03应用及文档</title>
    <url>/2024/11/26/Revit%E4%BA%8C%E5%BC%80%E6%8C%87%E5%8D%97/03%E5%BA%94%E7%94%A8%E5%8F%8A%E6%96%87%E6%A1%A3/</url>
    <content><![CDATA[<h1 id="Application及Document"><a href="#Application及Document" class="headerlink" title="Application及Document"></a><a href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_Introduction_Application_and_Document_html">Application及Document</a></h1><p>Revit 平台 API 中的顶级对象是Application和Document。这些类由 Application、UIApplication、Document 和 UIDocument 类表示。</p>
<p>Application对象是指单个 Revit 任务，提供对文档、选项和其他应用程序范围的数据和设置的访问。</p>
<p>Autodesk.Revit.UI.UIApplication - 提供对应用程序的 UI 级界面的访问，包括将 RibbonPanel 添加到用户界面的功能，以及在用户界面中获取活动文档的功能。</p>
<p>Autodesk.Revit.ApplicationServices.Application - 提供对所有其他应用程序级别属性的访问。</p>
<p>Document是表示建筑模型的单个 Revit 项目文件。Revit 可以打开多个项目，并为一个项目打开多个视图。</p>
<p>Autodesk.Revit.UI.UIDocument - 提供对文档的 UI 级界面的访问，例如选择的内容以及提示用户进行选择和选取点的功能。</p>
<p>Autodesk.Revit.DB.Document - 提供对所有其他文档级别属性的访问。</p>
<p>如果打开了多个文档，则活动文档是其视图在 Revit 任务中处于活动状态的文档。</p>
<p>本章介绍了所有Application和Document，然后重点介绍文件管理、设置和单位。有关 Element 类的更多详细信息，请参阅 Elements Essentials和 编辑元素 ，并参阅 视图 以了解有关视图元素的更多详细信息。</p>
<h2 id="Applicaion功能"><a href="#Applicaion功能" class="headerlink" title="Applicaion功能"></a>Applicaion功能</h2><p>Application和 UIApplication 成员提供对应用程序范围的数据和设置以及 Revit 的活动会话的访问。</p>
<h4 id="Application-应用"><a href="#Application-应用" class="headerlink" title="Application 应用"></a>Application 应用</h4><p>该类表示 Autodesk Revit 应用程序，提供对文档、选项和其他应用程序范围的数据和设置的访问。</p>
<h4 id="应用程序版本信息"><a href="#应用程序版本信息" class="headerlink" title="应用程序版本信息"></a>应用程序版本信息</h4><p>应用程序属性包括 VersionBuild、VersionNumber 和 VersionName。这些属性可用于根据 Revit 的发布和内部版本提供附加模块行为，如如何使用应用程序属性为附加模块强制实施正确的版本所示。</p>
<h4 id="应用程序范围的设置"><a href="#应用程序范围的设置" class="headerlink" title="应用程序范围的设置"></a>应用程序范围的设置</h4><p>Revit 一次使用一个共享参数文件。Application.OpenSharedParameterFile() 方法访问其路径在 SharedParametersFilename 属性中设置的共享参数文件。有关更多详细信息，请参阅共享参数。</p>
<h4 id="库内容"><a href="#库内容" class="headerlink" title="库内容"></a>库内容</h4><p>GetLibraryPaths() 和 SetLibraryPaths() 方法提供对路径信息的访问，用于标识 Revit 搜索内容的位置。</p>
<h4 id="图形显示"><a href="#图形显示" class="headerlink" title="图形显示"></a>图形显示</h4><p>BackgroundColor 属性允许读取和写入此会话中用于模型视图的背景颜色。AllowNavigationDuringRedraw 属性启用或禁用允许在重绘期间进行视图操作的选项。这可用于在重绘模型期间优化性能。</p>
<h4 id="文档管理"><a href="#文档管理" class="headerlink" title="文档管理"></a>文档管理</h4><p>Application 类提供了用于创建以下类型文档的方法：</p>
<ul>
<li>Family document 族文件</li>
<li>Project document 项目文档</li>
<li>Project template 项目模板</li>
</ul>
<p>OpenDocumentFile() 方法可用于打开这些文档类型中的任何一种。所有打开的文档都可以使用 Documents 属性进行检索。<br>有关更多详细信息，请参阅文档和文件管理。</p>
<h4 id="会话信息"><a href="#会话信息" class="headerlink" title="会话信息"></a>会话信息</h4><p>UserName 等属性和GetRevitServerNetworkHosts() 等方法提供对此会话特定信息的只读访问。</p>
<h4 id="登录信息"><a href="#登录信息" class="headerlink" title="登录信息"></a>登录信息</h4><p>静态 IsLoggedIn 属性检查用户是否已从此会话登录到其 Autodesk A360 帐户。如果用户已登录，则 LoginUserId 属性将返回当前登录的用户的用户 ID。（如果用户未登录，则用户 ID 将为空。与上一节中的 UserName 不同，LoginUserId 值不是可识别的值，而是内部 ID。结合 Store Entitlement REST API，Autodesk 应用程序的发布者可以验证当前用户是否已从 Autodesk App Store 购买了其应用程序。有关 Store Entitlement API 的更多信息，请参阅 <a href="http://www.autodesk.com/developapps%E3%80%82">www.autodesk.com/developapps。</a></p>
<h4 id="共享参数管理"><a href="#共享参数管理" class="headerlink" title="共享参数管理"></a>共享参数管理</h4><h4 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h4><p>Application 类公开 document 和 application 事件，例如 document open 和 save。订阅这些事件会在启用事件时通知应用程序并采取相应的措施。有关更多详细信息，请参阅 Add-In Integration 部分中的事件。</p>
<h4 id="创造"><a href="#创造" class="headerlink" title="创造"></a>创造</h4><p>“Create ”属性返回一个对象工厂，该对象工厂用于在 Revit 平台 API 中创建应用程序范围的实用程序和几何对象。如果要在 Revit Revit application memory （而不是your application’s memory）中创建对象，则使用“Create ”。</p>
<p>失败发布和处理</p>
<p>包含所有已注册的 FailureDefinitions 的 FailureDefinitionRegistry 可从静态 GetFailureDefinitionRegistry () 方法获得。静态方法 RegisterFailuresProcessor() 可用于注册自定义 IFailuresProcessor。有关发布和处理失败的更多信息，请参阅失败发布和处理。</p>
<h4 id="断开连接警告"><a href="#断开连接警告" class="headerlink" title="断开连接警告"></a>断开连接警告</h4><p>以下属性控制是否显示各种类型断开连接的图形警告。</p>
<ul>
<li>ShowGraphicalWarningCableTrayConduitDisconnects</li>
<li>ShowGraphicalWarningDuctDisconnects</li>
<li>ShowGraphicalWarningElectricalDisconnects</li>
<li>ShowGraphicalWarningHangerDisconnects</li>
</ul>
<h4 id="UIApplication"><a href="#UIApplication" class="headerlink" title="UIApplication"></a>UIApplication</h4><p>此类表示 Autodesk Revit 用户界面的活动会话，提供对 UI 自定义方法、事件和活动文档的访问。<br>文档管理</p>
<p>UIApplication 使用 UIActiveDocument 属性提供对活动文档的访问。此外，可以使用重载的 OpenAndActivateDocument() 方法打开 Revit 文档。文档将在默认视图处于活动状态的情况下打开。此方法不能在事务中调用，并且只能在事件期间调用 Revit 中尚未打开活动文档，并且该事件未嵌套在其他事件中。</p>
<h4 id="插件管理"><a href="#插件管理" class="headerlink" title="插件管理"></a>插件管理</h4><p>ActiveAddInId 属性获取当前活动的外部应用程序或外部命令 ID，而 LoadedApplications 属性返回成功加载的外部应用程序的数组。</p>
<h4 id="功能区面板实用程序"><a href="#功能区面板实用程序" class="headerlink" title="功能区面板实用程序"></a>功能区面板实用程序</h4><p>使用 UIApplication 对象将新的功能区面板和控件添加到 Revit。<br>有关更多详细信息，请参阅“加载项集成”部分中的 Ribbon 面板和控件。</p>
<h4 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h4><p>DrawingAreaExtents 属性返回一个矩形，该矩形表示绘图区域的屏幕像素坐标，而 MainWindowExtents 属性返回一个矩形，该矩形表示 Revit 主窗口的屏幕像素坐标</p>
<h4 id="事件-1"><a href="#事件-1" class="headerlink" title="事件"></a>事件</h4><p>UIApplication 类公开与 UI 相关的事件，例如显示对话框时。订阅这些事件会在启用事件时通知应用程序并采取相应的措施。有关更多详细信息，请参阅 Add-In Integration 部分中的事件。</p>
<h3 id="学科控制"><a href="#学科控制" class="headerlink" title="学科控制"></a>学科控制</h3><p>The properties:</p>
<ul>
<li>Application.IsArchitectureEnabled</li>
<li>Application.IsStructureEnabled</li>
<li>Application.IsStructuralAnalysisEnabled</li>
<li>Application.IsMassingEnabled</li>
<li>Application.IsEnergyAnalysisEnabled</li>
<li>Application.IsSystemsEnabled</li>
<li>Application.IsMechanicalEnabled</li>
<li>Application.IsMechanicalAnalysisEnabled</li>
<li>Application.IsElectricalEnabled</li>
<li>Application.IsElectricalAnalysisEnabled</li>
<li>Application.IsPipingEnabled</li>
<li>Application.IsPipingAnalysisEnabled</li>
</ul>
<p>提供对可用学科的 READ 和 MODIFY 访问权限。应用程序可以读取属性以确定何时启用或禁用其 UI 的各个方面。</p>
<p>切换领域状态时，Revit 的 UI 将进行调整，并且将根据需要启用或禁用某些操作和功能。启用分析模式仅在启用相应专业时生效。例如，除非还启用了机械专业，否则启用 Mechanical Analysis 不会生效。</p>
<h3 id="如何使用Application属性为外接程序强制实施正确的版本"><a href="#如何使用Application属性为外接程序强制实施正确的版本" class="headerlink" title="如何使用Application属性为外接程序强制实施正确的版本"></a>如何使用Application属性为外接程序强制实施正确的版本</h3><p>有时，由于存在特定的修复或兼容的 API，您需要仅在存在特定的 Revit Update Release 的情况下运行附加模块。</p>
<p>使用“Application”的属性可以检查 Revit 的特定版本。属性 VersionNumber 将返回表示主版本号的字符串，而 VersionBuild 属性将返回 Autodesk Revit 应用程序的内部内部版本号。</p>
<p>另一个有用的属性是 Application.SubVersionNumber 属性。它返回一个字符串，该字符串表示 Revit 应用程序的主要-次要版本号，例如“2018.0.0”。Autodesk 会针对所有主要和次要更新更新更新此字符串。小版本（如 2018.1.0）可能具有初始客户版本（如 2018.0.0）中未提供的其他 API 和功能。为支持初始版本而编写的加载项可能与订阅更新兼容，但在订阅更新中使用新功能的加载项将与初始版本不兼容。</p>
<p>以下示例代码演示了一种技术，用于确定 Revit 版本是否为初始已知 Revit 版本之后的任何 Update Release。</p>
<p>代码区域：使用 VersionBuild 确定您的外接程序是否兼容</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetVersionInfo</span>(<span class="params">Autodesk.Revit.ApplicationServices.Application app</span>)</span></span><br><span class="line">&#123; </span><br><span class="line">   <span class="comment">// 20110309_2315 is the datecode of the initial release of Revit 2012 </span></span><br><span class="line">   <span class="keyword">if</span> (app.VersionNumber == <span class="string">&quot;2012&quot;</span> &amp;&amp; </span><br><span class="line">       String.Compare(app.VersionBuild, <span class="string">&quot;20110309_2315&quot;</span>) &gt; <span class="number">0</span>)</span><br><span class="line">   &#123;</span><br><span class="line">       TaskDialog.Show(<span class="string">&quot;Supported version&quot;</span>, </span><br><span class="line">                      <span class="string">&quot;This application supported in this version.&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">   &#123;</span><br><span class="line">       TaskDialog dialog = <span class="keyword">new</span> TaskDialog(<span class="string">&quot;Unsupported version.&quot;</span>);</span><br><span class="line">       dialog.MainIcon = TaskDialogIcon.TaskDialogIconWarning;</span><br><span class="line">       dialog.MainInstruction = <span class="string">&quot;This Revit 2012 application is supported in UR1 and later releases.&quot;</span>;</span><br><span class="line">       dialog.Show();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Document功能"><a href="#Document功能" class="headerlink" title="Document功能"></a>Document功能</h2><p>Document存储 Revit 图元、管理数据并更新多个数据视图。Document 类主要提供以下功能。</p>
<p>Document </p>
<p>Document 类表示打开的 Autodesk Revit 项目。</p>
<p>Settings 属性</p>
<p>Settings 属性返回一个对象，该对象提供对 Revit 项目中常规组件的访问。有关更多详细信息，请参阅设置。</p>
<p>地点和位置</p>
<p>每个项目只有一个场地位置，用于标识 Earth 上的物理项目位置。一个工程可以有多个工程位置。每个位置都是站点位置的偏移或旋转。有关更多详细信息，请参阅地点和位置。</p>
<p>视图管理</p>
<p>一个项目文档可以有多个视图。ActiveView 属性返回表示活动视图的 View 对象。您可以过滤项目中的图元以检索其他视图。有关更多详细信息，请参阅 视图。</p>
<p>元素检索</p>
<p>Document 对象将元素存储在项目中。使用 Element 属性按 ElementId 或 UniqueId 检索特定元素。<br>有关更多详细信息，请参阅 Elements Essential。</p>
<p>文件管理</p>
<p>每个 Document 对象都代表一个 Revit 项目文件。Document 提供如下功能：<br>检索文件信息，例如文件路径名和项目标题。<br>提供 Close() 和 Save() 方法来关闭和保存文档。<br>有关更多详细信息，请参阅文档和文件管理。</p>
<p>元素管理</p>
<p>Revit 会保留项目中的所有图元对象。要创建新图元，请使用“Create”属性，该属性返回用于在 Revit 平台 API 中创建新项目图元实例（如 FamilyInstance 或 Group）的对象工厂。<br>Document 类还可用于删除元素。使用 Delete() 方法删除项目中的元素。已删除的元素和任何从属元素不会显示，并且会从文档中删除。对已删除元素的引用无效，并会导致异常。有关更多详细信息，请参阅编辑元素。</p>
<p>事件</p>
<p>某些操作会引发事件，例如当您使用 Save 或 Save As 保存项目时。要在应用程序中捕获事件并做出响应，必须注册事件处理程序。有关更多详细信息，请参阅 事件。</p>
<p>文档状态</p>
<p>多个属性提供有关文档状态的信息：</p>
<ul>
<li>IsModifiable - 当前是否可以修改文档（这意味着文档中有一个活动事务，并且更改不会被其他任何内容暂时阻止）</li>
<li>IsModified - 文档在打开或保存后是否发生更改</li>
<li>IsReadOnly - 如果为 true，则文档当前为只读且无法修改</li>
<li>IsReadOnlyFile - 文档是否以只读模式打开</li>
<li>IsFamilyDocument - 文档是否为家庭文档</li>
<li>IsWorkshared - 是否已在文档中启用工作集</li>
</ul>
<p>其他</p>
<p>Document 还提供其他功能：</p>
<ul>
<li>ParameterBindings 属性 - 参数定义和类别之间的映射。有关更多详细信息，请参阅共享参数。</li>
<li>ReactionsAreUpToDate 属性 - 报告反作用载荷是否发生变化。有关更多详细信息，请参阅负载。</li>
<li>Default Types - 访问族和非族元素的默认类型。有关更多详细信息，请参阅默认类型。</li>
</ul>
<p>UIDocument</p>
<p>UIDocument 类表示在 Revit 用户界面中打开的 Autodesk Revit 项目。</p>
<p>元素检索</p>
<p>使用 UIDocument 中的 Selection 属性检索所选元素。此属性返回一个对象，该对象表示包含所选项目元素的活动选择。它还提供了 UI 交互方法，用于在 Revit 模型中拾取对象。有关更多详细信息，请参阅 Elements Essentials。</p>
<p>元素显示</p>
<p>ShowElements() 方法使用来关注多个元素。</p>
<p>视图管理</p>
<p>通过调用 RefreshActiveView() 方法，可以使用 UIDocument 类来刷新活动文档中的活动视图。ActiveView 属性可用于检索或设置文档的活动视图。更改活动视图有一些限制。它只能在活动文档中使用，该文档不得处于只读状态，也不得位于事务中。此外，在 ViewActivating 或 ViewActivated 事件期间，或任何操作前事件 （如 DocumentSaving、DocumentClosing 或其他类似事件） 期间，不得更改活动视图。</p>
<p>UIDocument.ActiveGraphicalView 属性检索文档的活动图形视图。与 UIDocument.ActiveView 不同，如果用户碰巧在其中一个视图中进行选择，则此属性将永远不会返回辅助视图（如 Project Browser 或 System Browser）。</p>
<p>UIDocument 还可用于获取 Revit 用户界面中所有打开的视图窗口的列表。GetOpenUIViews 方法返回一个 UIViews 列表，其中包含有关 Revit 用户界面中视图窗口的数据。</p>
<h3 id="Default-Types-默认类型"><a href="#Default-Types-默认类型" class="headerlink" title="Default Types 默认类型"></a>Default Types 默认类型</h3><p>Revit 具有不同类别的默认类型。调用相关工具创建此类别的图元时，此默认类型将显示在 Revit 用户界面中。Revit API 通过 Document 类公开族和非族类型的默认类型。</p>
<p>族类型</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">GetDefaultFamilyTypeId()</td>
<td align="left">获取与给定族类别 ID 关联的默认系列类型 ID。</td>
</tr>
<tr>
<td align="left">SetDefaultFamilyTypeId()</td>
<td align="left">设置与给定族类别 ID 关联的默认族类型 ID。</td>
</tr>
<tr>
<td align="left">IsDefaultFamilyTypeIdValid()</td>
<td align="left">检查族类型 ID 是否有效，可设置为给定族类别 ID 的默认值。</td>
</tr>
</tbody></table>
<p>此外，给定 ElementType，ElementType.IsValidDefaultFamilyType() 标识它是否是给定族类别 ID 的有效默认族类型。 以下示例演示了如何获取结构柱类别的默认族类型 ID。然后，它获取默认类型的族符号并将其分配给给定的柱。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">AssignDefaultTypeToColumn</span>(<span class="params">Document document, FamilyInstance column</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ElementId defaultTypeId = document.GetDefaultFamilyTypeId(<span class="keyword">new</span> ElementId(BuiltInCategory.OST_StructuralColumns));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (defaultTypeId != ElementId.InvalidElementId)</span><br><span class="line">    &#123;</span><br><span class="line">        FamilySymbol defaultType = document.GetElement(defaultTypeId) <span class="keyword">as</span> FamilySymbol;</span><br><span class="line">        <span class="keyword">if</span> (defaultType != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            column.Symbol = defaultType;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下一个示例在首先检查给定门是否为有效的默认族类型 ID 后，为给定门的门类别设置默认类型。</p>
<p>代码区域：设置默认族类型 ID</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">SetDefaultTypeFromDoor</span>(<span class="params">Document document, FamilyInstance door</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ElementId doorCategoryId = <span class="keyword">new</span> ElementId(BuiltInCategory.OST_Doors);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// It is necessary to test the type suitability to be a default family type, for not every type can be set as default. </span></span><br><span class="line">    <span class="comment">// Trying to set a non-qualifying default type will cause an exception</span></span><br><span class="line">    <span class="keyword">if</span> (door.Symbol.IsValidDefaultFamilyType(doorCategoryId))</span><br><span class="line">    &#123;</span><br><span class="line">        document.SetDefaultFamilyTypeId(doorCategoryId, door.Symbol.Id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>非族类型</p>
<p>下表中的文档成员提供对非 Family 元素类型的默认类型的访问。</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">GetDefaultElementTypeId()</td>
<td align="left">获取给定非 Family 元素类型的默认元素类型 ID。</td>
</tr>
<tr>
<td align="left">SetDefaultElementTypeId()</td>
<td align="left">为给定的非 Family 元素类型设置默认元素类型 ID。</td>
</tr>
<tr>
<td align="left">IsDefaultElementTypeIdValid()</td>
<td align="left">检查元素类型 ID 是否对给定的非 Family 元素类型有效。</td>
</tr>
</tbody></table>
<p>下面的示例检查给定的墙壁是否使用墙壁类型的默认元素类型。</p>
<p>代码区域：获取默认元素类型 ID</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private bool IsWallUsingDefaultType(Document document, Wall wall)</span><br><span class="line">&#123;</span><br><span class="line">    ElementId defaultElementTypeId = document.GetDefaultElementTypeId(ElementTypeGroup.WallType);</span><br><span class="line">    return (wall.WallType.Id == defaultElementTypeId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="文档和文件管理"><a href="#文档和文件管理" class="headerlink" title="文档和文件管理"></a>文档和文件管理</h2><p>文档和文件管理使创建和查找文档变得容易。</p>
<p>文档检索</p>
<p>Application 类维护所有文档。如前所述，您可以在一个会话中打开多个文档。使用 UIApplication 类属性 ActiveUIDocument 检索活动文档。所有打开的文档（包括活动文档）都使用 Application 类 Documents 属性进行检索。该属性返回一个包含 Revit 任务中所有打开的文档的集。</p>
<p>文档文件信息</p>
<p>Document 类为每个相应的文件提供两个属性，即 PathName 和 Title。</p>
<p>PathName 返回文档的完全限定文件路径。如果项目自创建以来尚未保存，则 PathName 将返回空字符串。</p>
<p>Title 是项目标题，通常从项目文件名派生而来。返回值因您的系统设置而异。</p>
<p>打开文档</p>
<p>Application 类提供了一个重载的方法来打开现有项目文件：</p>
<p>表 3：在 API 中打开文档</p>
<table>
<thead>
<tr>
<th><strong>Method 方法</strong></th>
<th><strong>Event 事件</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Document OpenDocumentFile(string filename )<br /> Document OpenDocumentFile(ModelPath modelPath, OpenOptions openOptions)</td>
<td>DocumentOpened 文档已打开</td>
</tr>
</tbody></table>
<p>指定具有完全限定文件路径的字符串时，Revit 将打开该文件并创建一个 Document 实例。使用此方法可以通过为此方法分配文件通用命名转换 （UNC） 名称，在其他计算机上打开文件。该文件可以是扩展名为 .rvt 的项目文件、扩展名为 .rfa 的族文件或扩展名为 .rte 的样板文件。第二个重载将模型的路径作为 ModelPath 而不是字符串，并且 OpenOptions 参数提供用于打开文件的选项，例如从中心分离打开的文档（如果适用）的功能，以及与工作共享相关的选项。有关打开工作共享文档的更多信息，请参阅打开工作共享文档。这些方法在发生故障时引发特定的记录异常。例外情况分为 4 大类。</p>
<p>表 4：引发的异常类型</p>
<table>
<thead>
<tr>
<th><strong>Type 类型</strong></th>
<th><strong>Example 例</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Disk errors 磁盘错误</td>
<td>文件不存在或版本错误</td>
</tr>
<tr>
<td>Resource errors 资源错误</td>
<td>没有足够的内存或磁盘空间来打开文件</td>
</tr>
<tr>
<td>Central model file errors 中心模型文件错误</td>
<td>文件已锁定或损坏</td>
</tr>
<tr>
<td>Central model&#x2F;server errors 中心模型&#x2F;服务器错误</td>
<td>与服务器发生网络通信错误</td>
</tr>
</tbody></table>
<p>如果文档打开成功，则会引发 DocumentOpened 事件。</p>
<p> 创建文档 </p>
<p>使用下表中的 Application 方法创建新文档。<br>表 5：在 API 中创建文档</p>
<table>
<thead>
<tr>
<th><strong>Method 方法</strong></th>
<th><strong>Event 事件</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>Document NewProjectDocument(string templateFileName);</code></td>
<td>DocumentCreated</td>
</tr>
<tr>
<td><code>Document NewProjectDocument(UnitSystem unitSystem);</code></td>
<td>DocumentCreated</td>
</tr>
<tr>
<td><code>Document NewFamilyDocument(string templateFileName);</code></td>
<td>DocumentCreated</td>
</tr>
<tr>
<td><code>Document NewProjectTemplateDocument(string templateFilename);</code></td>
<td>DocumentCreated</td>
</tr>
</tbody></table>
<p>对于需要模板文件名作为参数的方法，将基于模板文件返回创建的文档。NewProjectDocument（UnitSystem）将创建一个没有指定模板的新英制或公制项目文档。</p>
<p>保存并关闭文档 Document 类提供了保存或关闭实例的方法。</p>
<p>表 6：在 API 中保存和关闭文档</p>
<table>
<thead>
<tr>
<th><strong>Method 方法</strong></th>
<th><strong>Event 事件</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Save() 保存</td>
<td>DocumentSaved 文档已保存</td>
</tr>
<tr>
<td>SaveAs() 保存为</td>
<td>DocumentSavedAs</td>
</tr>
<tr>
<td>Close() 关闭</td>
<td>DocumentClosed 文档已关闭</td>
</tr>
</tbody></table>
<p>Save() 有 2 个重载，一个没有参数，另一个带有 SaveOptions 参数，可以指定是否强制操作系统从磁盘上的文件中删除所有死数据。如果之前未保存该文件，则必须改为调用 SaveAs()。 </p>
<p>SaveAs() 有 3 个重载。一个重载仅将文件名作为参数，如果存在另一个具有给定文件名的文件，则会引发异常。其他 2 个重载将文件名作为参数（在一种情况下以 ModelPath 的形式）以及第二个 SaveAsOptions 参数，该参数可用于指定是否覆盖现有文件（如果存在）。SaveAsOptions 还可用于指定其他相关选项，例如是否删除磁盘上与文件相关的死数据和工作共享选项。 Save() 和 SaveAs() 在与打开文档时相同的 4 个类别中引发特定的记录异常，如上面的表 4 所示。</p>
<p> Close() 有两个重载。一个参数采用 Boolean 参数，该参数指示是否在关闭文件之前保存文件。第二个重载不带任何参数，如果文档被修改，系统会询问用户是否要在关闭之前保存文件。如果尚未设置文档的路径名，或者保存的目标文件是只读的，则此方法将引发异常。</p>
<p>注： Close() 方法不会影响活动文档或引发 DocumentClosed 事件，因为该文档由外部应用程序使用。您只能对非活动文档调用此方法。UIDocument 类还提供了保存和关闭实例的方法。</p>
<p>表 7：在 API 中保存和关闭 UIDocument</p>
<table>
<thead>
<tr>
<th><strong>Method 方法</strong></th>
<th><strong>Event 事件</strong></th>
</tr>
</thead>
<tbody><tr>
<td>SaveAndClose()</td>
<td>DocumentSaved, DocumentClosed</td>
</tr>
<tr>
<td>SaveAs() 保存为</td>
<td>DocumentSavedAs</td>
</tr>
</tbody></table>
<p>SaveAndClose() 在保存文档后关闭文档。如果尚未设置文档的路径名称，则向 Revit 用户显示“另存为”对话框，以设置其名称和位置。 SaveAs() 方法将文档保存为通过“另存为”对话框从 Revit 用户处获取的文件名和路径。</p>
<p>文档预览</p>
<p> 可以从 Document 获取 DocumentPreviewSettings 类，该类包含与保存给定文档的预览图像相关的设置。</p>
<p>代码区域：文档预览</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SaveActiveViewWithPreview</span>(<span class="params">UIApplication application</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Get the handle of current document.</span></span><br><span class="line">    Autodesk.Revit.DB.Document document = application.ActiveUIDocument.Document;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get the document&#x27;s preview settings</span></span><br><span class="line">    DocumentPreviewSettings settings = document.GetDocumentPreviewSettings();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Find a candidate 3D view</span></span><br><span class="line">    FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">    collector.OfClass(<span class="keyword">typeof</span>(View3D));</span><br><span class="line">    </span><br><span class="line">    Func&lt;View3D, <span class="built_in">bool</span>&gt; isValidForPreview = v =&gt; settings.IsViewIdValidForPreview(v.Id);</span><br><span class="line">    </span><br><span class="line">    View3D viewForPreview = collector.OfType().First(isValidForPreview);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Set the preview settings</span></span><br><span class="line">    <span class="keyword">using</span> (Transaction setTransaction = <span class="keyword">new</span> Transaction(document, <span class="string">&quot;Set preview view id&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        setTransaction.Start();</span><br><span class="line">        settings.PreviewViewId = viewForPreview.Id;</span><br><span class="line">        setTransaction.Commit();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Save the document</span></span><br><span class="line">    document.Save();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>荷载族</p>
<p>Document 类使您能够将整个族及其所有符号加载到项目中。由于加载整个族可能需要很长时间和大量内存，因此 Document 类提供了类似的方法 LoadFamilySymbol() 来仅加载指定的符号。有关更多详细信息，请参阅 族。</p>
<h2 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h2><p>下表标识了 Revit Platform UI“管理”选项卡中的命令以及相应的 API。</p>
<p>表 7：API 和 UI 中的设置</p>
<table>
<thead>
<tr>
<th><strong>UI 命令</strong></th>
<th><strong>关联 API</strong></th>
<th><strong>参考</strong></th>
</tr>
</thead>
<tbody><tr>
<td>设置 <img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/ac.menuaro.gif" alt="img"> 项目信息</td>
<td>Document.ProjectInformation</td>
<td>请参阅以下注释</td>
</tr>
<tr>
<td>设置 <img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/ac.menuaro.gif" alt="img"> 项目参数</td>
<td>Document.ParameterBindings (Only for Shared Parameter)</td>
<td>请参阅<a href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Shared_Parameters">共享参数</a></td>
</tr>
<tr>
<td>“项目位置”面板</td>
<td>Document.ProjectLocations</td>
<td>查看<a href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Place_and_Locations">地点和位置</a></td>
</tr>
<tr>
<td>设置 <img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/ac.menuaro.gif" alt="img"> 其他设置 <img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/ac.menuaro.gif" alt="img"> 填充图案</td>
<td>FilteredElementCollector filtering on class FillPatternElement</td>
<td>请参阅以下注释</td>
</tr>
<tr>
<td>设置 <img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/ac.menuaro.gif" alt="img"> 材质</td>
<td>FilteredElementCollector filtering on class Material</td>
<td>请参阅<a href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Material_Management">物料管理</a></td>
</tr>
<tr>
<td>设置 <img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/ac.menuaro.gif" alt="img"> 对象样式</td>
<td>Document.Settings.Categories</td>
<td>请参阅以下注释</td>
</tr>
<tr>
<td>阶段划分 <img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/ac.menuaro.gif" alt="img"> 阶段</td>
<td>Document.Phases</td>
<td>请参阅以下注释</td>
</tr>
<tr>
<td>设置 <img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/ac.menuaro.gif" alt="img"> 结构设置</td>
<td>Loads and related structural settings are available in the API</td>
<td>参见 <a href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Structural_Engineering">Structural Engineering</a></td>
</tr>
<tr>
<td>设置 <img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/ac.menuaro.gif" alt="img"> 项目单位</td>
<td>Document.GetUnits()</td>
<td>见<a href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Units">单位</a></td>
</tr>
<tr>
<td>面积和体积计算（在房间和面积面板上）</td>
<td>AreaVolumeSettings.GetAreaVolumeSettings()</td>
<td>请参阅以下注释</td>
</tr>
</tbody></table>
<p>注意：项目信息 - API 提供 ProjectInfo 类，该类使用 Document.ProjectInformation 检索，以表示 Revit 项目中的项目信息。下表标识了 Project Information 参数的相应 API。</p>
<p>表 8：项目信息</p>
<table>
<thead>
<tr>
<th><strong>参数</strong></th>
<th><strong>对应 API</strong></th>
<th><strong>内置参数</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Project Issue Date 项目发布日期</td>
<td>ProjectInfo.IssueDate</td>
<td>PROJECT_ISSUE_DATE</td>
</tr>
<tr>
<td>Project Status 项目进展</td>
<td>ProjectInfo.Status</td>
<td>PROJECT_STATUS</td>
</tr>
<tr>
<td>Client Name 客户端名称</td>
<td>ProjectInfo.ClientName</td>
<td>CLIENT_NAME</td>
</tr>
<tr>
<td>Project Address 项目地址</td>
<td>ProjectInfo.Address</td>
<td>PROJECT_ADDRESS</td>
</tr>
<tr>
<td>Project Name 项目名称</td>
<td>ProjectInfo.Name</td>
<td>PROJECT_NAME</td>
</tr>
<tr>
<td>Project Number 项目编号</td>
<td>ProjectInfo.Number</td>
<td>PROJECT_NUMBER</td>
</tr>
</tbody></table>
<p>使用 ProjectInfo 公开的属性来检索和设置所有字符串。这些属性由相应的内置参数实现。您可以直接通过内置参数获取或设置值。有关如何通过内置参数访问这些参数的更多信息，请参阅“Elements Essentials”部分中的参数。获取项目信息的推荐方法是使用 ProjectInfo 属性。</p>
<p>Fill Patterns</p>
<p>使用对类 FillPatternElement 的 FilteredElementCollector 过滤来检索当前文档中的所有填充图案。可以使用静态方法 FillPatternElement.GetFillPattern（Document， ElementId） 或 FillPatternElement.GetFillPatternByName （Document， string） 来检索特定的 FillPattern。</p>
<p>Object Styles</p>
<p>使用 Settings.Categories 检索 Category 对象中除 Line Style 之外的所有信息。有关更多详细信息，请参阅 Elements Essentials和 Material 部分中的 Other Classifications。</p>
<p>Phases</p>
<p>Revit 按阶段维护图元生命周期，阶段是项目生命周期中的不同时间段。文档中的所有阶段都使用 Document.Phases 属性进行检索。该属性返回一个包含 Phase 类实例的数组。但是，Revit API 不会公开 Phase 类中的函数。</p>
<p>Options</p>
<p> “Options”命令用于配置项目全局设置。您可以使用 Application.Options 属性检索 Options.Application 实例。目前，Options.Application 类仅支持访问库路径和共享参数文件。</p>
<p>Area and Volume Calculations</p>
<p>AreaVolumeSettings 类允许您启用或禁用体积计算，以及更改房间边界位置。</p>
<h2 id="单位"><a href="#单位" class="headerlink" title="单位"></a>单位</h2><p>Revit API 中用于处理单位的两个主要类是 Units 和 FormatOptions。Units 类表示文档的默认设置，用于将带有单位的数字格式设置为字符串。它包含每个单位类型的 FormatOptions 对象以及与小数符号和数字分组相关的设置。</p>
<p>Units 类为每个有效的 Unit 类型存储一个 FormatOptions 对象，但并非所有 Unit 类型都可以直接修改。有些 （如 UT_Number 和 UT_SiteAngle）具有固定的定义。其他单位的定义是从其他单位类型自动派生的。例如，UT_SheetLength 派生自 UT_Length UT_ForceScale 派生自 UT_Force。</p>
<p>FormatOptions 类包含一些设置，这些设置控制如何将带有单位的数字格式设置为字符串。它包含通常由最终用户在“格式”对话框中选择并存储在文档中的设置，例如舍入、准确性、显示单位以及是否禁止空格或前导零或尾随零。</p>
<p>FormatOptions 类以两种不同的方式使用。Units 类中的 FormatOptions 对象表示文档的默认设置。在其他位置使用的 FormatOptions 对象表示可以选择性地覆盖默认设置的设置。</p>
<p>UseDefault 属性控制 FormatOptions 对象是表示默认格式还是自定义格式。如果 UseDefault 为 true，则格式设置将根据 Units 类中的默认设置进行，并且对象中的其他设置都没有意义的。如果 UseDefault 为 false，则对象包含替代 Units 类中的默认设置的自定义设置。对于 Units 类中的 FormatOptions 对象，UseDefault 始终为 false。</p>
<p>Revit API 中与单元相关的重要枚举包括：</p>
<ul>
<li>UnitType - 要测量的物理量类型，例如长度或力（UT_Length 或 UT_Force）</li>
<li>DisplayUnitType - 用于将数字格式化为字符串或转换单位（即 DUT_METERS）的单位和显示格式</li>
<li>UnitSymbolType - 以数字的格式化字符串表示形式显示的单位符号，以指示值的单位（即 UST_M）</li>
</ul>
<p>单位换算<br>Revit API 提供了实用程序类，以便于在 Revit 中处理数量。使用 UnitUtils 类，可以轻松地将单位数据与 Revit 的内部单位相互转换。<br>Revit 有七个基本单位，每个基本单位都有自己的内部单位。下表列出了这些内部单位。</p>
<p>表 9：Revit Unit System 中的 7 个基本单元</p>
<table>
<thead>
<tr>
<th><strong>基本单位</strong></th>
<th><strong>Revit 中的单位</strong></th>
<th><strong>单位制</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Length 长度</td>
<td>Feet (ft) 英尺（英尺）</td>
<td>Imperial 英制</td>
</tr>
<tr>
<td>Angle 角度</td>
<td>Radian 弧度</td>
<td>Metric 公制</td>
</tr>
<tr>
<td>Mass 质量</td>
<td>Kilogram (kg) 千克 （kg）</td>
<td>Metric 公制</td>
</tr>
<tr>
<td>Time 时间</td>
<td>Seconds (s) 秒 （s）</td>
<td>Metric 公制</td>
</tr>
<tr>
<td>Electric Current 电流</td>
<td>Ampere (A) 安培 （A）</td>
<td>Metric 公制</td>
</tr>
<tr>
<td>Temperature 温度</td>
<td>Kelvin (K) 开尔文 （K）</td>
<td>Metric 公制</td>
</tr>
<tr>
<td>Luminous Intensity 发光强度</td>
<td>Candela (cd) 坎德拉 （cd）</td>
<td>Metric 公制</td>
</tr>
</tbody></table>
<p>注意：由于 Revit 以英尺为单位存储长度，以公制单位存储其他基本量，因此涉及长度的派生单位将是基于英制和公制的非标准单位。例如，由于力是以“每时间平方的质量长度”来测量的，因此它以 kg-ft &#x2F; s2 为单位存储。以下示例使用 UnitUtils.ConvertFromInternalUnits() 方法获取材料的最小屈服应力（以 kips&#x2F;平方英寸为单位）。</p>
<p>代码区域：从 Revit 的内部单位转换</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">double</span> <span class="title">GetYieldStressInKsi</span>(<span class="params">Material material</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">double</span> dMinYieldStress = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// Get the structural asset for the material</span></span><br><span class="line">    ElementId strucAssetId = material.StructuralAssetId;</span><br><span class="line">    <span class="keyword">if</span> (strucAssetId != ElementId.InvalidElementId)</span><br><span class="line">    &#123;</span><br><span class="line">        PropertySetElement pse = material.Document.GetElement(strucAssetId) <span class="keyword">as</span> PropertySetElement;</span><br><span class="line">        <span class="keyword">if</span> (pse != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            StructuralAsset asset = pse.GetStructuralAsset();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Get the min yield stress and convert to ksi</span></span><br><span class="line">            dMinYieldStress = asset.MinimumYieldStress;</span><br><span class="line">            dMinYieldStress = UnitUtils.ConvertFromInternalUnits(dMinYieldStress,</span><br><span class="line">                DisplayUnitType.DUT_KIPS_PER_SQUARE_INCH);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">return</span> dMinYieldStress;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>UnitUtils 还可用于将值从一种单位类型转换为另一种单位类型，例如平方英尺到平方米。在以下示例中，以英寸为单位输入的墙的顶部偏移值将转换为英尺，这是设置该值的预期单位。</p>
<p>代码区域：在单位之间转换</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetTopOffset</span>(<span class="params">Wall wall, <span class="built_in">double</span> dOffsetInches</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// convert user-defined offset value to feet from inches prior to setting</span></span><br><span class="line">    <span class="built_in">double</span> dOffsetFeet = UnitUtils.Convert(dOffsetInches,</span><br><span class="line">                                            DisplayUnitType.DUT_DECIMAL_INCHES,</span><br><span class="line">                                            DisplayUnitType.DUT_DECIMAL_FEET);</span><br><span class="line"></span><br><span class="line">    Parameter paramTopOffset = wall.get_Parameter(BuiltInParameter.WALL_TOP_OFFSET);</span><br><span class="line">    paramTopOffset.Set(dOffsetFeet);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>单元格式设置和解析</p>
<p>另一个实用程序类 UnitFormatUtils 可以格式化数据或分析格式化单元数据。</p>
<p>重载方法 Format() 可用于根据格式设置选项将值格式化为字符串，如以下示例所示。检索材料密度，然后使用 Format() 方法将该值转换为用户友好的单位值。</p>
<p>代码区域：将值格式化为字符串</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DisplayDensityOfMaterial</span>(<span class="params">Material material</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">double</span> density = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// get structural asset of material in order to get the density</span></span><br><span class="line">    ElementId strucAssetId = material.StructuralAssetId;</span><br><span class="line">    <span class="keyword">if</span> (strucAssetId != ElementId.InvalidElementId)</span><br><span class="line">    &#123;</span><br><span class="line">        PropertySetElement pse = material.Document.GetElement(strucAssetId) <span class="keyword">as</span> PropertySetElement;</span><br><span class="line">        <span class="keyword">if</span> (pse != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            StructuralAsset asset = pse.GetStructuralAsset();</span><br><span class="line"></span><br><span class="line">            density = asset.Density;</span><br><span class="line">            <span class="comment">// convert the density value to a user readable string that includes the units</span></span><br><span class="line">            Units units = material.Document.GetUnits();</span><br><span class="line">            <span class="comment">// false for maxAccuracy means accuracy specified by the FormatOptions should be used</span></span><br><span class="line">            <span class="comment">// false for forEditing since this will be for display only and no formatting modifications are necessary</span></span><br><span class="line">            <span class="built_in">string</span> strDensity = UnitFormatUtils.Format(units, UnitType.UT_UnitWeight, density, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">            <span class="built_in">string</span> msg = <span class="built_in">string</span>.Format(<span class="string">&quot;Raw Value: &#123;0&#125;\r\nFormatted Value: &#123;1&#125;&quot;</span>, density, strDensity);</span><br><span class="line">            TaskDialog.Show(<span class="string">&quot;Material Density&quot;</span>, msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重载的 UnitFormatUtils.TryParse() 方法使用指定单位类型的 Revit 内部单位（如果可能）将格式化字符串（包括单位）解析为值。以下示例采用用户输入的长度值（假定为数字和长度单位），并尝试将其分析为长度值。出于演示目的，将结果与 TaskDialog 中的输入字符串进行比较。</p>
<p>代码区域：解析字符串</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">double</span> <span class="title">GetLengthInput</span>(<span class="params">Document document, String userInputLength</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">double</span> dParsedLength = <span class="number">0</span>;</span><br><span class="line">    Units units = document.GetUnits();</span><br><span class="line">    <span class="comment">// try to parse a user entered string (i.e. 100 mm, 1&#x27;6&quot;)</span></span><br><span class="line">    <span class="built_in">bool</span> parsed = UnitFormatUtils.TryParse(units, UnitType.UT_Length, userInputLength, <span class="keyword">out</span> dParsedLength);</span><br><span class="line">    <span class="keyword">if</span> (parsed == <span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> msg = <span class="built_in">string</span>.Format(<span class="string">&quot;User Input: &#123;0&#125;\r\nParsed value: &#123;1&#125;&quot;</span>, userInputLength, dParsedLength);</span><br><span class="line">        TaskDialog.Show(<span class="string">&quot;Parsed Data&quot;</span>, msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dParsedLength;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="注：翻译自Revit-API-Developers-Guide"><a href="#注：翻译自Revit-API-Developers-Guide" class="headerlink" title="注：翻译自Revit API Developers Guide"></a><em><strong>注：</strong></em>翻译自<a href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_html">Revit API Developers Guide</a></h2>]]></content>
      <categories>
        <category>Revit二次开发人员指南</category>
      </categories>
      <tags>
        <tag>Revit</tag>
      </tags>
  </entry>
  <entry>
    <title>04元素要点</title>
    <url>/2024/11/26/Revit%E4%BA%8C%E5%BC%80%E6%8C%87%E5%8D%97/04%E5%85%83%E7%B4%A0%E8%A6%81%E7%82%B9/</url>
    <content><![CDATA[<h1 id="元素要点"><a href="#元素要点" class="headerlink" title="元素要点"></a><a href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_Introduction_Elements_Essentials_html">元素要点</a></h1><p>元素对应于单个建筑或绘图构件，例如门、墙或尺寸标注。此外，元素可以是门类型、视图或材质定义。</p>
<h2 id="元素分类"><a href="#元素分类" class="headerlink" title="元素分类"></a>元素分类</h2><p>Revit 图元分为六组：模型、草图、视图、组、注释和信息。每个组都包含相关的元素及其相应的符号。</p>
<h4 id="模型元素"><a href="#模型元素" class="headerlink" title="模型元素"></a>模型元素</h4><p>模型元素表示建筑项目中存在的物理项。“模型元素”组中的元素可以细分为以下元素：</p>
<p>族实例 - 族实例包含族实例对象。可以将族对象载入到项目中，也可以从族样板创建族对象。有关更多信息，请参阅系列实例。</p>
<p>主体图元 - 主体图元包含系统族对象，这些对象可以包含其他模型图元，例如墙、屋顶、天花板和楼板。有关主体图元的更多信息，请参见墙、楼板、屋顶和洞口。</p>
<p>结构元素-结构图元包含仅用于 Revit 结构特征的图元。有关 Structure Elements 的更多信息，请参见 Structural Engineering。</p>
<h4 id="视图元素"><a href="#视图元素" class="headerlink" title="视图元素"></a>视图元素</h4><p>视图图元表示在 Revit 中查看其他对象并与其他对象交互的方式。有关更多信息，请参阅视图。</p>
<h4 id="组元素"><a href="#组元素" class="headerlink" title="组元素"></a>组元素</h4><p>组图元表示辅助图元，例如 Revit 中的“阵列”和“组”对象。有关详细信息，请参阅编辑元素。</p>
<h4 id="注释和基准元素"><a href="#注释和基准元素" class="headerlink" title="注释和基准元素"></a>注释和基准元素</h4><p>注释和基准元素包含可见的非物理项。</p>
<p>注释元素表示在图纸上保持比例的二维构件，并且仅在一个视图中可见。有关注释元素的更多信息，请参阅注释元素。<br>注： 表示 2D 组件的注释元素不仅存在于 2D 视图中。例如，可以在 3D 视图中绘制尺寸，而它们所引用的形状仅存在于 2D 平面中。<br>基准元素表示用于建立项目上下文的非物理项。这些元素可以存在于视图中。基准元素进一步分为以下几部分：</p>
<ul>
<li>通用基准元素 - 通用基准元素表示用于存储建模数据的非物理可见项目。</li>
<li>基准 FamilyInstance - 基准 FamilyInstance 表示加载到项目中或从族模板创建的非物理可见项目。注意有关常用基准元素和基准族实例的更多信息，请参阅基准和信息元素;有关 ModelCurve 相关内容，请参阅草绘。</li>
<li>结构基准元素 - 结构基准元素表示用于存储结构建模数据的非物理可见项目。有关结构基准元素的详细信息，请参阅结构工程。</li>
</ul>
<h4 id="草图元素"><a href="#草图元素" class="headerlink" title="草图元素"></a>草图元素</h4><p>草图元素表示用于草绘 2D&#x2F;3D 形状的临时项目。此组包含族建模和体量分析中使用的以下对象：</p>
<p>SketchPlane 草图平面）</p>
<ul>
<li>Sketch 素描</li>
<li>Path3D 路径3D</li>
<li>GenericForm. 泛型形式。</li>
</ul>
<p>有关草图详细信息，请参阅草图绘制。</p>
<h4 id="信息元素"><a href="#信息元素" class="headerlink" title="信息元素"></a>信息元素</h4><p>信息元素包含用于存储项目和应用程序数据的非物理不可见项。信息元素进一步分为以下几部分：</p>
<ul>
<li>Project Datum Elements 项目基准元素</li>
<li>Project Datum Elements (Unique).项目基准元素 （Unique）。</li>
</ul>
<p>有关基准元素的更多信息，请参阅基准和信息元素。</p>
<h2 id="其他分类"><a href="#其他分类" class="headerlink" title="其他分类"></a>其他分类</h2><p>元素可以按Category, Family, Symbol and Instance.进行分类。</p>
<p>分类之间存在一些关系。例如：</p>
<p>您可以按类别区分不同类型的 FamilyInstances。结构柱等项目位于“结构柱”类别中，梁和支撑位于“结构框架”类别中，依此类推。<br>您可以通过Symbol来区分结构 FamilyInstance 元素。</p>
<h4 id="Category-类别"><a href="#Category-类别" class="headerlink" title="Category 类别"></a>Category 类别</h4><p>Element.Category 属性表示 Element 所属的类别或子类别。它用于标识元素类型。例如，“墙”类别中的任何内容都被视为墙。其他类别包括门和房间。</p>
<p>Category 是最通用的类。 Document.Settings.Categories 属性是一个包含文档中所有 Category 对象的映射，并细分为以下对象：</p>
<ul>
<li>模型类别 - 模型类别包括梁、柱、门、窗和墙。</li>
<li>注释类别 - 注释类别包括维度、网格、级别和文本注释。</li>
</ul>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-4C0CA7CF-C5CF-4042-B99D-AE185F64D17F-low.png" alt="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-4C0CA7CF-C5CF-4042-B99D-AE185F64D17F-low.png"></p>
<p> 图 20：类别</p>
<p>注意：以下指南适用于分类：</p>
<ul>
<li><p>一般而言，以下规则适用于类别：</p>
<ul>
<li><p>每个族对象都属于一个类别</p>
</li>
<li><p>非族对象（如材质和视图）不属于某个类别</p>
</li>
<li><p>也有例外，例如 ProjectInfo，它属于“项目信息”类别。</p>
</li>
</ul>
</li>
<li><p>元素及其对应的符号通常属于同一类别。例如，基本墙及其墙类型“通用 - 8”都属于“墙”类别。</p>
</li>
<li><p>相同类型的元素可以属于不同的类别。例如，SpotDimensions 具有 SpotDimensionType，但它可以属于两个不同的类别：高程点和高程点坐标。</p>
</li>
<li><p>不同的元素可以由于相似性或体系结构原因而属于同一类别。ModelLine 和 DetailLine 位于 Lines 类别中。</p>
</li>
</ul>
<p>要访问类别，您可以从文档的 Settings 类访问所有类别（例如，插入新的类别集），或者如果您只需要访问与内置类别关联的类别对象，您可以直接从 Category 类的静态重载 GetCategory（） 方法访问类别对象。</p>
<p>要访问类别：</p>
<ul>
<li><p>从文档属性中获取类别的完整映射：Document.Settings.Categories 返回一个 CategoryNameMap，其中包含按其名称编制索引的所有 Revit 类别的映射。</p>
</li>
<li><p>通过调用静态方法 Category.GetCategory（） 的相应重载来获取特定的内置类别。</p>
</li>
<li><p>通过调用静态方法 Category.GetCategory（) 的相应重载，按其 ElementId 获取特定类别或子类别。</p>
</li>
<li><p>代码区域 5-1：从文档设置中获取类别</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// Get settings of current document</span></span><br><span class="line">  Settings documentSettings = document.Settings;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get all categories of current document</span></span><br><span class="line">Categories groups = documentSettings.Categories;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Show the number of all the categories to the user</span></span><br><span class="line">String prompt = <span class="string">&quot;Number of all categories in current Revit document:&quot;</span> + groups.Size; </span><br><span class="line"></span><br><span class="line"><span class="comment">// get Floor category according to OST_Floors and show its name</span></span><br><span class="line">Category floorCategory = groups.get_Item(BuiltInCategory.OST_Floors);</span><br><span class="line">prompt += floorCategory.Name;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Give the user some information</span></span><br><span class="line">MessageBox.Show(prompt, <span class="string">&quot;Revit&quot;</span>, MessageBoxButtons.OK);</span><br></pre></td></tr></table></figure></li>
</ul>
<p>Category 的使用方式如下：</p>
<ul>
<li>Category 用于对元素进行分类。元素类别确定某些行为。例如，同一类别中的所有图元都可以包含在同一个明细表中。</li>
<li>元素具有基于其类别的参数。</li>
<li>类别还用于控制 Revit 中的可见性和图形外观。</li>
</ul>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-FD2C68CC-B442-4A39-B507-8965B15B1DCF-low.png" alt="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-FD2C68CC-B442-4A39-B507-8965B15B1DCF-low.png"><br>图 21：按类别划分的可见性</p>
<p>元素的类别由 Category ID 确定。</p>
<ul>
<li>类别 ID 由 ElementId 类表示。</li>
<li>导入的类别 ID 与文档中的元素相对应。</li>
<li>大多数类别都是内置的，它们的 ID 是存储在 ElementId 中的常量。</li>
<li>每个内置类别 ID 在 BuiltInCategory 枚举中都有相应的值。它们可以转换为相应的 BuiltInCategory 枚举类型。</li>
</ul>
<p>如果类别不是内置类别，则 ID 将转换为 null 值。</p>
<p>代码区域 5-2：获取元素类别</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">  Element selectedElement = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">foreach</span> (ElementId id <span class="keyword">in</span> uidoc.Selection.GetElementIds())</span><br><span class="line">    &#123;</span><br><span class="line">        selectedElement = document.GetElement(id);</span><br><span class="line">        <span class="keyword">break</span>;  <span class="comment">// just get one selected element</span></span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Get the category instance from the Category property</span></span><br><span class="line">  Category category = selectedElement.Category;</span><br><span class="line"></span><br><span class="line">BuiltInCategory enumCategory = (BuiltInCategory)category.Id.IntegerValue;</span><br></pre></td></tr></table></figure>

<p>注意：为了避免在使用 Category.Name 时出现全球化问题，BuiltInCategory 是更好的选择。Category.Name 在不同的语言中可能会有所不同。</p>
<h4 id="Family-族"><a href="#Family-族" class="headerlink" title="Family 族"></a>Family 族</h4><p>族是类别中的元素类。族可以按以下方式对图元进行分组：</p>
<ul>
<li>一组通用的参数 （属性）。</li>
<li>相同使用。</li>
<li>类似的图形表示。</li>
</ul>
<p>大多数族都是构件族文件，这意味着您可以将它们加载到项目中或从族模板创建它们。您可以确定属性集和族图形表示。<br>另一种族类型是系统 Family。系统族不可用于加载或创建。Revit 预定义了系统族属性和图形表示;它们包括墙、尺寸、屋顶、楼板（或楼板）和标高。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-428BCB2F-3741-4F05-A51A-9D5A9A03813D-low.png" alt="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-428BCB2F-3741-4F05-A51A-9D5A9A03813D-low.png"></p>
<p>图 22：族</p>
<p>除了用作 Element 类之外，Family 还是用于生成属于 Family 的新项目的模板。</p>
<h4 id="Revit-平台-API-中的族"><a href="#Revit-平台-API-中的族" class="headerlink" title="Revit 平台 API 中的族"></a>Revit 平台 API 中的族</h4><p>在 Revit 平台 API 中，Family 类和 FamilyInstance 都属于构件族。其他元素包括 System Family。</p>
<p>Revit 平台 API 中的族由三个对象表示：</p>
<ul>
<li>Family 族</li>
<li>FamilySymbol  族符号</li>
<li>FamilyInstance  族实例</li>
</ul>
<p>每个对象在 Family 结构中都起着重要作用。</p>
<p>Family 对象具有以下特征：</p>
<ul>
<li>表示整个族，例如梁。</li>
<li>表示磁盘上的整个族文件。</li>
<li>包含许多 FamilySymbol。</li>
</ul>
<p>FamilySymbol 对象表示族中的一组特定族设置，例如类型、混凝土矩形梁：16×32。</p>
<p>FamilyInstance 对象是一个 FamilySymbol 实例，表示 Revit 项目中的单个实例。例如，FamilyInstance 可以是项目中 16×32 混凝土矩形梁的单个实例。</p>
<p>注意：请记住，FamilyInstance 存在于 FamilyInstance 元素、基准元素和注释元素中。</p>
<p>因此，以下规则适用：</p>
<ul>
<li>每个 FamilyInstance 都有一个 FamilySymbol。</li>
<li>每个 FamilySymbol 都属于一个 Family。</li>
<li>每个 Family 都包含一个或多个 FamilySymbol。</li>
</ul>
<p>有关更多详细信息，请参阅系列实例。</p>
<h4 id="ElementType-元素类型"><a href="#ElementType-元素类型" class="headerlink" title="ElementType 元素类型"></a>ElementType 元素类型</h4><p>在 Revit Platform API 中，符号通常是用于定义实例的不可见图元。Symbols 在用户界面中称为Types。</p>
<ul>
<li>Type可以是族中的特定大小，例如 1730 × 2032 的门，也可以是 8×4×1&#x2F;2 的角度。</li>
<li>Type可以是样式，例如尺寸的默认线性或默认角度样式。</li>
</ul>
<p>Symbols表示包含一组类似元素的共享数据的元素。在某些情况下，Symbols表示可以从仓库获取的建筑构件，例如门或窗，并且可以在同一建筑物中多次放置。在其他情况下，Symbols 包含主机对象参数或其他元素。例如，WallType Symbol 包含特定墙壁类型的厚度、层数、每层的材料以及其他属性。</p>
<p>FamilySymbol 是 API 中的一个Symbols。它在 Revit 用户界面中也称为族类型。FamilySymbol 是族中的一类图元，其所有属性的值都完全相同。例如，所有 32×78 个六面板门都属于一种类型，而所有 24×80 个六面板门都属于另一种类型。与 Family 一样，FamilySymbol 也是一个模板。FamilySymbol 对象派生自 ElementType 对象和 Element 对象。</p>
<p>Instance 实例</p>
<p>实例是在建筑 （模型实例） 或绘图图纸 （注释实例） 上具有特定位置的项。Instance 表示 ElementType 的转换后的相同副本。例如，如果建筑物包含 20 个特定类型的窗户，则有一个 ElementType 具有 20 个实例。实例在用户界面中称为 Components。</p>
<p>注意：对于 FamilyInstance，可以使用 Symbol 属性而不是 GetTypeId（） 方法来获取相应的 FamilySymbol。它既方便又安全，因为您不需要进行类型转换。</p>
<h2 id="元素检索"><a href="#元素检索" class="headerlink" title="元素检索"></a>元素检索</h2><p>Revit中的图元非常常见。在对任何 Element 命令使用 API 之前，必须从 Revit 中检索所需的图元。有几种方法可以使用 Revit API 检索图元：</p>
<ul>
<li>ElementId - 如果元素的 ElementId 已知，则可以从文档中检索该元素。</li>
<li>元素过滤和迭代 - 这是检索文档中一组相关元素的好方法。</li>
<li>选定元素 - 检索用户已选定的元素集</li>
<li>特定元素 - 某些元素可用作文档的属性</li>
</ul>
<p>以下各节将更详细地讨论这些元素检索方法中的每一种。</p>
<h4 id="按-ID-获取元素"><a href="#按-ID-获取元素" class="headerlink" title="按 ID 获取元素"></a>按 ID 获取元素</h4><p>当所需元素的 ElementId 已知时，请使用 Document.Element 属性获取该元素。</p>
<h4 id="筛选-Elements-集合"><a href="#筛选-Elements-集合" class="headerlink" title="筛选 Elements 集合"></a>筛选 Elements 集合</h4><p>获取文档中元素的最常见方法是使用筛选来检索元素集合。Revit API 提供了 FilteredElementCollector 类和支持类，用于创建经过过滤的元素集合，然后可以迭代这些元素。有关更多信息，请参阅筛选。</p>
<h4 id="Selection-选择"><a href="#Selection-选择" class="headerlink" title="Selection 选择"></a>Selection 选择</h4><p>您可以只访问已选择的元素，而不是获取模型中所有元素的过滤集合。您可以使用 UIDocument.Selection.GetElementIds 方法从当前活动文档中获取所选对象。有关使用活动选择的更多信息，请参阅选择。</p>
<h4 id="从文档中访问特定元素"><a href="#从文档中访问特定元素" class="headerlink" title="从文档中访问特定元素"></a>从文档中访问特定元素</h4><p>除了使用常规方式访问图元外，Revit Platform API 还在 Document 类中具有属性，用于从当前活动文档中获取指定的图元，而无需迭代所有图元。下表列出了您可以检索的指定元素。</p>
<p>表 11：从文档属性中检索元素</p>
<table>
<thead>
<tr>
<th><strong>Element 元素</strong></th>
<th><strong>Document 属性中的访问</strong></th>
</tr>
</thead>
<tbody><tr>
<td>ProjectInfo 项目信息</td>
<td>Document.ProjectInformation</td>
</tr>
<tr>
<td>ProjectLocation 项目位置</td>
<td>Document.ProjectLocations</td>
</tr>
<tr>
<td>SiteLocation 站点位置</td>
<td>Document.SiteLocation</td>
</tr>
<tr>
<td>Phase 阶段</td>
<td>Document.Phases</td>
</tr>
</tbody></table>
<h2 id="一般属性"><a href="#一般属性" class="headerlink" title="一般属性"></a>一般属性</h2><p>以下特性对于使用 Revit 创建的每个图元都是通用的。</p>
<h4 id="ElementId-元素-Id"><a href="#ElementId-元素-Id" class="headerlink" title="ElementId 元素 Id"></a>ElementId 元素 Id</h4><p>活动文档中的每个元素都有一个唯一标识符，由 ElementId 存储类型表示。ElementId 对象是项目范围的。它是一个唯一编号，在元素模型中永远不会改变，这使得它可以存储在外部，以便在需要时检索元素。<br>在 Revit Platform API 中，您可以直接创建 ElementId，然后将唯一整数值与新的 ElementId 关联。默认情况下，新的 ElementId 值为 0。</p>
<p>代码区域 5-3：设置 ElementId</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Get the id of the element</span></span><br><span class="line">Autodesk.Revit.DB.ElementId selectedId = element.Id;</span><br><span class="line"><span class="built_in">int</span> idInteger = selectedId.IntegerValue;</span><br><span class="line"></span><br><span class="line"><span class="comment">// create a new id and set the value</span></span><br><span class="line">Autodesk.Revit.DB.ElementId id = <span class="keyword">new</span> Autodesk.Revit.DB.ElementId(idInteger);</span><br></pre></td></tr></table></figure>

<p>ElementId 具有以下用途：</p>
<p>使用 ElementId 从 Revit 中检索特定图元。从 Revit Application 类中，获取对活动文档的访问权限，然后使用Document.GetElement（ElementId） 方法获取指定的元素。</p>
<p>代码区域 5-4：使用 ElementId</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Get the id of the element</span></span><br><span class="line">Autodesk.Revit.DB.ElementId selectedId = element.Id;</span><br><span class="line"><span class="built_in">int</span> idInteger = selectedId.IntegerValue;</span><br><span class="line"></span><br><span class="line"><span class="comment">// create a new id and set the value</span></span><br><span class="line">Autodesk.Revit.DB.ElementId id = <span class="keyword">new</span> Autodesk.Revit.DB.ElementId(idInteger);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get the element </span></span><br><span class="line">Autodesk.Revit.DB.Element first = document.GetElement(id);</span><br></pre></td></tr></table></figure>

<p>如果项目中不存在 ID 号，则检索的元素为 null。</p>
<p>使用 ElementId 检查一个项目中的两个元素是否相等。不建议使用 Object.Equal（） 方法。</p>
<h4 id="UniqueId-唯一-Id"><a href="#UniqueId-唯一-Id" class="headerlink" title="UniqueId 唯一 Id"></a>UniqueId 唯一 Id</h4><p>每个元素都有一个 UniqueId，由 String 存储类型表示。UniqueId 对应于 ElementId。但是，与 ElementId 不同，UniqueId 的功能类似于 GUID（全局唯一标识符），它在单独的 Revit 项目中是唯一的。UniqueId 可以帮助您在将 Revit 项目文件导出为其他格式时跟踪元素。</p>
<p>代码区域 5-5：UniqueId</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">String uniqueId = element.UniqueId;</span><br></pre></td></tr></table></figure>

<p>注意：ElementId 仅在当前项目中是唯一的。它在单独的 Revit 项目中不是唯一的。UniqueId 在单独的项目中始终是唯一的。</p>
<h4 id="Location-位置"><a href="#Location-位置" class="headerlink" title="Location 位置"></a>Location 位置</h4><p>在建筑建模过程中，对象的位置非常重要。在Revit中，某些对象具有点位置。例如，一个表有一个点位置。其他对象具有线位置，表示位置曲线或根本没有位置。墙是具有线位置的元素。</p>
<p>Revit Platform API 为大多数图元提供 Location 类和位置功能。例如，它具有 Move（） 和 Rotate（） 方法来平移和旋转元素。但是，Location 类没有可以从中获取坐标等信息的属性。在这种情况下，将 Location 对象降级到其子类（如 LocationPoint 或 LocationCurve），以获取更详细的位置信息并使用对象派生进行控制。</p>
<p>在获取对象的几何图形时，检索元素在项目中的物理位置非常有用。检索位置时，以下规则适用：<br>Wall、Beam 和 Brace 使用 LocationCurve 进行曲线驱动。</p>
<p>Room、RoomTag、SpotDimension、Group、非曲线驱动的 FamilyInstances 以及所有 In-Place-FamilyInstances 都使用 LocationPoint。</p>
<p>在 Revit Platform API 中，曲线驱动意味着元素的几何图形或位置由一个或多个关联的曲线确定。几乎所有的分析模型元素都是曲线驱动的 - 线性荷载和面积荷载、墙、框架元素等。</p>
<p>其他元素无法检索 LocationCurve 或 LocationPoint。他们返回“Location ”，但未提供任何信息。</p>
<p>表 12：元素位置信息</p>
<table>
<thead>
<tr>
<th><strong>位置信息</strong></th>
<th><strong>Elements 元素</strong></th>
</tr>
</thead>
<tbody><tr>
<td>LocationCurve 位置曲线</td>
<td>Wall, Beam, Brace, Structural Truss, LineLoad(without host)</td>
</tr>
<tr>
<td>LocationPoint 位置点</td>
<td>Room, RoomTag, SpotDimension, Group, Column, Mass</td>
</tr>
<tr>
<td>Only Location 仅位置</td>
<td>Level, Floor, some Tags, BeamSystem, Rebar, Reinforcement, PointLoad, AreaLoad(without Host), Span Direction(IndependentTag)</td>
</tr>
<tr>
<td>No Location 无位置</td>
<td>View, LineLoad(with host), AreaLoad(with Host), BoundaryCondition</td>
</tr>
</tbody></table>
<p>注意：还有其他没有 Location 信息的元素。例如，LineLoad（带 host）或 AreaLoad（带 host）没有 Location。</p>
<p>某些 FamilyInstance LocationPoints（例如所有就地 FamilyInstances 和 mass）在创建时被指定为点 （0， 0， 0）。如果转换或移动实例，则 LocationPoint 坐标将更改。</p>
<p>若要更改 Group-s LocationPoint，请执行下列操作之一：</p>
<ul>
<li>在Revit UI中拖动组原点以更改LocationPoint坐标。在此情况下，组 LocationPoint 将更改，而 Group-s 的位置不会更改。</li>
<li>使用 ElementTransformUtils.MoveElement（） 方法移动组以更改 LocationPoint。这将更改 Group location 和 LocationPoint。</li>
</ul>
<p>有关 LocationCurve 和 LocationPoint 的更多信息，请参阅移动元素。</p>
<h4 id="Level-标高"><a href="#Level-标高" class="headerlink" title="Level 标高"></a>Level 标高</h4><p>楼层是有限的水平平面，用作楼层托管或基于楼层的元素（如屋顶、地板和天花板）的参考。Revit Platform API 提供了一个 Level 类，用于表示 Revit 中的标高线。如果元素是基于Level 的，请使用 API 获取元素分配到的 Level 对象。</p>
<p>代码区域 5-6：分配标高</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Get the level object to which the element is assigned.</span></span><br><span class="line"><span class="keyword">if</span> (element.LevelId.Equals(ElementId.InvalidElementId))</span><br><span class="line">&#123;</span><br><span class="line">    TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>,<span class="string">&quot;The element isn&#x27;t based on a level.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    Level level = element.Document.GetElement(element.LevelId) <span class="keyword">as</span> Level;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Format the prompt information(Name and elevation)</span></span><br><span class="line">    String prompt = <span class="string">&quot;The element is based on a level.&quot;</span>;</span><br><span class="line">    prompt += <span class="string">&quot;\nThe level name is:  &quot;</span> + level.Name;</span><br><span class="line">    prompt += <span class="string">&quot;\nThe level elevation is:  &quot;</span> + level.Elevation;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Show the information to the user.</span></span><br><span class="line">    TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>,prompt);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>许多元素（如柱）使用标高作为基本参考。当您获取柱标高时，您检索的标高是基础标高。</p>
<p>注意：使用 Reference Level 参数获取 Beam 或 Brace 标高。从 Level 属性中，您只会获得 null，而不是引用标高信息。标高是 Revit 中最常用的图元。在 Revit 平台 API 中，使用“level  ”过滤器检索所有标高。</p>
<p>有关更多级别详细信息，请参阅基准和信息元素。</p>
<h4 id="Parameter-参数"><a href="#Parameter-参数" class="headerlink" title="Parameter 参数"></a>Parameter 参数</h4><p>每个元素都有一组参数，用户可以在Revit中查看和编辑这些参数。参数在“元素属性”对话框中可见（选择任何元素，然后单击类型选择器旁边的“属性”按钮）。例如，下图显示了房间参数。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-78903670-DCD6-473B-AA90-45A0AA31B65D-low.png" alt="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-78903670-DCD6-473B-AA90-45A0AA31B65D-low.png"></p>
<p>图 25：Room 参数</p>
<p>在 Revit Platform API 中，每个 Element 对象都有一个 Parameters 属性，该属性是附加到 Element 的所有属性的集合。您可以更改集合中的属性值。例如，您可以从房间对象参数中获取房间的面积;此外，您还可以使用房间对象参数设置房间号。Parameter 是提供对元素对象中未公开的属性信息的访问的另一种方法。</p>
<p>通常，每个元素参数都有一个关联的参数 ID。参数 ID 由 ElementId 类表示。对于用户创建的参数，ID 对应于文档中的实际元素。但是，大多数参数都是内置的，其 ID 是存储在 ElementIds 中的常量。</p>
<p>参数是元素中数据存储的通用形式。在 Revit Platform API 中，最好使用内置参数 ID 来获取参数。Revit 具有大量使用 BuiltInParameter 枚举类型的内置参数。</p>
<p>有关详细信息，请参阅参数说明。</p>
<h2 id="注：翻译自Revit-API-Developers-Guide"><a href="#注：翻译自Revit-API-Developers-Guide" class="headerlink" title="注：翻译自Revit API Developers Guide"></a><em><strong>注：</strong></em>翻译自<a href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_html">Revit API Developers Guide</a></h2>]]></content>
      <categories>
        <category>Revit二次开发人员指南</category>
      </categories>
      <tags>
        <tag>Revit</tag>
      </tags>
  </entry>
  <entry>
    <title>05过滤</title>
    <url>/2024/11/26/Revit%E4%BA%8C%E5%BC%80%E6%8C%87%E5%8D%97/05%E8%BF%87%E6%BB%A4/</url>
    <content><![CDATA[<h1 id="Filtering-过滤"><a href="#Filtering-过滤" class="headerlink" title="Filtering 过滤"></a>Filtering 过滤</h1><p>Revit API提供了一种过滤和迭代Revit文档中图元的机制。这是获取一组相关元素（如文档中的所有墙或门）的最佳方法。过滤器也可以用来找到一个非常具体的元素集，如所有特定大小的梁。</p>
<p>获取通过指定过滤器的元素的基本步骤如下：</p>
<ol>
<li>创建新的FilteredElementCollector</li>
<li>对它应用一个或多个过滤器</li>
<li>获取过滤后的元素或元素ID（使用以下几种方法之一）</li>
</ol>
<p>下面的示例涵盖了在文档中筛选和迭代元素的基本步骤。</p>
<p><strong>代码区域6-1：使用元素过滤获取文档中的所有墙实例</strong></p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Find all Wall instances in the document by using category filter</span></span><br><span class="line">ElementCategoryFilter filter = <span class="keyword">new</span> ElementCategoryFilter(BuiltInCategory.OST_Walls);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Apply the filter to the elements in the active document</span></span><br><span class="line"><span class="comment">// Use shortcut WhereElementIsNotElementType() to find wall instances only</span></span><br><span class="line">FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">IList walls = </span><br><span class="line">collector.WherePasses(filter).WhereElementIsNotElementType().ToElements();</span><br><span class="line">String prompt = <span class="string">&quot;The walls in the current document are:\n&quot;</span>;</span><br><span class="line"><span class="keyword">foreach</span> (Element e <span class="keyword">in</span> walls)</span><br><span class="line">&#123;</span><br><span class="line">        prompt += e.Name + <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>, prompt);</span><br></pre></td></tr></table></figure>

<p><strong>Pages in this section 本节中的页面</strong></p>
<ul>
<li>创建FilteredElementCollector</li>
<li>应用过滤器</li>
<li>获取筛选的元素或元素ID</li>
<li>LINQ查询</li>
<li>边界框过滤器</li>
<li>元素交叉过滤器</li>
</ul>
<h2 id="创建FilteredElementCollector"><a href="#创建FilteredElementCollector" class="headerlink" title="创建FilteredElementCollector"></a>创建FilteredElementCollector</h2><p>用于元素迭代和筛选的主类称为FilteredElementCollector。它以三种方式之一构建：</p>
<ol>
<li>从文档-将搜索和筛选文档中的元素集</li>
<li>从一个文档和一组ElementId-将搜索和筛选一组指定的元素</li>
<li>从文档和视图-将搜索和过滤视图中的可见元素</li>
</ol>
<p><em><strong>注意：</strong></em>使用静态FilteredElementCollector.IsViewValidForElementIteration()过滤指定视图中的元素时，请始终检查视图是否对元素迭代有效。</p>
<p>首次创建对象时，没有应用任何过滤器。此类要求在尝试访问元素之前至少设置一个条件，否则将引发异常。</p>
<h2 id="应用过滤器"><a href="#应用过滤器" class="headerlink" title="应用过滤器"></a>应用过滤器</h2><p>可以使用ElementFilters将筛选器应用于FilteredElementCollector。ElementFilter是一个类，它检查元素以查看它是否满足特定条件。ElementFilter基类有三个派生类，它们将元素筛选器分为三个类别。</p>
<ul>
<li><em><strong>ElementQuickFilter</strong></em>-快速过滤器仅在ElementRecord上操作，ElementRecord是一个低内存类，它具有有限的读取元素属性的接口。被快速筛选器拒绝的元素将不会在内存中展开。</li>
<li><em><strong>ElementSlowFilter</strong></em>-慢过滤器要求首先获取元素并在内存中展开。因此，最好将慢速过滤器与至少一个ElementQuickFilter耦合，这应该最小化扩展的元素数量，以便根据该过滤器设置的标准进行评估。</li>
<li><em><strong>ElementLogicalFilter</strong></em>-逻辑筛选器将联合收割机两个或多个筛选器逻辑组合。Revit可能会对构件过滤器重新排序，以使最快作用的过滤器首先被评估。</li>
</ul>
<p>大多数过滤器可以使用重载构造函数来反转，该重载构造函数接受指示反转过滤器的布尔参数，以便通常被过滤器接受的元素将被拒绝，而通常被拒绝的元素将被接受。不能反转的过滤器在下面的相应部分中注明。</p>
<p>有一组预定义的过滤器可用于常见用途。这些内置过滤器中的许多都为上面的FilteredElementCollector部分中提到的FilteredElementCollector快捷方法提供了基础。接下来的三个部分提供了有关内置过滤器的更多信息。</p>
<p>创建筛选器后，需要将其应用于FilteredElementCollector。泛型方法WherePasses()用于将单个ElementFilter应用于FilteredElementCollector。</p>
<p>还可以使用FilteredElementCollector提供的许多快捷方法应用筛选器。有些应用一个特定的过滤器而不需要进一步的输入，比如WhereElementIsCurveDriven()，而其他应用一个特定的过滤器而只需要一个简单的输入，比如OfCategory()方法，它将BuiltInCategory作为一个参数。最后，还有一些方法，如UnionWith()，可以将过滤器连接在一起。所有这些方法都返回相同的收集器，从而可以轻松地将过滤器链接在一起。</p>
<h3 id="Quick-filters-快速筛选器"><a href="#Quick-filters-快速筛选器" class="headerlink" title="Quick filters 快速筛选器"></a>Quick filters 快速筛选器</h3><p>快速过滤器只在ElementRecord上操作，ElementRecord是一个低内存类，它具有有限的读取元素属性的接口。被快速筛选器拒绝的元素将不会在内存中展开。下表总结了内置的快速过滤器，下面是一些过滤器的示例。</p>
<p><strong>Table 13: Built-in Quick Filters<br>表13：内置快速过滤器</strong></p>
<table>
<thead>
<tr>
<th><strong>Built-in Filter 内置过滤器</strong></th>
<th><strong>What it passes 它所经过的</strong></th>
<th><strong>Shortcut Method(s) 快捷方法</strong></th>
</tr>
</thead>
<tbody><tr>
<td>BoundingBoxContainsPointFilter</td>
<td>具有包含给定点的边界框的元素</td>
<td>None</td>
</tr>
<tr>
<td>BoundingBoxIntersectsFilter</td>
<td>具有与给定轮廓相交的边界框的元素</td>
<td>None</td>
</tr>
<tr>
<td>BoundingBoxIsInsideFilter</td>
<td>在给定轮廓内有边界框的元素</td>
<td>None</td>
</tr>
<tr>
<td>ElementCategoryFilter</td>
<td>id 与输入类别id匹配的元素</td>
<td>OfCategoryId()</td>
</tr>
<tr>
<td>ElementClassFilter</td>
<td>与输入运行时类（或派生类）匹配的元素</td>
<td>OfClass()</td>
</tr>
<tr>
<td>ElementDesignOptionFilter</td>
<td>特定设计选项中的图元</td>
<td>ContainedInDesignOption()</td>
</tr>
<tr>
<td>ElementIsCurveDrivenFilter</td>
<td>曲线驱动的元素</td>
<td>WhereElementIsCurveDriven()</td>
</tr>
<tr>
<td>ElementIsElementTypeFilter</td>
<td>属于“元素类型”的元素</td>
<td>WhereElementIsNotElementType()</td>
</tr>
<tr>
<td>ElementMulticategoryFilter</td>
<td>与给定类别集中的任何一个相匹配的元素</td>
<td>None</td>
</tr>
<tr>
<td>ElementMulticlassFilter</td>
<td>与给定的类（或派生类）集匹配的元素</td>
<td>None</td>
</tr>
<tr>
<td>ElementOwnerViewFilter</td>
<td>视图专有的图元</td>
<td>OwnedByView()<br />WhereElementIsViewIndependent()</td>
</tr>
<tr>
<td>ElementStructuralTypeFilter</td>
<td>与给定结构类型匹配的元素</td>
<td>None</td>
</tr>
<tr>
<td>ExclusionFilter</td>
<td>除元素id之外的所有元素都输入到过滤器</td>
<td>Excluding()</td>
</tr>
<tr>
<td>FamilySymbolFilter</td>
<td>特定族的Symbol</td>
<td></td>
</tr>
</tbody></table>
<p><strong>注意：</strong>FamilySymbolFilter不能反转。</p>
<p><strong>注意：</strong>边界框过滤器排除所有从View派生的对象和从ElementType派生的对象。 下面的示例在文档中创建一个大纲，然后使用BoundingBoxIntersectsFilter查找文档中具有与该大纲相交的边界框的元素。然后，它展示了如何使用反向过滤器来查找边界框不与给定轮廓相交的所有墙。请注意，使用OfClass()方法也会将ElementClassFilter应用于集合。</p>
<p><strong>代码区域6-2：BoundingBoxIntersectsFilter示例</strong></p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Use BoundingBoxIntersects filter to find elements with a bounding box that intersects the </span></span><br><span class="line"><span class="comment">// given Outline in the document.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a Outline, uses a minimum and maximum XYZ point to initialize the outline. </span></span><br><span class="line">Outline myOutLn = <span class="keyword">new</span> Outline(<span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="keyword">new</span> XYZ(<span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a BoundingBoxIntersects filter with this Outline</span></span><br><span class="line">BoundingBoxIntersectsFilter filter = <span class="keyword">new</span> BoundingBoxIntersectsFilter(myOutLn);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Apply the filter to the elements in the active document</span></span><br><span class="line"><span class="comment">// This filter excludes all objects derived from View and objects derived from ElementType</span></span><br><span class="line">FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">IList elements = collector.WherePasses(filter).ToElements();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Find all walls which don&#x27;t intersect with BoundingBox: use an inverted filter </span></span><br><span class="line"><span class="comment">// to match elements</span></span><br><span class="line"><span class="comment">// Use shortcut command OfClass() to find walls only</span></span><br><span class="line">BoundingBoxIntersectsFilter invertFilter = <span class="keyword">new</span> BoundingBoxIntersectsFilter(myOutLn, <span class="literal">true</span>);</span><br><span class="line">collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">IList notIntersectWalls = collector.OfClass(<span class="keyword">typeof</span>(Wall)).WherePasses(invertFilter).ToElements();</span><br></pre></td></tr></table></figure>

<p>下一个示例使用排除过滤器查找文档中当前未选定的所有墙。</p>
<p>代码区域6-3：创建排除过滤器</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Find all walls that are not currently selected, </span></span><br><span class="line"><span class="comment">// Get all element ids which are current selected by users, exclude these ids when filtering</span></span><br><span class="line">ICollection selectedIds = uiDocument.Selection.GetElementIds();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Use the selection to instantiate an exclusion filter</span></span><br><span class="line">ExclusionFilter filter = <span class="keyword">new</span> ExclusionFilter(selectedIds);</span><br><span class="line"><span class="comment">// For the sake of simplicity we do not test here whether the selection is empty or not,</span></span><br><span class="line"><span class="comment">// but in production code a proper validation would have to be done to avoid an argument</span></span><br><span class="line"><span class="comment">// exception from the filter&#x27;s consructor.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Apply the filter to the elements in the active document,</span></span><br><span class="line"><span class="comment">// Use shortcut method OfClass() to find Walls only</span></span><br><span class="line">FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(uiDocument.Document);</span><br><span class="line">IList walls = collector.WherePasses(filter).OfClass(<span class="keyword">typeof</span>(Wall)).ToElements();</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>ElementClassFilter将匹配其类与输入类完全匹配的元素，或其类派生自输入类的元素。下面的示例使用ElementClassFilter获取文档中的所有加载。</p>
<p>代码区域6-4：使用ElementClassFilter获取负载</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Use ElementClassFilter to find all loads in the document</span></span><br><span class="line"><span class="comment">// Using typeof(LoadBase) will yield all AreaLoad, LineLoad and PointLoad</span></span><br><span class="line">ElementClassFilter filter = <span class="keyword">new</span> ElementClassFilter(<span class="keyword">typeof</span>(LoadBase));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Apply the filter to the elements in the active document</span></span><br><span class="line">FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">ICollection allLoads = collector.WherePasses(filter).ToElements();</span><br></pre></td></tr></table></figure>

<p>API中有一小部分元素子类不受元素类过滤器支持。这些类型存在于API中，但不存在于Revit的本机对象模型中，这意味着此过滤器不支持这些类型。为了使用类过滤器来查找这些类型的元素，需要使用更高级别的类，然后进一步处理结果以查找仅匹配子类型的元素。</p>
<p><strong>注：</strong>其中一些类型存在专用过滤器。 以下类型受此限制影响：</p>
<table>
<thead>
<tr>
<th><strong>Type 类型</strong></th>
<th><strong>Dedicated Filter 专用过滤器</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Autodesk.Revit.DB.Material的子类</td>
<td>None</td>
</tr>
<tr>
<td>Autodesk.Revit.DB.CurveElement的子类</td>
<td>CurveElementFilter</td>
</tr>
<tr>
<td>Autodesk.Revit.DB.ConnectorElement的子类</td>
<td>None</td>
</tr>
<tr>
<td>Autodesk.Revit.DB.HostedSweep的子类</td>
<td>None</td>
</tr>
<tr>
<td>Autodesk.Revit.DB.Architecture.Room</td>
<td>RoomFilter</td>
</tr>
<tr>
<td>Autodesk.Revit.DB.Mechanical.Space</td>
<td>SpaceFilter</td>
</tr>
<tr>
<td>Autodesk.Revit.DB.Area</td>
<td>AreaFilter</td>
</tr>
<tr>
<td>Autodesk.Revit.DB.Architecture.RoomTag</td>
<td>RoomTagFilter</td>
</tr>
<tr>
<td>Autodesk.Revit.DB.Mechanical.SpaceTag</td>
<td>SpaceTagFilter</td>
</tr>
<tr>
<td>Autodesk.Revit.DB.AreaTag</td>
<td>AreaTagFilter</td>
</tr>
<tr>
<td>Autodesk.Revit.DB.CombinableElement</td>
<td>None</td>
</tr>
<tr>
<td>Autodesk.Revit.DB.Mullion</td>
<td>None</td>
</tr>
<tr>
<td>Autodesk.Revit.DB.Panel</td>
<td>None</td>
</tr>
<tr>
<td>Autodesk.Revit.DB.AnnotationSymbol</td>
<td>None</td>
</tr>
<tr>
<td>Autodesk.Revit.DB.Structure.AreaReinforcementType</td>
<td>None</td>
</tr>
<tr>
<td>Autodesk.Revit.DB.Structure.PathReinforcementType</td>
<td>None</td>
</tr>
<tr>
<td>Autodesk.Revit.DB.AnnotationSymbolType</td>
<td>None</td>
</tr>
<tr>
<td>Autodesk.Revit.DB.Architecture.RoomTagType</td>
<td>None</td>
</tr>
<tr>
<td>Autodesk.Revit.DB.Mechanical.SpaceTagType</td>
<td>None</td>
</tr>
<tr>
<td>Autodesk.Revit.DB.AreaTagType</td>
<td>None</td>
</tr>
<tr>
<td>Autodesk.Revit.DB.Structure.TrussType</td>
<td>None</td>
</tr>
</tbody></table>
<h3 id="Slow-Filters-慢过滤器"><a href="#Slow-Filters-慢过滤器" class="headerlink" title="Slow Filters 慢过滤器"></a>Slow Filters 慢过滤器</h3><p>慢过滤器要求首先获得元素并在内存中展开。因此，最好将慢速过滤器与至少一个ElementQuickFilter耦合，这应该最小化扩展的元素数量，以便根据该过滤器设置的标准进行评估。下表总结了内置的慢速过滤器，下面的几个示例提供了对某些过滤器的深入了解。</p>
<p><strong>表14：内置慢速过滤器</strong></p>
<table>
<thead>
<tr>
<th><strong>Built-in Filter 内置过滤器</strong></th>
<th><strong>What it passes 它所经过的</strong></th>
<th><strong>Shortcut Method(s) 快捷方法</strong></th>
</tr>
</thead>
<tbody><tr>
<td>AreaFilter</td>
<td>Areas 区域</td>
<td>None</td>
</tr>
<tr>
<td>AreaTagFilter</td>
<td>Area tags 面积标记</td>
<td>None</td>
</tr>
<tr>
<td>CurveElementFilter</td>
<td>CurveElements 曲线元素</td>
<td>None</td>
</tr>
<tr>
<td>ElementLevelFilter</td>
<td>与给定级别ID关联的元素</td>
<td>None</td>
</tr>
<tr>
<td>ElementParameterFilter</td>
<td>元素传递一个或多个参数筛选规则</td>
<td>None</td>
</tr>
<tr>
<td>ElementPhaseStatusFilter</td>
<td>给定阶段上具有给定阶段状态的元素</td>
<td>None</td>
</tr>
<tr>
<td>FamilyInstanceFilter</td>
<td>一个特定的族实例</td>
<td>None</td>
</tr>
<tr>
<td>FamilyStructuralMaterialTypeFilter</td>
<td>给定结构材料类型的族元素</td>
<td>None</td>
</tr>
<tr>
<td>PrimaryDesignOptionMemberFilter</td>
<td>任何主设计选项所拥有的图元</td>
<td>None</td>
</tr>
<tr>
<td>RoomFilter</td>
<td>房间</td>
<td>None</td>
</tr>
<tr>
<td>RoomTagFilter</td>
<td>房间标记</td>
<td>None</td>
</tr>
<tr>
<td>SpaceFilter</td>
<td>空间</td>
<td>None</td>
</tr>
<tr>
<td>SpaceTagFilter</td>
<td>空间标签</td>
<td>None</td>
</tr>
<tr>
<td>StructuralInstanceUsageFilter</td>
<td>给定结构用途的族</td>
<td>None</td>
</tr>
<tr>
<td>StructuralMaterialTypeFilter</td>
<td>给定结构材料类型的族</td>
<td>None</td>
</tr>
<tr>
<td>StructuralWallUsageFilter</td>
<td>指定结构墙用途的墙</td>
<td>None</td>
</tr>
<tr>
<td>Element Intersection Filters</td>
<td>与给定图元的实体几何相交的图元</td>
<td>None</td>
</tr>
<tr>
<td>Element Intersection Filters</td>
<td>与给定实体几何相交的元素</td>
<td>None</td>
</tr>
</tbody></table>
<p>以下慢速过滤器不能反转： <em>RoomFilter</em> RoomTagFilter <em>AreaFilter</em> AreaTagFilter <em>SpaceFilter</em> * </p>
<p>FamilyInstanceFilter 如快速过滤器一节所述，有些类不能与ElementClassFilter一起使用。其中一些类，如Room和RoomTag有自己的专用过滤器。</p>
<p> 代码区域6-5：使用房间过滤器</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Use a RoomFilter to find all room elements in the document. It is necessary to use the </span></span><br><span class="line"><span class="comment">// RoomFilter and not an ElementClassFilter or the shortcut method OfClass() because the Room </span></span><br><span class="line"><span class="comment">// class is not supported by those methods.</span></span><br><span class="line">RoomFilter filter = <span class="keyword">new</span> RoomFilter();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Apply the filter to the elements in the active document</span></span><br><span class="line">FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">IList rooms = collector.WherePasses(filter).ToElements();</span><br></pre></td></tr></table></figure>

<p>ElementParameterFilter是一个功能强大的过滤器，可以根据元素可能具有的参数值查找元素。它可以查找参数值与特定值匹配或大于或小于某个值的元素。ElementParameterFilter还可用于查找支持特定共享参数的元素。 下面的示例使用ElementParameterFilter查找大小超过100平方英尺的房间和小于100平方英尺的房间。</p>
<p>代码区域6-6：使用参数过滤器</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Creates an ElementParameter filter to find rooms whose area is </span></span><br><span class="line"><span class="comment">// greater than specified value</span></span><br><span class="line"><span class="comment">// Create filter by provider and evaluator </span></span><br><span class="line">BuiltInParameter areaParam = BuiltInParameter.ROOM_AREA;</span><br><span class="line"><span class="comment">// provider</span></span><br><span class="line">ParameterValueProvider pvp = <span class="keyword">new</span> ParameterValueProvider(<span class="keyword">new</span> ElementId((<span class="built_in">int</span>)areaParam));</span><br><span class="line"><span class="comment">// evaluator</span></span><br><span class="line">FilterNumericRuleEvaluator fnrv = <span class="keyword">new</span> FilterNumericGreater();</span><br><span class="line"><span class="comment">// rule value </span></span><br><span class="line"><span class="built_in">double</span> ruleValue = <span class="number">100.0f</span>;      <span class="comment">// filter room whose area is greater than 100 SF</span></span><br><span class="line"><span class="comment">// rule</span></span><br><span class="line">FilterRule fRule = <span class="keyword">new</span> FilterDoubleRule(pvp, fnrv, ruleValue, <span class="number">1E-6</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create an ElementParameter filter</span></span><br><span class="line">ElementParameterFilter filter = <span class="keyword">new</span> ElementParameterFilter(fRule);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Apply the filter to the elements in the active document</span></span><br><span class="line">FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">IList rooms = collector.WherePasses(filter).ToElements();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Find rooms whose area is less than or equal to 100: </span></span><br><span class="line"><span class="comment">// Use inverted filter to match elements</span></span><br><span class="line">ElementParameterFilter lessOrEqualFilter = <span class="keyword">new</span> ElementParameterFilter(fRule, <span class="literal">true</span>); </span><br><span class="line">collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">IList lessOrEqualFounds = collector.WherePasses(lessOrEqualFilter).ToElements();</span><br></pre></td></tr></table></figure>

<p>下面的示例显示如何使用FamilyStructuralMaterialTypeFilter查找材质类型为木材的所有族。它还说明了如何使用反向过滤器来查找材质类型不是木材的所有族。</p>
<p>代码区域6-7：查找所有使用木质材料的家庭</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Use FamilyStructuralMaterialType filter to find families whose material type is Wood</span></span><br><span class="line">FamilyStructuralMaterialTypeFilter filter = <span class="keyword">new</span> FamilyStructuralMaterialTypeFilter(StructuralMaterialType.Wood);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Apply the filter to the elements in the active document</span></span><br><span class="line">FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">ICollection woodFamiles = collector.WherePasses(filter).ToElements();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Find families are not Wood: Use inverted filter to match families</span></span><br><span class="line">FamilyStructuralMaterialTypeFilter notWoodFilter = </span><br><span class="line">        <span class="keyword">new</span> FamilyStructuralMaterialTypeFilter(StructuralMaterialType.Wood, <span class="literal">true</span>);</span><br><span class="line">collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">ICollection notWoodFamilies = collector.WherePasses(notWoodFilter).ToElements();</span><br></pre></td></tr></table></figure>

<p>最后两个慢过滤器派生自ElementIntersectsFilter，后者是用于匹配与几何体相交的元素的过滤器的基类。有关此类过滤器的使用示例，请参见几何工具类一节中的代码区域：查找附近的墙。#逻辑过滤器逻辑过滤器联合收割机将两个或多个过滤器逻辑组合。下表总结了内置的逻辑筛选器。表15：内置逻辑过滤器</p>
<table>
<thead>
<tr>
<th><strong>Built-in Filter 内置过滤器</strong></th>
<th><strong>What it passes 它所经过的</strong></th>
<th><strong>Shortcut Method(s) 快捷方法</strong></th>
</tr>
</thead>
<tbody><tr>
<td>LogicalAndFilter</td>
<td>通过2个或更多过滤器的元素</td>
<td>WherePasses()-添加一个额外的过滤器IntersectWith()-连接两组独立的过滤器</td>
</tr>
<tr>
<td>LogicalOrFilter</td>
<td>至少通过2个或多个过滤器之一的元素</td>
<td>UnionWith()-连接两组独立的过滤器</td>
</tr>
</tbody></table>
<p>在下面的示例中，使用逻辑过滤器组合了两个快速过滤器，以获取文档中的所有door FamilyInstance元素。</p>
<p>代码区域6-8：使用LogicalAndFilter查找所有门实例</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Find all door instances in the project by finding all elements that both belong to the</span></span><br><span class="line"><span class="comment">// door category and are family instances.</span></span><br><span class="line">ElementClassFilter familyInstanceFilter = <span class="keyword">new</span> ElementClassFilter(<span class="keyword">typeof</span>(FamilyInstance));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a category filter for Doors</span></span><br><span class="line">ElementCategoryFilter doorsCategoryfilter = </span><br><span class="line">        <span class="keyword">new</span> ElementCategoryFilter(BuiltInCategory.OST_Doors);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a logic And filter for all Door FamilyInstances</span></span><br><span class="line">LogicalAndFilter doorInstancesFilter = <span class="keyword">new</span> LogicalAndFilter(familyInstanceFilter, </span><br><span class="line">        doorsCategoryfilter);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Apply the filter to the elements in the active document</span></span><br><span class="line">FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">IList doors = collector.WherePasses(doorInstancesFilter).ToElements();</span><br></pre></td></tr></table></figure>



<h2 id="获取筛选的元素或元素ID"><a href="#获取筛选的元素或元素ID" class="headerlink" title="获取筛选的元素或元素ID"></a>获取筛选的元素或元素ID</h2><p>将一个或多个过滤器应用于FilteredElementCollector后，可以通过以下三种方式之一来检索已过滤的元素集：</p>
<ol>
<li>获取Elements或ElementId的集合。<ul>
<li>ToElements()-返回通过所有应用的过滤器的所有元素</li>
<li>ToElementIds()-返回通过所有应用过滤器的所有元素的ElementIds</li>
</ul>
</li>
<li>获取与筛选器匹配的第一个Element或ElementId。<ul>
<li>FirstElement()-返回第一个元素以通过所有应用的过滤器</li>
<li>FirstElementId()-返回第一个元素的id，以通过所有应用的过滤器</li>
</ul>
</li>
<li>获取ElementId或Element迭代器。<ul>
<li>GetElementIdIterator()-将FilteredElementIdIterator返回到通过过滤器的元素id</li>
<li>GetElementIterator()-将FilteredElementIterator返回给通过过滤器的元素</li>
<li>GetEnumerator()-返回一个IEnumerator，它遍历传递元素的集合</li>
</ul>
</li>
</ol>
<p>一次只能使用这些组中的一个方法;如果调用另一个方法来提取元素，收集器将重置。因此，如果您之前已经获得了一个迭代器，那么当您调用另一个方法来提取元素时，它将停止并且不再遍历任何元素。</p>
<p>哪种方法最好取决于应用。如果只需要一个匹配元素，那么FirstElement()或FirstElementId()是最佳选择。如果需要所有匹配的元素，请使用ToElements()。如果需要一个变量，使用迭代器。</p>
<p>如果应用程序将删除元素或对过滤列表中的元素进行重大更改，ToElementIds()或元素id迭代器是最佳选择。这是因为删除元素或对元素进行重大更改会使元素句柄无效。对于元素id，对具有ElementId的Document.GetElement()的调用将始终返回有效的Element（如果元素已被删除，则返回空引用）。</p>
<p>使用ToElements()方法将筛选结果作为元素集合获取，允许使用foreach检查集合中的每个元素，如下所示：</p>
<p>代码区域6-9：使用ToElements()获取筛选结果</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Use ElementClassFilter to find all loads in the document</span></span><br><span class="line"><span class="comment">// Using typeof(LoadBase) will yield all AreaLoad, LineLoad and PointLoad</span></span><br><span class="line">ElementClassFilter filter = <span class="keyword">new</span> ElementClassFilter(<span class="keyword">typeof</span>(LoadBase));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Apply the filter to the elements in the active document</span></span><br><span class="line">FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">collector.WherePasses(filter);</span><br><span class="line">ICollection allLoads = collector.ToElements();</span><br><span class="line"></span><br><span class="line">String prompt = <span class="string">&quot;The loads in the current document are:\n&quot;</span>;</span><br><span class="line"><span class="keyword">foreach</span> (Element loadElem <span class="keyword">in</span> allLoads)</span><br><span class="line">&#123;</span><br><span class="line">        LoadBase load = loadElem <span class="keyword">as</span> LoadBase;</span><br><span class="line">        prompt += load.GetType().Name +  <span class="string">&quot;: &quot;</span> + </span><br><span class="line">                        load.Name + <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>, prompt);</span><br></pre></td></tr></table></figure>

<p>当只需要一个传递元素时，使用FirstElement()：</p>
<p>代码区域6-10：获取第一个通过的元素</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Create a filter to find all columns</span></span><br><span class="line">StructuralInstanceUsageFilter columnFilter = </span><br><span class="line">        <span class="keyword">new</span> StructuralInstanceUsageFilter(StructuralInstanceUsage.Column);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Apply the filter to the elements in the active document</span></span><br><span class="line">FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">collector.WherePasses(columnFilter);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get the first column from the filtered results</span></span><br><span class="line"><span class="comment">// Element will be a FamilyInstance</span></span><br><span class="line">FamilyInstance column = collector.FirstElement() <span class="keyword">as</span> FamilyInstance;</span><br></pre></td></tr></table></figure>

<p>在某些情况下，FirstElement()是不够的。下一个示例显示如何使用扩展方法获取第一个非模板3D视图（这对于ReferenceIntersector构造函数的输入很有用）。</p>
<p>代码区域6-11：使用扩展方法获取第一个传递元素</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Use filter to find a non-template 3D view</span></span><br><span class="line"><span class="comment">// This example does not use FirstElement() since first filterd view3D might be a template</span></span><br><span class="line">FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">Func&lt;View3D, <span class="built_in">bool</span>&gt; isNotTemplate = v3 =&gt; !(v3.IsTemplate);</span><br><span class="line"></span><br><span class="line"><span class="comment">// apply ElementClassFilter</span></span><br><span class="line">collector.OfClass(<span class="keyword">typeof</span>(View3D));</span><br><span class="line"></span><br><span class="line"><span class="comment">// use extension methods to get first non-template View3D</span></span><br><span class="line">View3D view3D = collector.Cast().First(isNotTemplate);</span><br></pre></td></tr></table></figure>

<p>The following example demonstrates the use of the FirstElementId() method to get one passing element (a 3d view in this case) and the use of ToElementIds() to get the filter results as a collection of element ids (in order to delete a set of elements in this case).<br>下面的示例演示了使用FirstElementId()方法获取一个传递元素（本例中为3D视图），以及使用ToElementIds()获取作为元素ID集合的过滤结果（本例中为删除一组元素）。</p>
<p>代码区域6-12：使用得到过滤器结果作为元素id</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Use shortcut OfClass to get View elements</span></span><br><span class="line">collector.OfClass(<span class="keyword">typeof</span>(View3D));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get the Id of the first view</span></span><br><span class="line">ElementId viewId = collector.FirstElementId();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Test if the view is valid for element filtering</span></span><br><span class="line"><span class="keyword">if</span> (FilteredElementCollector.IsViewValidForElementIteration(document, viewId))</span><br><span class="line">&#123;</span><br><span class="line">        FilteredElementCollector viewCollector = <span class="keyword">new</span> FilteredElementCollector(document, viewId);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Get all FamilyInstance items in the view</span></span><br><span class="line">        viewCollector.OfClass(<span class="keyword">typeof</span>(FamilyInstance));</span><br><span class="line">        ICollection familyInstanceIds = viewCollector.ToElementIds();</span><br><span class="line"></span><br><span class="line">        document.Delete(familyInstanceIds);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在下面的示例中使用了GetElementIterator()方法，该方法循环访问已筛选的元素以检查某些管道的流状态。</p>
<p>代码区域6-13：以元素迭代器的形式获取结果</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Apply a filter to get all pipes in the document</span></span><br><span class="line">collector.OfClass(<span class="keyword">typeof</span>(Autodesk.Revit.DB.Plumbing.Pipe));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get results as an element iterator and look for a pipe with</span></span><br><span class="line"><span class="comment">// a specific flow state</span></span><br><span class="line">FilteredElementIterator elemItr = collector.GetElementIterator();</span><br><span class="line">elemItr.Reset();</span><br><span class="line"><span class="keyword">while</span> (elemItr.MoveNext())</span><br><span class="line">&#123;</span><br><span class="line">        Pipe pipe = elemItr.Current <span class="keyword">as</span> Pipe;</span><br><span class="line">        <span class="keyword">if</span> (pipe.FlowState == PipeFlowState.LaminarState)</span><br><span class="line">        &#123;</span><br><span class="line">                TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>, <span class="string">&quot;Model has at least one pipe with Laminar flow state.&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者，过滤结果可以作为元素id迭代器返回：</p>
<p>代码区域6-14：以元素id迭代器的形式获取结果</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Use a RoomFilter to find all room elements in the document. </span></span><br><span class="line">RoomFilter filter = <span class="keyword">new</span> RoomFilter();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Apply the filter to the elements in the active document</span></span><br><span class="line">FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">collector.WherePasses(filter);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get results as ElementId iterator</span></span><br><span class="line">FilteredElementIdIterator roomIdItr = collector.GetElementIdIterator();</span><br><span class="line">roomIdItr.Reset();</span><br><span class="line"><span class="keyword">while</span> (roomIdItr.MoveNext())</span><br><span class="line">&#123;</span><br><span class="line">        ElementId roomId = roomIdItr.Current;</span><br><span class="line">        <span class="comment">// Warn rooms smaller than 50 SF</span></span><br><span class="line">        Room room = document.GetElement(roomId) <span class="keyword">as</span> Room;</span><br><span class="line">        <span class="keyword">if</span> (room.Area &lt; <span class="number">50.0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                String prompt = <span class="string">&quot;Room is too small: id = &quot;</span> + roomId.ToString();</span><br><span class="line">                TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>, prompt);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在某些情况下，针对给定的过滤器测试单个元素，而不是获取通过过滤器的所有元素，可能会很有用。ElementFilter.PassesFilter()有两个重载，它们根据筛选器测试给定的Element或ElementId，如果元素通过筛选器，则返回true。</p>
<h2 id="LINQ查询"><a href="#LINQ查询" class="headerlink" title="LINQ查询"></a>LINQ查询</h2><p>在.NET中，FilteredElementCollector类支持Elements的IEEETM接口。您可以将此类与LINQ查询和操作一起使用来处理元素列表。请注意，由于此类提供的ElementFilters和快捷方法在生成托管包装之前处理本机代码中的元素，因此在尝试使用LINQ查询处理结果之前，在收集器上使用尽可能多的本机筛选器将获得更好的性能。</p>
<p>The following example uses an ElementClassFilter to get all FamilyInstance elements in the document, and then uses a LINQ query to narrow down the results to those FamilyInstances with a specific name.<br>下面的示例使用ElementClassFilter获取文档中的所有FamilyInstance元素，然后使用LINQ查询将结果范围缩小到具有特定名称的FamilyInstance。</p>
<p>代码区域6-15：使用LINQ查询</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Use ElementClassFilter to find family instances whose name is 60&quot; x 30&quot; Student </span></span><br><span class="line">ElementClassFilter filter = <span class="keyword">new</span> ElementClassFilter(<span class="keyword">typeof</span>(FamilyInstance));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Apply the filter to the elements in the active document</span></span><br><span class="line">FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">collector.WherePasses(filter);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Use Linq query to find family instances whose name is 60&quot; x 30&quot; Student</span></span><br><span class="line"><span class="keyword">var</span> query = <span class="keyword">from</span> element <span class="keyword">in</span> collector</span><br><span class="line">                        <span class="keyword">where</span> element.Name == <span class="string">&quot;60\&quot; x 30\&quot; Student&quot;</span></span><br><span class="line">                        <span class="keyword">select</span> element;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Cast found elements to family instances, </span></span><br><span class="line"><span class="comment">// this cast to FamilyInstance is safe because ElementClassFilter for FamilyInstance was used</span></span><br><span class="line">List familyInstances = query.Cast().ToList();</span><br></pre></td></tr></table></figure>

<h2 id="边界框过滤器"><a href="#边界框过滤器" class="headerlink" title="边界框过滤器"></a>边界框过滤器</h2><p> BoundingBox过滤器：</p>
<ul>
<li>BoundingBoxIsInsideFilter</li>
<li>BoundingBoxIntersectsFilter</li>
<li>BoundingBoxContainsPointFilter</li>
</ul>
<p>帮助您查找其边界框满足特定条件的元素。您可以检查每个元素的边界框是否在给定体积内，是否与给定体积相交，或者是否包含给定点。也可以反向执行此检查，以查找不与体积相交或不包含给定点的元素。</p>
<p>BoundingBox过滤器使用Outline作为其输入。Outline是一个表示直角棱柱的类，其轴与Revit世界坐标系对齐。</p>
<p>这些过滤器最适合于实际几何形状与其边界框的几何形状紧密匹配的形状。示例可能包括曲线与X或Y方向对齐的线性墙、由此类墙形成的矩形房间、与此类墙对齐的楼板或屋顶，或者合理的矩形族。否则，可能会出现误报，因为元素的边界框可能比实际几何形状大得多。(在这些情况下，您可以使用实际图元的几何图形来确定图元是否真正满足条件）。</p>
<h2 id="元素交叉过滤器"><a href="#元素交叉过滤器" class="headerlink" title="元素交叉过滤器"></a>元素交叉过滤器</h2><p> 元素过滤器：</p>
<ul>
<li>ElementIntersectsElementFilter</li>
<li>ElementIntersectsSolidFilter</li>
</ul>
<p>其实际三维几何体与目标对象的三维几何体相交的过程元素。</p>
<p>使用ElementIntersectsElementFilter，目标对象是另一个元素。交点的确定与Revit在生成冲突报告期间确定是否存在冲突时使用的逻辑相同。(意味着某些图元组合永远不会通过此过滤器，例如在相交处自动连接的混凝土构件，或也从干涉检查中排除的场地图元）。此外，没有实心几何图形的图元（如钢筋）也不会通过此过滤器。</p>
<p>使用ElementIntersectsSolidFilter，目标对象是任何实体。该实体可以从现有图元中获得，使用GeometryCreationUtilities中的例程从头开始创建，或者是布尔运算等二次运算的结果。与ElementIntersectsElementFilter类似，此过滤器不会传递缺少实心几何图形的元素。</p>
<p>两个过滤器都可以反转以匹配目标对象体积之外的元素。</p>
<p>这两个过滤器都是慢速过滤器，因此最好与一个或多个快速过滤器（如类或类别过滤器）组合使用。</p>
<p> 代码区域：使用ElementIntersectsSolidFilter匹配阻止禁用出口到门的元素</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> </span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> Finds any Revit physical elements which interfere with the target </span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> solid region surrounding a door.</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> This routine is useful for detecting interferences which are </span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> violations of the Americans with Disabilities Act or other local disabled </span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> access codes.</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> The door instance.</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> The accessibility region calculated</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> to surround the approach of the door.</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> Because the geometric parameters of this region are code- and </span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> door-specific, calculation of the geometry of the region is not </span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> demonstrated in this example.</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> A collection of interfering element ids.</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> ICollection <span class="title">FindElementsInterferingWithDoor</span>(<span class="params">FamilyInstance doorInstance, Solid doorAccessibilityRegion</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// Setup the filtered element collector for all document elements.</span></span><br><span class="line">   FilteredElementCollector interferingCollector = </span><br><span class="line">      <span class="keyword">new</span> FilteredElementCollector(doorInstance.Document);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Only accept element instances</span></span><br><span class="line">   interferingCollector.WhereElementIsNotElementType();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Exclude intersections with the door itself or the host wall for the door.</span></span><br><span class="line">   List excludedElements = <span class="keyword">new</span> List();</span><br><span class="line">   excludedElements.Add(doorInstance.Id);</span><br><span class="line">   excludedElements.Add(doorInstance.Host.Id);</span><br><span class="line">   ExclusionFilter exclusionFilter = <span class="keyword">new</span> ExclusionFilter(excludedElements);</span><br><span class="line">   interferingCollector.WherePasses(exclusionFilter);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Set up a filter which matches elements whose solid geometry intersects </span></span><br><span class="line">   <span class="comment">// with the accessibility region</span></span><br><span class="line">   ElementIntersectsSolidFilter intersectionFilter = </span><br><span class="line">      <span class="keyword">new</span> ElementIntersectsSolidFilter(doorAccessibilityRegion);</span><br><span class="line">   interferingCollector.WherePasses(intersectionFilter);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Return all elements passing the collector</span></span><br><span class="line">   <span class="keyword">return</span> interferingCollector.ToElementIds();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="注：翻译自Revit-API-Developers-Guide"><a href="#注：翻译自Revit-API-Developers-Guide" class="headerlink" title="注：翻译自Revit API Developers Guide"></a><em><strong>注：</strong></em>翻译自<a href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_html">Revit API Developers Guide</a></h2>]]></content>
      <categories>
        <category>Revit二次开发人员指南</category>
      </categories>
      <tags>
        <tag>Revit</tag>
      </tags>
  </entry>
  <entry>
    <title>07参数</title>
    <url>/2024/11/23/Revit%E4%BA%8C%E5%BC%80%E6%8C%87%E5%8D%97/07%E5%8F%82%E6%95%B0/</url>
    <content><![CDATA[<h1 id="参数"><a href="#参数" class="headerlink" title="参数"></a><a href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_Basic_Interaction_with_Revit_Elements_Parameters_html">参数</a></h1><p>Revit提供了一种常规机制，为每个图元提供一组可编辑的参数。</p>
<p>在Revit UI中，某些图元参数在“图元属性”窗口中可见。以下各节介绍如何获取和使用内置参数、共享参数和全局参数。</p>
<p>在Revit Platform API中，参数在Element类中进行管理。您可以通过以下方式访问参数：</p>
<ul>
<li>通过迭代元素的所有参数的Element.Parameters集合（有关示例，请参见获取选定元素参数演练中的示例代码）。</li>
<li>通过迭代Element.GetOrderedParameters()返回的集合，该集合仅返回属性选项板中可见的参数。</li>
<li>通过重载的Element.Parameter属性直接访问参数。如果参数不存在，则属性返回null。</li>
<li>通过Element.ParametersMap集合按名称访问参数。</li>
<li>按名称字符串Element.LookupParameter()或Element.GetParameters()。</li>
</ul>
<p>如果知道内置ID、定义或参数，则可以使用重载的Parameter属性从Element中检索Parameter对象。Parameter[NULL]属性重载根据其全局唯一ID（Global Unique ID，NULL）获取共享参数，该全局唯一ID在创建共享参数时分配给该共享参数。}]}</p>
<p>Element.LookupParameter()方法根据参数的本地化名称获取参数，因此如果要按名称查找参数并且需要在多个区域设置中运行，则代码应处理不同的语言。此外，请记住，可能会出现同名参数的多个匹配，因为即使已经存在同名的内置参数，共享参数或项目参数也可以绑定到元素类别。因此，最好使用Element. GetParameter()，它将返回与给定名称匹配的所有参数。LookupParameter()将返回找到的第一个匹配项。</p>
<p>本节中的页面</p>
<ul>
<li>演练：获取选定的元素参数</li>
<li>参数关系</li>
<li>定义</li>
<li>内置参数</li>
<li>共享参数</li>
<li>全局参数</li>
<li>参数</li>
</ul>
<h2 id="演练：获取选定的元素参数"><a href="#演练：获取选定的元素参数" class="headerlink" title="演练：获取选定的元素参数"></a>演练：获取选定的元素参数</h2><p>元素参数是通过遍历元素参数集来检索的。下面的代码示例阐释如何从选定的元素中检索Parameter。</p>
<p>****注意：****此示例使用了一些参数成员，如AsValueString和DataType，这些将在后续主题中介绍。</p>
<p>代码区域8-1：获取选定的元素参数</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetElementParameterInformation</span>(<span class="params">Document document, Element element</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Format the prompt information string</span></span><br><span class="line">    String prompt = <span class="string">&quot;Show parameters in selected Element: \n\r&quot;</span>;</span><br><span class="line"></span><br><span class="line">    StringBuilder st = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="comment">// iterate element&#x27;s parameters</span></span><br><span class="line">    <span class="keyword">foreach</span> (Parameter para <span class="keyword">in</span> element.Parameters)</span><br><span class="line">    &#123;</span><br><span class="line">        st.AppendLine(GetParameterInformation(para, document));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Give the user some information</span></span><br><span class="line">    TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>, prompt + st.ToString());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">String <span class="title">GetParameterInformation</span>(<span class="params">Parameter para, Document document</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> defName = para.Definition.Name + <span class="string">&quot;\t : &quot;</span>;</span><br><span class="line">    <span class="built_in">string</span> defValue = <span class="built_in">string</span>.Empty;</span><br><span class="line">    <span class="comment">// Use different method to get parameter data according to the storage type</span></span><br><span class="line">    <span class="keyword">switch</span> (para.StorageType)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> StorageType.Double:</span><br><span class="line">            <span class="comment">//covert the number into Metric</span></span><br><span class="line">            defValue = para.AsValueString();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> StorageType.ElementId:</span><br><span class="line">            <span class="comment">//find out the name of the element</span></span><br><span class="line">            Autodesk.Revit.DB.ElementId id = para.AsElementId();</span><br><span class="line">            <span class="keyword">if</span> (id.IntegerValue &gt;= <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                defValue = document.GetElement(id).Name;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                defValue = id.IntegerValue.ToString();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> StorageType.Integer:</span><br><span class="line">            <span class="keyword">if</span> (ParameterType.YesNo == para.Definition.ParameterType)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (para.AsInteger() == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    defValue = <span class="string">&quot;False&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    defValue = <span class="string">&quot;True&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                defValue = para.AsInteger().ToString();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> StorageType.String:</span><br><span class="line">            defValue = para.AsString();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="literal">default</span>:</span><br><span class="line">            defValue = <span class="string">&quot;Unexposed parameter.&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> defName + defValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-07A40B76-5AD7-46C8-983F-494CECF88543-low.png"></p>
<p>图26：获取墙参数结果</p>
<p>注意：在Revit中，某些参数的值位于“图元属性”对话框的下拉列表中。可以使用Revit Platform API获取与Parameter的枚举类型对应的数值，但不能使用Parameter.AsValueString()方法获取值的字符串表示形式。</p>
<h2 id="参数关系"><a href="#参数关系" class="headerlink" title="参数关系"></a>参数关系</h2><p>参数可以相互影响。</p>
<p>参数之间存在关系，其中一个参数的值可以影响：</p>
<ul>
<li>是否可以设置另一个参数，或者是否为只读</li>
<li>哪些参数对元素有效</li>
<li>另一个参数的计算值</li>
</ul>
<p>此外，某些参数始终是只读的。</p>
<p>某些参数在Revit中计算，例如墙长度和面积参数。这些参数总是只读的，因为它们依赖于元素的内部状态。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-B11C1A73-B5DE-4429-B728-C739D963AE1A-low.png"></p>
<p>在此代码示例中，洞口的“Sill Height”参数将被调整，从而导致重新计算“Head Height”参数：</p>
<p>代码区域：参数关系示例</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// opening should be an opening such as a window or a door</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ShowParameterRelationship</span>(<span class="params">FamilyInstance opening</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">// get the original Sill Height and Head Height parameters for the opening</span></span><br><span class="line">        Parameter sillPara = opening.get_Parameter(BuiltInParameter.INSTANCE_SILL_HEIGHT_PARAM);</span><br><span class="line">        Parameter headPara = opening.get_Parameter(BuiltInParameter.INSTANCE_HEAD_HEIGHT_PARAM);</span><br><span class="line">        <span class="built_in">double</span> sillHeight = sillPara.AsDouble();</span><br><span class="line">        <span class="built_in">double</span> origHeadHeight = headPara.AsDouble();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Change the Sill Height only and notice that Head Height is recalculated</span></span><br><span class="line">        sillPara.Set(sillHeight + <span class="number">2.0</span>);</span><br><span class="line">        <span class="built_in">double</span> newHeadHeight = headPara.AsDouble();</span><br><span class="line">        MessageBox.Show(<span class="string">&quot;Old head height: &quot;</span> + origHeadHeight + <span class="string">&quot;; new head height: &quot;</span> </span><br><span class="line">                + newHeadHeight);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>全局参数也与其他参数有关系。有关详细信息，请参见“全局参数基础”主题。</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>定义对象描述数据类型、名称和其他参数细节。</p>
<p>有两种类型的定义对象派生自该对象。</p>
<ul>
<li>InternalDefinition表示完全存在于Revit数据库中的所有类型的定义。</li>
<li>ExternalDefinition表示存储在磁盘上的共享参数文件中的定义。</li>
</ul>
<p>您应该编写使用Definition基类的代码，以便该代码适用于内部和外部参数定义。下面的代码示例演示如何使用定义类型查找特定参数。</p>
<p> 代码区域8-2：根据定义类型查找参数</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Find parameter using the Parameter&#x27;s definition type.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Parameter <span class="title">FindParameter</span>(<span class="params">Element element</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        Parameter foundParameter = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// This will find the first parameter that measures length</span></span><br><span class="line">        <span class="keyword">foreach</span> (Parameter parameter <span class="keyword">in</span> element.Parameters)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">if</span> (parameter.Definition.ParameterType == ParameterType.Length)</span><br><span class="line">                &#123;</span><br><span class="line">                        foundParameter = parameter;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> foundParameter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="参数类型"><a href="#参数类型" class="headerlink" title="参数类型"></a>参数类型</h3><p>此属性返回参数数据类型，这会影响参数在Revit UI中的显示方式。一些参数类型枚举成员包括：</p>
<table>
<thead>
<tr>
<th><strong>Member name 成员名称</strong></th>
<th><strong>Description 描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td><em>Number</em></td>
<td>参数数据应解释为真实的数字，可能包括小数点。</td>
</tr>
<tr>
<td><em>Moment</em></td>
<td>数据值将表示为力矩。</td>
</tr>
<tr>
<td><em>AreaForce</em></td>
<td>数据值将表示为面积力。</td>
</tr>
<tr>
<td><em>LinearForce</em></td>
<td>数据值将表示为线性力。</td>
</tr>
<tr>
<td><em>Force</em></td>
<td>数据值将表示为力。</td>
</tr>
<tr>
<td><em>YesNo</em></td>
<td>一个布尔值，表示为Yes或No。</td>
</tr>
<tr>
<td><em>Material</em></td>
<td>此属性的值被视为材料。</td>
</tr>
<tr>
<td><em>URL</em></td>
<td>表示网址的文本字符串。</td>
</tr>
<tr>
<td><em>Angle</em></td>
<td>参数数据表示角度。内部表示将以弧度表示。用户可见表示将使用用户选择的单位。</td>
</tr>
<tr>
<td><em>Volume</em></td>
<td>参数数据表示体积。内部表示将以十进制立方英尺为单位。用户可见表示将使用用户选择的单位。</td>
</tr>
<tr>
<td><em>Area</em></td>
<td>参数数据表示一个区域。内部表示将以十进制平方英尺为单位。用户可见表示将使用用户选择的单位。</td>
</tr>
<tr>
<td><em>Integer</em></td>
<td>参数数据应解释为整数，正数或负数。</td>
</tr>
<tr>
<td><em>Invalid</em></td>
<td>参数类型无效。不应使用此值。</td>
</tr>
<tr>
<td><em>Length</em></td>
<td>参数数据表示长度。内部表示将以十进制英尺为单位。用户可见表示将在用户选择的单位系统中。</td>
</tr>
<tr>
<td><em>Text</em></td>
<td>参数数据应解释为文本字符串。</td>
</tr>
<tr>
<td><em>MultilineText</em></td>
<td>此参数的值将表示为多行文本。</td>
</tr>
<tr>
<td><em>FamilyType</em></td>
<td>用于控制嵌套在另一个族中的族的类型的参数。</td>
</tr>
<tr>
<td><em>Image</em></td>
<td>该参数的值是图像的id。</td>
</tr>
</tbody></table>
<p>有关参数类型.材质的更多详细信息，请参见材质。</p>
<p>ParameterGroup 参数组</p>
<p>定义类参数组属性返回参数定义组ID。BuiltInParameterGroup是一种枚举类型，列出了Revit支持的所有内置参数组。参数组用于对“图元属性”对话框中的参数进行排序。</p>
<h2 id="内部定义"><a href="#内部定义" class="headerlink" title="内部定义"></a>内部定义</h2><p>每个Parameter对象都有一个InternalDefinition，它可以从Definition属性中获得。InternalDefinition表示Revit文档中的参数定义。除了从Definition继承的属性之外，它还具有一些其他关键属性。</p>
<h3 id="BuiltInParameter-内置参数"><a href="#BuiltInParameter-内置参数" class="headerlink" title="BuiltInParameter 内置参数"></a>BuiltInParameter 内置参数</h3><p>此属性测试此定义是否标识内置参数。对于内置参数，此属性返回BuiltInParameter枚举值之一。对于自定义参数（如共享参数、全局参数或族参数），该值将为BuiltInParameter.INVALID。</p>
<h3 id="Id"><a href="#Id" class="headerlink" title="Id"></a>Id</h3><p>如果参数不是内置的，则此属性返回关联的ParameterElement的ID。</p>
<h3 id="VariesAcrossGroups"><a href="#VariesAcrossGroups" class="headerlink" title="VariesAcrossGroups"></a>VariesAcrossGroups</h3><p>该属性和相应的SetAllowVaryBetweenGroups()方法确定该参数的值是否可以在组实例的相关成员之间变化。如果为False，则组实例中相关成员的值将保持一致。这只能为非内置参数设置。</p>
<h3 id="Visible-可见"><a href="#Visible-可见" class="headerlink" title="Visible 可见"></a>Visible 可见</h3><p>visible属性指示是否对用户隐藏共享参数。如果您希望将数据添加到仅对您的应用程序有意义而对用户没有意义的元素中，这将非常有用。此值只能在创建共享参数定义时设置。</p>
<h2 id="内置参数"><a href="#内置参数" class="headerlink" title="内置参数"></a>内置参数</h2><p>Revit Platform API具有大量内置参数。</p>
<p>内置参数在Autodesk.Revit.Parameters.BuiltInParameter枚举中定义（有关此枚举的定义，请参见RevitAPI Help.chm文件）。此枚举已生成可从Visual Studio intellisense看到的文档，如下所示。每个id的文档都包括参数名称，如Autodesk Revit英文版的“图元属性”对话框中所示。请注意，多个不同的参数id可能映射到同一个英文名称;在这种情况下，您必须检查与特定元素关联的参数，以确定使用哪个参数id。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/BuiltInParameter-76164.jpg"></p>
<p>参数ID用于从元素中检索特定参数，如果它存在，使用Element.Parameter属性。但是，并非所有参数都可以使用ID进行检索。例如，族参数未在Revit Platform API中显示，因此，您无法使用内置参数ID获取它们。</p>
<p>以下代码示例显示如何使用BuiltInParameter Id获取特定参数：</p>
<p>代码区域8-3：基于BuiltInParameter获取参数</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Parameter <span class="title">FindWithBuiltinParameterID</span>(<span class="params">Wall wall</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">// Use the WALL_BASE_OFFSET paramametId</span></span><br><span class="line">        <span class="comment">// to get the base offset parameter of the wall.</span></span><br><span class="line">        BuiltInParameter paraIndex = BuiltInParameter.WALL_BASE_OFFSET;</span><br><span class="line">        Parameter parameter = wall.get_Parameter(paraIndex);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> parameter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：通过Parameter重载，可以使用枚举类型BuiltInParameter作为方法参数.例如，使用BuiltInParameter.GENERIC_WIDTH。</p>
<p>如果不知道确切的BuiltInParameter ID，请通过迭代ParameterSet集合获取参数。另一种用于测试或识别目的的方法是使用get_Parameter()方法测试每个BuiltInParameter。当您使用此方法时，参数集集合可能不包含从get_Parameter()方法返回的所有参数，尽管这种情况并不常见。</p>
<h2 id="共享参数"><a href="#共享参数" class="headerlink" title="共享参数"></a>共享参数</h2><p>共享参数是存储在外部文本文件中的参数定义。</p>
<p>定义由创建定义时生成的唯一标识符标识，并且可以在多个项目中使用。</p>
<p>与共享参数关联的主要对象有：</p>
<ul>
<li>DefinitionFile -表示磁盘上的共享参数文件</li>
<li>DefinitionGroup -一组共享参数，它们被组织成有意义的集合</li>
<li>ExternalDefinition -表示一个共享参数定义，属于一个配置组</li>
<li>ExternalDefinitions -支持创建新的共享参数定义</li>
<li>Binding-将参数定义绑定到一个或多个类别</li>
<li>BindingMap -包含Autodesk Revit项目中存在的所有参数绑定</li>
<li>ParameterElement-存储有关文档中特定用户定义参数的信息</li>
<li>SharedParameterElement -从ParameterElement派生，存储共享参数的定义以下各节介绍如何通过Revit Platform API访问共享参数定义，包括如何获取共享参数定义并将其绑定到某些类别中的元素。</li>
</ul>
<p>要在定义共享参数并将其绑定到类别后访问共享参数，请参见参数。</p>
<p>本节中的页面</p>
<ul>
<li>Definition File</li>
<li>Working with the Definition File</li>
<li>Binding </li>
<li>SharedParameterElement</li>
</ul>
<h3 id="Definition-File"><a href="#Definition-File" class="headerlink" title="Definition File"></a>Definition File</h3><p>DefinitionFile 表示一个共享参数文件，它是一个通用文本文件。</p>
<h4 id="Format-格式"><a href="#Format-格式" class="headerlink" title="Format 格式"></a>Format 格式</h4><p>共享参数定义文件是一个文本文件（.txt），包含三个块：Meta、GROUP和PARAM。GROUP和PARAM块与Revit API中的共享参数功能相关。不要直接编辑定义文件;而是使用UI或API编辑它。</p>
<p>尽管Revit API负责阅读和写入此文件，但以下部分提供了文件格式的信息，该文件格式与用于访问共享参数的API对象和方法密切对应。该文件使用制表符分隔字段，在文本编辑器中很难阅读。下面的代码区域显示了示例共享参数文本文件的内容。</p>
<p>代码区域22-1：参数定义文件示例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># This is a Revit shared parameter file.</span><br><span class="line"># Do not edit manually.</span><br><span class="line">META    VERSION    MINVERSION</span><br><span class="line">META    2    1</span><br><span class="line">GROUP    ID    NAME</span><br><span class="line">GROUP    1    MyGroup</span><br><span class="line">GROUP    2    AnotherGroup</span><br><span class="line">*PARAM    GUID    NAME    DATATYPE    DATACATEGORY    GROUP    VISIBLE    DESCRIPTION    USERMODIFIABLE</span><br><span class="line">PARAM    bb7f0005-9692-4b76-8fa3-30cec8aecf74    Price    INTEGER        2    1    Enter price in USD    1</span><br><span class="line">PARAM    b7ea2654-b206-4694-a087-756359b52e7f    areaTags    FAMILYTYPE    -2005020    1    1        1</span><br><span class="line">PARAM    d1a5439d-dc8d-4053-99fa-2f33804bae0e    MyParam    TEXT        1    1        1</span><br></pre></td></tr></table></figure>

<ul>
<li><p>GROUP块包含将每个参数定义与组关联的组条目。以下字段显示在GROUP块中：</p>
<ul>
<li>ID -唯一标识组并将参数定义与组关联。</li>
<li>Name - UI中显示的组名称。</li>
</ul>
</li>
<li><p>PARAM块包含参数定义。以下字段出现在PARAM块中：</p>
<ul>
<li><p>GUID - 识别参数定义。</p>
</li>
<li><p>NAME - 参数定义名称。</p>
</li>
<li><p>DATATYPE -参数类型。此字段可以是常见类型（TEXT、INTEGER等），结构类型（力、力矩等）或常用族类型（面积标记等）。通用类型和结构类型参数直接在文本文件中指定（例如：文本，力）。如果DATATYPE字段的值为FAMILYTYPE，则添加一个额外的数字。例如，FAMILYTYPE后跟-2005020表示族类型：面积标记。</p>
</li>
<li><p>DATACATEGORY -DATATYPE为FAMILYTYPE的参数的可选字段。</p>
</li>
<li><p>GROUP -用于标识包含当前参数定义的组的组ID。</p>
</li>
<li><p>VISIBLE -确定参数是否可见。此字段的值为0或1.0 </p>
</li>
<li><p>DESCRIPTION - 此参数的工具提示的可选字段。</p>
</li>
<li><p>USERMODIFIABLE -确定参数是否可由用户编辑。0 &#x3D;用户无法编辑参数，并且该参数在UI中呈灰色显示</p>
</li>
</ul>
</li>
</ul>
<p>在示例定义文件中，有两个组：</p>
<ul>
<li>MyGroup - ID 1 -包含MyParam的参数定义（文本类型参数）和areaTags的定义（家庭类型参数）。</li>
<li>AnotherGroup - ID 2 -包含Price的参数定义，它是一个价格类型参数。</li>
</ul>
<p>Of the 3 parameters in the sample file, only Price has a description. All of the parameters are visible and user modifiable.<br>在示例文件中的3个参数中，只有Price有描述。所有的参数都是可见的，用户可以修改。</p>
<h3 id="Working-with-the-Definition-File"><a href="#Working-with-the-Definition-File" class="headerlink" title="Working with the Definition File"></a>Working with the Definition File</h3><p>定在定义文件中设置参数义文件提供对共享参数的访问。</p>
<h4 id="在定义文件中设置参数"><a href="#在定义文件中设置参数" class="headerlink" title="在定义文件中设置参数"></a>在定义文件中设置参数</h4><p>使用以下步骤访问定义文件及其参数：</p>
<ol>
<li>使用现有文本文件或新文本文件指定Application.SharedParametersFiltrate属性。</li>
<li>使用Application.OpenSharedParameterFile()方法打开共享参数文件。</li>
<li>打开一个现有组或使用configtionFile.groups属性创建一个新组。</li>
<li>打开现有的外部参数定义或使用configuretionGroup.Definitions属性创建新定义。</li>
</ol>
<p>Autodesk. Revit. DB命名空间中的以下类和方法提供了使用Revit API访问共享参数的功能。</p>
<ul>
<li>DefinitionFile 类<ul>
<li>使用Application.OpenSharedParameterFile()方法检索。Revit每次使用一个共享参数文件。</li>
<li>表示一个共享参数文件。</li>
<li>包含多个Group对象。</li>
<li>共享参数被分组以便于管理，并包含共享参数定义。</li>
<li>可以根据需要添加新的定义。</li>
</ul>
</li>
<li>ExternalDefinition 类<ul>
<li>ExternalDefinition对象是由一个共享参数文件中的ExternationGroup对象创建的。</li>
<li>外部参数定义必须属于一个组，该组是共享参数定义的集合。</li>
</ul>
</li>
<li>Application.SharedParametersFilename 属性<ul>
<li>使用此属性获取和设置共享参数文件路径。</li>
<li>默认情况下，Revit没有共享参数文件。</li>
<li>使用前初始化此属性。如果它没有初始化，则会引发异常。</li>
</ul>
</li>
</ul>
<h4 id="创建共享参数文件"><a href="#创建共享参数文件" class="headerlink" title="创建共享参数文件"></a>创建共享参数文件</h4><p>代码区域22-3：创建共享参数文件</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">CreateExternalSharedParamFile</span>(<span class="params"><span class="built_in">string</span> sharedParameterFile</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        System.IO.FileStream fileStream = System.IO.File.Create(sharedParameterFile);</span><br><span class="line">        fileStream.Close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="访问现有共享参数文件"><a href="#访问现有共享参数文件" class="headerlink" title="访问现有共享参数文件"></a>访问现有共享参数文件</h4><p>由于Revit可以有许多共享参数文件，因此必须明确标识要访问的文件和外部参数。以下两个过程说明如何访问现有的共享参数文件。</p>
<p>从外部参数文件中获取配置文件</p>
<p>按照下面的代码所示设置共享参数文件路径，然后调用Application.OpenSharedParameterFile()方法。</p>
<p>代码区域22-4：从外部参数文件获取定义文件</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> DefinitionFile <span class="title">SetAndOpenExternalSharedParamFile</span>(<span class="params">Autodesk.Revit.ApplicationServices.Application application, <span class="built_in">string</span> sharedParameterFile</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// set the path of shared parameter file to current Revit</span></span><br><span class="line">    application.SharedParametersFilename = sharedParameterFile;</span><br><span class="line">    <span class="comment">// open the file</span></span><br><span class="line">    <span class="keyword">return</span> application.OpenSharedParameterFile();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注：设置共享参数路径时，请考虑以下几点： 在每次安装过程中，Revit无法检测是否在其他版本中设置了共享参数文件。必须再次为新的Revit安装绑定共享参数文件。 如果Application. SharedParametersFilm设置为无效路径，则仅在调用OpenSharedParameterFile()时引发异常。 * Revit可以使用多个共享参数文件。即使加载参数时只使用一个参数文件，也可以自由更改当前文件。 </p>
<h4 id="遍历所有参数"><a href="#遍历所有参数" class="headerlink" title="遍历所有参数"></a>遍历所有参数</h4><p>下面的示例阐释如何遍历参数项并在消息框中显示结果。</p>
<p>代码区域22-5：遍历参数条目</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ShowDefinitionFileInfo</span>(<span class="params">DefinitionFile myDefinitionFile</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    StringBuilder fileInformation = <span class="keyword">new</span> StringBuilder(<span class="number">500</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get the file name </span></span><br><span class="line">    fileInformation.AppendLine(<span class="string">&quot;File Name: &quot;</span> + myDefinitionFile.Filename);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// iterate the Definition groups of this file</span></span><br><span class="line">    <span class="keyword">foreach</span> (DefinitionGroup myGroup <span class="keyword">in</span> myDefinitionFile.Groups)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// get the group name</span></span><br><span class="line">        fileInformation.AppendLine(<span class="string">&quot;Group Name: &quot;</span> + myGroup.Name);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// iterate the difinitions</span></span><br><span class="line">        <span class="keyword">foreach</span> (Definition definition <span class="keyword">in</span> myGroup.Definitions)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// get definition name</span></span><br><span class="line">            fileInformation.AppendLine(<span class="string">&quot;Definition Name: &quot;</span> + definition.Name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>,fileInformation.ToString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="更改参数定义所有者组"><a href="#更改参数定义所有者组" class="headerlink" title="更改参数定义所有者组"></a>更改参数定义所有者组</h4><p>以下示例说明如何更改参数定义组所有者。</p>
<p>代码区域22-6：更改参数定义组所有者</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ReadEditExternalParam</span>(<span class="params">DefinitionFile <span class="keyword">file</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// get ExternalDefinition from shared parameter file</span></span><br><span class="line">    DefinitionGroups myGroups = <span class="keyword">file</span>.Groups;</span><br><span class="line">    DefinitionGroup myGroup = myGroups.get_Item(<span class="string">&quot;MyGroup&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (myGroup != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ExternalDefinition myExtDef = myGroup.Definitions.get_Item(<span class="string">&quot;MyParam&quot;</span>) <span class="keyword">as</span> ExternalDefinition;</span><br><span class="line">        <span class="keyword">if</span> (myExtDef != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            DefinitionGroup newGroup = myGroups.get_Item(<span class="string">&quot;AnotherGroup&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (newGroup != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// change the OwnerGroup of the ExternalDefinition</span></span><br><span class="line">                myExtDef.OwnerGroup = newGroup;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Binding"><a href="#Binding" class="headerlink" title="Binding"></a>Binding</h3><p>绑定是将共享参数与模型中某些类别的元素联系在一起。</p>
<p>有两种类型的绑定可用，实例绑定和类型绑定。两者之间的主要区别在于，实例绑定参数出现在这些类别中元素的所有实例上。更改其中一个实例的参数不会影响该参数的其他实例。类型绑定参数仅出现在类型对象上，并由使用该类型的所有实例共享。更改类型绑定参数会影响使用该类型的元素的所有实例。请注意，定义只能绑定到实例或类型，而不能同时绑定到两者。</p>
<p>要绑定参数，请执行以下操作：</p>
<ol>
<li>使用InstanceBinding或TypeBinding对象可以创建一个新的Binding对象，该对象包括参数绑定到的类别。</li>
<li>使用Document.ParameterBindings属性提供的BindingMap对象将绑定和定义添加到文档中。</li>
</ol>
<p>Autodesk.Revit.DB命名空间中的以下类和方法提供了有关将参数绑定到元素的详细信息。</p>
<ul>
<li>BindingMap类<ul>
<li>从Document.ParameterBindings属性检索。</li>
<li>参数绑定将参数定义连接到一个或多个类别中的元素。</li>
<li>该映射用于查询现有绑定以及使用Insert方法生成新的参数绑定。</li>
</ul>
</li>
<li>BindingMap.Insert()方法<ul>
<li>绑定对象类型规定参数是绑定到所有实例还是仅绑定到类型。</li>
<li>参数定义不能同时绑定到实例和类型。</li>
<li>如果参数绑定存在，则该方法返回false。</li>
</ul>
</li>
</ul>
<h4 id="Type-Binding"><a href="#Type-Binding" class="headerlink" title="Type Binding"></a>Type Binding</h4><p>TypeBinding对象用于将特性绑定到Revit类型（如墙类型）。它与实例绑定的不同之处在于，该属性由类型绑定中标识的所有实例共享。更改一个类型的参数会影响同一类型的所有实例。</p>
<p>下面的代码示例演示如何使用共享参数文件添加参数定义。以下代码执行的操作与使用Revit UI中的对话框执行的操作相同。参数定义按以下顺序创建：</p>
<ol>
<li>将创建共享参数文件。</li>
<li>将为墙类型创建定义组和参数定义。</li>
<li>定义将根据墙类别绑定到当前文档中的墙类型参数。</li>
</ol>
<p>代码区域22-7：使用共享参数文件添加类型参数定义</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">SetNewParameterToTypeWall</span>(<span class="params">UIApplication app, DefinitionFile myDefinitionFile</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Create a new group in the shared parameters file</span></span><br><span class="line">    DefinitionGroups myGroups = myDefinitionFile.Groups;</span><br><span class="line">    DefinitionGroup myGroup = myGroups.Create(<span class="string">&quot;MyParameters&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create a type definition</span></span><br><span class="line">    ExternalDefinitionCreationOptions option = <span class="keyword">new</span> ExternalDefinitionCreationOptions(<span class="string">&quot;CompanyName&quot;</span>, ParameterType.Text);</span><br><span class="line">    Definition myDefinition_CompanyName = myGroup.Definitions.Create(option);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create a category set and insert category of wall to it</span></span><br><span class="line">    CategorySet myCategories = app.Application.Create.NewCategorySet();</span><br><span class="line">    <span class="comment">// Use BuiltInCategory to get category of wall</span></span><br><span class="line">    Category myCategory = Category.GetCategory(app.ActiveUIDocument.Document, BuiltInCategory.OST_Walls);</span><br><span class="line"></span><br><span class="line">    myCategories.Insert(myCategory);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Create an object of TypeBinding according to the Categories</span></span><br><span class="line">    TypeBinding typeBinding = app.Application.Create.NewTypeBinding(myCategories);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get the BingdingMap of current document.</span></span><br><span class="line">    BindingMap bindingMap = app.ActiveUIDocument.Document.ParameterBindings;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Bind the definitions to the document</span></span><br><span class="line">    <span class="built_in">bool</span> typeBindOK = bindingMap.Insert(myDefinition_CompanyName, typeBinding,</span><br><span class="line">        BuiltInParameterGroup.PG_TEXT);</span><br><span class="line">    <span class="keyword">return</span> typeBindOK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Instance-Binding"><a href="#Instance-Binding" class="headerlink" title="Instance Binding"></a>Instance Binding</h4><p>InstanceBinding对象指示参数定义和某些类别实例中的参数之间的绑定。</p>
<p>Once bound, the parameter appears in all property dialog boxes for the instance (if the visible property is set to true). Changing the parameter in any one instance does not change the value in any other instance.<br>绑定后，该参数将显示在实例的所有属性对话框中（如果visible属性设置为true）。在任何一个实例中更改参数不会更改任何其他实例中的值。</p>
<p>The following code sample demonstrates how to add parameter definitions using a shared parameter file. Parameter definitions are added in the following order:<br>下面的代码示例演示如何使用共享参数文件添加参数定义。参数定义按以下顺序添加：</p>
<ol>
<li>A shared parameter file is created<br>创建共享参数文件</li>
<li>A definition group and a definition for all Walls instances is created<br>将创建所有墙实例的定义组和定义</li>
<li>Definitions are bound to each wall instance parameter in the current document based on the wall category.<br>定义将根据墙类别绑定到当前文档中的每个墙实例参数。</li>
</ol>
<p>代码区域22-8：使用共享参数文件添加实例参数定义</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">SetNewParameterToInstanceWall</span>(<span class="params">UIApplication app, DefinitionFile myDefinitionFile</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// create a new group in the shared parameters file</span></span><br><span class="line">    DefinitionGroups myGroups = myDefinitionFile.Groups;</span><br><span class="line">    DefinitionGroup myGroup = myGroups.Create(<span class="string">&quot;MyParameters1&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create an instance definition in definition group MyParameters</span></span><br><span class="line">    ExternalDefinitonCreationOptions option = <span class="keyword">new</span> ExternalDefinitonCreationOptions(<span class="string">&quot;Instance_ProductDate&quot;</span>, ParameterType.Text);</span><br><span class="line">    <span class="comment">// Don&#x27;t let the user modify the value, only the API</span></span><br><span class="line">    option.UserModifiable = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// Set tooltip</span></span><br><span class="line">    option.Description = <span class="string">&quot;Wall product date&quot;</span>;</span><br><span class="line">    Definition myDefinition_ProductDate = myGroup.Definitions.Create(option);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create a category set and insert category of wall to it</span></span><br><span class="line">    CategorySet myCategories = app.Application.Create.NewCategorySet();</span><br><span class="line">    <span class="comment">// use BuiltInCategory to get category of wall</span></span><br><span class="line">    Category myCategory = Category.GetCategory(app.ActiveUIDocument.Document, BuiltInCategory.OST_Walls);</span><br><span class="line"></span><br><span class="line">    myCategories.Insert(myCategory);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Create an instance of InstanceBinding</span></span><br><span class="line">    InstanceBinding instanceBinding = app.Application.Create.NewInstanceBinding(myCategories);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get the BingdingMap of current document.</span></span><br><span class="line">    BindingMap bindingMap = app.ActiveUIDocument.Document.ParameterBindings;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Bind the definitions to the document</span></span><br><span class="line">    <span class="built_in">bool</span> instanceBindOK = bindingMap.Insert(myDefinition_ProductDate,</span><br><span class="line">                                    instanceBinding, BuiltInParameterGroup.PG_TEXT);</span><br><span class="line">    <span class="keyword">return</span> instanceBindOK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="SharedParameterElement"><a href="#SharedParameterElement" class="headerlink" title="SharedParameterElement"></a>SharedParameterElement</h3><p>SharedParameterElements存储有关文档中特定用户定义的共享参数的信息</p>
<p>用户定义的参数存储在文档中，并由ParameterElement类表示。子类SharedParameterElement表示加载到文档中的共享参数。ParemeterElement也是GlobalParameter的基类。</p>
<p>一旦共享参数被加载到文档中，就可以从SharedParameterElement类中检索有关它的信息。SharedParameterElement从父ParameterElement类继承GetDefinition()方法。GetDefinition()返回表示文档中参数定义的InternalDefinition，而不是存储在共享参数文件中的共享参数的ExternalDefinition。SharedParameterElement还通过GuidValue属性提供对标识共享参数的Guid的访问。</p>
<p>该类的静态Create()方法可以从ExternalDefinition在文档中创建一个新的SharedParameterElement。</p>
<p>静态函数可以从给定的Guid中检索SharedParameterElement。</p>
<p>在下面的示例中，明细表包含一个表示共享参数值的字段。从SharedParameterElement检索共享参数的定义。</p>
<p>代码区域：获取共享参数的定义</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Check if a given shared parameter in a schedule can vary across groups</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">CanParamVaryAcrossGroups</span>(<span class="params">ViewSchedule schedule, <span class="built_in">string</span> sharedParamName</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">bool</span> variesAcrossGroups = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> numFields =  schedule.Definition.GetFieldCount();</span><br><span class="line">    <span class="comment">// Find the field with the given name</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; numFields; i++)</span><br><span class="line">       &#123;</span><br><span class="line">              ScheduleField field = schedule.Definition.GetField(i);</span><br><span class="line">        <span class="keyword">if</span> (field.GetName().Contains(sharedParamName))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Get the SharedParameterElement from the field&#x27;s parameter id</span></span><br><span class="line">            SharedParameterElement spe = schedule.Document.GetElement(field.ParameterId) <span class="keyword">as</span> SharedParameterElement;</span><br><span class="line">            <span class="keyword">if</span> (spe != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                InternalDefinition definition = spe.GetDefinition();</span><br><span class="line">                variesAcrossGroups = definition.VariesAcrossGroups;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> variesAcrossGroups;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SharedParameterElements在使用RebarContainers时特别有用。可以将共享参数作为覆盖添加到RebarContainer的参数管理器中。shared参数不需要绑定到要作为覆盖添加的任何类别。下面的示例将给定的共享参数作为重写添加到RebarContainer。</p>
<p>代码区域：使用SharedParameterElement重写RebarContainer</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Find the named shared parameter and add it as an override to the parameter manger for the given RebarContainer</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddSharedParameterOverride</span>(<span class="params">RebarContainer container, <span class="built_in">string</span> sharedParamName</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// find the shared parameter guid</span></span><br><span class="line">    FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(container.Document);</span><br><span class="line">    collector.OfClass(<span class="keyword">typeof</span>(SharedParameterElement));</span><br><span class="line">    IEnumerable paramCollector = collector.Cast();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">foreach</span> (SharedParameterElement spe <span class="keyword">in</span> paramCollector)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (spe.Name.CompareTo(sharedParamName) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            RebarContainerParameterManager paramManager = container.GetParametersManager();</span><br><span class="line">            paramManager.AddSharedParameterAsOverride(spe.Id);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="全局参数"><a href="#全局参数" class="headerlink" title="全局参数"></a>全局参数</h2><p>全局参数支持通过项目文档中定义的特殊参数控制几何约束。</p>
<p>全局参数可用于标注和报告至&#x2F;自标注，以及设置实例参数的值。它们可用于驱动尺寸或其他元素参数的值，也可由选定尺寸驱动，选定尺寸的值将确定全局参数的值。</p>
<p>本节中的页面</p>
<ul>
<li>管理全局参数</li>
<li>全局参数基础</li>
<li>报告与非报告参数</li>
<li>公式和全局参数</li>
<li>使用全局参数标注标注</li>
</ul>
<h3 id="管理全局参数"><a href="#管理全局参数" class="headerlink" title="管理全局参数"></a>管理全局参数</h3><p>GlobalParametersManager类提供对特定模型中的全局参数元素的常规信息和数据的访问。</p>
<p>GlobalParametersManager提供了管理项目文档中全局参数的主要访问点。它提供了静态方法来访问和重新排序全局参数，并测试名称的唯一性和ID的有效性。</p>
<h4 id="全局参数-1"><a href="#全局参数-1" class="headerlink" title="全局参数"></a>全局参数</h4><p>仅在项目文档中支持全局参数，而在族文档中不支持全局参数。然而，即使有项目文件，在某些情况下也可能暂时或永久地不允许使用全局参数。AreGlobalParametersAllowed()方法将指示在指定文档中是否允许全局参数。</p>
<p>如果允许在项目文档中使用全局参数，请使用方法GetAllGlobalParameters()获取指定文档中的所有全局参数，或使用GetGlobalParametersOrdered()获取全局参数的有序列表。检索有序列表时，项目的顺序与Revit用户界面中标准“全局参数”对话框中全局参数的显示顺序相对应。</p>
<p>要按名称获取全局参数，请调用FindByName()，它将返回命名的全局参数的ElementId，如果没有找到具有给定名称的全局参数，则返回ElementId.InvalidElementId。由于全局参数名称必须是唯一的，因此应在创建新的GlobalParameter之前调用IsUniqueName()方法来检查名称。</p>
<p>给定全局参数的ElementId，IsValidGlobalParameter()将确认给定的ElementId是有效的全局参数id。</p>
<p>下面的示例演示如何获取所有全局参数（如果文档中允许全局参数）。</p>
<p>代码区域：获取全局参数</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> Returns all global parameter elements defined in the given document. </span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> </span></span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> Revit project document.</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> A set of ElementIds of global parameter elements</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ISet <span class="title">GetAllGlobalParameters</span>(<span class="params">Document document</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Global parameters are not available in all documents.</span></span><br><span class="line">    <span class="comment">// They are available in projects, but not in families.</span></span><br><span class="line">    <span class="keyword">if</span> (GlobalParametersManager.AreGlobalParametersAllowed(document))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> GlobalParametersManager.GetAllGlobalParameters(document);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// return an empty set if global parameters are not available in the document</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HashSet();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="重新排序全局参数"><a href="#重新排序全局参数" class="headerlink" title="重新排序全局参数"></a>重新排序全局参数</h4><p>GlobalParametersManager提供了更改项目文档中全局参数的给定顺序的方法。这些操作对全局参数本身没有影响。重新排列的顺序仅在Revit的标准“全局参数”对话框中可见，并反映在GetGlobalParametersOrdered()方法中。</p>
<ul>
<li>SortParameters()-按字母顺序的升序或降序对全局参数进行排序，但仅在其各自的参数组范围内。</li>
<li>MoveParameterDownOrder()-按当前顺序向下移动给定参数。</li>
<li>MoveParameterUpOrder()-将给定参数按当前顺序上移。一个参数只能在其参数组内移动，所以如果一个参数因为位于其组的边界而不能再移动，MoveParameter方法将返回False。</li>
</ul>
<h3 id="全局参数基础"><a href="#全局参数基础" class="headerlink" title="全局参数基础"></a>全局参数基础</h3><p>GlobalParameter类表示项目文档中的全局参数，可用于创建和修改全局参数。</p>
<h4 id="创建全局参数"><a href="#创建全局参数" class="headerlink" title="创建全局参数"></a>创建全局参数</h4><p>全局参数只能在项目文档中创建，而不能在族中创建。全局参数通过静态Create()方法在给定文档中创建，具有给定的名称和参数类型。每个新参数在文档中必须有一个唯一的名称，可以使用静态GlobalParametersManager.IsUniqueName()方法确定该名称。全局参数几乎可以使用任何类型的数据创建，但有几种类型目前不受支持，例如ElementId类型。使用静态GlobalParameter.IsValidDataType()方法测试特定数据类型是否适合全局参数。</p>
<p>代码区域：创建新的全局参数</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> </span></span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> Creates a new Global Parameter of type Length, assigns it an initial value,</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> and uses it to label a set of input dimension elements.</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> </span></span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> Revit project document in which to create the parameter.</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> Name of the global parameter to create.</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> A value the new global parameter is to have.</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> A set of dimension to labe by the new global parameter.</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> ElementId of the new GlobalParameter</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ElementId <span class="title">CreateNewGlobalParameter</span>(<span class="params">Document document, String name, <span class="built_in">double</span> <span class="keyword">value</span>, ISet dimensionsToLabel</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!GlobalParametersManager.AreGlobalParametersAllowed(document))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> System.InvalidOperationException(<span class="string">&quot;Global parameters are not permitted in the given document&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!GlobalParametersManager.IsUniqueName(document, name))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> System.ArgumentException(<span class="string">&quot;Global parameter with such name already exists in the document&quot;</span>, <span class="string">&quot;name&quot;</span>);</span><br><span class="line"></span><br><span class="line">    ElementId gpid = ElementId.InvalidElementId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// creation of any element must be in a transaction</span></span><br><span class="line">    <span class="keyword">using</span> (Transaction trans = <span class="keyword">new</span> Transaction(document, <span class="string">&quot;Create Global Parameter&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        trans.Start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// create a GP with the given name and type Length</span></span><br><span class="line">        GlobalParameter gp = GlobalParameter.Create(document, name, ParameterType.Length);</span><br><span class="line">        <span class="keyword">if</span> (gp != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// if created successfully, assign it a value</span></span><br><span class="line">            <span class="comment">// note: parameters of type Length accept Double values</span></span><br><span class="line">            gp.SetValue(<span class="keyword">new</span> DoubleParameterValue(<span class="keyword">value</span>));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// if a collection of dimensions was given, label them with this new parameter</span></span><br><span class="line">            <span class="keyword">foreach</span> (ElementId elemid <span class="keyword">in</span> dimensionsToLabel)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// not just any dimension is allowed to be labeled</span></span><br><span class="line">                <span class="comment">// check first to avoid exceptions</span></span><br><span class="line">                <span class="keyword">if</span> (gp.CanLabelDimension(elemid))</span><br><span class="line">                &#123;</span><br><span class="line">                    gp.LabelDimension(elemid);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            gpid = gp.Id;</span><br><span class="line">        &#125;</span><br><span class="line">        trans.Commit();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> gpid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="获取和设置全局参数的值"><a href="#获取和设置全局参数的值" class="headerlink" title="获取和设置全局参数的值"></a>获取和设置全局参数的值</h4><p>所有全局参数，无论是公式驱动的、尺寸驱动的还是独立的，都有值。可以通过调用GetValue()方法来获取值。该方法返回的对象是从ParameterValue类派生的类之一的实例：</p>
<ul>
<li>IntegerParameterValue </li>
<li>DoubleParameterValue</li>
<li>StringParameterValue</li>
</ul>
<p>所有派生类都只有一个属性Value，它获取或设置相应类型的值。</p>
<p>具体实例由创建时指定的全局参数的类型确定。既不是公式驱动的参数也不是维度驱动的参数（报告）可以被赋值。要使用的方法是SetValue()，它接受GetValue()返回的相同类型的参数值。但是，类型也可以很容易地推导出来：Text参数只接受StringParameterValue。Integer 和 YesNo 参数仅接受IntegerParameterValue。所有其他参数仅接受DoubleParameterValue。</p>
<h4 id="受全局参数影响的元素"><a href="#受全局参数影响的元素" class="headerlink" title="受全局参数影响的元素"></a>受全局参数影响的元素</h4><p>全局参数可以与其他全局参数以及常规族实例参数相关联（常规族实例参数可以通过指定公式将全局参数报告为它们的值）。有两种方法可用于查找参数之间的关系：GlobalParameter.GetAffectedGlobalParameters()和GlobalParameter.GetAffectedElements()。前者返回在其各自的公式中引用特定全局参数的所有其他全局参数。后一个方法返回一组所有元素，其中一些参数由全局参数控制。这两个方法与GlobalParameter.GetLabeledDimensions()一起可以帮助确定模型元素如何通过全局参数相互关联。</p>
<p>可以在Parameter类中找到用于维护元素属性和全局参数之间的关联的方法。</p>
<h3 id="报告与非报告参数"><a href="#报告与非报告参数" class="headerlink" title="报告与非报告参数"></a>报告与非报告参数</h3><p>全局参数类型的最大区别是它们是报告参数还是非报告参数。</p>
<h4 id="什么是报告和非报告参数？"><a href="#什么是报告和非报告参数？" class="headerlink" title="什么是报告和非报告参数？"></a>什么是报告和非报告参数？</h4><p>有几种方法可以对全局参数进行分类，但最重要的分类可能源于GlobalParameter.IsReporting属性，该属性将全局参数分为两组-报告和非报告。报告参数的重要性在于它们的值由报告参数标记的维度驱动。这意味着报告参数的值反映了尺寸（长度或角度）的值，并在尺寸更改时更新。非报告参数的行为方式相反-它们驱动已由其标记的尺寸的值，这导致通过全局参数的值控制模型的几何体。</p>
<p>报告参数在几个方面受到限制。它们只能是“长度”或“角度”类型，这是因为尺寸必须能够驱动值。出于同样的原因，报告参数可能没有公式。</p>
<p>另一方面，非报告参数几乎可以是任何类型（长度、宽度、面积等）。ElementId类型除外。此外，非报告参数可能已分配公式，其中其他全局参数可用作参数。这样，一个全局参数的值可以从其他参数（或多个参数）导出，而其他参数可以是报告或非报告的。</p>
<p>全局参数的其他重要属性是IsDrivenByDimension和IsDrivenByFormula，它们是互斥的-分配了公式的参数不能由维驱动（也不能由报告驱动），反之亦然。</p>
<h4 id="使全局参数报告或不报告"><a href="#使全局参数报告或不报告" class="headerlink" title="使全局参数报告或不报告"></a>使全局参数报告或不报告</h4><p>全局参数在创建时最初是非报告的，但一旦创建了全局参数并且属于合格类型，就可以使用GlobalParameter.IsReporting属性将其设置为报告。使用GlobalParameter.HasValidTypeForReporting()确保可以使特定数据类型进行报告。请注意，当一个参数标记了多个维度后，该参数可能无法进行报告。这是因为报告参数只能标记一个维度（并由一个维驱动）。</p>
<p>生成参数报告的另一种方法是通过GlobalParameter.SetDrivingDimension()方法，该方法通过全局参数标记一个维度，如果尚未报告，则也生成参数报告。</p>
<p>尽管由尺寸驱动的参数会自动生成报告，但由公式驱动的参数则不会。为了设置公式，全局参数必须为非报告参数。因此，在分配公式之前，必须首先将报告参数更改为非报告参数。</p>
<h3 id="公式和全局参数"><a href="#公式和全局参数" class="headerlink" title="公式和全局参数"></a>公式和全局参数</h3><p>公式可以分配给非报告参数。</p>
<p>与族参数一样，可以使用GlobalParameter.SetFormula()方法将公式分配给全局参数。由于要设置公式，全局参数必须为非报告参数，因此在分配公式之前，必须将报告参数更改为非报告参数。</p>
<p>计算公式的值必须与参数的值类型兼容。例如，允许在分配给Double（<strong>Number</strong>）参数的公式中使用<strong>NULL</strong>参数，反之亦然。但是，不允许在公式中的参数类型为<strong>“ether”</strong>或“<strong>Number”</strong>的参数中使用<strong>Length</strong>或<strong>Angle</strong>参数。</p>
<p>公式可以包括所有标准的算术运算和逻辑运算（如函数<strong>and</strong>，<strong>or</strong>，<strong>not</strong>）。逻辑运算的输入必须是布尔值（YesNo类型的参数）。因此，算术运算只能应用于数值。虽然字符串（文本）参数不支持任何操作，但字符串可以用作逻辑<strong>If</strong>操作的结果。根据其类型（和单位），不同值类型的参数可以组合。但是，无单位值（例如<strong>，“”</strong>和<strong>“Number</strong>（double）”）只能相互组合。</p>
<p>由于公式可能会变得非常复杂，并且由于某些公式无法分配给某些参数，因此可以使用IsValidFormula()方法来测试公式对于全局参数是否有效。如果调用SetFormula()时全局参数的公式无效，则将引发异常。</p>
<p>GetFormula()将以字符串的形式返回当前公式。</p>
<p>下面的代码示例创建四个全局参数，然后将公式设置为1，以便它的值为其他两个参数中的任何一个，具体取决于第四个参数的布尔值。</p>
<p>代码区域：设置公式</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetCombinationParameters</span>(<span class="params">Document document</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    GlobalParameter gpB = <span class="literal">null</span>;</span><br><span class="line">    GlobalParameter gpT = <span class="literal">null</span>;</span><br><span class="line">    GlobalParameter gpF = <span class="literal">null</span>;</span><br><span class="line">    GlobalParameter gpX = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> TRUE = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">int</span> FALSE = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// transaction to create global parameters and set their values</span></span><br><span class="line">    <span class="keyword">using</span> (Transaction trans = <span class="keyword">new</span> Transaction(document, <span class="string">&quot;Creating global parameters&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// create 4 new global parameters</span></span><br><span class="line"></span><br><span class="line">        trans.Start();</span><br><span class="line"></span><br><span class="line">        gpB = GlobalParameter.Create(document, <span class="string">&quot;GPB&quot;</span>, ParameterType.YesNo);</span><br><span class="line">        gpT = GlobalParameter.Create(document, <span class="string">&quot;GPT&quot;</span>, ParameterType.Text);</span><br><span class="line">        gpF = GlobalParameter.Create(document, <span class="string">&quot;GPF&quot;</span>, ParameterType.Text);</span><br><span class="line">        gpX = GlobalParameter.Create(document, <span class="string">&quot;GPX&quot;</span>, ParameterType.Text);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// assign initial values and a formula to the global parameters</span></span><br><span class="line"></span><br><span class="line">        gpB.SetValue(<span class="keyword">new</span> IntegerParameterValue(TRUE));</span><br><span class="line">        gpT.SetValue(<span class="keyword">new</span> StringParameterValue(<span class="string">&quot;TypeA&quot;</span>));</span><br><span class="line">        gpF.SetValue(<span class="keyword">new</span> StringParameterValue(<span class="string">&quot;TypeB&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Set the formula to GPX so that its final value is either the value of GPT (TypeA)</span></span><br><span class="line">        <span class="comment">// or GPF (TypeB) depending on whether the value of GPB is True or False.</span></span><br><span class="line">        <span class="comment">// Note: in this particular case we are certain the formula is valid, but if weren&#x27;t </span></span><br><span class="line">        <span class="comment">// certain, we could use a validation method as we are now going to illustrate here:</span></span><br><span class="line">        <span class="built_in">string</span> expression = <span class="string">&quot;if(GPB,GPT,GPF)&quot;</span>; <span class="comment">// XPX &lt;== if (GPB == TRUE) then GPT else GPF</span></span><br><span class="line">        <span class="keyword">if</span> (gpX.IsValidFormula(expression))</span><br><span class="line">        &#123;</span><br><span class="line">            gpX.SetFormula(expression);        &#125;</span><br><span class="line"></span><br><span class="line">        trans.Commit();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// we can test that the formula works</span></span><br><span class="line">    <span class="comment">// since the boolean value is TRUE, the value of the GPX parameter</span></span><br><span class="line">    <span class="comment">// should be the same as the value of the GPT parameters</span></span><br><span class="line"></span><br><span class="line">    StringParameterValue sTrue = gpT.GetValue() <span class="keyword">as</span> StringParameterValue;</span><br><span class="line">    StringParameterValue sFalse = gpF.GetValue() <span class="keyword">as</span> StringParameterValue;</span><br><span class="line">    StringParameterValue sValue = gpX.GetValue() <span class="keyword">as</span> StringParameterValue;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sValue.Value != sTrue.Value)</span><br><span class="line">    &#123;</span><br><span class="line">        TaskDialog.Show(<span class="string">&quot;Error&quot;</span>, <span class="string">&quot;Unexpected value of a global parameter&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// we can also test that evaluation of the formula is affected by changes</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> (Transaction trans = <span class="keyword">new</span> Transaction(document, <span class="string">&quot;Change value of a YesNo parameter&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        trans.Start();</span><br><span class="line">        gpB.SetValue(<span class="keyword">new</span> IntegerParameterValue(FALSE));</span><br><span class="line">        trans.Commit();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sValue = gpX.GetValue() <span class="keyword">as</span> StringParameterValue;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sValue.Value != sFalse.Value)</span><br><span class="line">    &#123;</span><br><span class="line">        TaskDialog.Show(<span class="string">&quot;Error&quot;</span>, <span class="string">&quot;Unexpected value of a global parameter&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用全局参数标注标注"><a href="#使用全局参数标注标注" class="headerlink" title="使用全局参数标注标注"></a>使用全局参数标注标注</h3><p>全局参数的一个关键特性是它们能够“标记”尺寸。</p>
<p>当维度由全局参数标记时，其值要么由参数控制（非报告），要么驱动参数的值（报告）。需要注意的是，报告参数最多只能标记一个维对象，这意味着参数只能由一个维驱动。如果尺寸标注有多个线段，并且由非报告参数标记，则每个线段的值将由该参数驱动。多段维不能用报告参数标记。</p>
<p>如果该维度已被另一个全局参数标记，则再次标记它将自动将其与该参数分离。</p>
<p>目前，只能标记单个<strong>线性</strong>和<strong>角度</strong>尺寸，但也有其他限制。使用CanLabelDimension()方法来确定是否可以标记特定的维度元素。此外，由于参数的值和由其标记的尺寸相互依赖，因此全局参数的数据类型必须是<strong>Length</strong>或<strong>Angle</strong>，因为这是尺寸可以表示的唯一单位。</p>
<p>下面的示例创建一个全局参数，并使用它来标记给定维度元素集。</p>
<p>代码区域：标签尺寸</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">DriveSelectedDimensions</span>(<span class="params">Document document, <span class="built_in">string</span> name, <span class="built_in">double</span> <span class="keyword">value</span>, ISet dimset</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!GlobalParametersManager.AreGlobalParametersAllowed(document))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> System.InvalidOperationException(<span class="string">&quot;Global parameters are not permitted in the given document&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!GlobalParametersManager.IsUniqueName(document, name))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> System.ArgumentException(<span class="string">&quot;Global parameter with such name already exists in the document&quot;</span>, <span class="string">&quot;name&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">value</span> &lt;= <span class="number">0.0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> System.ArgumentException(<span class="string">&quot;Value of a global parameter that drives dimension must be a positive number&quot;</span>, <span class="string">&quot;value&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> nLabeledDims = <span class="number">0</span>;   <span class="comment">// number of labeled dimensions (for testing)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// creation of any element must be in a transaction</span></span><br><span class="line">    <span class="keyword">using</span> (Transaction trans = <span class="keyword">new</span> Transaction(document, <span class="string">&quot;Create Global Parameter&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        trans.Start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// create a GP with the given name and type Length</span></span><br><span class="line">        <span class="comment">// Note: Length (or Angle) is required type of global parameters that are to label a dimension</span></span><br><span class="line">        GlobalParameter newgp = GlobalParameter.Create(document, name, ParameterType.Length);</span><br><span class="line">        <span class="keyword">if</span> (newgp != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            newgp.SetValue(<span class="keyword">new</span> DoubleParameterValue(<span class="keyword">value</span>));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// use the parameter to label the given dimensions</span></span><br><span class="line">            <span class="keyword">foreach</span> (ElementId elemid <span class="keyword">in</span> dimset)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// not just any dimension is allowed to be labeled</span></span><br><span class="line">                <span class="comment">// check first to avoid exceptions</span></span><br><span class="line">                <span class="keyword">if</span> (newgp.CanLabelDimension(elemid))</span><br><span class="line">                &#123;</span><br><span class="line">                    newgp.LabelDimension(elemid);</span><br><span class="line">                    nLabeledDims += <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            trans.Commit();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// for illustration purposes only, we&#x27;ll test the results of our modifications </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.) Check the new parameter can be found</span></span><br><span class="line"></span><br><span class="line">    ElementId gpid = GlobalParametersManager.FindByName(document,name);</span><br><span class="line">    <span class="keyword">if</span> (gpid == ElementId.InvalidElementId)</span><br><span class="line">    &#123;</span><br><span class="line">        TaskDialog.Show(<span class="string">&quot;Error&quot;</span>, <span class="string">&quot;Failed to find a newly created global parameter&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    GlobalParameter gp = document.GetElement(gpid) <span class="keyword">as</span> GlobalParameter;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. Check the number of labeled dimension is as expected</span></span><br><span class="line"></span><br><span class="line">    ISet labeledSet = gp.GetLabeledDimensions();</span><br><span class="line">    <span class="keyword">if</span> (labeledSet.Count != nLabeledDims)</span><br><span class="line">    &#123;</span><br><span class="line">        TaskDialog.Show(<span class="string">&quot;Error&quot;</span>, <span class="string">&quot;Have not found all the dimension that were labeled.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> labeledSet.Count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SetDrivingDimension()方法结合了两个操作：a）如果参数尚未报告，则进行参数报告，以及B）使用它标记给定维。因此，全局参数必须符合报告条件，并且不得用于标记多个维。有关报告参数的详细信息，请参阅报告参数与非报告参数页面 如果此参数已由另一个维度驱动，则在标记给定的维度之前，将首先取消标记另一个维度。这是因为报告参数一次只能标记一个维度（即，它只能由一个维度驱动）。 下一个示例创建由尺寸值驱动的全局参数。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">AssignDrivingDimension</span>(<span class="params">Document document, ElementId gpid, ElementId dimid</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// we expect to find the global parameter in the document</span></span><br><span class="line">    GlobalParameter gp = document.GetElement(gpid) <span class="keyword">as</span> GlobalParameter;</span><br><span class="line">    <span class="keyword">if</span> (gp == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// we expect to find the given dimension in the document</span></span><br><span class="line">    Dimension dim = document.GetElement(dimid) <span class="keyword">as</span> Dimension;</span><br><span class="line">    <span class="keyword">if</span> (dim == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// not every global parameter can label</span></span><br><span class="line">    <span class="comment">// and not every dimension can be labeled</span></span><br><span class="line">    <span class="keyword">if</span> (!gp.CanLabelDimension(dimid))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// we need a transaction to modify the model</span></span><br><span class="line">    <span class="keyword">using</span> (Transaction trans = <span class="keyword">new</span> Transaction(document,<span class="string">&quot;Assign a driving dimension&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        trans.Start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// we cannot assign a driving dimension to a global</span></span><br><span class="line">        <span class="comment">// parameter that is already used to label other dimensions</span></span><br><span class="line">        ISet dimset = gp.GetLabeledDimensions();</span><br><span class="line">        <span class="keyword">foreach</span> (ElementId elemid <span class="keyword">in</span> dimset)</span><br><span class="line">        &#123;</span><br><span class="line">            gp.UnlabelDimension(elemid);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// with the GP free of all previously labels (if there were any)</span></span><br><span class="line">        gp.SetDrivingDimension(dimid);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// we should be able to commit, but we test the result anyway</span></span><br><span class="line">        <span class="keyword">if</span> (trans.Commit() != TransactionStatus.Committed)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h2><p>Parameter类包含给定参数的值。</p>
<p>Autodesk Revit中的所有图元都包含参数，这些参数可以作为一个集合或单独检索。可以使用BuiltInParameter枚举、Definition对象或Shared Parameter对象从任何Element中获取单个参数对象。参数中包含的数据可以是Double、String、String或ElementId，如其String Type属性所示。对于值类型，DisplayUnitType属性将指示用于参数值的显示单位。Parameter对象还包含一个Definition对象，用于描述参数的数据类型、名称和其他详细信息。</p>
<h3 id="StorageType"><a href="#StorageType" class="headerlink" title="StorageType"></a>StorageType</h3><p>储存类型描述内部存储的参数值的类型。</p>
<p>根据属性值，使用相应的get和set方法来检索和设置参数数据值。</p>
<p>“储存类型”是一种枚举类型，列出了Revit支持的所有内部参数数据存储类型：</p>
<table>
<thead>
<tr>
<th><strong>Member Name 成员名称</strong></th>
<th><strong>Description 描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td><em>String</em></td>
<td>内部数据存储为字符串。</td>
</tr>
<tr>
<td><em>ElementId</em></td>
<td>数据类型表示一个元素，并存储为元素ID。</td>
</tr>
<tr>
<td><em>Double</em></td>
<td>数据在内部存储为8字节浮点数。</td>
</tr>
<tr>
<td><em>Integer</em></td>
<td>内部数据存储为有符号的32位整数。</td>
</tr>
<tr>
<td><em>None</em></td>
<td>无表示无效的存储类型。仅供内部使用。</td>
</tr>
</tbody></table>
<p>在大多数情况下，ElementId值为正数。但是，它可以是负数。当ElementId值为负时，它不表示元素，而是具有另一种含义。例如，梁的垂直投影的存储类型参数为ElementId。当参数值为Level 1或Level 2时，ElementId值为正，并与该级别的ElementId相对应。但是，当参数值设置为“自动检测”、“梁中心”或“梁顶部”时，ElementId值为负值。 下面的代码示例显示如何根据参数的类型检查参数的值是否可以设置为double值：</p>
<p>代码区域：检查参数的类型</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">SetParameter</span>(<span class="params">Parameter parameter, <span class="built_in">double</span> <span class="keyword">value</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">bool</span> result = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//if the parameter is readonly, you can&#x27;t change the value of it</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> != parameter &amp;&amp; !parameter.IsReadOnly)</span><br><span class="line">    &#123;</span><br><span class="line">        StorageType parameterType = parameter.StorageType;</span><br><span class="line">        <span class="keyword">if</span> (StorageType.Double != parameterType)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;The storagetypes of value and parameter are different!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//If successful, the result is true</span></span><br><span class="line">        result = parameter.Set(<span class="keyword">value</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Set()方法返回值指示参数值已更改。Set()方法在参数值被更改时返回true，否则返回false。 并非所有参数都是可写的。如果参数为只读，则引发异常。 ## AsValueString()和SetValueString() 这两个Parameter类方法仅适用于值类型参数，这些参数是表示测量量的双精度或整数参数。 使用AsValueString()方法以带有度量单位的字符串形式获取参数值。例如，“底部偏移”值（墙参数）为“双精度”值。通常，该值在“图元属性”中显示为字符串，如-20 ‘0”。使用AsValueString()方法，您可以直接获得-20 ‘0”字符串值。使用AsDouble()方法，可以得到一个不带度量单位的double值，如-20。 使用SetValueString()方法更改值类型参数的值，而不是使用Set()方法。下面的代码示例说明如何使用SetValueString()方法更改参数值：</p>
<p>使用参数. SetValueString()</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">SetWithValueString</span>(<span class="params">Parameter foundParameter</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">bool</span> result = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (!foundParameter.IsReadOnly)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//If successful, the result is true</span></span><br><span class="line">        result = foundParameter.SetValueString(<span class="string">&quot;-22\&#x27;3\&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="全局参数关联"><a href="#全局参数关联" class="headerlink" title="全局参数关联"></a>全局参数关联</h3><p>Parameter类有几种方法用于维护元素参数和全局参数之间的关联。方法GetAssociatedGlobalParameter()返回当前与参数关联的全局参数的ElementId（如果有）。如果此参数未与任何全局参数关联，则返回InvalidElementId。InvalidElementId也会在为一个甚至不能与全局参数相关联的参数（即一个不可参数化的参数或一个带有公式的参数）调用时返回。</p>
<p>有两种方法可以确定参数是否可以与全局参数关联。参数.CanBeAssociatedWithGlobalParameters()测试参数是否可以与任何全局参数相关联。只有定义为可参数化的属性才能与全局参数相关联。这不包括任何只读参数和公式驱动参数，以及具有Revit施加的其他显式或隐式限制的参数。若要测试特定全局参数是否可以与此参数关联，请使用Parameter.CanBeAssociatedWithGlobalParameter()。请记住，参数的值类型必须与全局参数的类型匹配，才能创建关联。</p>
<p>对于可以与全局参数关联的参数，请使用AssociateWithGlobalParameter()创建关联。关联后，可以在以后通过调用DissociateFromGlobalParameter()方法解除参数关联</p>
<h2 id="注：翻译自Revit-API-Developers-Guide"><a href="#注：翻译自Revit-API-Developers-Guide" class="headerlink" title="注：翻译自Revit API Developers Guide"></a><em><strong>注：</strong></em>翻译自<a href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_html">Revit API Developers Guide</a></h2>]]></content>
      <categories>
        <category>Revit二次开发人员指南</category>
      </categories>
      <tags>
        <tag>Revit</tag>
      </tags>
  </entry>
  <entry>
    <title>06选择</title>
    <url>/2024/12/05/Revit%E4%BA%8C%E5%BC%80%E6%8C%87%E5%8D%97/06%E9%80%89%E6%8B%A9/</url>
    <content><![CDATA[<h1 id="选择"><a href="#选择" class="headerlink" title="选择"></a><a href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_Basic_Interaction_with_Revit_Elements_Selection_html">选择</a></h1><p>您可以使用UIDo.Selection.GetElementIds()方法从当前活动文档中获取所选对象，该方法返回所选元素的ElementIds集合。此方法返回的集合可以直接与FilteredElementCollector一起使用，以筛选选定的元素。</p>
<p>Selection对象还可以用于使用SetElementIds()方法以编程方式更改当前选择。</p>
<p>Pages in this section 本节中的页面</p>
<ul>
<li>Changing the Selection 更改选择</li>
<li>User Selection 用户选择</li>
<li>Filtered User Selection 筛选的用户选择</li>
</ul>
<h2 id="更改选择"><a href="#更改选择" class="headerlink" title="更改选择"></a>更改选择</h2><p>要修改选定的图元，请执行以下操作：</p>
<ol>
<li>创建新的ElementId列表。</li>
<li>把ElementIds放进去。</li>
<li>使用新列表调用SetElementIds()。</li>
</ol>
<p>下面的示例说明了如何通过获取当前选择并仅过滤出墙以设置为新选择来更改选定的元素。</p>
<p><strong>代码区域7-1：更改所选元素</strong></p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ChangeSelection</span>(<span class="params">UIDocument uidoc</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Get selected elements from current document.</span></span><br><span class="line">    ICollection selectedIds = uidoc.Selection.GetElementIds();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Display current number of selected elements</span></span><br><span class="line">    TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>, <span class="string">&quot;Number of selected elements: &quot;</span> + selectedIds.Count.ToString());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Go through the selected items and filter out walls only.</span></span><br><span class="line">    ICollection selectedWallIds = <span class="keyword">new</span> List();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">foreach</span> (ElementId id <span class="keyword">in</span> selectedIds)</span><br><span class="line">    &#123;</span><br><span class="line">        Element elements = uidoc.Document.GetElement(id);</span><br><span class="line">        <span class="keyword">if</span> (elements <span class="keyword">is</span> Wall)</span><br><span class="line">        &#123;</span><br><span class="line">            selectedWallIds.Add(id);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set the created element set as current select element set.</span></span><br><span class="line">    uidoc.Selection.SetElementIds(selectedWallIds);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Give the user some information.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != selectedWallIds.Count)</span><br><span class="line">    &#123;</span><br><span class="line">        TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>, selectedWallIds.Count.ToString() + <span class="string">&quot; Walls are selected!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>,<span class="string">&quot;No Walls have been selected!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="用户选择"><a href="#用户选择" class="headerlink" title="用户选择"></a>用户选择</h2><p>Selection类也有一些方法，允许用户选择新对象，甚至是屏幕上的一个点。这允许用户使用光标选择一个或多个元素（或其他对象，如边或面），然后将控制权返回给应用程序。这些函数不会自动将新选区添加到活动选区集合中。</p>
<ul>
<li>PickObject()方法提示用户在Revit模型中选择对象。</li>
<li>PickObjects()方法提示用户在Revit模型中选择多个对象。</li>
<li>PickElementsByRectangle()方法提示用户使用矩形选择多个元素。</li>
<li>PickPoint()方法提示用户在活动草图平面中拾取点。</li>
<li>PickBox()方法调用一个通用的双击编辑器，让用户在屏幕上指定一个矩形区域。</li>
</ul>
<p>调用PickObject()或PickObject时指定要选择的对象类型。可以指定的对象类型有：元素、PointOnElement、边或面。</p>
<p>当应用程序提示用户拾取对象或元素时，StatusbarTip属性在状态栏中显示一条消息。每个Pick函数都有一个重载，该重载具有一个String参数，可以在其中提供自定义状态消息。</p>
<p>代码区域7-2：使用PickObject()和PickElementsByRectangle()添加选定元素</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">UIDocument uidoc = <span class="keyword">new</span> UIDocument(document);</span><br><span class="line">Selection choices = uidoc.Selection;</span><br><span class="line"><span class="comment">// Pick one object from Revit.</span></span><br><span class="line">Reference hasPickOne = choices.PickObject(ObjectType.Element);</span><br><span class="line"><span class="keyword">if</span> (hasPickOne != <span class="literal">null</span>)</span><br><span class="line">&#123;</span><br><span class="line">    TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>, <span class="string">&quot;One element selected.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Use the rectangle picking tool to identify model elements to select.</span></span><br><span class="line">IList pickedElements = uidoc.Selection.PickElementsByRectangle(<span class="string">&quot;Select by rectangle&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (pickedElements.Count &gt; <span class="number">0</span>)</span><br><span class="line">&#123; </span><br><span class="line">    <span class="comment">// Collect Ids of all picked elements</span></span><br><span class="line">    IList idsToSelect = <span class="keyword">new</span> List(pickedElements.Count);</span><br><span class="line">    <span class="keyword">foreach</span> (Element element <span class="keyword">in</span> pickedElements)</span><br><span class="line">    &#123;</span><br><span class="line">        idsToSelect.Add(element.Id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update the current selection</span></span><br><span class="line">    uidoc.Selection.SetElementIds(idsToSelect);</span><br><span class="line">    TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>, <span class="built_in">string</span>.Format(<span class="string">&quot;&#123;0&#125; elements added to Selection.&quot;</span>, idsToSelect.Count));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>PickPoint()方法有2个重载，其中ObjectSnapTypes参数用于指定用于选择的捕捉类型的类型。可以指定多个，如下一个示例所示。</p>
<p>代码区域7-3：捕捉点</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PickPoint</span>(<span class="params">UIDocument uidoc</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">        ObjectSnapTypes snapTypes = ObjectSnapTypes.Endpoints | ObjectSnapTypes.Intersections;</span><br><span class="line">        XYZ point = uidoc.Selection.PickPoint(snapTypes, <span class="string">&quot;Select an end point or intersection&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">string</span> strCoords = <span class="string">&quot;Selected point is &quot;</span> + point.ToString();</span><br><span class="line"></span><br><span class="line">        TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>, strCoords);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>PickBox()方法接受一个PickBoxStyle枚举器。这些选项包括“交叉”、“包围”和“方向”，前者是选择完全或部分位于框内的对象时使用的样式，后者是选择完全被框包围的对象时使用的样式，前者是框的样式取决于框的绘制方向。如果从右向左绘制，则使用“交叉”样式;如果以相反方向绘制，则使用“包围”样式。 PickBox()返回一个PickedBox，其中包含选定的Min和Max点。以下示例演示了在点云选择中使用PickBox()。</p>
<p>代码区域：PickBox</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PromptForPointCloudSelection</span>(<span class="params">UIDocument uiDoc, PointCloudInstance pcInstance</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Autodesk.Revit.ApplicationServices.Application app = uiDoc.Application.Application;</span><br><span class="line">    Selection currentSel = uiDoc.Selection;</span><br><span class="line"></span><br><span class="line">    PickedBox pickedBox = currentSel.PickBox(PickBoxStyle.Enclosing, <span class="string">&quot;Select region of cloud for highlighting&quot;</span>);</span><br><span class="line"></span><br><span class="line">    XYZ min = pickedBox.Min;</span><br><span class="line">    XYZ max = pickedBox.Max;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Transform points into filter</span></span><br><span class="line">    View view = uiDoc.ActiveView;</span><br><span class="line">    XYZ right = view.RightDirection;</span><br><span class="line">    XYZ up = view.UpDirection;</span><br><span class="line"></span><br><span class="line">    List planes = <span class="keyword">new</span> List();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// X boundaries</span></span><br><span class="line">    <span class="built_in">bool</span> directionCorrect = IsPointAbovePlane(right, min, max);</span><br><span class="line">    planes.Add(Plane.CreateByNormalAndOrigin(right, directionCorrect ? min : max));</span><br><span class="line">    planes.Add(Plane.CreateByNormalAndOrigin(-right, directionCorrect ? max : min));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Y boundaries</span></span><br><span class="line">    directionCorrect = IsPointAbovePlane(up, min, max);</span><br><span class="line">    planes.Add(Plane.CreateByNormalAndOrigin(up, directionCorrect ? min : max));</span><br><span class="line">    planes.Add(Plane.CreateByNormalAndOrigin(-up, directionCorrect ? max : min));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create filter</span></span><br><span class="line">    PointCloudFilter filter = PointCloudFilterFactory.CreateMultiPlaneFilter(planes);</span><br><span class="line">    Transaction t = <span class="keyword">new</span> Transaction(uiDoc.Document, <span class="string">&quot;Highlight&quot;</span>);</span><br><span class="line">    t.Start();</span><br><span class="line">    pcInstance.SetSelectionFilter(filter);</span><br><span class="line">    pcInstance.FilterAction = SelectionFilterAction.Highlight;</span><br><span class="line">    t.Commit();</span><br><span class="line">    uiDoc.RefreshActiveView();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="筛选的用户选择"><a href="#筛选的用户选择" class="headerlink" title="筛选的用户选择"></a>筛选的用户选择</h2><p>PickObject()、PickObjects()和PickElementsByRectangle()都具有将ISelectionFilter作为参数的重载。ISelectionFilter是一个接口，可用于在选择操作期间过滤对象。它有两个可以覆盖的方法：AllowElement()用于指定是否允许选择元素，以及AllowReference()用于指定是否允许选择对一段几何图形的引用。</p>
<p>下面的示例阐释如何使用ISelectionFilter接口将用户的选择限制为“体量”类别中的元素。它不允许选择对几何图元的任何参照。</p>
<p>使用ISelectionFilter限制元素选择</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IList <span class="title">GetManyRefByRectangle</span>(<span class="params">UIDocument doc</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        ReferenceArray ra = <span class="keyword">new</span> ReferenceArray();</span><br><span class="line">        ISelectionFilter selFilter = <span class="keyword">new</span> MassSelectionFilter();</span><br><span class="line">        IList eList = doc.Selection.PickElementsByRectangle(selFilter, </span><br><span class="line">                <span class="string">&quot;Select multiple faces&quot;</span>) <span class="keyword">as</span> IList;</span><br><span class="line">        <span class="keyword">return</span> eList;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MassSelectionFilter</span> : <span class="title">ISelectionFilter</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">AllowElement</span>(<span class="params">Element element</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">if</span> (element.Category.Name == <span class="string">&quot;Mass&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">AllowReference</span>(<span class="params">Reference refer, XYZ point</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下一个示例演示如何使用ISelectionFilter仅允许选择平面。</p>
<p>代码区域7-5：使用ISelectionFilter限制几何选择</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SelectPlanarFaces</span>(<span class="params">Autodesk.Revit.DB.Document document</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        UIDocument uidoc = <span class="keyword">new</span> UIDocument(document);</span><br><span class="line">        ISelectionFilter selFilter = <span class="keyword">new</span> PlanarFacesSelectionFilter(document);</span><br><span class="line">        IList faces = uidoc.Selection.PickObjects(ObjectType.Face, </span><br><span class="line">                selFilter, <span class="string">&quot;Select multiple planar faces&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PlanarFacesSelectionFilter</span> : <span class="title">ISelectionFilter</span></span><br><span class="line">&#123;</span><br><span class="line">        Document doc = <span class="literal">null</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">PlanarFacesSelectionFilter</span>(<span class="params">Document document</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">                doc = document;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">AllowElement</span>(<span class="params">Element element</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">AllowReference</span>(<span class="params">Reference refer, XYZ point</span>)</span></span><br><span class="line">        &#123;                <span class="keyword">if</span> (doc.GetElement(refer).GetGeometryObjectFromReference(refer) <span class="keyword">is</span> PlanarFace)</span><br><span class="line">                &#123;</span><br><span class="line">                        <span class="comment">// Only return true for planar faces. Non-planar faces will not be selectable </span></span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有关从选定元素中检索元素的更多信息，请参见“入门”部分中的演练：检索选定元素。</p>
<h2 id="注：翻译自Revit-API-Developers-Guide"><a href="#注：翻译自Revit-API-Developers-Guide" class="headerlink" title="注：翻译自Revit API Developers Guide"></a><em><strong>注：</strong></em>翻译自<a href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_html">Revit API Developers Guide</a></h2>]]></content>
      <categories>
        <category>Revit二次开发人员指南</category>
      </categories>
      <tags>
        <tag>Revit</tag>
      </tags>
  </entry>
  <entry>
    <title>08集合</title>
    <url>/2024/12/05/Revit%E4%BA%8C%E5%BC%80%E6%8C%87%E5%8D%97/08%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a><a href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_Basic_Interaction_with_Revit_Elements_Collections_Collections_and_Iterators_html">集合</a></h1><p>大多数Revit Platform API属性和方法在提供对一组相关项的访问时都使用.NET Framework集合类。</p>
<p>在Revit集合类型中实现的IEnumerator和IEnumerator接口在System.Collection命名空间中定义。</p>
<p>Pages in this section 本节中的页面</p>
<ul>
<li>Interface 接口</li>
<li>Collections and Iterators 集合和迭代器</li>
</ul>
<h2 id="Interface-接口"><a href="#Interface-接口" class="headerlink" title="Interface 接口"></a>Interface 接口</h2><p>以下各节讨论与接口相关的集合类型。</p>
<h3 id="IEnumerable"><a href="#IEnumerable" class="headerlink" title="IEnumerable"></a>IEnumerable</h3><p>IELTS接口位于System.Collections命名空间中。它公开枚举数，该枚举数支持对非泛型集合进行简单迭代。GetEnumerator（）方法获取实现此接口的枚举器。返回的IEnumerator对象在整个集合中迭代。GetEnumerator（）方法由C#中的foreach循环隐式使用。</p>
<h3 id="IEnumerator"><a href="#IEnumerator" class="headerlink" title="IEnumerator"></a>IEnumerator</h3><p>IEnumerator接口位于System.Collections命名空间中。它支持对非泛型集合进行简单迭代。IEnumerator是所有非泛型枚举器的基接口。C#中的foreach语句隐藏了枚举器的复杂性。</p>
<p>注意：建议使用foreach而不是直接操作枚举器。</p>
<p>枚举数用于读取集合数据，但不能用于修改基础集合。使用IEnumerator如下：</p>
<ul>
<li>最初，枚举数位于集合中第一个元素的前面。但是，最好总是在第一次获取枚举数时调用Reset（）。<ul>
<li>Reset（）方法将枚举数移回原始位置。在此位置，调用Current属性将引发异常。</li>
<li>调用MoveNext（）方法，在阅读当前迭代器值之前，将枚举器前进到集合的第一个元素。</li>
</ul>
</li>
<li>在调用MoveNext（）方法或Reset（）方法之前，Current属性返回相同的对象。MoveNext（）方法将当前迭代器设置为下一个元素。</li>
<li>如果MoveNext通过了集合的末尾，则枚举数位于集合中最后一个元素之后，MoveNext返回false。<ul>
<li>当枚举数处于此位置时，对MoveNext的后续调用也返回false。</li>
<li>如果对MoveNext的最后一次调用返回false，则调用Current属性将引发异常。</li>
<li>要再次将当前迭代器设置为集合中的第一个元素，请调用Reset（）方法，然后调用MoveNext（）。</li>
</ul>
</li>
<li>只要集合保持不变，枚举数就保持有效。<ul>
<li>如果对集合进行了更改（如添加、修改或删除元素），则枚举数将失效，并且下次调用MoveNext（）或Reset（）方法时将引发InvalidOperationException。</li>
<li>如果在MoveNext和当前迭代器之间修改了集合，则Current属性返回到指定的元素，即使枚举器已经无效。</li>
</ul>
</li>
</ul>
<p>注意：所有对Reset（）方法的调用都必须导致枚举数的相同状态。首选的实现是将枚举数移动到集合的开头，在第一个元素之前。如果在创建枚举数之后修改了集合，则这将使枚举数无效，这与MoveNext（）和Current属性一致。</p>
<h2 id="Collections-and-Iterators-集合和迭代器"><a href="#Collections-and-Iterators-集合和迭代器" class="headerlink" title="Collections and Iterators 集合和迭代器"></a>Collections and Iterators 集合和迭代器</h2><p>在Revit Platform API中，集合和迭代器是通用且类型安全的。</p>
<p>所有集合都实现IEnumerator接口，所有相关迭代器都实现IEnumerator接口。因此，所有方法和属性都在Revit Platform API中实现，并且可以在相关集合中发挥作用。</p>
<p>所有集合的实现都是类似的。下面的示例使用ModelCurveArray演示如何使用主集合属性：</p>
<p>代码区域9-2：使用集合</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">UIDocument uidoc = <span class="keyword">new</span> UIDocument(document); </span><br><span class="line">ICollection selectedIds = uidoc.Selection.GetElementIds();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Store the ModelLine references</span></span><br><span class="line">ModelCurveArray lineArray = <span class="keyword">new</span> ModelCurveArray();</span><br><span class="line"></span><br><span class="line"><span class="comment">// … Store operation</span></span><br><span class="line">Autodesk.Revit.DB.ElementId id = <span class="keyword">new</span> Autodesk.Revit.DB.ElementId(<span class="number">131943</span>); <span class="comment">//assume 131943 is a model line element id</span></span><br><span class="line">lineArray.Append(document.GetElement(id) <span class="keyword">as</span> ModelLine);</span><br><span class="line"></span><br><span class="line"><span class="comment">// use Size property of Array</span></span><br><span class="line">TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>,<span class="string">&quot;Before Insert: &quot;</span> + lineArray.Size + <span class="string">&quot; in lineArray.&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// use IsEmpty property of Array</span></span><br><span class="line"><span class="keyword">if</span> (!lineArray.IsEmpty)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// use Item(int) property of Array</span></span><br><span class="line">    ModelCurve modelCurve = lineArray.get_Item(<span class="number">0</span>) <span class="keyword">as</span> ModelCurve;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// erase the specific element from the set of elements</span></span><br><span class="line">    selectedIds.Remove(modelCurve.Id);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create a new model line and insert to array of model line</span></span><br><span class="line">    SketchPlane sketchPlane = modelCurve.SketchPlane;</span><br><span class="line"></span><br><span class="line">    XYZ startPoint = <span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);  <span class="comment">// the start point of the line</span></span><br><span class="line">    XYZ endPoint = <span class="keyword">new</span> XYZ(<span class="number">10</span>, <span class="number">10</span>, <span class="number">0</span>);  <span class="comment">// the end point of the line</span></span><br><span class="line">    <span class="comment">// create geometry line</span></span><br><span class="line">    Line geometryLine = Line.CreateBound(startPoint, endPoint);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create the ModelLine</span></span><br><span class="line">    ModelLine line = document.Create.NewModelCurve(geometryLine, sketchPlane) <span class="keyword">as</span> ModelLine;</span><br><span class="line"></span><br><span class="line">    lineArray.Insert(line, lineArray.Size - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>,<span class="string">&quot;After Insert: &quot;</span> + lineArray.Size + <span class="string">&quot; in lineArray.&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// use the Clear() method to remove all elements in lineArray</span></span><br><span class="line">lineArray.Clear();</span><br><span class="line"></span><br><span class="line">TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>,<span class="string">&quot;After Clear: &quot;</span> + lineArray.Size + <span class="string">&quot; in lineArray.&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="注：翻译自Revit-API-Developers-Guide"><a href="#注：翻译自Revit-API-Developers-Guide" class="headerlink" title="注：翻译自Revit API Developers Guide"></a><em><strong>注：</strong></em>翻译自<a href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_html">Revit API Developers Guide</a></h2>]]></content>
      <categories>
        <category>Revit二次开发人员指南</category>
      </categories>
      <tags>
        <tag>Revit</tag>
      </tags>
  </entry>
  <entry>
    <title>12墙、楼板、天花板、屋顶和洞口</title>
    <url>/2024/11/21/Revit%E4%BA%8C%E5%BC%80%E6%8C%87%E5%8D%97/12%E5%A2%99%E3%80%81%E6%A5%BC%E6%9D%BF%E3%80%81%E5%A4%A9%E8%8A%B1%E6%9D%BF%E3%80%81%E5%B1%8B%E9%A1%B6%E5%92%8C%E6%B4%9E%E5%8F%A3/</url>
    <content><![CDATA[<h1 id="墙、楼板、天花板、屋顶和洞口"><a href="#墙、楼板、天花板、屋顶和洞口" class="headerlink" title="墙、楼板、天花板、屋顶和洞口"></a><a href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_Revit_Geometric_Elements_Walls_Floors_Ceilings_Roofs_and_Openings_html">墙、楼板、天花板、屋顶和洞口</a></h1><p>元素和表示内置位置构造的相应ElementType。</p>
<p>以下部分介绍与内置位置构造（如墙、楼板、天花板、屋顶和洞口）相关的类及其相应的属性。</p>
<p>本节中的页面</p>
<ul>
<li>墙</li>
<li>楼板、天花板和基础</li>
<li>屋顶</li>
<li>幕墙</li>
<li>其他元素</li>
<li>复合结构</li>
<li>洞口</li>
<li>热属性</li>
</ul>
<h2 id="墙"><a href="#墙" class="headerlink" title="墙"></a>墙</h2><p>WallType.Kind枚举表示四种墙：</p>
<ul>
<li>Stacked 叠层墙</li>
<li>Curtain 幕墙</li>
<li>Basic 基本</li>
<li>Unknown 未知</li>
</ul>
<p>Wall和WallType类与基本墙类型一起使用，同时为叠层墙和幕墙提供有限的功能。有时您需要检查墙以确定墙类型。例如，不能使用API从叠层墙获取子墙。WallKind是只读的，由系统系列设置。</p>
<p>Wall.Flipped属性和Wall.flip（）方法可以访问和控制墙的方向。在下面的示例中，将在调用flip（）方法之前和之后比较Wall。</p>
<ul>
<li>之前的Orientation属性为（0.0，1.0，0.0）。</li>
<li>翻转调用后的Orientation属性为（0.0，-1.0，0.0）。</li>
<li>“墙定位线（WALL_KEY_REF_PARAM）”参数为3，表示下表中的“饰面：内部”。</li>
<li>以该线为参照，墙将被移动，但“位置”不会更改。</li>
</ul>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-4BFD801E-18BC-4021-8371-C29AF13CF7EE-low.png"></p>
<p><strong>图33：原始墙</strong></p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-85CF3DAD-C029-41C5-ACC6-1FEC8CA304E4-low.png"></p>
<p><strong>图34：翻转后的墙</strong></p>
<p><strong>表24：墙位置线</strong></p>
<table>
<thead>
<tr>
<th><strong>Location Line Value 定位线值</strong></th>
<th><strong>Description 描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>墙中心线</td>
</tr>
<tr>
<td>1</td>
<td>核心层中心线</td>
</tr>
<tr>
<td>2</td>
<td>表面：外部</td>
</tr>
<tr>
<td>3</td>
<td>表面：内部</td>
</tr>
<tr>
<td>4</td>
<td>核心面：外部</td>
</tr>
<tr>
<td>5</td>
<td>核心面：内部</td>
</tr>
</tbody></table>
<p>Wall类中有五个静态覆盖方法可用于创建Wall：</p>
<p>表25：Create（）重载</p>
<table>
<thead>
<tr>
<th><strong>Name 名称</strong></th>
<th><strong>Description 描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Create(Document, Curve, WallType, Level, Double, Double, Boolean, Boolean)</td>
<td>使用指定的墙类型、高度和偏移在项目中创建新的矩形轮廓墙。</td>
</tr>
<tr>
<td>Create(Document, IList Curve , Boolean)</td>
<td>使用默认墙样式在项目中创建非矩形轮廓墙。</td>
</tr>
<tr>
<td>Create(Document, Curve, ElementId, Boolean)</td>
<td>使用默认墙样式在项目中由ElementId指定的标高上创建新的矩形轮廓墙。</td>
</tr>
<tr>
<td>Create(Document, IList Curve , ElementId, ElementId, Boolean)</td>
<td>使用指定的墙类型在项目中创建非矩形轮廓墙。</td>
</tr>
<tr>
<td>Create(Document, IList Curve , ElementId, ElementId, Boolean, XYZ)</td>
<td>使用指定的墙类型和法向量在项目中创建非矩形轮廓墙。</td>
</tr>
</tbody></table>
<p>WallType墙功能（WALL_ATTR_EXTERIOR）参数会影响创建的墙实例“房间边界和结构用途”参数。WALL_ATTR_EXTERIOR值是一个整数：</p>
<p><strong>表26：墙功能</strong></p>
<table>
<thead>
<tr>
<th><strong>Wall Function 墙功能</strong></th>
<th><strong>Interior 内部</strong></th>
<th><strong>Exterior 外部</strong></th>
<th><strong>Foundation 基础墙</strong></th>
<th><strong>Retaining 挡土墙</strong></th>
<th><strong>Soffit 檐底板</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Value 值</td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
</tr>
</tbody></table>
<p>以下规则适用于由API创建的墙：</p>
<ul>
<li>如果输入结构参数为true或Wall Function（WALL_ATTR_EXTERIOR）参数为Foundation，则Wall StructuralUsage参数为Bearing;否则为NonBearing。</li>
<li>如果墙功能（WALL_ATTR_EXTERIOR）参数为“Retaining”，则创建的墙房间边界（WALL_ATTR_ROOM_BOUNDING）参数为false。</li>
</ul>
<p>有关与结构相关的函数（如AnalyticalModel属性）的详细信息，请参见结构工程。</p>
<h2 id="楼板、天花板和基础"><a href="#楼板、天花板和基础" class="headerlink" title="楼板、天花板和基础"></a>楼板、天花板和基础</h2><p>与楼板、天花板和基础关联的类。</p>
<p>楼板、天花板和基础相关的API项目包括：</p>
<p>表28：API中的地板、天花板和基础</p>
<table>
<thead>
<tr>
<th><strong>Object 对象</strong></th>
<th><strong>Element Type 元素类型</strong></th>
<th><strong>ElementType Type ElementType类型</strong></th>
<th><strong>Element Creation 元素创建</strong></th>
<th><strong>Other 其他</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Floor</td>
<td>Floor</td>
<td>FloorType</td>
<td>NewFloor()&#x2F;NewSlab()</td>
<td>FloorType.IsFoundationSlab &#x3D; false</td>
</tr>
<tr>
<td>Slab</td>
<td>Floor</td>
<td>FloorType</td>
<td>NewSlab()</td>
<td>FloorType.IsFoundationSlab &#x3D; false</td>
</tr>
<tr>
<td>Ceiling</td>
<td>Ceiling</td>
<td>CeilingType</td>
<td>No</td>
<td>Category &#x3D; OST_Ceilings</td>
</tr>
<tr>
<td>Wall Foundation</td>
<td>WallFoundation</td>
<td>WallFoundationType</td>
<td>No</td>
<td>Category &#x3D; OST_StructuralFoundation</td>
</tr>
<tr>
<td>Isolated Foundation</td>
<td>FamilyInstance</td>
<td>FamilySymbol</td>
<td>NewFamilyInstance()</td>
<td>Category &#x3D; OST_StructuralFoundation</td>
</tr>
<tr>
<td>Foundation Slab</td>
<td>Floor</td>
<td>FloorType</td>
<td>NewFloor()</td>
<td>Category &#x3D; OST_StructuralFoundation FloorType.IsFoundationSlab &#x3D; true</td>
</tr>
</tbody></table>
<p>注意：Floor和Ceiling派生自CeilingAndFloor类。以下规则适用于Floor：</p>
<ul>
<li>从基础设计栏创建的元素具有相同的类别OST_StructuralFoundation，但对应于不同的类。</li>
<li>FloorType IsFoundationSlab属性将FloorType类别设置为OST_StructuralFoundation或不设置。</li>
</ul>
<p>检索FloorType以使用NewFloor创建楼板或基础底板时，请使用以下方法：</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-26C2760B-04F0-4690-AF22-6EB1A0CDD933-low.png"></p>
<p>图35：创建基础和楼板</p>
<p>当前，API不提供对Floor类中的地板坡度箭头的访问。但是，在使用Revit的结构功能时，可以使用NewSlab（）创建斜板：</p>
<p>代码区域11-1：NewSlab（）</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Floor <span class="title">NewSlab</span>(<span class="params">CurveArray profile, Level level, Line slopedArrow, <span class="built_in">double</span> slope,<span class="built_in">bool</span> isStructural</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>使用slopedArrow参数创建坡度箭头。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-5589AB8C-03FB-4FE6-BB20-065A37058854-low.png"></p>
<p>图36：NewSlab中的slopedArrow参数</p>
<p>NewSlab（）中斜率参数的单位是rise&#x2F;run。</p>
<p>Floor.FloorType属性是使用Floor.GetTypeId（）方法的替代方法。有关与结构相关的成员（如GetSpanDirectionSymbolIds（）方法和SpanDirectionAngle属性）的详细信息，请参见结构工程部分。</p>
<p>在Revit中编辑独立基础时，可以执行以下操作：</p>
<ul>
<li>您可以选取宿主，例如楼板。但是，FamilyInstance对象Host属性始终返回null。</li>
<li>删除宿主楼板时，基础不会随之删除。</li>
<li>Foundation 宿主可通过Host（MANANCE_FREE_HOST_PARAM）参数访问。</li>
<li>使用另一个相关的“偏移”（Offset_FREE_HOST_OFFSET_PARAM）参数控制宿主元素的基础偏移。</li>
</ul>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-6FECE5EE-DCFE-42E5-B3F8-868B44E774D5-low.png"></p>
<p>图37：为FoundationSlab（FamilyInstance）选择宿主</p>
<p>条形基础由API中的WallFoundation类表示。API提供对WallFoundation和WallFoundationType的有限访问，但使用GetAnalyticalModel（）方法时除外（请参阅“结构工程”部分中的分析模型）。例如，附着的墙不能用于Revit的建筑功能。使用Revit的结构功能，可以使用AnalyticalModel类中的GetAnalyticalModelSupports（）方法显示Wall类和WallFoundation类之间的关系。有关详细信息，请参见“结构工程”部分中的分析模型。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-03EA5485-1F1B-429D-8917-02B86A50E627-low.png"></p>
<h3 id="修改板"><a href="#修改板" class="headerlink" title="修改板"></a>修改板</h3><p>您可以使用SlabShapeEditor类修改基于板的元素的形式。此类允许您：</p>
<ul>
<li>操作选定的基于板的元素上的一个或多个点或边</li>
<li>在元素上添加点以更改元素的几何图形</li>
<li>添加线性边并将板的现有面拆分为更小的子面域</li>
<li>删除形状修改器并将图元几何图形重置回未修改的形状。</li>
</ul>
<p>下面是将选定的已修改地板恢复为其原始形状的示例：</p>
<p>代码区域11-2：恢复板的形状</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ResetSlabShapes</span>(<span class="params">Autodesk.Revit.DB.Document document</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        UIDocument uidoc = <span class="keyword">new</span> UIDocument(document);</span><br><span class="line">        Selection choices = uidoc.Selection;</span><br><span class="line">        ElementSet collection = choices.Elements;</span><br><span class="line">        <span class="keyword">foreach</span> (Autodesk.Revit.DB.Element elem <span class="keyword">in</span> collection)</span><br><span class="line">        &#123;</span><br><span class="line">                Floor floor = elem <span class="keyword">as</span> Floor;</span><br><span class="line">                <span class="keyword">if</span> (floor != <span class="literal">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                        SlabShapeEditor slabShapeEditor = floor.SlabShapeEditor;</span><br><span class="line">                        slabShapeEditor.ResetSlabShape();</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有关使用SlabShapeEditor和相关类的详细示例，请参见Revit SDK中包含的SlabShapeEditing示例应用程序。</p>
<h2 id="屋顶"><a href="#屋顶" class="headerlink" title="屋顶"></a>屋顶</h2><p>Revit API中屋顶的表示。</p>
<p>Revit Platform API中的屋顶均派生自RoofBase对象。有两个类：</p>
<ul>
<li>FootPrintRoof -表示由建筑物迹线区构成的屋顶</li>
<li>ExtrusionRoof -表示由拉伸轮廓制成的屋顶</li>
</ul>
<p>两者都有一个RoofType属性，用于获取或设置屋顶的类型。此示例说明如何基于某些选定的墙创建迹线屋顶：</p>
<p>代码区域11-3：创建迹线屋顶</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Before invoking this sample, select some walls to add a roof over.</span></span><br><span class="line"><span class="comment">// Make sure there is a level named &quot;Roof&quot; in the document.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// find the Roof level</span></span><br><span class="line">FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">collector.OfClass(<span class="keyword">typeof</span>(Level));</span><br><span class="line"><span class="keyword">var</span> elements = <span class="keyword">from</span> element <span class="keyword">in</span> collector <span class="keyword">where</span> element.Name == <span class="string">&quot;Roof&quot;</span> <span class="keyword">select</span> element;</span><br><span class="line">Level level = elements.Cast().ElementAt(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">collector.OfClass(<span class="keyword">typeof</span>(RoofType));</span><br><span class="line">RoofType roofType = collector.FirstElement() <span class="keyword">as</span> RoofType; </span><br><span class="line"></span><br><span class="line"><span class="comment">// Get the handle of the application</span></span><br><span class="line">Autodesk.Revit.ApplicationServices.Application application = document.Application;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Define the footprint for the roof based on user selection</span></span><br><span class="line">CurveArray footprint = application.Create.NewCurveArray();</span><br><span class="line">UIDocument uidoc = <span class="keyword">new</span> UIDocument(document);</span><br><span class="line">ICollection selectedIds = uidoc.Selection.GetElementIds();</span><br><span class="line"><span class="keyword">if</span> (selectedIds.Count != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">foreach</span> (ElementId id <span class="keyword">in</span> selectedIds)</span><br><span class="line">    &#123;</span><br><span class="line">        Element element = document.GetElement(id);</span><br><span class="line">        Wall wall = element <span class="keyword">as</span> Wall;</span><br><span class="line">        <span class="keyword">if</span> (wall != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            LocationCurve wallCurve = wall.Location <span class="keyword">as</span> LocationCurve;</span><br><span class="line">            footprint.Append(wallCurve.Curve);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ModelCurve modelCurve = element <span class="keyword">as</span> ModelCurve;</span><br><span class="line">        <span class="keyword">if</span> (modelCurve != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            footprint.Append(modelCurve.GeometryCurve);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;You should select a curve loop, or a wall loop, or loops combination \nof walls and curves to create a footprint roof.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ModelCurveArray footPrintToModelCurveMapping = <span class="keyword">new</span> ModelCurveArray();</span><br><span class="line">FootPrintRoof footprintRoof = document.Create.NewFootPrintRoof(footprint, level, roofType, <span class="keyword">out</span> footPrintToModelCurveMapping);</span><br><span class="line">ModelCurveArrayIterator iterator = footPrintToModelCurveMapping.ForwardIterator();</span><br><span class="line">iterator.Reset();</span><br><span class="line"><span class="keyword">while</span> (iterator.MoveNext())</span><br><span class="line">&#123;</span><br><span class="line">    ModelCurve modelCurve = iterator.Current <span class="keyword">as</span> ModelCurve;</span><br><span class="line">    footprintRoof.set_DefinesSlope(modelCurve, <span class="literal">true</span>);</span><br><span class="line">    footprintRoof.set_SlopeAngle(modelCurve, <span class="number">0.5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有关如何创建ExtrusionRoof的示例，请参见Revit API SDK附带的NewRoof示例应用程序。</p>
<p>天沟、筋膜檐沟和封檐带图元派生自表示屋顶的HostedSweep类。可以通过API创建、删除或修改它们。若要创建这些元素，请使用Document.Create.NewFascia（）或Document.Create.NewGutter（）重写之一。有关如何创建新檐沟和封檐带的示例，请参见SDK示例中包含的NewHostedSweep应用程序。下面是一个代码片段，显示了您可以修改gutter元素的属性。</p>
<p>代码区域11-4：修改天沟</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ModifyGutter</span>(<span class="params">Autodesk.Revit.DB.Document document</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        UIDocument uidoc = <span class="keyword">new</span> UIDocument(document);</span><br><span class="line">        ElementSet collection = uidoc.Selection.Elements;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">foreach</span> (Autodesk.Revit.DB.Element elem <span class="keyword">in</span> collection)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">if</span> (elem <span class="keyword">is</span> Gutter)</span><br><span class="line">                &#123;</span><br><span class="line">                        Gutter gutter = elem <span class="keyword">as</span> Gutter;</span><br><span class="line">                        <span class="comment">// convert degrees to rads:</span></span><br><span class="line">                        gutter.Angle = <span class="number">45.00</span> * Math.PI / <span class="number">180</span>;</span><br><span class="line">                        TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>,<span class="string">&quot;Changed gutter angle&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="幕墙"><a href="#幕墙" class="headerlink" title="幕墙"></a>幕墙</h2><p>幕墙、幕墙系统和幕墙屋顶是CurtainGrid对象的主体图元。幕墙只能有一个CurtainGrid，而幕墙系统和幕墙屋顶可以包含一个或多个CurtainGrid。有关如何创建CurtainSystem的示例，请参见Revit SDK附带的CurtainSystem示例应用程序。有关创建幕墙并使用网格线填充幕墙的示例，请参见CurtainWallGrid示例应用程序。</p>
<h2 id="其他元素"><a href="#其他元素" class="headerlink" title="其他元素"></a>其他元素</h2><p>有些元素不是HostObject（也没有特定的类），但它们是可以承载其他对象的特殊情况。例如，ramp及其关联的元素类型在API中没有特定的类，而是在OST_Ramp类别中表示为Element和ElementType。</p>
<h2 id="复合结构"><a href="#复合结构" class="headerlink" title="复合结构"></a>复合结构</h2><p>描述墙、楼板、屋顶或天花板的内部结构。</p>
<p>墙、楼板、天花板和屋顶都是API类HostObject的子对象。HostObject（及其相关类型类HostObjAttributes）提供对CompoundStructure的只读访问。复合结构由有序层的集合组成，对于墙来说，从外部到内部，或者对于地板，屋顶或天花板来说，从顶部到底部。这些层的属性决定了相关墙、楼板、屋顶或天花板的整体结构的厚度、材质和功能。</p>
<p>层可以通过GetLayers（）方法访问，并使用SetLayers（）完全替换。</p>
<p>通常，这些层是平行的，并以固定的层宽度延伸整个主体对象。然而，对于墙，结构也可以是“垂直复合”的，其中层在距墙的顶部和底部的指定垂直距离处变化。使用CompoundStructure.IsVerticallyCompound来标识它们。对于垂直复合结构，该结构通过矩形描述垂直截面，该矩形被划分为多边形区域，多边形区域的边都是垂直或水平段。映射将这些区域中的每一个与CompoundStructure中的层的索引相关联，该层的索引确定该区域的属性。</p>
<p>可以使用复合结构来找到不同层边界的几何位置。方法CompoundStructure.GetOffsetForLocationLine（）提供从中心定位线到任何定位线选项（芯体中心线、任一侧的饰面面或芯体侧）的偏移。</p>
<p>有了到定位线的偏移，您可以从已知位置开始，使用CompoundStructure.GetLayerWidth（）获取每个边界层的宽度，从而获取每个层边界的位置。</p>
<p>使用CompoundStructure的一些注意事项：</p>
<ul>
<li>元素的总宽度是每个CompoundStructureLayer的宽度之和。您无法直接更改元素的总宽度，但可以通过更改CompoundStructureLayer宽度来更改它。指定的可变长度层的索引（如果已分配）可以从CompoundStructure.VariableLayerIndex获得。</li>
<li>必须将CompoundStructure设置回HostObjAttributes实例（使用HostObjAttributes.SetCompoundStructure（）方法），以便存储任何更改。</li>
<li>对HostObjAttributes的更改会影响当前文档中的每个实例。如果需要新的层组合，则需要创建新的HostObjAttributes（使用ElementType.Duplicate（））并将新的CompoundStructure分配给它。</li>
<li>CompoundStructureLayer DeckProfileId和DeckEmbeddingType属性仅适用于Revit结构要素中的Slab。有关详细信息，请参阅结构工程。</li>
</ul>
<h3 id="材质"><a href="#材质" class="headerlink" title="材质"></a>材质</h3><p>HostObjAttributes中的每个CompoundStructureLayer通常与某种类型的材质一起显示。如果CompoundStructureLayer.MaterialId返回-1，则表示该Material与Category相关。有关详细信息，请参阅材料。获取CompoundStructureLayer材质的示例代码如下：</p>
<p>代码区域11-5：获取CompoundStructureLayer材质</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetWallLayerMaterial</span>(<span class="params">Autodesk.Revit.DB.Document document, Wall wall</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">// get WallType of wall</span></span><br><span class="line">        WallType aWallType = wall.WallType;</span><br><span class="line">        <span class="comment">// Only Basic Wall has compoundStructure</span></span><br><span class="line">        <span class="keyword">if</span> (WallKind.Basic == aWallType.Kind)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Get CompoundStructure</span></span><br><span class="line">                CompoundStructure comStruct = aWallType.GetCompoundStructure();</span><br><span class="line">                Categories allCategories = document.Settings.Categories;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Get the category OST_Walls default Material; </span></span><br><span class="line">                <span class="comment">// use if that layer&#x27;s default Material is </span></span><br><span class="line">                Category wallCategory = allCategories.get_Item(BuiltInCategory.OST_Walls);</span><br><span class="line">                Autodesk.Revit.DB.Material wallMaterial = wallCategory.Material;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">foreach</span> (CompoundStructureLayer structLayer <span class="keyword">in</span> comStruct.GetLayers())</span><br><span class="line">                &#123;</span><br><span class="line">                        Autodesk.Revit.DB.Material layerMaterial = </span><br><span class="line">                                document.GetElement(structLayer.MaterialId) <span class="keyword">as</span> Material;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// If CompoundStructureLayer&#x27;s Material is specified, use default</span></span><br><span class="line">                        <span class="comment">// Material of its Category</span></span><br><span class="line">                        <span class="keyword">if</span> (<span class="literal">null</span> == layerMaterial)</span><br><span class="line">                        &#123;</span><br><span class="line">                                <span class="keyword">switch</span> (structLayer.Function)</span><br><span class="line">                                &#123;</span><br><span class="line">                                        <span class="keyword">case</span> MaterialFunctionAssignment.Finish1:</span><br><span class="line">                                                layerMaterial =</span><br><span class="line">                                                        allCategories.get_Item(BuiltInCategory.OST_WallsFinish1).Material;</span><br><span class="line">                                                <span class="keyword">break</span>;</span><br><span class="line">                                        <span class="keyword">case</span> MaterialFunctionAssignment.Finish2:</span><br><span class="line">                                                layerMaterial =</span><br><span class="line">                                                        allCategories.get_Item(BuiltInCategory.OST_WallsFinish2).Material;</span><br><span class="line">                                                <span class="keyword">break</span>;</span><br><span class="line">                                        <span class="keyword">case</span> MaterialFunctionAssignment.Membrane:</span><br><span class="line">                                                layerMaterial =</span><br><span class="line">                                                        allCategories.get_Item(BuiltInCategory.OST_WallsMembrane).Material;</span><br><span class="line">                                                <span class="keyword">break</span>;</span><br><span class="line">                                        <span class="keyword">case</span> MaterialFunctionAssignment.Structure:</span><br><span class="line">                                                layerMaterial =</span><br><span class="line">                                                        allCategories.get_Item(BuiltInCategory.OST_WallsStructure).Material;</span><br><span class="line">                                                <span class="keyword">break</span>;</span><br><span class="line">                                        <span class="keyword">case</span> MaterialFunctionAssignment.Substrate:</span><br><span class="line">                                                layerMaterial = </span><br><span class="line">                                                        allCategories.get_Item(BuiltInCategory.OST_WallsSubstrate).Material;</span><br><span class="line">                                                <span class="keyword">break</span>;</span><br><span class="line">                                        <span class="keyword">case</span> MaterialFunctionAssignment.Insulation:</span><br><span class="line">                                                layerMaterial = </span><br><span class="line">                                                        allCategories.get_Item(BuiltInCategory.OST_WallsInsulation).Material;</span><br><span class="line">                                                <span class="keyword">break</span>;</span><br><span class="line">                                        <span class="literal">default</span>:</span><br><span class="line">                                                <span class="comment">// It is impossible to reach here</span></span><br><span class="line">                                                <span class="keyword">break</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">if</span> (<span class="literal">null</span> == layerMaterial)</span><br><span class="line">                                &#123;</span><br><span class="line">                                        <span class="comment">// CompoundStructureLayer&#x27;s default Material is its SubCategory</span></span><br><span class="line">                                        layerMaterial = wallMaterial;</span><br><span class="line">                                &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>,<span class="string">&quot;Layer Material: &quot;</span> + layerMaterial);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有时只需要“结构”层的材料。与其在每个层中查找其函数为MaterialFunctionAssignment.Structure的层，不如使用CompoundStructure.StructuralMaterialIndex属性查找其材料定义了类型的结构属性的层的索引，以便进行分析。<br>注意：调用SetLayers（）时，StructuralMaterialIndex值将被清除，需要重置。</p>
<h2 id="洞口"><a href="#洞口" class="headerlink" title="洞口"></a>洞口</h2><p>在Revit Platform API中，Opening对象派生自Element对象，并包含所有Element对象属性和方法。若要检索项目中的所有Openings，请使用Document.ElementIterator查找Elements.Opening对象。</p>
<h3 id="常规属性"><a href="#常规属性" class="headerlink" title="常规属性"></a>常规属性</h3><p>本节说明如何使用洞口属性。</p>
<ul>
<li><p>Isolation Boundary-确定洞口是否具有矩形边界。</p>
<ul>
<li>如果为true，则表示Opening具有矩形边界，并且可以从Opening BoundaryRect属性获取IList集合。否则，属性返回null。</li>
<li>如果为false，则可以从BoundaryCurves属性获取CurveArray对象。</li>
</ul>
</li>
<li><p>BoundaryCurves -如果开口边界不是矩形，则此属性检索几何信息;否则返回null。该属性返回一个CurveArray对象，其中包含表示Opening对象边界的曲线。有关曲线的更多详细信息，请参阅几何体。</p>
</li>
<li><p>BoundaryRect -如果开口边界是矩形，则可以使用此属性获取几何信息;否则返回null。</p>
<ul>
<li>该属性返回一个包含XYZ坐标的IList集合。</li>
<li>IList集合通常包含矩形边界的最小（左下）和最大（右上）坐标。</li>
</ul>
</li>
<li><p>Host -host属性检索Opening host元素。主体图元是由Opening对象剪切的图元。</p>
<p><strong>注意：</strong>如果洞口对象的类别为竖井洞口，则洞口主体为空。</p>
</li>
</ul>
<p>下面的示例说明如何检索现有的Opening属性。</p>
<p>代码区域11-6：检索现有洞口属性</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Getinfo_Opening</span>(<span class="params">Opening opening</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> message = <span class="string">&quot;Opening:&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//get the host element of this opening</span></span><br><span class="line">    message += <span class="string">&quot;\nThe id of the opening&#x27;s host element is : &quot;</span> + opening.Host.Id.IntegerValue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//get the information whether the opening has a rect boundary</span></span><br><span class="line">    <span class="comment">//If the opening has a rect boundary, we can get the geometry information from BoundaryRect property.</span></span><br><span class="line">    <span class="comment">//Otherwise we should get the geometry information from BoundaryCurves property</span></span><br><span class="line">    <span class="keyword">if</span> (opening.IsRectBoundary)</span><br><span class="line">    &#123;</span><br><span class="line">        message += <span class="string">&quot;\nThe opening has a rectangular boundary.&quot;</span>;</span><br><span class="line">        <span class="comment">//array contains two XYZ objects: the max and min coords of boundary</span></span><br><span class="line">        IList boundaryRect = opening.BoundaryRect;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//get the coordinate value of the min coordinate point</span></span><br><span class="line">        XYZ point = opening.BoundaryRect[<span class="number">0</span>];</span><br><span class="line">        message += <span class="string">&quot;\nMin coordinate point:(&quot;</span> + point.X + <span class="string">&quot;, &quot;</span></span><br><span class="line">                                + point.Y + <span class="string">&quot;, &quot;</span> + point.Z + <span class="string">&quot;)&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//get the coordinate value of the Max coordinate point</span></span><br><span class="line">        point = opening.BoundaryRect[<span class="number">1</span>];</span><br><span class="line">        message += <span class="string">&quot;\nMax coordinate point: (&quot;</span> + point.X + <span class="string">&quot;, &quot;</span></span><br><span class="line">                                + point.Y + <span class="string">&quot;, &quot;</span> + point.Z + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        message += <span class="string">&quot;\nThe opening doesn&#x27;t have a rectangular boundary.&quot;</span>;</span><br><span class="line">        <span class="comment">// Get curve number</span></span><br><span class="line">        <span class="built_in">int</span> curves = opening.BoundaryCurves.Size;</span><br><span class="line">        message += <span class="string">&quot;\nNumber of curves is : &quot;</span> + curves;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; curves; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Autodesk.Revit.DB.Curve curve = opening.BoundaryCurves.get_Item(i);</span><br><span class="line">            <span class="comment">// Get curve start point</span></span><br><span class="line">            message += <span class="string">&quot;\nCurve start point: &quot;</span> + XYZToString(curve.GetEndPoint(<span class="number">0</span>));</span><br><span class="line">            <span class="comment">// Get curve end point</span></span><br><span class="line">            message += <span class="string">&quot;; Curve end point: &quot;</span> + XYZToString(curve.GetEndPoint(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>,message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// output the point&#x27;s three coordinates</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">XYZToString</span>(<span class="params">XYZ point</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;(&quot;</span> + point.X + <span class="string">&quot;, &quot;</span> + point.Y + <span class="string">&quot;, &quot;</span> + point.Z + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="创建洞口"><a href="#创建洞口" class="headerlink" title="创建洞口"></a>创建洞口</h3><p>在Revit Platform API中，使用Document.NewOpening（）方法在项目中创建洞口。有四种方法重载可用于在不同的宿主元素中创建洞口：</p>
<p>代码区域11-7：NewOpening（）</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Create a new Opening in a beam, brace and column. </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Opening <span class="title">NewOpening</span>(<span class="params">Element famInstElement, CurveArray profile, eRefFace iFace</span>)</span>; </span><br></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Create a new Opening in a roof, floor and ceiling. </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Opening <span class="title">NewOpening</span>(<span class="params">Element hostElement, CurveArray profile, <span class="built_in">bool</span> bPerpendicularFace</span>)</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Create a new Opening Element. </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Opening <span class="title">NewOpening</span>(<span class="params">Level bottomLevel, Level topLevel, CurveArray  profile</span>)</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Create an opening in a straight wall or arc wall. </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Opening <span class="title">NewOpening</span>(<span class="params">Wall, XYZ pntStart, XYZ pntEnd</span>)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>在梁、支撑或柱中创建洞口-用于在族实例中创建洞口。iFace参数指示放置洞口的面。</li>
<li>创建屋顶、楼板或天花板洞口-用于在屋顶、楼板或天花板中创建洞口。</li>
<li>bPerceptiularFace参数指示洞口是垂直于面还是垂直于面。</li>
<li>如果该参数为true，则洞口垂直于主体图元面。请参见下图：</li>
</ul>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-EED350DF-2DD4-4562-998D-C020C739D6F8-low.png"></p>
<p>图40：垂直于主体元素切割的开口</p>
<ul>
<li>创建新洞口图元-用于在项目中创建竖井洞口。但是，请确保topLevel高于bottomLevel;否则将引发异常。</li>
<li>在直墙或弧形墙中创建洞口-用于在墙中创建矩形洞口。pntStart和pntEnd的坐标应该是可以塑造矩形的角坐标。例如，矩形的左下角和右上角。否则会引发异常。</li>
</ul>
<p>注意：使用“洞口”命令只能创建矩形墙洞口。要在墙上创建一些孔，请编辑墙轮廓而不是“洞口”命令。</p>
<h2 id="热属性"><a href="#热属性" class="headerlink" title="热属性"></a>热属性</h2><p>某些部件类型（如墙、楼板、天花板、屋顶和建筑地坪）具有计算和可设置的热属性，这些热属性由ThermalProperties类表示。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/ThermalProperties-76171.jpg"></p>
<p>hermalProperties类具有上面显示的值的属性。吸收率和粗糙度是可修改的，而传热系数、热阻和热质量是只读的。这些计算值的单位如下表所示。</p>
<table>
<thead>
<tr>
<th><strong>Property 属性</strong></th>
<th><strong>Unit 单位</strong></th>
</tr>
</thead>
<tbody><tr>
<td>HeatTransferCoefficient 导热系数</td>
<td>watts per meter-squared kelvin (W&#x2F;(m^2<em>K)</em></td>
</tr>
<tr>
<td>ThermalResistance 热阻</td>
<td>meter-squared kelvin per watt ((m^2K)&#x2F;Watt)</td>
</tr>
<tr>
<td>ThermalMass 热质量</td>
<td>kilogram feet-squared per second squared kelvin (kg ft^2&#x2F;(s^2 K))</td>
</tr>
</tbody></table>
<p>可以使用以下类型的ThermalProperties属性检索热属性：</p>
<ul>
<li>WallType </li>
<li>FloorType</li>
<li>CeilingType </li>
<li>RoofType </li>
<li>BuildingPadType</li>
</ul>
]]></content>
      <categories>
        <category>Revit二次开发人员指南</category>
      </categories>
      <tags>
        <tag>Revit</tag>
      </tags>
  </entry>
  <entry>
    <title>09编辑元素</title>
    <url>/2024/12/05/Revit%E4%BA%8C%E5%BC%80%E6%8C%87%E5%8D%97/09%E7%BC%96%E8%BE%91%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<h1 id="编辑元素"><a href="#编辑元素" class="headerlink" title="编辑元素"></a><a href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_Basic_Interaction_with_Revit_Elements_Editing_Elements_html">编辑元素</a></h1><p>在Revit中，可以使用Revit Platform API移动、复制、旋转、对齐、删除、镜像、编组和排列一个元素或一组元素。在API中使用编辑功能与在Revit UI中使用命令类似。</p>
<p>Pages in this section 本节中的页面</p>
<ul>
<li>Moving Elements 移动元素</li>
<li>Copying Elements 复制元素</li>
<li>Rotating elements 旋转元素</li>
<li>Aligning Elements 对齐元素</li>
<li>Mirroring Elements 镜像元素</li>
<li>Grouping Elements 对元素进行分组</li>
<li>Creating Arrays of Elements 创建元素数组</li>
<li>Deleting Elements 删除元素</li>
<li>Pinned Elements 固定元素</li>
</ul>
<h2 id="移动元素"><a href="#移动元素" class="headerlink" title="移动元素"></a>移动元素</h2><p>ElementTransformUtils类提供两个静态方法来将一个或多个元素从一个位置移动到另一个位置。</p>
<p>表19：移动方法</p>
<table>
<thead>
<tr>
<th><strong>Member</strong></th>
<th>**Description **</th>
</tr>
</thead>
<tbody><tr>
<td>MoveElement( Document, ElementId, XYZ)</td>
<td>将文档中的元素移动指定的向量。</td>
</tr>
<tr>
<td>MoveElements(Document, ICollection, XYZ)</td>
<td>将文档中的几个元素移动指定向量的一组ID。</td>
</tr>
</tbody></table>
<p>注意：当您使用MoveElement（）或MoveElements（）方法时，以下规则适用。这些方法不能将基于标高的图元从标高上移或下移。如果图元基于标高，则不能修改Z坐标值。但是，可以将图元放置在同一标高中的任何位置。同样，某些基于标高的图元具有偏移实例参数，可以使用该参数在Z方向上移动它们。例如，如果在标高1中的原始位置（0，0，0）创建新柱，然后将其移动到新位置（10，20，30），则柱将放置在位置（10，20，0）而不是（10，20，30）。</p>
<p>代码区域10-1：使用MoveElement（）</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">MoveColumn</span>(<span class="params">Autodesk.Revit.DB.Document document, FamilyInstance column</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">            <span class="comment">// get the column current location</span></span><br><span class="line">            LocationPoint columnLocation = column.Location <span class="keyword">as</span> LocationPoint;</span><br><span class="line"></span><br><span class="line">            XYZ oldPlace = columnLocation.Point;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Move the column to new location.</span></span><br><span class="line">            XYZ newPlace = <span class="keyword">new</span> XYZ(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>);</span><br><span class="line">            ElementTransformUtils.MoveElement(document, column.Id, newPlace);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// now get the column&#x27;s new location</span></span><br><span class="line">            columnLocation = column.Location <span class="keyword">as</span> LocationPoint;</span><br><span class="line">            XYZ newActual = columnLocation.Point;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">string</span> info = <span class="string">&quot;Original Z location: &quot;</span> + oldPlace.Z + </span><br><span class="line">                            <span class="string">&quot;\nNew Z location: &quot;</span> + newActual.Z;</span><br><span class="line"></span><br><span class="line">            TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>,info);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>移动一个或多个图元时，关联图元也会移动。例如，如果移动带窗的墙，则窗也会移动。 * 无法移动固定的图元。 在Revit中移动图元的另一种方法是使用位置及其衍生对象。在Revit Platform API中，Location对象提供了平移和旋转图元的功能。更多的位置信息和控制可以使用Location对象的派生，如LocationPoint或LocationCurve。如果Location元素向下转换为LocationCurve对象或LocationPoint对象，则直接将曲线或点移动到新位置。</p>
<p>代码区域10-2：使用位置移动</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">bool</span> <span class="title">MoveUsingLocationCurve</span>(<span class="params">Autodesk.Revit.ApplicationServices.Application application, Wall wall</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        LocationCurve wallLine = wall.Location <span class="keyword">as</span> LocationCurve;</span><br><span class="line">        XYZ translationVec = <span class="keyword">new</span> XYZ(<span class="number">10</span>, <span class="number">20</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> (wallLine.Move(translationVec));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-CA323378-0ABA-4B2B-B242-2D98C01F0A78-low.png"></p>
<p>图30：使用LocationCurve移动墙</p>
<p>此外，还可以使用LocationCurve Curve属性或LocationPoint Point属性在Revit中移动一个图元。 使用Curve特性将曲线驱动元素移动到任何指定位置。许多图元是曲线驱动的，例如墙、梁和支撑。还可以使用属性调整元素长度的大小。</p>
<p>代码区域10-3：使用曲线移动</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MoveUsingCurveParam</span>(<span class="params">Autodesk.Revit.ApplicationServices.Application application, Wall wall</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    LocationCurve wallLine = wall.Location <span class="keyword">as</span> LocationCurve;</span><br><span class="line">    XYZ p1 = XYZ.Zero;</span><br><span class="line">    XYZ p2 = <span class="keyword">new</span> XYZ(<span class="number">10</span>, <span class="number">20</span>, <span class="number">0</span>);</span><br><span class="line">    Line newWallLine = Line.CreateBound(p1, p2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Change the wall line to a new line.</span></span><br><span class="line">    wallLine.Curve = newWallLine;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还可以使用LocationCurve.JoinType属性获取或设置基于曲线的元素的联接属性。 使用LocationPoint Point属性设置元素的物理位置。</p>
<p>代码区域10-4：使用点移动</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LocationMove</span>(<span class="params">FamilyInstance column</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        LocationPoint columnPoint = column.Location <span class="keyword">as</span> LocationPoint;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != columnPoint)</span><br><span class="line">        &#123;</span><br><span class="line">                XYZ newLocation = <span class="keyword">new</span> XYZ(<span class="number">10</span>, <span class="number">20</span>, <span class="number">0</span>);</span><br><span class="line">                <span class="comment">// Move the column to the new location</span></span><br><span class="line">                columnPoint.Point = newLocation;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="复制元素"><a href="#复制元素" class="headerlink" title="复制元素"></a>复制元素</h2><p>ElementTransformUtils类提供了几个静态方法，用于将一个或多个元素从一个位置复制到另一个位置，可以在同一文档或视图中复制，也可以复制到不同的文档或视图中。</p>
<p>表：复制方法</p>
<table>
<thead>
<tr>
<th><strong>Member</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody><tr>
<td>CopyElement( Document, ElementId, XYZ)</td>
<td>复制元素并将副本放置在给定变换所指示的位置。</td>
</tr>
<tr>
<td>CopyElements(Document, ICollection, XYZ)</td>
<td>复制一组元素，并将副本放置在给定事务指示的位置。</td>
</tr>
<tr>
<td>CopyElements(Document, ICollection, Document, Transform, CopyPasteOptions)</td>
<td>将一组元素从源文档复制到目标文档。</td>
</tr>
<tr>
<td>CopyElements(View, ICollection, View, Transform, CopyPasteOptions)</td>
<td>将一组元素从源视图复制到目标视图。</td>
</tr>
</tbody></table>
<p>所有方法都返回新创建元素的ElementId集合，包括CopyElement（）。该集合包括由于依赖关系而创建的任何元素。</p>
<p>从一个文档复制到另一个文档的方法只能用于复制非视图特定的元素。副本被放置在其各自的原始位置或由可选转换指定的位置。</p>
<p>应使用从一个视图复制到另一个视图的方法来复制视图特定的图元。该方法可用于视图专有图元和模型图元，但绘图视图不能用作模型图元的目标。粘贴的图元将被重新定位，以确保在目标视图中正确放置。例如，从一个标高复制到另一个标高时，标高会发生更改。通过提供可选的Transform参数，可以在目标视图中执行其他转换。此附加变换必须在目标视图的平面内。</p>
<p>从一个视图复制到另一个视图时，源视图和目标视图都必须是能够绘制详图和视图专有图元（如楼板和天花板平面、立面、剖面或绘图视图）的二维图形视图。ElementTransformUtils.GetTransformFromViewToView（）方法将返回从源视图复制到目标视图时应用于元素的转换。</p>
<p>在视图之间或文档之间复制时，可以设置可选的CopyPasteOptions参数以覆盖默认的复制&#x2F;粘贴设置。默认情况下，如果在粘贴操作过程中出现重复的类型名称，Revit将显示一个模式对话框，其中包含仅复制具有唯一名称的类型或取消操作的选项。CopyPasteOptions可用于指定一个自定义处理程序，使用IDuplicateTypeException接口来处理重复的类型名称。</p>
<p>See the Duplicate Views sample in the Revit SDK for a detailed example of copying between documents and between views.<br>有关在文档之间和视图之间复制的详细示例，请参见Revit SDK中的“复制视图”示例。</p>
<h2 id="旋转元素"><a href="#旋转元素" class="headerlink" title="旋转元素"></a>旋转元素</h2><p>ElementTransformUtils类提供了两个静态方法来旋转项目中的一个或多个元素。</p>
<p>表20：旋转方法</p>
<table>
<thead>
<tr>
<th><strong>Member</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody><tr>
<td>RotateElement(Document, ElementId, Line, double)</td>
<td>将文档中的元素围绕给定轴旋转指定的弧度数。</td>
</tr>
<tr>
<td>RotateElements(Document, ICollection, Line, double)</td>
<td>按项目中的ID将多个图元围绕给定轴旋转指定的弧度数。</td>
</tr>
</tbody></table>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-2CDF32C7-BA19-499B-81BE-02A982E310D7-low.png"></p>
<p>图31：逆时针旋转 </p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-11A64EB3-0D9F-4A33-8DB7-CBA34CFBD04C-low.png"></p>
<p>图32：顺时针旋转 请注意，锁定的图元不能旋转。</p>
<p>代码区域10-5：使用RotateElement（）</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">RotateColumn</span>(<span class="params">Autodesk.Revit.DB.Document document, Autodesk.Revit.DB.Element element</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    XYZ point1 = <span class="keyword">new</span> XYZ(<span class="number">10</span>, <span class="number">20</span>, <span class="number">0</span>);</span><br><span class="line">    XYZ point2 = <span class="keyword">new</span> XYZ(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>);</span><br><span class="line">    <span class="comment">// The axis should be a bound line.</span></span><br><span class="line">    Line axis = Line.CreateBound(point1, point2);</span><br><span class="line">    ElementTransformUtils.RotateElement(document, element.Id, axis, Math.PI / <span class="number">3.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果元素Location可以向下转换为LocationCurve或LocationPoint，则可以直接旋转曲线或点。</p>
<p>代码区域10-6：基于位置曲线旋转</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">bool</span> <span class="title">LocationRotate</span>(<span class="params">Autodesk.Revit.ApplicationServices.Application application, Autodesk.Revit.DB.Element element</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">bool</span> rotated = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// Rotate the element via its location curve.</span></span><br><span class="line">    LocationCurve curve = element.Location <span class="keyword">as</span> LocationCurve;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> != curve)</span><br><span class="line">    &#123;</span><br><span class="line">        Curve line = curve.Curve;</span><br><span class="line">        XYZ aa = line.GetEndPoint(<span class="number">0</span>);</span><br><span class="line">        XYZ cc = <span class="keyword">new</span> XYZ(aa.X, aa.Y, aa.Z + <span class="number">10</span>);</span><br><span class="line">        Line axis = Line.CreateBound(aa, cc);</span><br><span class="line">        rotated = curve.Rotate(axis, Math.PI / <span class="number">2.0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rotated;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码区域10-7：基于位置点旋转</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">bool</span> <span class="title">LocationRotate</span>(<span class="params">Autodesk.Revit.ApplicationServices.Application application, Autodesk.Revit.Element element</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="built_in">bool</span> rotated = <span class="literal">false</span>;</span><br><span class="line">        LocationPoint location = element.Location <span class="keyword">as</span> LocationPoint;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != location)</span><br><span class="line">        &#123;</span><br><span class="line">                XYZ aa = location.Point;</span><br><span class="line">                XYZ cc = <span class="keyword">new</span> XYZ(aa.X, aa.Y, aa.Z + <span class="number">10</span>);</span><br><span class="line">                Line axis = Line.CreateBound(aa, cc);                </span><br><span class="line">            rotated = location.Rotate(axis, Math.PI / <span class="number">2.0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> rotated;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="对齐元素"><a href="#对齐元素" class="headerlink" title="对齐元素"></a>对齐元素</h2><p>ItemFactoryBase.NewAlignment（）方法可以在两个引用之间创建新的锁定对齐。这两个引用必须是以下组合之一：</p>
<ul>
<li>2个平面</li>
<li>2条线</li>
<li>线和点</li>
<li>直线和参考平面</li>
<li>2个弧</li>
<li>2个圆柱面</li>
</ul>
<p>这些参照必须已经几何对齐，因为此函数不会强制它们对齐。如果可以创建对齐，则返回一个表示锁定对齐的新Dimension对象。否则将抛出异常。</p>
<p>NewAlignment（）方法还需要一个视图来确定路线的方向。</p>
<p>请参见SDK Samples中包含的FamilyCreation文件夹中的“桁架”示例。其中有几个使用NewAlignment（）的示例，例如将新桁架的下弦杆锁定到底部参照平面。</p>
<h2 id="镜像元素"><a href="#镜像元素" class="headerlink" title="镜像元素"></a>镜像元素</h2><p>ElementTransformUtils类提供两个静态方法来镜像项目中的一个或多个元素。</p>
<p>表21：镜像方法</p>
<table>
<thead>
<tr>
<th><strong>Member 构件</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody><tr>
<td>MirrorElement(Document, ElementId, Plane)</td>
<td>关于几何平面镜像一个元素。</td>
</tr>
<tr>
<td>MirrorElements(Document, ICollection, Plane, Boolean)</td>
<td>关于几何平面镜像多个元素。可以在原始几何体或副本上执行。</td>
</tr>
</tbody></table>
<p>执行镜像操作后，可以从“选择元素集”（Selection ElementSet）访问新元素。</p>
<p>ElementTransformUtils. Canadian Element（）和ElementTransformUtils. Canadian Elements（）可用于在尝试镜像元素之前确定是否可以镜像一个或多个元素。</p>
<p>下面的代码演示如何使用根据墙的侧面计算的平面镜像墙。</p>
<p>代码区域10-8：镜像墙壁</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">MirrorWall</span>(<span class="params">Autodesk.Revit.DB.Document document, Wall wall</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        Reference reference = HostObjectUtils.GetSideFaces(wall, ShellLayerType.Exterior).First();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// get one of the wall&#x27;s major side faces</span></span><br><span class="line">        Face face = wall.GetGeometryObjectFromReference(reference) <span class="keyword">as</span> Face; </span><br><span class="line"></span><br><span class="line">        UV bboxMin = face.GetBoundingBox().Min;</span><br><span class="line">        <span class="comment">// create a plane based on this side face with an offset of 10 in the X &amp; Y directions</span></span><br><span class="line"></span><br><span class="line">        Plane plane = <span class="keyword">new</span> Plane(face.ComputeNormal(bboxMin), </span><br><span class="line">                face.Evaluate(bboxMin).Add(<span class="keyword">new</span> XYZ(<span class="number">10</span>, <span class="number">10</span>, <span class="number">0</span>)));</span><br><span class="line"></span><br><span class="line">        ElementTransformUtils.MirrorElement(document, wall.Id, plane);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个FamilyInstance都有一个镜像属性。它指示是否镜像FamilyInstance（例如柱）。</p>
<h2 id="对元素进行分组"><a href="#对元素进行分组" class="headerlink" title="对元素进行分组"></a>对元素进行分组</h2><p>Revit 平台 API 使用 Creation.Document.NewGroup（） 方法选择一个图元或多个图元或组，然后将它们组合在一起。对于您放置的组的每个实例，它们之间都有关联。例如，您可以创建一个包含床、墙和窗户的组，然后在项目中放置该组的多个实例。如果修改一个组中的墙，则该墙会针对该组的所有实例进行更改。这使得修改建筑模型变得更加容易，因为您可以在一次操作中更改组的多个实例。</p>
<p>代码区域 10-9：创建组</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Group <span class="keyword">group</span> = <span class="literal">null</span>;</span><br><span class="line">UIDocument uidoc = <span class="keyword">new</span> UIDocument(document);</span><br><span class="line">ICollection selectedIds = uidoc.Selection.GetElementIds();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (selectedIds.Count &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Group all selected elements</span></span><br><span class="line">    <span class="keyword">group</span> = document.Create.NewGroup(selectedIds);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最初，该组具有通用名称，例如 Group 1。可以通过更改组类型的名称来修改它，如下所示：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Change the default group name to a new name &quot;MyGroup&quot;</span></span><br><span class="line"><span class="keyword">group</span>.GroupType.Name = <span class="string">&quot;MyGroup&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>Revit 中有三种类型的组;模型组、详图组和附加详图组。所有 API 都是使用 NewGroup（） 方法创建的。创建的 Group 的类型取决于传递的 Elements。</p>
<ul>
<li>如果未传递详图元素，则会创建一个模型组。</li>
<li>如果所有元素都是详图元素，则会创建一个详图组。</li>
<li>如果同时包含两种类型的元素，则会创建并返回包含 Attached Detail Group 的模型组。</li>
</ul>
<p><em><strong>注意</strong></em>对元素进行分组后，可以从项目中删除这些元素。</p>
<ul>
<li>删除模型组中的模型元素后，当鼠标光标悬停在组上或单击该组时，该模型元素仍然可见，即使应用程序向 UI 返回 Succeeded 也是如此。实际上，模型元素已被删除，您无法选择或访问该元素。</li>
<li>当组实例的最后一个成员被删除、排除或从项目中移除时，模型组实例将被删除。</li>
</ul>
<p>对元素进行分组时，无法移动或旋转它们。如果对分组的元素执行这些操作，则元素不会发生任何变化，但 Move（） 或 Rotate（） 方法返回 true。</p>
<p>如果不对维度和标记引用的元素进行分组，则无法对它们进行分组。如果这样做，API 调用将失败。</p>
<p>您可以对引用模型组中的模型元素的维度和标签进行分组。尺寸和标记将添加到附加的详图组中。如果不对父组执行相同的操作，则无法移动、复制、旋转、阵列或镜像附着的详图组。</p>
<h2 id="创建元素阵列"><a href="#创建元素阵列" class="headerlink" title="创建元素阵列"></a>创建元素阵列</h2><p>Revit 平台 API 提供了两个类，即 LinearArray 和 RadialArray，用于对项目中的一个或多个图元进行阵列。这些类提供静态方法，用于创建一个或多个选定组件的线性或径向阵列。线性阵列表示从一个点沿直线创建的阵列，而径向阵列表示沿圆弧创建的阵列。</p>
<p>作为使用阵列的示例，您可以选择位于同一墙中的门和窗，然后创建门、墙和窗配置的多个实例。</p>
<p>LinearArray 和 RadialArray 都提供了对一个或多个元素进行阵列的方法，而无需进行分组和关联。尽管类似于用于阵列元素的 Create（） 方法，但每个生成的元素都独立于其他元素，并且可以在不影响其他元素的情况下进行操作。有关可用于创建线性或径向阵列的方法的更多信息，请参阅下表。</p>
<p>表 22：LinearArray 方法</p>
<table>
<thead>
<tr>
<th><strong>Member 成员</strong></th>
<th><strong>Description 描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Create(Document, View, ElementId, int, XYZ, ArrayAnchorMember)</td>
<td>按指定数字对项目中的一个元素进行阵列。</td>
</tr>
<tr>
<td>Create(Document, View, ICollection, int, XYZ, ArrayAnchorMember)</td>
<td>按指定数字对项目中的一组元素进行阵列。</td>
</tr>
<tr>
<td>ArrayElementWithoutAssociation(Document, View, ElementId, int, XYZ, ArrayAnchorMember)</td>
<td>按指定数字对项目中的一个元素进行阵列。生成的元素不与线性阵列关联。</td>
</tr>
<tr>
<td>ArrayElementsWithoutAssociation(Document, View, ICollection, int, XYZ, ArrayAnchorMember)</td>
<td>按指定数字对项目中的一组元素进行阵列排列。生成的元素不与线性阵列关联。</td>
</tr>
</tbody></table>
<p>表 23：RadialArray 方法</p>
<table>
<thead>
<tr>
<th><strong>Member 成员</strong></th>
<th><strong>Description 描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Create(Document, View, ElementId, int, Line, double, ArrayAnchorMember)</td>
<td>根据输入旋转轴对项目中的一个元素进行阵列。</td>
</tr>
<tr>
<td>Create(Document, View, ICollection, int, Line, double, ArrayAnchorMember)</td>
<td>根据输入旋转轴对项目中的一组元素进行阵列。</td>
</tr>
<tr>
<td>ArrayElementWithoutAssociation(Document, View, ElementId, int, Line, double, ArrayAnchorMember)</td>
<td>根据输入旋转轴对项目中的一个元素进行阵列.生成的元素不与线性阵列关联。</td>
</tr>
<tr>
<td>ArrayElementsWithoutAssociation(Document, View, ICollection, int, Line, double, ArrayAnchorMember)</td>
<td>根据输入旋转轴对项目中的一组元素进行阵列。生成的元素不与线性阵列关联。</td>
</tr>
</tbody></table>
<p>如果您需要创建组件的多个实例并同时操作它们，则排列元素的方法非常有用。数组中的每个实例都可以是组的成员。</p>
<p>注意：使用方法对元素进行阵列时，以下规则适用：</p>
<ul>
<li>执行 Linear 和 Radial Array 操作时，依赖于阵列元素的元素也会排列。</li>
<li>某些元素无法排列，因为它们无法分组。有关组和阵列限制的详细信息，请参见《Revit 用户指南》。</li>
<li>大多数注释符号不支持数组。</li>
</ul>
<h2 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h2><p>Revit 平台 API 提供了 Delete（） 方法，用于删除项目中的一个或多个图元。</p>
<p> 表 23：删除成员</p>
<table>
<thead>
<tr>
<th><strong>Member</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Delete(ElementId)</td>
<td>使用元素 ID 从项目中删除元素</td>
</tr>
<tr>
<td>Delete(<a href="http://msdn2.microsoft.com/en-us/library/92t2ye13">ICollection</a>)</td>
<td>按元素的 ID 从项目中删除多个元素。</td>
</tr>
</tbody></table>
<p>第一种方法根据 Id 删除单个元素，如以下示例所示。</p>
<p>代码区域：根据 ElementId 删除元素</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">DeleteElement</span>(<span class="params">Autodesk.Revit.DB.Document document, Element element</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">// Delete an element via its id</span></span><br><span class="line">        Autodesk.Revit.DB.ElementId elementId = element.Id;</span><br><span class="line">        ICollection&lt;Autodesk.Revit.DB.ElementId&gt; deletedIdSet = document.Delete(elementId);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == deletedIdSet.Count)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Deleting the selected element in Revit failed.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String prompt = <span class="string">&quot;The selected element has been removed and &quot;</span>;</span><br><span class="line">        prompt += deletedIdSet.Count - <span class="number">1</span>;</span><br><span class="line">        prompt += <span class="string">&quot; more dependent elements have also been removed.&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Give the user some information</span></span><br><span class="line">        TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>, prompt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：删除元素时，与该元素关联的任何子元素也将被删除，如上面的示例所示。</p>
<p>该 API 还提供了一种删除多个元素的方法。</p>
<p>代码区域：根据 Id 删除多个元素</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Delete all the selected elements via the set of elements</span></span><br><span class="line">UIDocument uidoc = <span class="keyword">new</span> UIDocument(document); </span><br><span class="line">ICollection elements = uidoc.Selection.GetElementIds();</span><br><span class="line">ICollection&lt;Autodesk.Revit.DB.ElementId&gt; deletedIdSet = document.Delete(elements);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="number">0</span> == deletedIdSet.Count)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Deleting the selected elements in Revit failed.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>,<span class="string">&quot;The selected element has been removed.&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>注意：删除元素后，对已删除元素的任何引用都将无效，并在访问这些元素时引发异常。</p>
<h2 id="固定元素"><a href="#固定元素" class="headerlink" title="固定元素"></a>固定元素</h2><p>可以固定元素以防止它们移动。Element.Pinned 属性可用于检查元素是否已固定，或者固定或取消固定元素。</p>
<p>当 Element.Pinned 设置为 true 时，无法移动或旋转元素。</p>
<h2 id="注：翻译自Revit-API-Developers-Guide"><a href="#注：翻译自Revit-API-Developers-Guide" class="headerlink" title="注：翻译自Revit API Developers Guide"></a><em><strong>注：</strong></em>翻译自<a href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_html">Revit API Developers Guide</a></h2>]]></content>
      <categories>
        <category>Revit二次开发人员指南</category>
      </categories>
      <tags>
        <tag>Revit</tag>
      </tags>
  </entry>
  <entry>
    <title>14族文档</title>
    <url>/2024/11/29/Revit%E4%BA%8C%E5%BC%80%E6%8C%87%E5%8D%97/14%E6%97%8F%E6%96%87%E6%A1%A3/</url>
    <content><![CDATA[<h1 id="族文档"><a href="#族文档" class="headerlink" title="族文档"></a><a href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_Revit_Geometric_Elements_Family_Documents_html">族文档</a></h1><p>本节讨论族以及如何：</p>
<ul>
<li>创建和修改族文档</li>
<li>访问族类型和参数</li>
</ul>
<p>本节中的页面</p>
<ul>
<li>关于族文档</li>
<li>在族中创建图元</li>
<li>族元素的可见性</li>
<li>管理族类型和参数</li>
</ul>
<h2 id="关于族文档"><a href="#关于族文档" class="headerlink" title="关于族文档"></a>关于族文档</h2><h3 id="族"><a href="#族" class="headerlink" title="族"></a>族</h3><p>族对象表示整个Revit族。族文档是表示族的文档(rfa)而不是Revit项目。</p>
<p>使用Revit API的族创建功能，可以创建和编辑族及其类型。当您有来自外部系统的现有数据并希望将其转换为Revit族库时，此功能特别有用。</p>
<p>对系统族编辑的API访问不可用。</p>
<h3 id="类别"><a href="#类别" class="headerlink" title="类别"></a>类别</h3><p>如前一节所述，Family.FamilyCategory属性指示族的类别，如柱、家具、结构框架或窗。</p>
<p>以下代码可用于确定打开的Revit族文档中族的类别。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> categoryName = familyDoc.OwnerFamily.FamilyCategory.Name;</span><br></pre></td></tr></table></figure>

<p>还可以设置FamilyCategory，以允许更改正在编辑的族的类别。</p>
<p> <strong>参数设置</strong> 可以从族文档的OwnerFamily属性访问族参数，如下例所示。</p>
<p>代码区域13-2：打开的Revit族文档的类别</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// get the owner family of the family document.</span></span><br><span class="line">Family family = familyDoc.OwnerFamily; </span><br><span class="line">Parameter param = family.get_Parameter(BuiltInParameter.FAMILY_WORK_PLANE_BASED);</span><br><span class="line"><span class="comment">// this param is a Yes/No parameter in UI, but an integer value in API</span></span><br><span class="line"><span class="comment">// 1 for true and 0 for false</span></span><br><span class="line"><span class="built_in">int</span> isTrue = param.AsInteger(); </span><br><span class="line"><span class="comment">// param.Set(1); // set value to true.</span></span><br></pre></td></tr></table></figure>

<h3 id="创建族文档"><a href="#创建族文档" class="headerlink" title="创建族文档"></a>创建族文档</h3><p>如果文档是族文档（由IsFamilyDocument属性确定），则可以通过Document类修改Revit族文档并访问族类型和参数。若要在处理Project文档时编辑现有族，请使用Document类中提供的EditFamily（）函数，然后在编辑完成后使用LoadFamily（）将族重新加载回所有者文档。要创建新的族文档，请使用Application.NewFamilyDocument（）：</p>
<p>代码区域13-3：创建新的族文档</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// create a new family document using Generic Model.rft template</span></span><br><span class="line"><span class="built_in">string</span> templateFileName = <span class="string">@&quot;C:\Documents and Settings\All Users\Application Data\Autodesk\RST 2011\Imperial Templates\Generic Model.rft&quot;</span>;</span><br><span class="line"></span><br><span class="line">Document familyDocument = application.NewFamilyDocument(templateFileName);</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">null</span> == familyDocument)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Cannot open family document&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="嵌套族符号"><a href="#嵌套族符号" class="headerlink" title="嵌套族符号"></a>嵌套族符号</h3><p>可以过滤FamilySymbols的族文档，以将所有FamilySymbols加载到族中。在此代码示例中，列出了给定FamilyInstance的族中的所有嵌套FamilySymbol。</p>
<p>代码区域13-4：在族中获取嵌套的族符号</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetLoadedSymbols</span>(<span class="params">Autodesk.Revit.DB.Document document, FamilyInstance familyInstance</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != familyInstance.Symbol)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="comment">// Get family associated with this</span></span><br><span class="line">                Family family = familyInstance.Symbol.Family;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Get Family document for family</span></span><br><span class="line">                Document familyDoc = document.EditFamily(family);</span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">null</span> != familyDoc &amp;&amp; familyDoc.IsFamilyDocument == <span class="literal">true</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                        String loadedFamilies = <span class="string">&quot;FamilySymbols in &quot;</span> + family.Name + <span class="string">&quot;:\n&quot;</span>;</span><br><span class="line">                        FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">                        ICollection collection = </span><br><span class="line">                                collector.OfClass(<span class="keyword">typeof</span>(FamilySymbol)).ToElements();</span><br><span class="line">                        <span class="keyword">foreach</span> (Element e <span class="keyword">in</span> collection)</span><br><span class="line">                        &#123;</span><br><span class="line">                                FamilySymbol fs = e <span class="keyword">as</span> FamilySymbol;</span><br><span class="line">                                loadedFamilies += <span class="string">&quot;\t&quot;</span> + fs.Name + <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>,loadedFamilies);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="在族中创建元素"><a href="#在族中创建元素" class="headerlink" title="在族中创建元素"></a>在族中创建元素</h2><p>FamilyItemFactory类提供了在族文档中创建图元的功能。可以通过Document.FamilyCreate属性访问它。FamilyItemFactory派生自ItemFactoryBase类，该类是一个实用的用于在Revit项目文档和族文档中创建元素。</p>
<p> 本节中的页面</p>
<ul>
<li>创建表单元素</li>
<li>创建注释</li>
</ul>
<h3 id="创建形状元素"><a href="#创建形状元素" class="headerlink" title="创建形状元素"></a>创建形状元素</h3><p>FamilyItemFactory类提供了在族中创建形状图元的功能，例如拉伸、旋转、放样和融合。有关这些3D草图表格的更多信息，请参见3D草图部分。</p>
<p>下面的示例演示如何创建新的Extrusion元素。它将创建一个简单的矩形截面轮廓，然后将新创建的“拉伸”移动到新位置。</p>
<p>代码区域：创建新拉伸</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Extrusion <span class="title">CreateExtrusion</span>(<span class="params">Autodesk.Revit.DB.Document document, SketchPlane sketchPlane</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Extrusion rectExtrusion = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// make sure we have a family document</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">true</span> == document.IsFamilyDocument)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// define the profile for the extrusion</span></span><br><span class="line">        CurveArrArray curveArrArray = <span class="keyword">new</span> CurveArrArray();</span><br><span class="line">        CurveArray curveArray1 = <span class="keyword">new</span> CurveArray();</span><br><span class="line">        CurveArray curveArray2 = <span class="keyword">new</span> CurveArray();</span><br><span class="line">        CurveArray curveArray3 = <span class="keyword">new</span> CurveArray();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// create a rectangular profile</span></span><br><span class="line">        XYZ p0 = XYZ.Zero;</span><br><span class="line">        XYZ p1 = <span class="keyword">new</span> XYZ(<span class="number">10</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        XYZ p2 = <span class="keyword">new</span> XYZ(<span class="number">10</span>, <span class="number">10</span>, <span class="number">0</span>);</span><br><span class="line">        XYZ p3 = <span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">10</span>, <span class="number">0</span>);</span><br><span class="line">        Line line1 = Line.CreateBound(p0, p1);</span><br><span class="line">        Line line2 = Line.CreateBound(p1, p2);</span><br><span class="line">        Line line3 = Line.CreateBound(p2, p3);</span><br><span class="line">        Line line4 = Line.CreateBound(p3, p0);</span><br><span class="line">        curveArray1.Append(line1);</span><br><span class="line">        curveArray1.Append(line2);</span><br><span class="line">        curveArray1.Append(line3);</span><br><span class="line">        curveArray1.Append(line4);</span><br><span class="line"></span><br><span class="line">        curveArrArray.Append(curveArray1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// create solid rectangular extrusion</span></span><br><span class="line">        rectExtrusion = document.FamilyCreate.NewExtrusion(<span class="literal">true</span>, curveArrArray, sketchPlane, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != rectExtrusion)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// move extrusion to proper place</span></span><br><span class="line">            XYZ transPoint1 = <span class="keyword">new</span> XYZ(<span class="number">-16</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            ElementTransformUtils.MoveElement(document, rectExtrusion.Id, transPoint1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Create new Extrusion failed.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Please open a Family document before invoking this command.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rectExtrusion;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下示例显示了如何从族文档中的实心卵形轮廓创建新放样。</p>
<p>代码区域：创建新放样</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Sweep <span class="title">CreateSweep</span>(<span class="params">Autodesk.Revit.DB.Document document, SketchPlane sketchPlane</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Sweep sweep = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// make sure we have a family document</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">true</span> == document.IsFamilyDocument)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Define a profile for the sweep</span></span><br><span class="line">        CurveArrArray arrarr = <span class="keyword">new</span> CurveArrArray();</span><br><span class="line">        CurveArray arr = <span class="keyword">new</span> CurveArray();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create an ovoid profile</span></span><br><span class="line">        XYZ pnt1 = <span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        XYZ pnt2 = <span class="keyword">new</span> XYZ(<span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        XYZ pnt3 = <span class="keyword">new</span> XYZ(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        arr.Append(Arc.Create(pnt2, <span class="number">1.0</span>d, <span class="number">0.0</span>d, <span class="number">180.0</span>d, XYZ.BasisX, XYZ.BasisY));</span><br><span class="line">        arr.Append(Arc.Create(pnt1, pnt3, pnt2));</span><br><span class="line">        arrarr.Append(arr);</span><br><span class="line">        SweepProfile profile = document.Application.Create.NewCurveLoopsProfile(arrarr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create a path for the sweep</span></span><br><span class="line">        XYZ pnt4 = <span class="keyword">new</span> XYZ(<span class="number">10</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        XYZ pnt5 = <span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">10</span>, <span class="number">0</span>);</span><br><span class="line">        Curve curve = Line.CreateBound(pnt4, pnt5);</span><br><span class="line"></span><br><span class="line">        CurveArray curves = <span class="keyword">new</span> CurveArray();</span><br><span class="line">        curves.Append(curve);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// create a solid ovoid sweep</span></span><br><span class="line">        sweep = document.FamilyCreate.NewSweep(<span class="literal">true</span>, curves, sketchPlane, profile, <span class="number">0</span>, ProfilePlaneLocation.Start);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != sweep)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// move to proper place</span></span><br><span class="line">            XYZ transPoint1 = <span class="keyword">new</span> XYZ(<span class="number">11</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            ElementTransformUtils.MoveElement(document, sweep.Id, transPoint1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Failed to create a new Sweep.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Please open a Family document before invoking this command.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sweep;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-169B9078-7508-4982-B10D-333FF97CA345-low.png"></p>
<p>图50：由上一个示例创建的卵形扫描</p>
<p> FreeFormElement类允许创建从输入实体轮廓创建的非参数化几何体。FreeFormElement可以与其他可组合元素一起参与连接和空切割。元素的平面可以在面法线方向上以交互方式和编程方式偏移。</p>
<p>将子类别转换为形状 在族中创建新形状后，可能需要修改形状的子类别。例如，您可能有一个门族，并且希望创建多个门的子类别，并将不同的子类别指定给族中的不同门类型。 下面的示例演示如何创建新的子类别，为其指定材质，然后将该子类别指定给窗体。</p>
<p>代码区域：指定子类别</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AssignSubCategory</span>(<span class="params">Document document, GenericForm extrusion</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// create a new subcategory</span></span><br><span class="line">    Category cat = document.OwnerFamily.FamilyCategory;</span><br><span class="line">    Category subCat = document.Settings.Categories.NewSubcategory(cat, <span class="string">&quot;NewSubCat&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create a new material and assign it to the subcategory</span></span><br><span class="line">    ElementId materialId = Material.Create(document, <span class="string">&quot;Wood Material&quot;</span>);</span><br><span class="line">    subCat.Material = document.GetElement(materialId) <span class="keyword">as</span> Material;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// assign the subcategory to the element</span></span><br><span class="line">    extrusion.Subcategory = subCat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="创建注释"><a href="#创建注释" class="headerlink" title="创建注释"></a>创建注释</h3><p>还可以在族中创建新注释（例如尺寸标注和ModelText和TextNote对象）以及曲线注释元素（例如SymbolicCurve、ModelCurve和DetailCurve）。有关注释元素的详细信息，请参见注释元素。</p>
<p>此外，还可以添加新路线，并参照确定路线方向的视图和两个几何图形参照。</p>
<p>以下示例演示如何创建新的弧长标注。</p>
<p>代码区域：创建标注</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Dimension <span class="title">CreateArcDimension</span>(<span class="params">Document document, SketchPlane sketchPlane</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Autodesk.Revit.Creation.Application appCreate = document.Application.Create;</span><br><span class="line">    Line gLine1 = Line.CreateBound(<span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>), <span class="keyword">new</span> XYZ(<span class="number">2</span>, <span class="number">2</span>, <span class="number">0</span>));</span><br><span class="line">    Line gLine2 = Line.CreateBound(<span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>), <span class="keyword">new</span> XYZ(<span class="number">2</span>, <span class="number">4</span>, <span class="number">0</span>));</span><br><span class="line">    Arc arctoDim = Arc.Create(<span class="keyword">new</span> XYZ(<span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>), <span class="keyword">new</span> XYZ(<span class="number">-1</span>, <span class="number">2</span>, <span class="number">0</span>), <span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>));</span><br><span class="line">    Arc arcofDim = Arc.Create(<span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>), <span class="keyword">new</span> XYZ(<span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>), <span class="keyword">new</span> XYZ(<span class="number">0.8</span>, <span class="number">2.8</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    Autodesk.Revit.Creation.FamilyItemFactory creationFamily = document.FamilyCreate;</span><br><span class="line">    ModelCurve modelCurve1 = creationFamily.NewModelCurve(gLine1, sketchPlane);</span><br><span class="line">    ModelCurve modelCurve2 = creationFamily.NewModelCurve(gLine2, sketchPlane);</span><br><span class="line">    ModelCurve modelCurve3 = creationFamily.NewModelCurve(arctoDim, sketchPlane);</span><br><span class="line">    <span class="comment">//get their reference</span></span><br><span class="line">    Reference ref1 = modelCurve1.GeometryCurve.Reference;</span><br><span class="line">    Reference ref2 = modelCurve2.GeometryCurve.Reference;</span><br><span class="line">    Reference arcRef = modelCurve3.GeometryCurve.Reference;</span><br><span class="line"></span><br><span class="line">    Dimension newArcDim = creationFamily.NewArcLengthDimension(document.ActiveView, arcofDim, arcRef, ref1, ref2);</span><br><span class="line">    <span class="keyword">if</span> (newArcDim == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Failed to create new arc length dimension.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> newArcDim;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-813DEE5B-AD67-4892-934A-EF192F72A5BB-low.png"></p>
<p>图51：产生的弧长尺寸</p>
<p>某些类型的尺寸标注可以使用FamilyParameter进行标记。如果尝试获取或设置Label属性，则无法标记的尺寸标注将引发Autodesk.Revit. Revit.InvalidOperationException。在下面的示例中，在两条线之间创建了一个新的线性尺寸标注，并将其标记为“width”。</p>
<p>代码区域：标注尺寸</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Dimension <span class="title">CreateLinearDimension</span>(<span class="params">Document document</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// first create two lines</span></span><br><span class="line">    XYZ pt1 = <span class="keyword">new</span> XYZ(<span class="number">5</span>, <span class="number">5</span>, <span class="number">0</span>);</span><br><span class="line">    XYZ pt2 = <span class="keyword">new</span> XYZ(<span class="number">5</span>, <span class="number">10</span>, <span class="number">0</span>);</span><br><span class="line">    Line line = Line.CreateBound(pt1, pt2);</span><br><span class="line">    Plane plane = Plane.CreateByNormalAndOrigin(pt1.CrossProduct(pt2), pt2);</span><br><span class="line">    SketchPlane skplane = SketchPlane.Create (document, plane);</span><br><span class="line">    ModelCurve modelcurve1 = document.FamilyCreate.NewModelCurve(line, skplane);</span><br><span class="line"></span><br><span class="line">    pt1 = <span class="keyword">new</span> XYZ(<span class="number">10</span>, <span class="number">5</span>, <span class="number">0</span>);</span><br><span class="line">    pt2 = <span class="keyword">new</span> XYZ(<span class="number">10</span>, <span class="number">10</span>, <span class="number">0</span>);</span><br><span class="line">    line = Line.CreateBound(pt1, pt2);</span><br><span class="line">    plane = Plane.CreateByNormalAndOrigin(pt1.CrossProduct(pt2), pt2);</span><br><span class="line">    skplane = SketchPlane.Create (document, plane);</span><br><span class="line">    ModelCurve modelcurve2 = document.FamilyCreate.NewModelCurve(line, skplane);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// now create a linear dimension between them</span></span><br><span class="line">    ReferenceArray ra = <span class="keyword">new</span> ReferenceArray();</span><br><span class="line">    ra.Append(modelcurve1.GeometryCurve.Reference);</span><br><span class="line">    ra.Append(modelcurve2.GeometryCurve.Reference);</span><br><span class="line"></span><br><span class="line">    pt1 = <span class="keyword">new</span> XYZ(<span class="number">5</span>, <span class="number">10</span>, <span class="number">0</span>);</span><br><span class="line">    pt2 = <span class="keyword">new</span> XYZ(<span class="number">10</span>, <span class="number">10</span>, <span class="number">0</span>);</span><br><span class="line">    line = Line.CreateBound(pt1, pt2);</span><br><span class="line"></span><br><span class="line">    Dimension dim = document.FamilyCreate.NewLinearDimension(document.ActiveView, line, ra);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create a label for the dimension called &quot;width&quot;</span></span><br><span class="line">    FamilyParameter param = document.FamilyManager.AddParameter(<span class="string">&quot;width&quot;</span>, </span><br><span class="line">        BuiltInParameterGroup.PG_CONSTRAINTS, </span><br><span class="line">        ParameterType.Length, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    dim.FamilyLabel = param;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dim;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-802D577E-3791-4286-A288-0B7858C6459C-low.png"></p>
<p>图52：标记的线性尺寸</p>
<h2 id="族元素的可见性"><a href="#族元素的可见性" class="headerlink" title="族元素的可见性"></a>族元素的可见性</h2><p>FamilyElementVisibility类可用于控制族图元在项目文档中的可见性。例如，如果有门族，则可能只希望门开启方向在放置门的项目文档的平面视图中可见，而在三维视图中不可见。通过设置门开启方向的可见性，您可以控制其可见性。FamilyElementVisibility适用于以下具有SetVisibility（）函数的族图元类：</p>
<ul>
<li>GenericForm</li>
<li>SymbolicCurve</li>
<li>ModelText </li>
<li>CurveByPoints</li>
<li>ModelCurve </li>
<li>ReferencePoint </li>
<li>ImportInstance</li>
</ul>
<p>在下面的示例中，生成的族文档将显示文本“Hello World”，其下有一条线。当族载入到Revit项目文档中并放置实例时，在平面视图中，只有该线可见。在3D视图中，将同时显示线条和文本，除非将“详细程度”设置为“粗”，在这种情况下，线条将消失。</p>
<p>代码区域13-10：设置族图元可见性</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">CreateAndSetVisibility</span>(<span class="params">Autodesk.Revit.DB.Document familyDocument, SketchPlane sketchPlane</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// create a new ModelCurve in the family document</span></span><br><span class="line">    XYZ p0 = <span class="keyword">new</span> XYZ(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    XYZ p1 = <span class="keyword">new</span> XYZ(<span class="number">5</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    Line line1 = Line.CreateBound(p0, p1);</span><br><span class="line"></span><br><span class="line">    ModelCurve modelCurve1 = familyDocument.FamilyCreate.NewModelCurve(line1, sketchPlane);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create a new ModelText along ModelCurve line</span></span><br><span class="line">    ModelText text = familyDocument.FamilyCreate.NewModelText(<span class="string">&quot;Hello World&quot;</span>, <span class="literal">null</span>, sketchPlane, p0, HorizontalAlign.Center, <span class="number">0.1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set visibility for text</span></span><br><span class="line">    FamilyElementVisibility textVisibility = <span class="keyword">new</span> FamilyElementVisibility(FamilyElementVisibilityType.Model);</span><br><span class="line">    textVisibility.IsShownInTopBottom = <span class="literal">false</span>;</span><br><span class="line">    text.SetVisibility(textVisibility);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set visibility for line</span></span><br><span class="line">    FamilyElementVisibility curveVisibility = <span class="keyword">new</span> FamilyElementVisibility(FamilyElementVisibilityType.Model);</span><br><span class="line">    curveVisibility.IsShownInCoarse = <span class="literal">false</span>;</span><br><span class="line">    modelCurve1.SetVisibility(curveVisibility);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="管理族类型和参数"><a href="#管理族类型和参数" class="headerlink" title="管理族类型和参数"></a>管理族类型和参数</h2><p>族文档提供对FamilyManager属性的访问。FamilyManager类提供对族类型和参数的访问。使用此类，可以添加和删除类型、添加和删除族参数和共享参数、设置不同族类型中的参数值以及定义公式来驱动参数值。</p>
<p><strong>在族中获取种类</strong></p>
<p>FamilyManager可用于遍历族中的种类，如下例所示。</p>
<p>代码区域13-11：获取族中的种类</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetFamilyTypesInFamily</span>(<span class="params">Document familyDoc</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (familyDoc.IsFamilyDocument)</span><br><span class="line">    &#123;</span><br><span class="line">        FamilyManager familyManager = familyDoc.FamilyManager;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// get types in family</span></span><br><span class="line">        <span class="built_in">string</span> types = <span class="string">&quot;Family Types: &quot;</span>;</span><br><span class="line">        FamilyTypeSet familyTypes = familyManager.Types;</span><br><span class="line">        FamilyTypeSetIterator familyTypesItor = familyTypes.ForwardIterator();</span><br><span class="line">        familyTypesItor.Reset();</span><br><span class="line">        <span class="keyword">while</span> (familyTypesItor.MoveNext())</span><br><span class="line">        &#123;</span><br><span class="line">            FamilyType familyType = familyTypesItor.Current <span class="keyword">as</span> FamilyType;</span><br><span class="line">            types += <span class="string">&quot;\n&quot;</span> + familyType.Name;</span><br><span class="line">        &#125;</span><br><span class="line">        TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>,types);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-60AB2EDC-BC4E-4E08-8922-38ECF4B7F991-low.png"></p>
<p>图53：混凝土矩形柱族中的族种类</p>
<p><strong>编辑族种类</strong></p>
<p>FamilyManager提供了遍历族中现有种类以及添加和修改种类及其参数的功能。</p>
<p>下面的示例演示如何添加新种类（familysymbol），设置其参数，然后将新种类分配给FamilyInstance。种类编辑是通过使用Set（）函数在当前种类上完成的。当前种类可从CurrentType属性获得。CurrentType属性可用于在编辑之前设置当前种类，或使用NewType（）函数创建新种类并将其设置为当前种类以进行编辑。</p>
<p>请注意，一旦创建并修改了新种类，就会使用Document.LoadFamily（）将族重新载入到Revit项目中，以使新种类可用。</p>
<p>代码区域13-12：编辑族类型</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">EditFamilyTypes</span>(<span class="params">Document document, FamilyInstance familyInstance</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// example works best when familyInstance is a rectangular concrete element</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((<span class="literal">null</span> == document) || (<span class="literal">null</span> == familyInstance.Symbol))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;   <span class="comment">// invalid arguments</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get family associated with this</span></span><br><span class="line">    Family family = familyInstance.Symbol.Family;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> == family)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;    <span class="comment">// could not get the family</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get Family document for family</span></span><br><span class="line">    Document familyDoc = document.EditFamily(family);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> == familyDoc)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;    <span class="comment">// could not open a family for edit</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    FamilyManager familyManager = familyDoc.FamilyManager;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> == familyManager)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;  <span class="comment">// cuould not get a family manager</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start transaction for the family document</span></span><br><span class="line">    <span class="keyword">using</span> (Transaction newFamilyTypeTransaction = <span class="keyword">new</span> Transaction(familyDoc, <span class="string">&quot;Add Type to Family&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> changesMade = <span class="number">0</span>;</span><br><span class="line">        newFamilyTypeTransaction.Start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// add a new type and edit its parameters</span></span><br><span class="line">        FamilyType newFamilyType = familyManager.NewType(<span class="string">&quot;2X2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (newFamilyType != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// look for &#x27;b&#x27; and &#x27;h&#x27; parameters and set them to 2 feet</span></span><br><span class="line">            FamilyParameter familyParam = familyManager.get_Parameter(<span class="string">&quot;宽度&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (<span class="literal">null</span> != familyParam)</span><br><span class="line">            &#123;</span><br><span class="line">                familyManager.Set(familyParam, <span class="number">2.0</span>);</span><br><span class="line">                changesMade += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            familyParam = familyManager.get_Parameter(<span class="string">&quot;高度&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (<span class="literal">null</span> != familyParam)</span><br><span class="line">            &#123;</span><br><span class="line">                familyManager.Set(familyParam, <span class="number">2.0</span>);</span><br><span class="line">                changesMade += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">2</span> == changesMade)   <span class="comment">// set both paramaters?</span></span><br><span class="line">        &#123;</span><br><span class="line">            newFamilyTypeTransaction.Commit();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>   <span class="comment">// could not make the change -&gt; should roll back </span></span><br><span class="line">        &#123;</span><br><span class="line">            newFamilyTypeTransaction.RollBack();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// if could not make the change or could not commit it, we return</span></span><br><span class="line">        <span class="keyword">if</span> (newFamilyTypeTransaction.GetStatus() != TransactionStatus.Committed)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// now update the Revit project with Family which has a new type</span></span><br><span class="line">    LoadOpts loadOptions = <span class="keyword">new</span> LoadOpts();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This overload is necessary for reloading an edited family</span></span><br><span class="line">    <span class="comment">// back into the source document from which it was extracted</span></span><br><span class="line">    family = familyDoc.LoadFamily(document, loadOptions);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> != family)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// find the new type and assign it to FamilyInstance</span></span><br><span class="line">        ISet familySymbolIds = family.GetFamilySymbolIds();</span><br><span class="line">        <span class="keyword">foreach</span> (ElementId id <span class="keyword">in</span> familySymbolIds)</span><br><span class="line">        &#123;</span><br><span class="line">            FamilySymbol familySymbol = family.Document.GetElement(id) <span class="keyword">as</span> FamilySymbol;</span><br><span class="line">            <span class="keyword">if</span> ((<span class="literal">null</span> != familySymbol) &amp;&amp; familySymbol.Name == <span class="string">&quot;2X2&quot;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">using</span> (Transaction changeSymbol = <span class="keyword">new</span> Transaction(document, <span class="string">&quot;Change Symbol Assignment&quot;</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                    changeSymbol.Start();</span><br><span class="line">                    familyInstance.Symbol = familySymbol;</span><br><span class="line">                    changeSymbol.Commit();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">LoadOpts</span> : <span class="title">IFamilyLoadOptions</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">OnFamilyFound</span>(<span class="params"><span class="built_in">bool</span> familyInUse, <span class="keyword">out</span> <span class="built_in">bool</span> overwriteParameterValues</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        overwriteParameterValues = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">OnSharedFamilyFound</span>(<span class="params">Family sharedFamily, <span class="built_in">bool</span> familyInUse, <span class="keyword">out</span> FamilySource source, <span class="keyword">out</span> <span class="built_in">bool</span> overwriteParameterValues</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        source = FamilySource.Family;</span><br><span class="line">        overwriteParameterValues = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>FamilyManager类提供对所有族参数的访问。这包括族内置参数、类别内置参数和与族类型关联的共享参数。有两种方法可以获取族参数：</p>
<ul>
<li>Parameters property - 获取族中的所有参数</li>
<li>GetParameters（）-按族中所有参数在Revit UI中出现的顺序获取这些参数使用GetParameters（）方法时，Revit UI顺序首先按组确定，然后按各个参数的顺序确定。</li>
</ul>
<p>可以从给定族的API（不支持重新排序参数的钢筋形状族除外）重新排序（在其组内）族参数。这允许参数以最符合逻辑的顺序呈现给用户。排序仅影响同一参数组中的可见参数。属于不同组的参数将保持分离，并且组的顺序不会受到影响。</p>
<p>对参数重新排序的最简单方法是使用FamilyManager.SortParameters（）方法，该方法接受一个指示所需排序顺序的参数。下面的示例按升序对参数进行排序。</p>
<p>代码区域：对族参数排序</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">DisplayParametersInAscendingOrder</span>(<span class="params">Document familyDoc</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    FamilyManager familyManager = familyDoc.FamilyManager;</span><br><span class="line">    familyManager.SortParameters(ParametersOrder.Ascending);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：排序是一次性操作。当添加新参数时，它们不会自动排序。若要对参数的排序方式进行更多控制，请使用FamilyManager.ReorderParameters（）方法，该方法以新顺序接受族参数列表。此列表必须包含GetParameters（）方法返回的所有参数，包括任何不可见的参数，否则将引发异常。</p>
<h2 id="注：翻译自Revit-API-Developers-Guide"><a href="#注：翻译自Revit-API-Developers-Guide" class="headerlink" title="注：翻译自Revit API Developers Guide"></a><em><strong>注：</strong></em>翻译自<a href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_html">Revit API Developers Guide</a></h2>]]></content>
      <categories>
        <category>Revit二次开发人员指南</category>
      </categories>
      <tags>
        <tag>Revit</tag>
      </tags>
  </entry>
  <entry>
    <title>11事务</title>
    <url>/2024/11/20/Revit%E4%BA%8C%E5%BC%80%E6%8C%87%E5%8D%97/11%E4%BA%8B%E5%8A%A1/</url>
    <content><![CDATA[<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a><a href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_Basic_Interaction_with_Revit_Elements_Transactions_html">事务</a></h1><p>事务是类似于上下文的对象，可封装对Revit模型所做的任何更改。只有在存在打开的活动事务处理时，才能对文档进行任何更改。尝试在事务之外更改文档将引发异常。在提交活动事务之前，更改不会成为模型的一部分。因此，事务中的所有更改都可以显式或隐式回滚（通过析构函数）。在任何给定时间，每个文档只能打开一个事务。一个事务可以由一个或多个操作组成。</p>
<p>Revit API中有三个与事务相关的主要类：</p>
<ul>
<li>Transaction 事务</li>
<li>SubTransaction 子事务</li>
<li>TransactionGroup 事务组</li>
</ul>
<p>本节将更深入地讨论这些类中的每一个类。对文档进行更改时只需要Transaction类。其他类可用于更好地组织更改。</p>
<p>***注意:***如果事务是从外部线程或外部非模态对话框启动的，则会引发异常。事务只能从支持的API工作流启动，例如外部命令、事件、更新程序或回调的一部分。</p>
<p><strong>本节中的页面</strong></p>
<ul>
<li>Transaction Classes 事务类</li>
<li>Transactions in Events 事件中的事务</li>
<li>Failure Handling Options 故障处理选项</li>
<li>Getting Element Geometry and AnalyticalModel<br>获取元素几何图形和分析模型</li>
<li>Temporary transactions 临时事务</li>
</ul>
<h2 id="Transaction-Classes-事务类"><a href="#Transaction-Classes-事务类" class="headerlink" title="Transaction Classes 事务类"></a>Transaction Classes 事务类</h2><p>三个事务对象共享通用方法：</p>
<p>表51：通用事务对象方法</p>
<table>
<thead>
<tr>
<th><strong>Method 方法</strong></th>
<th><strong>Description 描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Start</td>
<td>将启动上下文</td>
</tr>
<tr>
<td>Commit</td>
<td>结束上下文并将所有更改提交到文档</td>
</tr>
<tr>
<td>Rollback</td>
<td>结束上下文并放弃对文档的所有更改</td>
</tr>
<tr>
<td>GetStatus</td>
<td>返回事务对象的当前状态</td>
</tr>
</tbody></table>
<p>除了返回当前状态的GetStatus（）方法外，Start、Commit和RollBack方法还返回TransactionStatus，指示该方法是否成功。可用的TransactionStatus值包括：</p>
<p>表52：TransactionStatus值</p>
<table>
<thead>
<tr>
<th><strong>Status 状态</strong></th>
<th><strong>Description 描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Uninitialized</td>
<td>对象实例化后的初始值;上下文尚未启动</td>
</tr>
<tr>
<td>Started</td>
<td>事务对象已成功启动（调用了Start）</td>
</tr>
<tr>
<td>RolledBack</td>
<td>事务对象已成功回滚（调用了Rollback）</td>
</tr>
<tr>
<td>Committed</td>
<td>已成功提交事务对象（调用了Commit）</td>
</tr>
<tr>
<td>Pending</td>
<td>试图提交或回滚事务对象，但由于失败，该过程尚未完成，正在等待最终用户的响应（在非模态对话框中）。一旦故障处理完成，状态将自动更新（为Committed或RolledBack状态）。</td>
</tr>
</tbody></table>
<h3 id="Transaction-事务"><a href="#Transaction-事务" class="headerlink" title="Transaction 事务"></a>Transaction 事务</h3><p>事务是对Revit模型进行任何更改所需的上下文。一次只能打开一个事务;不允许嵌套。每个事务都必须有一个名称，一旦事务成功提交，该名称将列在Revit的“撤消”菜单中。</p>
<p>代码区域23-1：使用事务</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">CreatingSketch</span>(<span class="params">UIApplication uiApplication</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Autodesk.Revit.DB.Document document = uiApplication.ActiveUIDocument.Document;</span><br><span class="line">    Autodesk.Revit.ApplicationServices.Application application = uiApplication.Application;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create a few geometry lines. These lines are transaction (not in the model),</span></span><br><span class="line">    <span class="comment">// therefore they do not need to be created inside a document transaction.</span></span><br><span class="line">    XYZ Point1 = XYZ.Zero;</span><br><span class="line">    XYZ Point2 = <span class="keyword">new</span> XYZ(<span class="number">10</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    XYZ Point3 = <span class="keyword">new</span> XYZ(<span class="number">10</span>, <span class="number">10</span>, <span class="number">0</span>);</span><br><span class="line">    XYZ Point4 = <span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">10</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    Line geomLine1 = Line.CreateBound(Point1, Point2);</span><br><span class="line">    Line geomLine2 = Line.CreateBound(Point4, Point3);</span><br><span class="line">    Line geomLine3 = Line.CreateBound(Point1, Point4);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This geometry plane is also transaction and does not need a transaction</span></span><br><span class="line">    XYZ origin = XYZ.Zero;</span><br><span class="line">    XYZ normal = <span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    Plane geomPlane = Plane.CreateByNormalAndOrigin(normal, origin);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// In order to a sketch plane with model curves in it, we need</span></span><br><span class="line">    <span class="comment">// to start a transaction because such operations modify the model.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// All and any transaction should be enclosed in a &#x27;using&#x27;</span></span><br><span class="line">    <span class="comment">// block or guarded within a try-catch-finally blocks</span></span><br><span class="line">    <span class="comment">// to guarantee that a transaction does not out-live its scope.</span></span><br><span class="line">    <span class="keyword">using</span> (Transaction transaction = <span class="keyword">new</span> Transaction(document))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (transaction.Start(<span class="string">&quot;Create model curves&quot;</span>) == TransactionStatus.Started)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Create a sketch plane in current document</span></span><br><span class="line">            SketchPlane sketch = SketchPlane.Create(document,geomPlane);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Create a ModelLine elements using the geometry lines and sketch plane</span></span><br><span class="line">            ModelLine line1 = document.Create.NewModelCurve(geomLine1, sketch) <span class="keyword">as</span> ModelLine;</span><br><span class="line">            ModelLine line2 = document.Create.NewModelCurve(geomLine2, sketch) <span class="keyword">as</span> ModelLine;</span><br><span class="line">            ModelLine line3 = document.Create.NewModelCurve(geomLine3, sketch) <span class="keyword">as</span> ModelLine;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Ask the end user whether the changes are to be committed or not</span></span><br><span class="line">            TaskDialog taskDialog = <span class="keyword">new</span> TaskDialog(<span class="string">&quot;Revit&quot;</span>);</span><br><span class="line">            taskDialog.MainContent = <span class="string">&quot;Click either [OK] to Commit, or [Cancel] to Roll back the transaction.&quot;</span>;</span><br><span class="line">            TaskDialogCommonButtons buttons = TaskDialogCommonButtons.Ok | TaskDialogCommonButtons.Cancel;</span><br><span class="line">            taskDialog.CommonButtons = buttons;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (TaskDialogResult.Ok == taskDialog.Show())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// For many various reasons, a transaction may not be committed</span></span><br><span class="line">                <span class="comment">// if the changes made during the transaction do not result a valid model.</span></span><br><span class="line">                <span class="comment">// If committing a transaction fails or is canceled by the end user,</span></span><br><span class="line">                <span class="comment">// the resulting status would be RolledBack instead of Committed.</span></span><br><span class="line">                <span class="keyword">if</span> (TransactionStatus.Committed != transaction.Commit())</span><br><span class="line">                &#123;</span><br><span class="line">                    TaskDialog.Show(<span class="string">&quot;Failure&quot;</span>, <span class="string">&quot;Transaction could not be committed&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                transaction.RollBack();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="SubTransaction-子事务"><a href="#SubTransaction-子事务" class="headerlink" title="SubTransaction 子事务"></a>SubTransaction 子事务</h3><p>SubTransaction可以用来封装一组模型修改操作。子事务是可选的。修改模型时不需要它们。它们是一种方便的工具，允许将较大的任务逻辑拆分为较小的任务。子事务只能在已经打开的事务中创建，并且必须在事务关闭（提交或回滚）之前关闭（提交或回滚）。与事务不同，子事务可以嵌套，但任何嵌套的子事务都必须在封闭子事务之前关闭。子事务没有名称，因为它们不显示在Revit的“撤消”菜单上。</p>
<h3 id="TransactionGroup事务组"><a href="#TransactionGroup事务组" class="headerlink" title="TransactionGroup事务组"></a>TransactionGroup事务组</h3><p>TransactionGroup允许将几个独立的事务分组在一起，这使组的所有者有机会一次处理多个事务。当一个事务组要被关闭时，它可以被回滚，这意味着属于该组的所有以前提交的事务都将被回滚。如果不回滚，则可以提交或同化组。在前一种情况下，所有提交的事务（在组内）将保持原样。在后一种情况下，组内的事务将被合并到一个单独的事务中，该事务将使用组的名称。</p>
<p>事务组只能在没有打开的事务时启动，并且必须在关闭所有封闭的事务（回滚或提交）后关闭。事务组可以嵌套，但必须在封闭组关闭之前关闭任何嵌套组。事务组是可选的。修改模型时不需要这些参数。</p>
<p>下面的示例演示如何使用Assimilate（）方法使用TransactionGroup来合并两个单独的Transactions。下面的代码将导致单个Undo项添加到Undo菜单，名称为“Level and Grid”。</p>
<p>代码区域23-2：将多个事务合并到一个TransactionGroup中</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">CompoundOperation</span>(<span class="params">Autodesk.Revit.DB.Document document</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// All and any transaction group should be enclosed in a &#x27;using&#x27; block or guarded within</span></span><br><span class="line">    <span class="comment">// a try-catch-finally blocks to guarantee that the group does not out-live its scope.</span></span><br><span class="line">    <span class="keyword">using</span> (TransactionGroup transGroup = <span class="keyword">new</span> TransactionGroup(document, <span class="string">&quot;Level and Grid&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (transGroup.Start() == TransactionStatus.Started)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// We are going to call two methods, each having its own local transaction.</span></span><br><span class="line">            <span class="comment">// For our compound operation to be considered successful, both the individual</span></span><br><span class="line">            <span class="comment">// transactions must succeed. If either one fails, we will roll our group back,</span></span><br><span class="line">            <span class="comment">// regardless of what transactions might have already been committed.</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (CreateLevel(document, <span class="number">25.0</span>) &amp;&amp; CreateGrid(document, <span class="keyword">new</span> XYZ(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>), <span class="keyword">new</span> XYZ(<span class="number">10</span>,<span class="number">0</span>,<span class="number">0</span>)))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// The process of assimilating will merge the two (or any number of) committed</span></span><br><span class="line">                <span class="comment">// transaction together and will assign the grid&#x27;s name to the one resulting transaction,</span></span><br><span class="line">                <span class="comment">// which will become the only item from this compound operation appearing in the undo menu.</span></span><br><span class="line">                transGroup.Assimilate();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// Since we could not successfully finish at least one of the individual</span></span><br><span class="line">                <span class="comment">// operation, we are going to roll the entire group back, which will</span></span><br><span class="line">                <span class="comment">// undo any transaction already committed while this group was open.</span></span><br><span class="line">                transGroup.RollBack();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">CreateLevel</span>(<span class="params">Autodesk.Revit.DB.Document document, <span class="built_in">double</span> elevation</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// All and any transaction should be enclosed in a &#x27;using&#x27;</span></span><br><span class="line">    <span class="comment">// block or guarded within a try-catch-finally blocks</span></span><br><span class="line">    <span class="comment">// to guarantee that a transaction does not out-live its scope.</span></span><br><span class="line">    <span class="keyword">using</span> (Transaction transaction = <span class="keyword">new</span> Transaction(document, <span class="string">&quot;Creating Level&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Must start a transaction to be able to modify a document</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( TransactionStatus.Started == transaction.Start())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="literal">null</span> != Level.Create(document, elevation))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// For many various reasons, a transaction may not be committed</span></span><br><span class="line">                <span class="comment">// if the changes made during the transaction do not result a valid model.</span></span><br><span class="line">                <span class="comment">// If committing a transaction fails or is canceled by the end user,</span></span><br><span class="line">                <span class="comment">// the resulting status would be RolledBack instead of Committed.</span></span><br><span class="line">                <span class="keyword">return</span> (TransactionStatus.Committed == transaction.Commit());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// For we were unable to create the level, we will roll the transaction back</span></span><br><span class="line">            <span class="comment">// (although on this simplified case we know there weren&#x27;t any other changes)</span></span><br><span class="line"></span><br><span class="line">            transaction.RollBack();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">CreateGrid</span>(<span class="params">Autodesk.Revit.DB.Document document, XYZ p1, XYZ p2</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// All and any transaction should be enclosed in a &#x27;using&#x27;</span></span><br><span class="line">    <span class="comment">// block or guarded within a try-catch-finally blocks</span></span><br><span class="line">    <span class="comment">// to guarantee that a transaction does not out-live its scope.</span></span><br><span class="line">    <span class="keyword">using</span> (Transaction transaction = <span class="keyword">new</span> Transaction(document, <span class="string">&quot;Creating Grid&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Must start a transaction to be able to modify a document</span></span><br><span class="line">        <span class="keyword">if</span> (TransactionStatus.Started == transaction.Start())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// We create a line and use it as an argument to create a grid</span></span><br><span class="line">            Line gridLine = Line.CreateBound(p1, p2);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((<span class="literal">null</span> != gridLine) &amp;&amp; (<span class="literal">null</span> != Grid.Create(document, gridLine)))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (TransactionStatus.Committed == transaction.Commit())</span><br><span class="line">                &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// For we were unable to create the grid, we will roll the transaction back</span></span><br><span class="line">            <span class="comment">// (although on this simplified case we know there weren&#x27;t any other changes)</span></span><br><span class="line"></span><br><span class="line">            transaction.RollBack();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="事件中的事务"><a href="#事件中的事务" class="headerlink" title="事件中的事务"></a>事件中的事务</h2><h3 id="在事件期间修改文档"><a href="#在事件期间修改文档" class="headerlink" title="在事件期间修改文档"></a>在事件期间修改文档</h3><p>事件不会自动打开事务。因此，文档不会在事件期间被修改，除非事件的某个处理程序通过在事务内部进行更改来修改文档。如果事件处理程序打开一个事务，则要求它也关闭它（提交它或回滚它），否则所有更改都将被丢弃。</p>
<p>请注意，在某些事件（例如DocumentClosing事件）期间，不允许修改活动文档。如果事件处理程序试图在此类事件期间进行修改，则将引发异常。事件文档指示事件是否为只读。</p>
<h3 id="DocumentChanged事件"><a href="#DocumentChanged事件" class="headerlink" title="DocumentChanged事件"></a>DocumentChanged事件</h3><p>DocumentChanged事件在每个事务提交、撤消或重做后引发。这是一个只读事件，旨在使外部数据与Revit数据库的状态保持同步。若要更新Revit数据库以响应图元中的更改，请使用动态模型更新框架。</p>
<h2 id="失败处理选项"><a href="#失败处理选项" class="headerlink" title="失败处理选项"></a>失败处理选项</h2><p>失败处理选项是在事务结束时如何处理失败（如果有）的选项。在使用Transaction.SetFailureHandlingOptions（）方法调用Transaction.Commit（）或Transaction.RollBack（）之前，可以随时设置失败处理选项。但是，在提交或回滚事务后，这些选项将返回到各自的默认设置。</p>
<p>SetFailureHandlingOptions（）方法接受FailureHandlingOptions对象作为参数。无法创建此对象，必须使用GetFailureHandlingOptions（）方法从事务中获取它。通过调用相应的Set方法（如SetClearAfterRollback（））来设置选项。以下各节将更详细地讨论故障处理选项。</p>
<h3 id="ClearAfterRollback"><a href="#ClearAfterRollback" class="headerlink" title="ClearAfterRollback"></a>ClearAfterRollback</h3><p>此选项控制是否应在回滚事务后清除所有警告。默认值为False。</p>
<h3 id="DelayedMiniWarnings-DelayedMinimax"><a href="#DelayedMiniWarnings-DelayedMinimax" class="headerlink" title="DelayedMiniWarnings DelayedMinimax"></a>DelayedMiniWarnings DelayedMinimax</h3><p>此选项控制是否在当前正在结束的事务结束时显示小警告（如果有），或者是否应将其推迟到下一个事务结束时显示。当不希望在每个步骤结束时显示中间警告，而希望等到整个链完成时，通常在事务链中使用此方法。</p>
<p>多个事务可能会延迟验证。第一个未将此选项设置为True的事务将显示其自己的所有警告（如果有）以及可能从以前的事务累积的所有警告。默认值为False。</p>
<p>注意：此选项在模态模式下被忽略（请参阅下面的ForcedModalHandling）。</p>
<h3 id="ForcedModalHandling"><a href="#ForcedModalHandling" class="headerlink" title="ForcedModalHandling"></a>ForcedModalHandling</h3><p>此选项控制最终的故障是以模态方式还是以非模态方式处理。预设值为True。请注意，如果设置了非模态故障处理，则处理事务可能会异步完成，这意味着从Commit或RollBack调用返回时，事务将尚未完成（状态将为“Pending”）。</p>
<h3 id="SetFailuresPreprocessor"><a href="#SetFailuresPreprocessor" class="headerlink" title="SetFailuresPreprocessor"></a>SetFailuresPreprocessor</h3><p>如果提供此接口，则在事务结束时发现失败时调用此接口。预处理器可以检查当前的故障，甚至尝试解决它们。有关详细信息，请参阅故障发布和处理。</p>
<h3 id="SetTransactionFinalizer"><a href="#SetTransactionFinalizer" class="headerlink" title="SetTransactionFinalizer"></a>SetTransactionFinalizer</h3><p>终结器是一个接口，如果提供了该接口，则可用于在事务结束时执行自定义操作。请注意，它不会在调用Commit（）或RollBack（）方法时调用，而是仅在提交或回滚过程完成后调用。事务终结器必须实现<em>ITransactionFinalizer</em>接口，该接口需要定义两个函数：</p>
<ul>
<li>OnCommitted - called at the end of committing a transaction<br>OnCommitted -在提交事务结束时调用</li>
<li>OnRolledBack - called at the end of rolling back a transaction<br>OnRolledBack -在回滚事务结束时调用</li>
</ul>
<p><em><strong>注意：</strong></em>由于终结器是在事务完成后调用的，因此除非启动新事务，否则无法从终结器修改文档。</p>
<h2 id="获取元素几何图形和分析模型"><a href="#获取元素几何图形和分析模型" class="headerlink" title="获取元素几何图形和分析模型"></a>获取元素几何图形和分析模型</h2><p>创建新图元或修改图元后，需要重新生成和自动连接图元以将更改传播到整个模型中。如果不进行再生（以及相关的自动连接），则无法获得“几何”属性和“元素的分析模型”（在创建新元素的情况下），或者它们可能无效。在访问图元的“几何”或“分析模型”之前，了解再生发生的方式和时间非常重要。</p>
<p>尽管再生和自动连接对于传播模型中所做的更改是必要的，但这可能很耗时。最好是这些事件只在必要时发生。</p>
<p>当修改模型的事务成功提交时，或者调用Document.Regenerate（）或Document.AutoJoinElements（）方法时，自动进行重新生成和自动联接。Regenerate（）和AutoJoinElements（）只能在打开的事务中调用。应该注意的是，Regeneration（）方法可能会失败，在这种情况下，RegenerationFailedException将被抛出。如果发生这种情况，则需要通过回滚当前事务或子事务来回滚对文档的更改。</p>
<p>有关更多信息，请参见分析模型和几何形状。</p>
<p>下面的示例程序演示了事务如何填充这些属性：</p>
<p>代码区域23-3：填充几何和分析模型属性的事务处理</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TransactionDuringElementCreation</span>(<span class="params">UIApplication uiApplication, Level level</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Autodesk.Revit.DB.Document document = uiApplication.ActiveUIDocument.Document;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Build a location line for the wall creation</span></span><br><span class="line">    XYZ start = <span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    XYZ end = <span class="keyword">new</span> XYZ(<span class="number">10</span>, <span class="number">10</span>, <span class="number">0</span>);</span><br><span class="line">    Autodesk.Revit.DB.Line geomLine = Line.CreateBound(start, end);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// All and any transaction should be enclosed in a &#x27;using&#x27;</span></span><br><span class="line">    <span class="comment">// block or guarded within a try-catch-finally blocks</span></span><br><span class="line">    <span class="comment">// to guarantee that a transaction does not out-live its scope.</span></span><br><span class="line">    <span class="keyword">using</span> (Transaction wallTransaction = <span class="keyword">new</span> Transaction(document, <span class="string">&quot;Creating wall&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="comment">// To create a wall, a transaction must be first started</span></span><br><span class="line">       <span class="keyword">if</span> (wallTransaction.Start() == TransactionStatus.Started)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="comment">// Create a wall using the location line</span></span><br><span class="line">           Wall wall = Wall.Create(document, geomLine, level.Id, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">           <span class="comment">// the transaction must be committed before you can</span></span><br><span class="line">           <span class="comment">// get the value of Geometry and AnalyticalModel.</span></span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (wallTransaction.Commit() == TransactionStatus.Committed)</span><br><span class="line">           &#123;</span><br><span class="line">               Autodesk.Revit.DB.Options options = uiApplication.Application.Create.NewGeometryOptions();</span><br><span class="line">               Autodesk.Revit.DB.GeometryElement geoelem = wall.get_Geometry(options);</span><br><span class="line">               Autodesk.Revit.DB.Structure.AnalyticalModel analyticalmodel = wall.GetAnalyticalModel();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此示例的事务时间轴如下所示：</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-A7296713-19E7-4C50-A7B6-F3F7893A8EDD-low.png"></p>
<h2 id="临时事务"><a href="#临时事务" class="headerlink" title="临时事务"></a>临时事务</h2><p>并不总是需要提交事务。事务框架还允许回滚事务。这在事务处理过程中出现错误时很有用，但也可以直接用作创建临时事务的技术。</p>
<p>使用临时事务对于某些类型的分析可能很有用。例如，如果应用程序希望在墙或其他对象被洞口剪切之前从其提取几何属性，则应将临时事务与Document.Delete（）结合使用。当应用程序删除剪切目标元素的元素时，剪切元素的几何图形将恢复到其原始状态（在重新生成文档之后）。</p>
<p>要使用临时事务处理，请执行以下操作：</p>
<ol>
<li>使用Transaction构造函数实例化Transaction，并为其分配一个名称。</li>
<li>调用Transaction.Start（）</li>
<li>对文档进行临时更改（元素修改、删除或创建）</li>
<li>重新生成文档</li>
<li>提取所需的几何图形和属性</li>
<li>调用Transaction.RollBack（）将文档还原到以前的状态。</li>
</ol>
<p>这种技术也适用于子事务。</p>
<h2 id="注：翻译自Revit-API-Developers-Guide"><a href="#注：翻译自Revit-API-Developers-Guide" class="headerlink" title="注：翻译自Revit API Developers Guide"></a><em><strong>注：</strong></em>翻译自<a href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_html">Revit API Developers Guide</a></h2>]]></content>
      <categories>
        <category>Revit二次开发人员指南</category>
      </categories>
      <tags>
        <tag>Revit</tag>
      </tags>
  </entry>
  <entry>
    <title>15概念设计</title>
    <url>/2024/12/05/Revit%E4%BA%8C%E5%BC%80%E6%8C%87%E5%8D%97/15%E6%A6%82%E5%BF%B5%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<h1 id="概念设计"><a href="#概念设计" class="headerlink" title="概念设计"></a><a href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_Revit_Geometric_Elements_Conceptual_Design_html">概念设计</a></h1><p>本章讨论用于在族文档中创建复杂几何图形的Revit API的概念设计功能。通过添加新对象（点和通过这些点的样条曲线）来支持形状制作。可以分割、填充图案和嵌板化生成的曲面，以创建具有持久参数关系的可构建形状。</p>
<p>本节中的页面</p>
<ul>
<li>点和曲线对象</li>
<li>形状</li>
<li>曲面的几何化</li>
<li>自适应构件</li>
<li>创建.addin清单文件</li>
</ul>
<h2 id="点和曲线对象"><a href="#点和曲线对象" class="headerlink" title="点和曲线对象"></a>点和曲线对象</h2><p>参照点是在概念设计环境的XYZ工作空间中指定位置的元素。可以创建参照点来设计和打印直线、样条曲线和形状。可以将ReferencePoint添加到ReferencePointArray，然后用于创建CurveByPoints，而CurveByPoints又可用于创建形状。</p>
<p>下面的示例演示如何创建CurveByPoints对象。请参见下一节中的“创建放样形状”示例，了解如何从多个CurveByPoints对象创建形状。</p>
<p>代码区域14-1：创建新的CurveByPoints</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//体量中创建</span></span><br><span class="line">ReferencePointArray rpa = <span class="keyword">new</span> ReferencePointArray();</span><br><span class="line"></span><br><span class="line">XYZ xyz = document.Application.Create.NewXYZ(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">ReferencePoint rp = document.FamilyCreate.NewReferencePoint(xyz);</span><br><span class="line">rpa.Append(rp);</span><br><span class="line"></span><br><span class="line">xyz = document.Application.Create.NewXYZ(<span class="number">0</span>, <span class="number">30</span>, <span class="number">10</span>);</span><br><span class="line">rp = document.FamilyCreate.NewReferencePoint(xyz);</span><br><span class="line">rpa.Append(rp);</span><br><span class="line"></span><br><span class="line">xyz = document.Application.Create.NewXYZ(<span class="number">0</span>, <span class="number">60</span>, <span class="number">0</span>);</span><br><span class="line">rp = document.FamilyCreate.NewReferencePoint(xyz);</span><br><span class="line">rpa.Append(rp);</span><br><span class="line"></span><br><span class="line">xyz = document.Application.Create.NewXYZ(<span class="number">0</span>, <span class="number">100</span>, <span class="number">30</span>);</span><br><span class="line">rp = document.FamilyCreate.NewReferencePoint(xyz);</span><br><span class="line">rpa.Append(rp);</span><br><span class="line"></span><br><span class="line">xyz = document.Application.Create.NewXYZ(<span class="number">0</span>, <span class="number">150</span>, <span class="number">0</span>);</span><br><span class="line">rp = document.FamilyCreate.NewReferencePoint(xyz);</span><br><span class="line">rpa.Append(rp);</span><br><span class="line"></span><br><span class="line">CurveByPoints curve = document.FamilyCreate.NewCurveByPoints(rpa);</span><br></pre></td></tr></table></figure>

<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-91A84A22-3B88-45F4-B7CE-8D75F685A95A-low.png"></p>
<p>图54：CurveByPoints曲线</p>
<p>参照点可以基于XYZ坐标创建，如上例所示，也可以相对于其他几何图元创建，以便当参照几何图元更改时，这些点会移动。这些点使用PointElementReference类的子类创建。这些子类是：</p>
<ul>
<li>PointOnEdge</li>
<li>PointOnEdgeEdgeIntersection</li>
<li>PointOnEdgeFaceIntersection</li>
<li>PointOnFace</li>
<li>PointOnPlane</li>
</ul>
<p>例如，上一个示例中的最后两行代码在CurveByPoints的中间创建了一个参考点。</p>
<p>可以使用模型线或参照线创建形状。模型线在创建过程中由形状“使用”，不再作为单独的图元存在。另一方面，参照线在形状创建后仍然存在，如果移动它们，可能会改变形状。虽然API没有ReferenceLine类，但可以使用ModelCurve.ChangeToReferenceLine（）方法将模型线更改为参考线。</p>
<p>代码区域14-2：使用参照线创建形状</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//demo失败（报错，无效操作）</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> FormArray <span class="title">CreateRevolveForm</span>(<span class="params">Document document</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    FormArray revolveForms = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create one profile</span></span><br><span class="line">    ReferenceArray ref_ar = <span class="keyword">new</span> ReferenceArray();</span><br><span class="line"></span><br><span class="line">    XYZ ptA = <span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">    XYZ ptB = <span class="keyword">new</span> XYZ(<span class="number">100</span>, <span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">    Line line = Line.CreateBound(ptA, ptB);</span><br><span class="line">    ModelCurve modelcurve = MakeLine(document, ptA, ptB);</span><br><span class="line">    ref_ar.Append(modelcurve.GeometryCurve.Reference);</span><br><span class="line"></span><br><span class="line">    ptA = <span class="keyword">new</span> XYZ(<span class="number">100</span>, <span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">    ptB = <span class="keyword">new</span> XYZ(<span class="number">100</span>, <span class="number">100</span>, <span class="number">10</span>);</span><br><span class="line">    modelcurve = MakeLine(document, ptA, ptB);</span><br><span class="line">    ref_ar.Append(modelcurve.GeometryCurve.Reference);</span><br><span class="line"></span><br><span class="line">    ptA = <span class="keyword">new</span> XYZ(<span class="number">100</span>, <span class="number">100</span>, <span class="number">10</span>);</span><br><span class="line">    ptB = <span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">    modelcurve = MakeLine(document, ptA, ptB);</span><br><span class="line">    ref_ar.Append(modelcurve.GeometryCurve.Reference);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create axis for revolve form</span></span><br><span class="line">    ptA = <span class="keyword">new</span> XYZ(<span class="number">-5</span>, <span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">    ptB = <span class="keyword">new</span> XYZ(<span class="number">-5</span>, <span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line">    ModelCurve axis = MakeLine(document, ptA, ptB);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// make axis a Reference Line</span></span><br><span class="line">    axis.ChangeToReferenceLine();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Typically this operation produces only a single form, </span></span><br><span class="line">    <span class="comment">// but some combinations of arguments will create multiple froms from a single profile.</span></span><br><span class="line">    revolveForms = document.FamilyCreate.NewRevolveForms(<span class="literal">true</span>, ref_ar, axis.GeometryCurve.Reference, <span class="number">0</span>, Math.PI / <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> revolveForms;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelCurve <span class="title">MakeLine</span>(<span class="params">Document doc, XYZ ptA, XYZ ptB</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Autodesk.Revit.ApplicationServices.Application app = doc.Application;</span><br><span class="line">    <span class="comment">// Create plane by the points</span></span><br><span class="line">    Line line = Line.CreateBound(ptA, ptB);</span><br><span class="line">    XYZ norm = ptA.CrossProduct(ptB);</span><br><span class="line">    <span class="keyword">if</span> (norm.IsZeroLength()) norm = XYZ.BasisZ;</span><br><span class="line">    Plane plane = Plane.CreateByNormalAndOrigin(norm, ptB);</span><br><span class="line">    SketchPlane skplane = SketchPlane.Create(doc, plane);</span><br><span class="line">    <span class="comment">// Create line here</span></span><br><span class="line">    ModelCurve modelcurve = doc.FamilyCreate.NewModelCurve(line, skplane);</span><br><span class="line">    <span class="keyword">return</span> modelcurve;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-F5F29826-D2EA-4007-8C3F-8F30975261C4-low.png"></p>
<p>图55：生成的Revolve表单</p>
<h2 id="形状"><a href="#形状" class="headerlink" title="形状"></a>形状</h2><h3 id="创建形状"><a href="#创建形状" class="headerlink" title="创建形状"></a>创建形状</h3><p>与族创建类似，概念设计环境提供了创建新形状的功能。可以创建以下类型的形状：拉伸、旋转、放样、放样融合、放样和曲面形状。体量族不使用族创建中使用的“混合”、“拉伸”、“旋转”、“放样”和“放样融合”类，而是将“形状”类用于所有类型的形状。</p>
<p>拉伸形状是从平面的闭合曲线回路创建的。旋转形状是根据轮廓和与轮廓在同一平面上的直线创建的，轮廓是围绕其旋转形状以创建三维形状的轴。放样形状是从沿沿着平面路径放样的二维轮廓创建的。放样融合是从多个轮廓创建的，每个轮廓都是平面的，沿沿着单个曲线放样。放样形状由位于不同平面上的两个或多个截面轮廓创建。单个曲面形状是从轮廓创建的，类似于拉伸，但不指定高度。</p>
<p>下面的示例创建一个简单的拉伸形状。请注意，由于用于创建形状的ModelCurves不会转换为参照线，因此它们将由生成的形状使用。</p>
<p>代码区域14-3：创建拉伸形状</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Form <span class="title">CreateExtrusionForm</span>(<span class="params">Autodesk.Revit.DB.Document document</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Form extrusionForm = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create one profile</span></span><br><span class="line">    ReferenceArray ref_ar = <span class="keyword">new</span> ReferenceArray();</span><br><span class="line"></span><br><span class="line">    XYZ ptA = <span class="keyword">new</span> XYZ(<span class="number">10</span>, <span class="number">10</span>, <span class="number">0</span>);</span><br><span class="line">    XYZ ptB = <span class="keyword">new</span> XYZ(<span class="number">90</span>, <span class="number">10</span>, <span class="number">0</span>);</span><br><span class="line">    ModelCurve modelcurve = MakeLine(document, ptA, ptB);</span><br><span class="line">    ref_ar.Append(modelcurve.GeometryCurve.Reference);</span><br><span class="line"></span><br><span class="line">    ptA = <span class="keyword">new</span> XYZ(<span class="number">90</span>, <span class="number">10</span>, <span class="number">0</span>);</span><br><span class="line">    ptB = <span class="keyword">new</span> XYZ(<span class="number">10</span>, <span class="number">90</span>, <span class="number">0</span>);</span><br><span class="line">    modelcurve = MakeLine(document, ptA, ptB);</span><br><span class="line">    ref_ar.Append(modelcurve.GeometryCurve.Reference);</span><br><span class="line"></span><br><span class="line">    ptA = <span class="keyword">new</span> XYZ(<span class="number">10</span>, <span class="number">90</span>, <span class="number">0</span>);</span><br><span class="line">    ptB = <span class="keyword">new</span> XYZ(<span class="number">10</span>, <span class="number">10</span>, <span class="number">0</span>);</span><br><span class="line">    modelcurve = MakeLine(document, ptA, ptB);</span><br><span class="line">    ref_ar.Append(modelcurve.GeometryCurve.Reference);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The extrusion form direction</span></span><br><span class="line">    XYZ direction = <span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">0</span>, <span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">    extrusionForm = document.FamilyCreate.NewExtrusionForm(<span class="literal">true</span>, ref_ar, direction);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> profileCount = extrusionForm.ProfileCount;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> extrusionForm;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelCurve <span class="title">MakeLine</span>(<span class="params">Document doc, XYZ ptA, XYZ ptB</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Autodesk.Revit.ApplicationServices.Application app = doc.Application;</span><br><span class="line">    <span class="comment">// Create plane by the points</span></span><br><span class="line">    Line line = Line.CreateBound(ptA, ptB);</span><br><span class="line">    XYZ norm = ptA.CrossProduct(ptB);</span><br><span class="line">    <span class="keyword">if</span> (norm.IsZeroLength()) norm = XYZ.BasisZ;</span><br><span class="line">    Plane plane = Plane.CreateByNormalAndOrigin(norm, ptB);</span><br><span class="line">    SketchPlane skplane = SketchPlane.Create(doc, plane);</span><br><span class="line">    <span class="comment">// Create line here</span></span><br><span class="line">    ModelCurve modelcurve = doc.FamilyCreate.NewModelCurve(line, skplane);</span><br><span class="line">    <span class="keyword">return</span> modelcurve;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-ACA912B3-A871-4886-8600-A95C293FB2D5-low.png"></p>
<p>图56：所得拉伸形状</p>
<p>下面的示例显示如何使用一系列CurveByPoints对象创建放样形状。</p>
<p>代码区域14-4：创建放样形状</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Form <span class="title">CreateLoftForm</span>(<span class="params">Autodesk.Revit.Document document</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        Form loftForm = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        ReferencePointArray rpa = <span class="keyword">new</span> ReferencePointArray();</span><br><span class="line">        ReferenceArrayArray ref_ar_ar = <span class="keyword">new</span> ReferenceArrayArray();</span><br><span class="line">        ReferenceArray ref_ar = <span class="keyword">new</span> ReferenceArray();</span><br><span class="line">        ReferencePoint rp = <span class="literal">null</span>;</span><br><span class="line">        XYZ xyz = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// make first profile curve for loft</span></span><br><span class="line">        xyz = document.Application.Create.NewXYZ(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        rp = document.FamilyCreate.NewReferencePoint(xyz);</span><br><span class="line">        rpa.Append(rp);</span><br><span class="line"></span><br><span class="line">        xyz = document.Application.Create.NewXYZ(<span class="number">0</span>, <span class="number">50</span>, <span class="number">10</span>);</span><br><span class="line">        rp = document.FamilyCreate.NewReferencePoint(xyz);</span><br><span class="line">        rpa.Append(rp);</span><br><span class="line"></span><br><span class="line">        xyz = document.Application.Create.NewXYZ(<span class="number">0</span>, <span class="number">100</span>, <span class="number">0</span>);</span><br><span class="line">        rp = document.FamilyCreate.NewReferencePoint(xyz);</span><br><span class="line">        rpa.Append(rp);</span><br><span class="line"></span><br><span class="line">        CurveByPoints cbp = document.FamilyCreate.NewCurveByPoints(rpa);</span><br><span class="line">        ref_ar.Append(cbp.GeometryCurve.Reference);</span><br><span class="line">        ref_ar_ar.Append(ref_ar);</span><br><span class="line">        rpa.Clear();</span><br><span class="line">        ref_ar = <span class="keyword">new</span> ReferenceArray();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// make second profile curve for loft</span></span><br><span class="line">        xyz = document.Application.Create.NewXYZ(<span class="number">50</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        rp = document.FamilyCreate.NewReferencePoint(xyz);</span><br><span class="line">        rpa.Append(rp);</span><br><span class="line"></span><br><span class="line">        xyz = document.Application.Create.NewXYZ(<span class="number">50</span>, <span class="number">50</span>, <span class="number">30</span>);</span><br><span class="line">        rp = document.FamilyCreate.NewReferencePoint(xyz);</span><br><span class="line">        rpa.Append(rp);</span><br><span class="line"></span><br><span class="line">        xyz = document.Application.Create.NewXYZ(<span class="number">50</span>, <span class="number">100</span>, <span class="number">0</span>);</span><br><span class="line">        rp = document.FamilyCreate.NewReferencePoint(xyz);</span><br><span class="line">        rpa.Append(rp);</span><br><span class="line"></span><br><span class="line">        cbp = document.FamilyCreate.NewCurveByPoints(rpa);</span><br><span class="line">        ref_ar.Append(cbp.GeometryCurve.Reference);</span><br><span class="line">        ref_ar_ar.Append(ref_ar);</span><br><span class="line">        rpa.Clear();</span><br><span class="line">        ref_ar = <span class="keyword">new</span> ReferenceArray();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// make third profile curve for loft</span></span><br><span class="line">        xyz = document.Application.Create.NewXYZ(<span class="number">75</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        rp = document.FamilyCreate.NewReferencePoint(xyz);</span><br><span class="line">        rpa.Append(rp);</span><br><span class="line"></span><br><span class="line">        xyz = document.Application.Create.NewXYZ(<span class="number">75</span>, <span class="number">50</span>, <span class="number">5</span>);</span><br><span class="line">        rp = document.FamilyCreate.NewReferencePoint(xyz);</span><br><span class="line">        rpa.Append(rp);</span><br><span class="line"></span><br><span class="line">        xyz = document.Application.Create.NewXYZ(<span class="number">75</span>, <span class="number">100</span>, <span class="number">0</span>);</span><br><span class="line">        rp = document.FamilyCreate.NewReferencePoint(xyz);</span><br><span class="line">        rpa.Append(rp);</span><br><span class="line"></span><br><span class="line">        cbp = document.FamilyCreate.NewCurveByPoints(rpa);</span><br><span class="line">        ref_ar.Append(cbp.GeometryCurve.Reference);</span><br><span class="line">        ref_ar_ar.Append(ref_ar);</span><br><span class="line"></span><br><span class="line">        loftForm = document.FamilyCreate.NewLoftForm(<span class="literal">true</span>, ref_ar_ar);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> loftForm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-8F7F53FC-51B6-4547-86C4-709C11B72FCA-low.png"></p>
<p>图57：生成的放样形状</p>
<h3 id="形状修改"><a href="#形状修改" class="headerlink" title="形状修改"></a>形状修改</h3><p>一旦创建，可以通过改变形状的子元素（即面、边、曲线或顶点）或整个轮廓来修改形状。修改表单的方法包括：</p>
<ul>
<li>AddEdge</li>
<li>AddProfile</li>
<li>DeleteProfile</li>
<li>DeleteSubElement</li>
<li>MoveProfile </li>
<li>MoveSubElement </li>
<li>RotateProfile</li>
<li>RotateSubElement</li>
<li>ScaleSubElement</li>
</ul>
<p>此外，可以通过添加边或轮廓来修改形状，然后可以使用上面列出的方法进行修改。</p>
<p>下面的示例将给定形状的第一条轮廓曲线移动指定的偏移量。相应的图显示了将此代码应用于上一个示例中的放样形式的结果。</p>
<p>代码区域14-5：移动轮廓</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">MoveForm</span>(<span class="params">Form form</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="built_in">int</span> profileCount = form.ProfileCount;</span><br><span class="line">        <span class="keyword">if</span> (form.ProfileCount &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">int</span> profileIndex = <span class="number">0</span>;   <span class="comment">// modify the first form only</span></span><br><span class="line">                <span class="keyword">if</span> (form.CanManipulateProfile(profileIndex))</span><br><span class="line">                &#123;</span><br><span class="line">                XYZ offset = <span class="keyword">new</span> XYZ(<span class="number">-25</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">                form.MoveProfile(profileIndex, offset);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-BCA27D2B-71B9-40CE-A94E-2858C22B8A08-low.png"></p>
<p>图58：修改后的放样形式</p>
<p>下一个示例演示如何移动给定形状的单个顶点。相应的图演示了此代码对前面的拉伸形状示例的影响</p>
<p>代码区域14-6：移动子元素</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">MoveSubElement</span>(<span class="params">Form form</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">if</span> (form.ProfileCount &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">int</span> profileIndex = <span class="number">0</span>;   <span class="comment">// get first profile</span></span><br><span class="line">                ReferenceArray ra = form.get_CurveLoopReferencesOnProfile(profileIndex, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">foreach</span> (Reference r <span class="keyword">in</span> ra)</span><br><span class="line">                &#123;</span><br><span class="line">                        ReferenceArray ra2 = form.GetControlPoints(r);</span><br><span class="line">                        <span class="keyword">foreach</span> (Reference r2 <span class="keyword">in</span> ra2)</span><br><span class="line">                        &#123;</span><br><span class="line">                                Point vertex = document.GetElement(r2).GetGeometryObjectFromReference(r2) <span class="keyword">as</span> Point;</span><br><span class="line"></span><br><span class="line">                                XYZ offset = <span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">15</span>, <span class="number">0</span>);</span><br><span class="line">                                form.MoveSubElement(r2, offset);</span><br><span class="line">                                <span class="keyword">break</span>;  <span class="comment">// just move the first point</span></span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>图59：修改拉伸的形状</p>
<h2 id="表面的几何化"><a href="#表面的几何化" class="headerlink" title="表面的几何化"></a>表面的几何化</h2><h3 id="分割表面"><a href="#分割表面" class="headerlink" title="分割表面"></a>分割表面</h3><p>形状的面可以用UV网格划分。可以使用DividedSurface.GetReferencesWithDividedSurface（）和DividedSurface.GetDividedSurfaceForReference（）方法（如后续示例所示）访问分割曲面的数据，也可以在形状上创建新的分割曲面，如下所示。</p>
<p>代码区域14-7：划分表面</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DivideSurface</span>(<span class="params">Document document, Form form</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Autodesk.Revit.ApplicationServices.Application application = document.Application;</span><br><span class="line">    Options opt = application.Create.NewGeometryOptions();</span><br><span class="line">    opt.ComputeReferences = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    Autodesk.Revit.DB.GeometryElement geomElem = form.get_Geometry(opt);</span><br><span class="line">    <span class="keyword">foreach</span> (GeometryObject geomObj <span class="keyword">in</span> geomElem)</span><br><span class="line">    &#123;</span><br><span class="line">        Solid solid = geomObj <span class="keyword">as</span> Solid;</span><br><span class="line">        <span class="keyword">foreach</span> (Face face <span class="keyword">in</span> solid.Faces)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (face.Reference != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                DividedSurface ds = DividedSurface.Create(document,face.Reference);</span><br><span class="line">                <span class="comment">// create a divided surface with fixed number of U and V grid lines</span></span><br><span class="line">                SpacingRule srU = ds.USpacingRule;</span><br><span class="line">                srU.SetLayoutFixedNumber(<span class="number">16</span>, SpacingRuleJustification.Center, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">                SpacingRule srV = ds.VSpacingRule;</span><br><span class="line">                srV.SetLayoutFixedNumber(<span class="number">24</span>, SpacingRuleJustification.Center, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">break</span>;  <span class="comment">// just divide one face of form</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-68B498E3-3756-47BF-8392-1F12F2F8D4ED-low.png"></p>
<p>图60：由UV网格划分的形状面</p>
<p>通过指定DividedSurface的USpacing和VSpacing属性，可以为U和V网格线定义SpacingRule，方法是指定固定的网格数（如上例所示）、网格之间的固定距离或网格之间的最小或最大间距。每个间距规则都需要其他信息，例如对正和网格旋转。</p>
<p>图案化表面</p>
<p>可以对分割的曲面进行阵列。任何内置平铺填充图案都可以应用于分割表面。平铺图案是指定给DividedSurface的ElementType。平铺图案根据UV栅格布局应用于曲面，因此更改DividedSurface的USpacing和VSpacing属性将影响图案化曲面的显示方式。</p>
<p>下面的示例演示如何使用OctagonRotate图案覆盖分割曲面。相应的图显示了将其应用于上一示例中的分割曲面时的外观。注意这个例子还演示了如何在窗体上获取DividedSurface。</p>
<p>代码区域14-8：图案化表面</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TileSurface</span>(<span class="params">Document document, Form form</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// cover surface with OctagonRotate tile pattern</span></span><br><span class="line">    TilePatterns tilePatterns = document.Settings.TilePatterns;</span><br><span class="line">    <span class="keyword">foreach</span> (Reference r <span class="keyword">in</span> DividedSurface.GetReferencesWithDividedSurfaces(form))</span><br><span class="line">    &#123;</span><br><span class="line">        DividedSurface ds = DividedSurface.GetDividedSurfaceForReference(document, r);</span><br><span class="line">        ds.ChangeTypeId(tilePatterns.GetTilePattern(TilePatternsBuiltIn.OctagonRotate).Id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>图61：应用于分割表面的平铺图案</p>
<p>除了将内置的平铺填充图案应用于分割表面之外，还可以使用“基于幕墙嵌板填充图案的.rft”样板创建自己的体量嵌板族。然后，可以使用DividedSurface.ChangeTypeId（）方法将这些嵌板族载入体量族并应用于分割曲面。</p>
<p>“族”的下列属性特定于幕墙嵌板族：</p>
<ul>
<li>IsCurtainPanelFamily</li>
<li>CurtainPanelHorizontalSpacing -分隔网格的水平间距</li>
<li>CurtainPanelVerticalSpacing -分隔网格的垂直间距</li>
<li>CurtainPanelTilePattern -平铺图案的选择</li>
</ul>
<p>下面的示例演示如何编辑体量嵌板族，然后将其应用于概念体量文档中的形状。若要运行此示例，请首先使用“Curtain Panel Pattern Based.rft”样板创建一个新的族文档。</p>
<p>代码区域14-9：编辑幕墙嵌板族</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Family family = document.OwnerFamily;</span><br><span class="line"><span class="keyword">if</span> (family.IsCurtainPanelFamily == <span class="literal">true</span> &amp;&amp;</span><br><span class="line">    family.CurtainPanelTilePattern == TilePatternsBuiltIn.Rectangle)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// first change spacing of grids in family document</span></span><br><span class="line">    family.CurtainPanelHorizontalSpacing = <span class="number">20</span>;</span><br><span class="line">    family.CurtainPanelVerticalSpacing = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create new points and lines on grid</span></span><br><span class="line">    Autodesk.Revit.ApplicationServices.Application app = document.Application;</span><br><span class="line">    FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">    ICollection collection = collector.OfClass(<span class="keyword">typeof</span>(ReferencePoint)).ToElements();</span><br><span class="line">    <span class="built_in">int</span> ctr = <span class="number">0</span>;</span><br><span class="line">    ReferencePoint rp0 = <span class="literal">null</span>, rp1 = <span class="literal">null</span>, rp2 = <span class="literal">null</span>, rp3 = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">foreach</span> (Autodesk.Revit.DB.Element e <span class="keyword">in</span> collection)</span><br><span class="line">    &#123;</span><br><span class="line">        ReferencePoint rp = e <span class="keyword">as</span> ReferencePoint;</span><br><span class="line">        <span class="keyword">switch</span> (ctr)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                rp0 = rp;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                rp1 = rp;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                rp2 = rp;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                rp3 = rp;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ctr++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ReferencePointArray rpAr = <span class="keyword">new</span> ReferencePointArray();</span><br><span class="line">    rpAr.Append(rp0);</span><br><span class="line">    rpAr.Append(rp2);</span><br><span class="line">    CurveByPoints curve1 = document.FamilyCreate.NewCurveByPoints(rpAr);</span><br><span class="line">    PointLocationOnCurve pointLocationOnCurve25 = <span class="keyword">new</span> PointLocationOnCurve(PointOnCurveMeasurementType.NormalizedCurveParameter, <span class="number">0.25</span>, PointOnCurveMeasureFrom.Beginning);</span><br><span class="line">    PointOnEdge poeA = app.Create.NewPointOnEdge(curve1.GeometryCurve.Reference, pointLocationOnCurve25);</span><br><span class="line">    ReferencePoint rpA = document.FamilyCreate.NewReferencePoint(poeA);</span><br><span class="line">    PointLocationOnCurve pointLocationOnCurve75 = <span class="keyword">new</span> PointLocationOnCurve(PointOnCurveMeasurementType.NormalizedCurveParameter, <span class="number">0.75</span>, PointOnCurveMeasureFrom.Beginning);</span><br><span class="line">    PointOnEdge poeB = app.Create.NewPointOnEdge(curve1.GeometryCurve.Reference, pointLocationOnCurve75);</span><br><span class="line">    ReferencePoint rpB = document.FamilyCreate.NewReferencePoint(poeB);</span><br><span class="line"></span><br><span class="line">    rpAr.Clear();</span><br><span class="line">    rpAr.Append(rp1);</span><br><span class="line">    rpAr.Append(rp3);</span><br><span class="line">    CurveByPoints curve2 = document.FamilyCreate.NewCurveByPoints(rpAr);</span><br><span class="line">    PointOnEdge poeC = app.Create.NewPointOnEdge(curve2.GeometryCurve.Reference, pointLocationOnCurve25);</span><br><span class="line">    ReferencePoint rpC = document.FamilyCreate.NewReferencePoint(poeC);</span><br><span class="line">    PointOnEdge poeD = app.Create.NewPointOnEdge(curve2.GeometryCurve.Reference, pointLocationOnCurve75);</span><br><span class="line">    ReferencePoint rpD = document.FamilyCreate.NewReferencePoint(poeD);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Please open a curtain family document before calling this command.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-8EECE3F0-4C1F-4B31-9133-D3D64676E7FE-low.png"></p>
<p>图62：幕墙嵌板族</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-263500A5-C732-4E47-B9AA-D878AF9E9729-low.png"></p>
<p>图63：指定给分割表面的幕墙嵌板</p>
<h2 id="自适应构件"><a href="#自适应构件" class="headerlink" title="自适应构件"></a>自适应构件</h2><p>自适应组件旨在处理组件需要灵活地适应许多独特的上下文条件的情况。例如，自适应构件可用于通过排列符合用户定义约束的多个构件生成的重复系统中。</p>
<p>下面的代码显示如何将自适应构件族的实例创建到体量族中，并以数学方式设置每个点的位置。</p>
<p>代码区域：创建自适应构件族的实例</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">CreateAdaptiveComponentInstance</span>(<span class="params">Document document, FamilySymbol symbol</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Create a new instance of an adaptive component family</span></span><br><span class="line">            FamilyInstance instance = AdaptiveComponentInstanceUtils.CreateAdaptiveComponentInstance(document, symbol);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Get the placement points of this instance</span></span><br><span class="line">            <span class="keyword">var</span> placePointIds = <span class="keyword">new</span> List&lt;ElementId&gt;();</span><br><span class="line">            placePointIds = AdaptiveComponentInstanceUtils.GetInstancePlacementPointElementRefIds(instance).ToList();</span><br><span class="line">            <span class="built_in">double</span> x = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Set the position of each placement point</span></span><br><span class="line">            <span class="keyword">foreach</span> (ElementId id <span class="keyword">in</span> placePointIds)</span><br><span class="line">            &#123;</span><br><span class="line">                ReferencePoint point = document.GetElement(id) <span class="keyword">as</span> ReferencePoint;</span><br><span class="line">                point.Position = <span class="keyword">new</span> Autodesk.Revit.DB.XYZ(<span class="number">10</span>*x, <span class="number">10</span>*Math.Cos(x), <span class="number">0</span>);</span><br><span class="line">                x += Math.PI / <span class="number">6</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>若要批处理创建自适应组件，可以使用FamilyInstanceCreationData构造函数的重载，该构造函数接受两个参数-FamilySymbol和要初始化自适应实例的XYZ自适应点列表。结合使用Autodesk. Rev. Creation. ItemFactoryBase. NewFamilyInstances 2（）方法（该方法采用FamilyInstanceCreationData对象列表），可以一次添加多个自适应构件。这可能比逐个放置单个自适应组件更有效。</p>
<h2 id="创建-addin清单文件"><a href="#创建-addin清单文件" class="headerlink" title="创建.addin清单文件"></a>创建.addin清单文件</h2><p>HelloWorld.dll文件出现在项目输出目录中。如果要在Revit中调用应用程序，请创建清单文件以将其注册到Revit中。</p>
<p>创建清单文件</p>
<ol>
<li><p>在记事本中创建一个新的文本文件。</p>
</li>
<li><p>增加以下案文：</p>
<p>代码区域30-10：为外部命令创建.addin清单文件</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span> standalone=<span class="string">&quot;no&quot;</span>?&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    HelloWorld</span><br><span class="line">    HelloWorld.HelloWorld</span><br><span class="line">    HelloWorld</span><br><span class="line">    Show Hello World.</span><br><span class="line">    AlwaysVisible</span><br><span class="line">    C:\Samples\HelloWorld\HelloWorld\bin\Debug\HelloWorld.dll</span><br><span class="line">    <span class="number">239B</span>D853<span class="number">-36E4</span><span class="number">-461f</span><span class="number">-9171</span>-C5ACEDA4E723</span><br><span class="line">    ADSK</span><br><span class="line">    Autodesk, Inc, www.autodesk.com</span><br></pre></td></tr></table></figure></li>
</ol>
<p>注意：FullClassName包括在项目属性的“应用程序”选项卡上找到的根命名空间。</p>
<p>将文件保存为HelloWorld.addin并将其放在以下位置：</p>
<ul>
<li>C:\ProgramData\Autodesk\Revit\Addins\2018\</li>
</ul>
<p>有关使用清单文件的更多详细信息，请参阅加载项集成。</p>
<h2 id="注：翻译自Revit-API-Developers-Guide"><a href="#注：翻译自Revit-API-Developers-Guide" class="headerlink" title="注：翻译自Revit API Developers Guide"></a><em><strong>注：</strong></em>翻译自<a href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_html">Revit API Developers Guide</a></h2>]]></content>
      <categories>
        <category>Revit二次开发人员指南</category>
      </categories>
      <tags>
        <tag>Revit</tag>
      </tags>
  </entry>
  <entry>
    <title>16基准和信息元素</title>
    <url>/2024/12/06/Revit%E4%BA%8C%E5%BC%80%E6%8C%87%E5%8D%97/16%E5%9F%BA%E5%87%86%E5%92%8C%E4%BF%A1%E6%81%AF%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<h1 id="基准和信息元素"><a href="#基准和信息元素" class="headerlink" title="基准和信息元素"></a><a href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_Revit_Geometric_Elements_Datum_and_Information_Elements_html">基准和信息元素</a></h1><p>本章介绍Revit中的基准元素和信息元素。</p>
<ul>
<li>基准元素包括标高、轴网和模型线。</li>
<li>信息元素包括阶段、设计选项和EnergyDataSettings。</li>
</ul>
<p>有关Revit图元分类的详细信息，请参见图元要素。</p>
<p>注：如果您需要更多信息，请参阅相关章节：</p>
<ul>
<li>有关荷载基础、荷载工况、荷载组合、荷载性质和荷载用途，请参阅结构工程</li>
<li>对于模型曲线，请参阅草图</li>
<li>对于材质和填充图案，请参阅材质</li>
<li>有关能量数据设置，请参阅能量数据</li>
</ul>
<p>本节中的页面</p>
<ul>
<li>Levels 标高</li>
<li>Grids 轴网</li>
<li>Phase 阶段</li>
<li>Design Options 设计选项</li>
</ul>
<h2 id="标高"><a href="#标高" class="headerlink" title="标高"></a>标高</h2><p>标高是一个有限的水平面，用作以标高为主体的图元（如墙、屋顶、楼板和天花板）的参照。</p>
<p>在Revit Platform API中，Level类派生自DatumPlane类，而DatumPlane类派生自Element类。继承的Name属性用于检索Revit UI中标高编号旁边的用户可见标高名称。若要检索项目中的所有标高，请将ElementClassFilter与Level类一起使用。</p>
<h3 id="高程"><a href="#高程" class="headerlink" title="高程"></a>高程</h3><p>Level类具有以下属性：</p>
<ul>
<li>“高程”特性用于检索或更改高于或低于地平面的高程。</li>
<li>ProjectElevation属性用于检索相对于项目原点的高程，而不考虑高程基准参数值。</li>
<li>“高程基准”值是一个标高类型参数。<ul>
<li>它的内置参数是LEVEL_RELATIVE_BASE_TYPE。</li>
<li>它的类型是整型</li>
<li>0对应于项目，1对应于共享。</li>
</ul>
</li>
</ul>
<p>下面的代码示例阐释如何使用Level类筛选器检索项目中的所有标高。</p>
<p>代码区域15-1：检索所有标高</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Getinfo_Level</span>(<span class="params">Document document</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        StringBuilder levelInformation = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="built_in">int</span> levelNumber = <span class="number">0</span>;</span><br><span class="line">        FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">        ICollection collection = collector.OfClass(<span class="keyword">typeof</span>(Level)).ToElements();</span><br><span class="line">        <span class="keyword">foreach</span> (Element e <span class="keyword">in</span> collection)</span><br><span class="line">        &#123;</span><br><span class="line">                Level level = e <span class="keyword">as</span> Level;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">null</span> != level)</span><br><span class="line">                &#123;</span><br><span class="line">                        <span class="comment">// keep track of number of levels</span></span><br><span class="line">                        levelNumber++;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//get the name of the level</span></span><br><span class="line">                        levelInformation.Append(<span class="string">&quot;\nLevel Name: &quot;</span> + level.Name);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//get the elevation of the level</span></span><br><span class="line">                        levelInformation.Append(<span class="string">&quot;\n\tElevation: &quot;</span> + level.Elevation);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// get the project elevation of the level</span></span><br><span class="line">                        levelInformation.Append(<span class="string">&quot;\n\tProject Elevation: &quot;</span> + level.ProjectElevation);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//number of total levels in current document</span></span><br><span class="line">        levelInformation.Append(<span class="string">&quot;\n\n There are &quot;</span> + levelNumber + <span class="string">&quot; levels in the document!&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//show the level information in the messagebox</span></span><br><span class="line">        TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>,levelInformation.ToString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="创造标高"><a href="#创造标高" class="headerlink" title="创造标高"></a>创造标高</h3><p>使用“标高”命令，可以定义建筑内的垂直高度或楼层，还可以为每个现有楼层或其他建筑参照创建标高。必须在剖面视图或立面视图中添加标高。此外，还可以使用Revit平台API创建新标高。</p>
<p>下面的代码示例阐释如何创建新标高。</p>
<p>代码区域15-2：创建新标高</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function">Level <span class="title">CreateLevel</span>(<span class="params">Autodesk.Revit.DB.Document document</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// The elevation to apply to the new level</span></span><br><span class="line">    <span class="built_in">double</span> elevation = <span class="number">20.0</span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Begin to create a level</span></span><br><span class="line">    Level level = Level.Create(document, elevation);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> == level)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Create a new level failed.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Change the level name</span></span><br><span class="line">    level.Name = <span class="string">&quot;New level&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> level;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：创建新标高后，Revit不会为此标高创建关联的平面视图。如果有必要，您可以自己创建。有关如何创建平面视图的详细信息，请参见平面视图。</p>
<h2 id="轴网"><a href="#轴网" class="headerlink" title="轴网"></a>轴网</h2><p>Grid类表示Autodesk Revit中的一条轴网线。</p>
<p>网格由Grid类表示，Grid类派生自DatumPlane类，DatumPlane类派生自Element类。它包含所有网格属性和方法。继承的Name属性用于检索网格线的内容。</p>
<h3 id="曲线"><a href="#曲线" class="headerlink" title="曲线"></a>曲线</h3><p>Grid类Curve属性获取表示网格线几何图形的对象。</p>
<ul>
<li>如果IsCurved属性返回true，则Curve属性将是Arc类对象。</li>
<li>如果IsCurved属性返回false，则Curve属性将是Line类对象。</li>
</ul>
<p>有关详细信息，请参考几何图形。</p>
<p>下面的代码是一个使用Grid类的简单示例。调用命令后，结果将显示在消息框中。</p>
<p>代码区域15-3：使用Grid类</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetInfo_Grid</span>(<span class="params">Grid grid</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> message = <span class="string">&quot;Grid : &quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Show IsCurved property</span></span><br><span class="line">    message += <span class="string">&quot;\nIf grid is Arc : &quot;</span> + grid.IsCurved;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Show Curve information</span></span><br><span class="line">    Autodesk.Revit.DB.Curve curve = grid.Curve;</span><br><span class="line">    <span class="keyword">if</span> (grid.IsCurved)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// if the curve is an arc, give center and radius information</span></span><br><span class="line">        Autodesk.Revit.DB.Arc arc = curve <span class="keyword">as</span> Autodesk.Revit.DB.Arc;</span><br><span class="line">        message += <span class="string">&quot;\nArc&#x27;s radius: &quot;</span> + arc.Radius;</span><br><span class="line">        message += <span class="string">&quot;\nArc&#x27;s center:  (&quot;</span> + XYZToString(arc.Center);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// if the curve is a line, give length information</span></span><br><span class="line">        Autodesk.Revit.DB.Line line = curve <span class="keyword">as</span> Autodesk.Revit.DB.Line;</span><br><span class="line">        message += <span class="string">&quot;\nLine&#x27;s Length: &quot;</span> + line.Length;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Get curve start point</span></span><br><span class="line">    message += <span class="string">&quot;\nStart point: &quot;</span> + XYZToString(curve.GetEndPoint(<span class="number">0</span>));</span><br><span class="line">    <span class="comment">// Get curve end point</span></span><br><span class="line">    message += <span class="string">&quot;; End point: &quot;</span> + XYZToString(curve.GetEndPoint(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>,message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// output the point&#x27;s three coordinates</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">XYZToString</span>(<span class="params">XYZ point</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;(&quot;</span> + point.X + <span class="string">&quot;, &quot;</span> + point.Y + <span class="string">&quot;, &quot;</span> + point.Z + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="创建轴网"><a href="#创建轴网" class="headerlink" title="创建轴网"></a>创建轴网</h3><p>Grid类中有两个重载的Create（）方法可用于在Revit Platform API中创建新的轴网。使用以下方法和不同的参数，可以创建曲线或直线格线：</p>
<p>代码区域15-4：Grid.Create（）</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Grid <span class="title">Create</span>(<span class="params"> Document document, Arc arc </span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Grid <span class="title">Create</span>(<span class="params"> Document document, Line line </span>)</span>;</span><br></pre></td></tr></table></figure>

<p>注意：用于创建网格的弧或线必须位于水平面内。</p>
<p>下面的代码示例演示如何创建带有直线或圆弧的新轴网。</p>
<p>代码区域15-5：使用直线或圆弧创建网格</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateGrid</span>(<span class="params">Autodesk.Revit.DB.Document document</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Create the geometry line which the grid locates</span></span><br><span class="line">    XYZ start = <span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    XYZ end = <span class="keyword">new</span> XYZ(<span class="number">30</span>, <span class="number">30</span>, <span class="number">0</span>);</span><br><span class="line">    Line geomLine = Line.CreateBound(start, end);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create a grid using the geometry line</span></span><br><span class="line">    Grid lineGrid = Grid.Create(document, geomLine);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> == lineGrid)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Create a new straight grid failed.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Modify the name of the created grid</span></span><br><span class="line">    lineGrid.Name = <span class="string">&quot;New Name1&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create the geometry arc which the grid locates</span></span><br><span class="line">    XYZ end0 = <span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    XYZ end1 = <span class="keyword">new</span> XYZ(<span class="number">10</span>, <span class="number">40</span>, <span class="number">0</span>);</span><br><span class="line">    XYZ pointOnCurve = <span class="keyword">new</span> XYZ(<span class="number">5</span>, <span class="number">7</span>, <span class="number">0</span>);</span><br><span class="line">    Arc geomArc = Arc.Create(end0, end1, pointOnCurve);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create a grid using the geometry arc</span></span><br><span class="line">    Grid arcGrid = Grid.Create(document, geomArc);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> == arcGrid)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Create a new curved grid failed.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Modify the name of the created grid</span></span><br><span class="line">    arcGrid.Name = <span class="string">&quot;New Name2&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：在Revit中，创建轴网时，轴网将自动按数字或字母顺序命名。</p>
<h2 id="阶段"><a href="#阶段" class="headerlink" title="阶段"></a>阶段</h2><p>一些建筑项目，如翻新，分阶段进行。阶段具有以下特征：</p>
<ul>
<li>阶段表示项目生命周期中的不同时间段。</li>
<li>建筑物内图元的寿命由阶段控制。</li>
<li>每个元素都有一个构造阶段，但只有具有有限寿命的元素才有一个破坏阶段。</li>
</ul>
<p>项目中的所有阶段都可以从Document对象中检索。Phase对象包含三个有用的信息：Name、ID和UniqueId。其余属性始终返回null或空集合。</p>
<p>添加到项目中的每个新建模构件都具有“创建的阶段ID”和“拆除的阶段ID”特性。Element.AllowPhases（）方法指示是否可以修改其阶段ID属性。</p>
<p>“创建的阶段ID”特性具有以下特征：</p>
<ul>
<li>它标识添加组件的阶段。</li>
<li>默认值为与当前视图“阶段”值相同的ID。</li>
<li>通过选择与下拉列表相对应的新值来更改“创建的阶段ID”参数。</li>
</ul>
<p>已拆除阶段ID属性具有以下特征：</p>
<ul>
<li>它标识在哪个阶段拆除构件。</li>
<li>默认值为无。</li>
<li>使用拆除工具拆除构件会将特性更新为拆除图元所在视图中的当前阶段ID值。</li>
<li>可以通过将“已拆除的阶段ID”特性设置为其他值来拆除构件。</li>
<li>如果使用Revit Platform API删除某个阶段，则当前阶段中的所有建模构件仍然存在。这些元件的“创建的阶段ID”参数值将更改为“特性”对话框下拉列表中的下一项。 <img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-3840696A-98D6-4898-8004-EFB85A3247E1-low.png" alt="img"></li>
</ul>
<p>图65：阶段创建的组件参数值</p>
<p>下面的代码示例显示当前文档中支持的所有阶段。阶段名称显示在消息框中。</p>
<p>代码区域15-6：展示所有支持的阶段</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Getinfo_Phase</span>(<span class="params">Document doc</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">// Get the phase array which contains all the phases.</span></span><br><span class="line">        PhaseArray phases = doc.Phases;</span><br><span class="line">        <span class="comment">// Format the string which identifies all supported phases in the current document.</span></span><br><span class="line">        String prompt = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> != phases.Size)</span><br><span class="line">        &#123;</span><br><span class="line">                prompt = <span class="string">&quot;All the phases in current document list as follow:&quot;</span>;</span><br><span class="line">                <span class="keyword">foreach</span> (Phase ii <span class="keyword">in</span> phases)</span><br><span class="line">                &#123;</span><br><span class="line">                        prompt += <span class="string">&quot;\n\t&quot;</span> + ii.Name;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">                prompt = <span class="string">&quot;There are no phases in current document.&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Give the user the information.</span></span><br><span class="line">        TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>,prompt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="设计选项"><a href="#设计选项" class="headerlink" title="设计选项"></a>设计选项</h2><p>设计选项提供了一种在项目中探索备选设计的方法。</p>
<p>设计选项提供了适应项目范围变化或开发供审查的替代设计的灵活性。您可以开始使用主项目模型，然后沿着向客户展示的方式开发变体。大多数图元都可以添加到设计选项中。不能添加到设计选项中的图元被视为主模型的一部分，并且没有设计备选方案。</p>
<p>设计选项的主要用途是作为元素类的属性。请参阅以下示例。</p>
<p>代码区域15-7：使用设计选项</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Getinfo_DesignOption</span>(<span class="params">Document document</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Get the selected Elements in the Active Document</span></span><br><span class="line">    UIDocument uidoc = <span class="keyword">new</span> UIDocument(document);</span><br><span class="line">    ICollection selectedIds = uidoc.Selection.GetElementIds();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">foreach</span> (ElementId id <span class="keyword">in</span> selectedIds)</span><br><span class="line">    &#123;</span><br><span class="line">        Element element = document.GetElement(id);</span><br><span class="line">        <span class="comment">//Use the DesignOption property of Element</span></span><br><span class="line">        <span class="keyword">if</span> (element.DesignOption != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>,element.DesignOption.Name.ToString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下规则适用于设计选项</p>
<ul>
<li>如果元素位于主模型中，则DesignOption属性的值为null。否则，将返回在Revit UI中创建的名称。</li>
<li>ActiveDocument中只能存在一个活动DesignOption元素。<ul>
<li>主选项被视为默认的活动DesignOption。例如，一个设计选项集名为“墙”，该设计选项集中有两个设计选项，分别名为“砖墙”和“玻璃墙”。如果“砖墙”是主选项，则元素迭代器只检索此选项和属于它的元素。“玻璃墙”不活跃。</li>
</ul>
</li>
</ul>
<h2 id="注：翻译自Revit-API-Developers-Guide"><a href="#注：翻译自Revit-API-Developers-Guide" class="headerlink" title="注：翻译自Revit API Developers Guide"></a><em><strong>注：</strong></em>翻译自<a href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_html">Revit API Developers Guide</a></h2>]]></content>
      <categories>
        <category>Revit二次开发人员指南</category>
      </categories>
      <tags>
        <tag>Revit</tag>
      </tags>
  </entry>
  <entry>
    <title>13族实例</title>
    <url>/2024/11/23/Revit%E4%BA%8C%E5%BC%80%E6%8C%87%E5%8D%97/13%E6%97%8F%E5%AE%9E%E4%BE%8B/</url>
    <content><![CDATA[<h1 id="族实例"><a href="#族实例" class="headerlink" title="族实例"></a><a href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_Revit_Geometric_Elements_Family_Instances_html">族实例</a></h1><p>在本节中，您将了解以下内容：</p>
<ul>
<li>族与族实例的关系</li>
<li>族和族实例特征</li>
<li>如何载入或创建族和族实例特征</li>
<li>族实例与族符号的关系</li>
</ul>
<p> 本节中的页面</p>
<ul>
<li>Identifying Elements 识别元素</li>
<li>FamilyInstances 族实例</li>
<li>Code Samples 代码示例</li>
<li>FamilySymbol 族符号</li>
<li>Family 族</li>
</ul>
<h2 id="识别元素"><a href="#识别元素" class="headerlink" title="识别元素"></a>识别元素</h2><p>在Revit中，判断元素是否为FamilyInstance的最简单方法是使用属性对话框。</p>
<ul>
<li>如果族名称以“系统族”开头，并且禁用了“载入”按钮，则该族属于“系统族”。</li>
</ul>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-96BC987E-5C38-45EF-9621-2D6EF89989B1-low.png"></p>
<p>图41：系统族</p>
<ul>
<li>属于构件族的常规FamilyInstance不以System Family开头。</li>
<li>例如，在下图中，桌子家具的族名为Desk。此外，还启用了“加载”按钮。</li>
</ul>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-67F1CF63-64EF-40E4-BF92-284873CDDB31-low.png"></p>
<p>图42：组件族</p>
<p>有一些例外，例如：体量和内建成员。“族”和“类型”字段为空。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-A2B06CEE-7E4A-494B-8DE8-7131068F182B-low.png"></p>
<p>图43：体量或内建构件示例</p>
<p>Revit Platform API中的族由三个对象表示：</p>
<ul>
<li>Family </li>
<li>FamilySymbol</li>
<li>FamilyInstance</li>
</ul>
<p>每件对象在族结构中都起着重要的作用。</p>
<p>“族”对象表示整个族，例如单平面门。例如，“单面齐平门族”对应于“单面齐平.rfa”文件。Family对象包含多个FamilySymbols，用于获取所有族符号，以便于将实例从一个符号切换到另一个符号。</p>
<p>FamilySymbol对象表示与Revit UI中的“类型”（例如34”×80”）相对应的一组特定族设置。</p>
<p>FamilyInstance对象表示Revit项目中的实际Type（FamilySymbol）实例。例如，在下图中，FamilyInstance是项目中的一扇门。</p>
<ul>
<li>每个FamilyInstance都有一个FamilySymbol。门是一个34”×80”的实例。</li>
<li>每个FamilySymbol都属于一个Family。34”×80”符号属于单齐平系列。</li>
<li>每个族都包含一个或多个族符号。单齐平系列包含34”×80”符号、34”×84”符号、36”×84”等。</li>
</ul>
<p>注意：虽然大多数组件元素都是通过API类FamilySymbol和FamilyInstance公开的，但也有一些是用特定的API类包装的。例如，AnnotationSymbolType包装FamilySymbol，AnnotationSymbol包装FamilyInstance。</p>
<h2 id="族实例-1"><a href="#族实例-1" class="headerlink" title="族实例"></a>族实例</h2><p>FamilyInstance对象包括梁、支撑、柱、家具、体量等。FamilyInstance对象提供了更详细的属性，以便可以更改项目中的族实例类型和外观。</p>
<h3 id="位置相关属性"><a href="#位置相关属性" class="headerlink" title="位置相关属性"></a>位置相关属性</h3><p>与位置相关的属性显示FamilyInstance对象的物理和几何特征，如方向、旋转和位置。</p>
<h4 id="Orientation-朝向"><a href="#Orientation-朝向" class="headerlink" title="Orientation 朝向"></a>Orientation 朝向</h4><p>对于某些FamilyInstance对象，可以更改面方向或手方向。例如，门可以面向房间或墙壁的外部或内部，并且可以将把手放置在左侧或右侧。下表比较了门、窗和桌子族实例。</p>
<p>表29：比较族实例</p>
<table>
<thead>
<tr>
<th><strong>Boolean Property 布尔属性</strong></th>
<th><strong>Door 门</strong></th>
<th>**Window (Fixed: 36”w × 72”h) **</th>
<th><strong>Desk 书桌</strong></th>
</tr>
</thead>
<tbody><tr>
<td>CanFlipFacing</td>
<td>True</td>
<td>True</td>
<td>False</td>
</tr>
<tr>
<td>CanFlipHand</td>
<td>True</td>
<td>False</td>
<td>False</td>
</tr>
</tbody></table>
<p>如果CanFlipFacing或CanFlipHand为true，则可以分别调用flipFacing（）或flipHand（）方法。这些方法可以分别改变面向方向或手方向。否则，这些方法不执行任何操作并返回False。修改方向时，请记住某些类型的窗可以同时修改手方向和面方向，例如带Trim的3x3平开窗族。门有四种不同的朝向和手方向组合。请参见下图中的组合，下表中列出了相应的布尔值。 </p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-AC8B1DB7-860B-46D3-A0BD-DBF120980580-low.png"></p>
<p>图44：具有不同面方向和手方向的门</p>
<p>表30：相同类型的不同饰面</p>
<table>
<thead>
<tr>
<th><strong>Boolean Property 布尔属性</strong></th>
<th>**Door 1 **</th>
<th>**Door 2 **</th>
<th>**Door 3 **</th>
<th>**Door 4 **</th>
</tr>
</thead>
<tbody><tr>
<td>FacingFlipped</td>
<td>False</td>
<td>True</td>
<td>False</td>
<td>True</td>
</tr>
<tr>
<td>HandFlipped</td>
<td>False</td>
<td>True</td>
<td>True</td>
<td>False</td>
</tr>
</tbody></table>
<h4 id="Orientation-Work-Plane-方位-工作平面"><a href="#Orientation-Work-Plane-方位-工作平面" class="headerlink" title="Orientation - Work Plane 方位-工作平面"></a>Orientation - Work Plane 方位-工作平面</h4><p>也可以更改FamilyInstance的工作平面方向。如果CanFlipWorkPlane为true，则可以设置IsWorkPlaneFlipped属性。尝试为不允许翻转工作平面的FamilyInstance设置此属性将导致异常。</p>
<h4 id="Rotation-Mirrored-旋转-镜像"><a href="#Rotation-Mirrored-旋转-镜像" class="headerlink" title="Rotation - Mirrored 旋转-镜像"></a>Rotation - Mirrored 旋转-镜像</h4><p>镜像属性指示FamilyInstance对象是否已镜像。</p>
<p>表31：门镜像属性</p>
<table>
<thead>
<tr>
<th><strong>Boolean Property 布尔属性</strong></th>
<th>**Door 1 **</th>
<th>**Door 2 **</th>
<th>**Door 3 **</th>
<th>**Door 4 **</th>
</tr>
</thead>
<tbody><tr>
<td>Mirrored</td>
<td>False</td>
<td>False</td>
<td>True</td>
<td>True</td>
</tr>
</tbody></table>
<p>在前面的门示例中，Door 1和Door 2的Mirror属性为False，而Door 3和Door 4的Mirror属性均为True。这是因为在Revit项目中创建门时，默认结果为“门1”或“门2”。要创建类似“门3”或“门4”的门，必须分别翻转“门1”和“门2”的方向。翻转操作类似于镜像变换，这就是为什么“门3”和“门4”镜像属性为True。 有关在Revit中使用Mirror（）方法的详细信息，请参阅“编辑图元”一章。 #### Rotation - CanRotate和rotate（） 族实例布尔CanRotate属性用于测试族实例是否可以旋转180度。这取决于实例所属的族。例如，在下面的图片中，Window 1（Casement 3×3 with Trim：36”×72”）和Door 1（Double-Glass 2：72”×82”）的CanRotate属性为true，而Window 2（Fixed：36“w × 72“h）的CanRotate属性为false。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-8E93FD79-81F8-4B3D-B09F-9C9A4A1A556C-low.png"></p>
<p><strong>图45：旋转后的变化</strong> </p>
<p>如果CanRotate为true，则可以调用族实例rotate（）方法，该方法将族实例翻转180度。否则，该方法不执行任何操作并返回False。上图还显示了执行rotate（）方法后的Window 1和Door 1状态。 回想一下本文档前面的旋转图元部分，可以使用ElementTransformUtils.RotateElement（）和ElementTransformUtils.RotateElements（）将族实例（和其他图元）旋转用户指定的角度。</p>
<p><strong>位置</strong> Location属性确定实例在项目中的物理位置。实例可以具有点位置或线位置。 以下特征适用于位置： </p>
<p><em>点位置是LocationPoint类对象-基础、门或桌子都有点位置</em> </p>
<p>线位置是LocationCurve类对象-梁具有线位置。 * 它们都是Location类的子类。 有关位置的详细信息，请参阅编辑元素。</p>
<p>Host和HostFace Host和HostFace都是FamilyInstance属性。 </p>
<p><strong>Host</strong> FamilyInstance对象有一个返回其宿主元素的Host属性。 某些FamilyInstance对象没有宿主元素，如Tables和其他家具，因此Host属性不返回任何内容，因为没有创建主体元素。但是，其他对象（如门和窗）必须具有宿主图元。在这种情况下，Host属性返回窗或门所在的墙元素。请参见下图。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-837ECA51-19DE-4B19-A304-A5C26F24EBD0-low.png"></p>
<p>图46：以墙为主体的门和窗 </p>
<p><strong>HostFace</strong> HostFace属性获取对族实例的宿主面的参照，或者如果实例放置在工作平面上，则获取对工作平面下面的几何图形面的参照。如果工作平面未参照其他几何图形，或者实例未以面或工作平面为宿主，则此属性将返回空参照。</p>
<p> <strong>子组件和超级组件</strong> FamilyInstance. GetSubmenentIds（）方法返回加载到该族中的族实例的ElementIds。将“Table-Dining Round w Chairs.rfa”的实例放置在项目中时，GetSubmenuentIds（）方法将返回椅子集的ElementIds。 SuperComponent属性返回族实例的父构件。在“Table-Dining Round w Chairs. rfa”中，每个嵌套椅子的族实例超级组件都是“Table-Dining Round w Chairs. rfa”的实例。</p>
<p>代码区域12-1：从FamilyInstance获取子组件和超级组件</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetSubAndSuperComponents</span>(<span class="params">FamilyInstance familyInstance</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ICollection subElemSet = familyInstance.GetSubComponentIds();</span><br><span class="line">    <span class="keyword">if</span> (subElemSet != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> subElems = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">foreach</span> (Autodesk.Revit.DB.ElementId ee <span class="keyword">in</span> subElemSet)</span><br><span class="line">        &#123;</span><br><span class="line">            FamilyInstance f = familyInstance.Document.GetElement(ee) <span class="keyword">as</span> FamilyInstance;</span><br><span class="line">            subElems = subElems + f.Name + <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>,<span class="string">&quot;Subcomponent count = &quot;</span> + subElemSet.Count + <span class="string">&quot;\n&quot;</span> + subElems);</span><br><span class="line">    &#125;</span><br><span class="line">    FamilyInstance super = familyInstance.SuperComponent <span class="keyword">as</span> FamilyInstance;</span><br><span class="line">    <span class="keyword">if</span> (super != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>,<span class="string">&quot;SUPER component: &quot;</span> + super.Name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="几何"><a href="#几何" class="headerlink" title="几何"></a>几何</h3><p>有时，FamilyInstance对象的几何图形会通过连接、剪切、顶盖、延伸或其他在Revit中进行的后期处理进行修改。FamilyInstance.HasModifiedGeometry（）方法标识此FamilyInstance的几何图形是否已从自动生成的默认值修改。GetOriginalGeometry（）方法将返回实例的原始几何体，该几何体在可能发生任何修改之前。若要获取实例的当前几何体，请使用从Element类继承的Geometry属性。</p>
<h3 id="空间元素计算点"><a href="#空间元素计算点" class="headerlink" title="空间元素计算点"></a>空间元素计算点</h3><p>FamilyInstance具有多个成员，用于直接从族实例中阅读有关空间计算点的信息。HasSpatialElementCalculationPoint属性标识此实例是否有一个SpatialElementCalculationPoint用作Revit的搜索点，以标识实例是否位于房间或空间内。如果为true，GetSpatialElementCalculationPoint（）方法将返回此实例的计算点的位置作为XYZ点。</p>
<p>HasSpatialElementFromToCalculationPoints属性标识此实例是否具有一对SpatialElementCalculationPoints，它们用作Revit的搜索点，以标识实例是否位于最多两个房间或空间之间。对于连接两个房间或空间（如门或窗）的族实例，这些点确定哪个房间或空间被视为“从”，哪个被视为“到”。当此属性为true时，GetSpatialElementFromToCalculationPoints（）方法将此实例的计算点的位置作为XYZ点的列表返回。</p>
<h3 id="其它属性"><a href="#其它属性" class="headerlink" title="其它属性"></a>其它属性</h3><p>本部分中的属性特定于Revit的建筑和结构工程功能。它们在各自的章节中都有详细介绍。</p>
<h4 id="房间信息"><a href="#房间信息" class="headerlink" title="房间信息"></a>房间信息</h4><p>FamilyInstance属性包括Room、FromRoom和ToRoom。有关房间的详细信息，请参阅建筑。</p>
<h4 id="空间信息"><a href="#空间信息" class="headerlink" title="空间信息"></a>空间信息</h4><p>FamilyInstance有一个Space属性，用于标识MEP中保存实例的空间。</p>
<h4 id="结构分析模型"><a href="#结构分析模型" class="headerlink" title="结构分析模型"></a>结构分析模型</h4><p>GetAnalyticalModel（）方法检索族实例结构分析模型。</p>
<p>有关分析模型的详细信息，请参阅结构工程。</p>
<h3 id="创建FamilyInstance对象"><a href="#创建FamilyInstance对象" class="headerlink" title="创建FamilyInstance对象"></a>创建FamilyInstance对象</h3><p>通常，FamilyInstance对象是使用Autodesk.Revit.Creation.Document的12种重载方法之一NewFamilyInstance（）创建的。选择使用哪个重载不仅取决于实例的类别，还取决于放置的其他特征，例如是否应将其作为主体、相对于参照标高放置或直接放置在特定面上。详细信息包含在下面的表32 -使用NewFamilyInstance（）创建实例的选项中。</p>
<p>某些FamilyInstance对象需要创建多个位置。在这些情况下，使用此对象提供的更详细的创建方法更合适（请参见表33 -使用其他方法创建实例的选项）。如果未创建实例，则会引发异常。在调用该方法之前，必须将使用的类型&#x2F;符号加载到项目中。</p>
<p>检查NewFamilyInstance（）的所有重载以确保输入FamilySymbol处于活动状态（FamilySymbol.IsActive）。如果输入FamilySymbol处于非活动状态，则该方法将抛出ArgumentException。文档中未使用的符号可能会被停用，以节省内存和再生时间。当符号处于非活动状态时，其几何图形为空，无法访问。为了访问文档中未激活的符号的几何图形，应首先通过调用FamilySymbol.Activate（）来激活该符号。</p>
<p>表32 -使用NewFamilyInstance（）创建实例的选项</p>
<table>
<thead>
<tr>
<th align="left">Category 类别</th>
<th align="left">NewFamilyInstance() parameters NewFamilyInstance（）参数</th>
<th align="left">Comments注解</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Air Terminals Boundary Conditions Casework Communication Devices Data Devices Electrical Equipment Electrical Fixtures Entourage Fire Alarm Devices Furniture Furniture Systems Generic Models Lighting Devices Lighting Fixtures Mass Mechanical Equipment Nurse Call Devices Parking Planting Plumbing Fixtures Security Devices Site Specialty Equipment Sprinklers Structural Connections Structural Foundations Structural Stiffeners Telephone Devices</td>
<td align="left">XYZ, FamilySymbol, StructuralType</td>
<td align="left">在任意位置创建实例，而不参照标高或宿主元素。</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">XYZ, FamilySymbol, Element, StructuralType</td>
<td align="left">如果要在墙壁、地板或天花板上承载</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">XYZ, FamilySymbol, XYZ, Element, StructuralType</td>
<td align="left">如果要以墙、楼板或天花板为主体，并且需要以非默认方向，</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">XYZ, FamilySymbol, Element, Level, StructuralType</td>
<td align="left">如果要以墙、楼板或天花板为宿主并与参照标高关联，</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">XYZ, FamilySymbol, Level, StructuralType</td>
<td align="left">如果要将其关联到参考标高</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">Face, XYZ, XYZ, FamilySymbol XYZ，</td>
<td align="left">如果它是基于面的并且需要以非默认方向，</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">Reference, XYZ, XYZ, FamilySymbol</td>
<td align="left">如果它是基于面的，并且需要以非默认方向，则接受对面的引用，而不是对Face</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">Face, Line, FamilySymbol</td>
<td align="left">如果它是基于面和线的</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">Reference, Line, FamilySymbol</td>
<td align="left">如果它是基于面和线的，但接受对面的引用，而不是面</td>
</tr>
<tr>
<td align="left">Columns Structural Columns</td>
<td align="left">XYZ, FamilySymbol, Level, StructuralType</td>
<td align="left">创建柱，使其底部位于参照标高上。柱将延伸到模型中的下一个可用标高，或者如果参照标高之上没有合适的标高，则将延伸默认柱高。</td>
</tr>
<tr>
<td align="left">Doors Windows</td>
<td align="left">XYZ, FamilySymbol, Element, StructuralType</td>
<td align="left">门和窗必须以墙为宿主。如果可以使用默认方向放置它们，请使用此方法。</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">XYZ, FamilySymbol, XYZ, Element, StructuralType</td>
<td align="left">如果创建的实例需要以非默认方向</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">XYZ, FamilySymbol, Element, Level, StructuralType</td>
<td align="left">如果实例需要关联到参照标高</td>
</tr>
<tr>
<td align="left">Structural Framing (Beams, Braces)</td>
<td align="left">Curve, FamilySymbol, Level, StructuralType</td>
<td align="left">根据其曲线创建基于标高的支撑或梁。这是创建梁和支撑的推荐方法</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">XYZ, FamilySymbol, StructuralType</td>
<td align="left">在任意位置创建实例</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">XYZ, FamilySymbol, Element, Level, StructuralType</td>
<td align="left">如果它位于图元（地板等）上，并与参考标高相关联</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">XYZ, FamilySymbol, Level, StructuralType</td>
<td align="left">如果它与参考标高相关联，</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">XYZ, FamilySymbol, Element, StructuralType</td>
<td align="left">如果它位于图元（地板等）上</td>
</tr>
<tr>
<td align="left">Detail Component</td>
<td align="left">Line, FamilySymbol, View</td>
<td align="left">仅限于基于二维族线的详图符号</td>
</tr>
<tr>
<td align="left">Generic Annotations</td>
<td align="left">XYZ, FamilySymbol, View</td>
<td align="left">仅显示为二维族符号</td>
</tr>
</tbody></table>
<p>结构实例在创建后长度为零。通过使用LocationCurve.Curve属性设置其曲线（FamilyInstance.Location为LocationCurve）来扩展它。</p>
<p>通过使用Document.NewFamilyList（）一次创建多个族实例，可以简化代码并提高性能。此方法有一个参数，该参数是描述要创建的族实例的FamilyInstanceCreationData对象的列表。</p>
<p>代码区域12-2：批量创建族实例</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function">ICollection <span class="title">BatchCreateColumns</span>(<span class="params">Autodesk.Revit.DB.Document document, Level level</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        List fiCreationDatas = <span class="keyword">new</span> List();</span><br><span class="line"></span><br><span class="line">        ICollection elementSet = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Try to get a FamilySymbol</span></span><br><span class="line">        FamilySymbol familySymbol = <span class="literal">null</span>;</span><br><span class="line">        FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">        ICollection collection = collector.OfClass(<span class="keyword">typeof</span>(FamilySymbol)).ToElements();</span><br><span class="line">        <span class="keyword">foreach</span> (Element e <span class="keyword">in</span> collection)</span><br><span class="line">        &#123;</span><br><span class="line">                familySymbol = e <span class="keyword">as</span> FamilySymbol;</span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">null</span> != familySymbol.Category)</span><br><span class="line">                &#123;</span><br><span class="line">                        <span class="keyword">if</span> (<span class="string">&quot;Structural Columns&quot;</span> == familySymbol.Category.Name)</span><br><span class="line">                        &#123;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != familySymbol)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="comment">//Create 10 FamilyInstanceCreationData items for batch creation </span></span><br><span class="line">                <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt; <span class="number">11</span>; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                        XYZ location = <span class="keyword">new</span> XYZ(i * <span class="number">10</span>, <span class="number">100</span>, <span class="number">0</span>);</span><br><span class="line">                        FamilyInstanceCreationData fiCreationData = <span class="keyword">new</span> FamilyInstanceCreationData(location, familySymbol, level, </span><br><span class="line">                                        StructuralType.Column);</span><br><span class="line">                        <span class="keyword">if</span> (<span class="literal">null</span> != fiCreationData)</span><br><span class="line">                        &#123;</span><br><span class="line">                                fiCreationDatas.Add(fiCreationData);</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (fiCreationDatas.Count &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                        <span class="comment">// Create Columns</span></span><br><span class="line">            elementSet = document.Create.NewFamilyInstances2(fiCreationDatas);</span><br><span class="line">        &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Batch creation failed.&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;No column types found.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> elementSet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>某些族类型的实例最好通过Autodesk.Revit.Creation.Document.NewFamilyInstance（）以外的方法创建。这些列于下表。</p>
<p>表33 -使用其他方法创建实例的选项</p>
<table>
<thead>
<tr>
<th><strong>Category 类别</strong></th>
<th><strong>Creation method 创建方法</strong></th>
<th><strong>Comments</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Air Terminal Tags Area Load Tags Area Tags Casework Tags Ceiling Tags Communication Device Tags Curtain Panel Tags Data Device Tags Detail Item Tags Door Tags Duct Accessory Tags Duct Fitting Tags Duct Tags Electrical Equipment Tags Electrical Fixture Tags Fire Alarm Device Tags Flex Duct Tags Flex Pipe Tags Floor Tags Furniture System Tags Furniture Tags Generic Model Tags Internal Area Load Tags Internal Line Load Tags Internal Point Load Tags Keynote Tags Lighting Device Tags Lighting Fixture Tags Line Load Tags Mass Floor Tags Mass Tags Mechanical Equipment Tags Nurse Call Device Tags Parking Tags Pipe Accessory Tags Pipe Fitting Tags Pipe Tags Planting Tags Plumbing Fixture Tags Point Load Tags Property Line Segment Tags Property Tags Railing Tags Revision Cloud Tags Roof Tags Room Tags Security Device Tags Site Tags Space Tags Specialty Equipment Tags Spinkler Tags Stair Tags Structural Area Reinforcement Tags Structural Beam System Tags Structural Column Tags Structural Connection Tags Structural Foundation Tags Structural Framing Tags Structural Path Reinforcement Tags Structural Rebar Tags Structural Stiffener Tags Structural Truss Tags Telephone Device Tags Wall Tags Window Tags Wire Tag Zone Tags on Tags Structural Foundation Tags Structural Framing Tags Structural Path Reinforcement Tags Structural Rebar Tags Structural Truss Tags Telephone Device Tags Wall Tags Window Tags Wire Tag Zone</td>
<td>IndependentTag.Create(Document, ElementId, Reference, Boolean, TagMode, TagOrientation, XYZ)</td>
<td>TagMode should be TM_ADDBY_CATEGORY and there should be a related tag loaded when try to create a tag，otherwise exception will be thrown（当尝试创建一个标记时，应该有一个相关的标签载入家庭）</td>
</tr>
<tr>
<td>Material Tags</td>
<td>IndependentTag.Create(Document, ElementId, Reference, Boolean, TagMode, TagOrientation, XYZ)</td>
<td>TagMode应为TM_ADDBY_MATERIAL，并且应加载材质标签族，否则将引发异常</td>
</tr>
<tr>
<td>Multi-Category Tags</td>
<td>IndependentTag.Create(Document, ElementId, Reference, Boolean, TagMode, TagOrientation, XYZ)</td>
<td>TagMode应为TM_ADDBY_MULTICATEGORY，并且应加载多类别标记族，否则将抛出异常</td>
</tr>
<tr>
<td>Title Blocks</td>
<td>ViewSheet.Create(Document, ElementId)</td>
<td>标题栏将添加到新创建的图纸中。</td>
</tr>
</tbody></table>
<p>使用Document.LoadFamily（）或Document.LoadFamilySymbol（）方法加载族和族符号。某些族（如梁）具有多个端点，插入方式与插入单个点实例的方式相同。插入线性族实例后，可以使用Element.Location属性更改其端点。有关详细信息，请参阅代码示例。</p>
<h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p>用于使用Family Data的代码示例。</p>
<p>有关使用Family Object的详细信息，请查看以下代码示例。请注意，在NewFamilyInstance（）方法中，需要StructuralType参数来指定要创建的族实例的类型。以下是一些示例：</p>
<p>表34：NewFamilyInstance（）方法中StructuralType参数的值</p>
<table>
<thead>
<tr>
<th><strong>Type of Family Instance 族实例的类型</strong></th>
<th><strong>Value of StructuralType StructuralType的值</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Doors, tables, etc. 门、桌子等</td>
<td>NonStructural 非结构</td>
</tr>
<tr>
<td>Beams 梁</td>
<td>Beam 梁</td>
</tr>
<tr>
<td>Braces 支撑</td>
<td>Brace 支撑</td>
</tr>
<tr>
<td>Columns 柱</td>
<td>Column 柱</td>
</tr>
<tr>
<td>Footings 基础</td>
<td>Footing 基础</td>
</tr>
</tbody></table>
<h3 id="创建桌"><a href="#创建桌" class="headerlink" title="创建桌"></a>创建桌</h3><p>以下函数演示了如何将表族加载到Revit项目中，以及如何从该族中的所有符号创建实例。</p>
<p>如果指定的族以前已加载，则LoadFamily（）方法返回false。因此，在以下情况下，在调用此函数之前，不加载族Table-Dining Round w Chairs.rfa。在本例中，默认情况下，桌是在标高1创建的。</p>
<p>代码区域12-3：创建桌</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateTables</span>(<span class="params">Autodesk.Revit.DB.Document document</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    String fileName = <span class="string">@&quot;C:\ProgramData\Autodesk\RVT 2014\Libraries\US Imperial\Furniture\Tables\Table-Dining Round w Chairs.rfa&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// try to load family</span></span><br><span class="line">    Family family = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (!document.LoadFamily(fileName, <span class="keyword">out</span> family))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Unable to load &quot;</span> + fileName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Loop through table symbols and add a new table for each</span></span><br><span class="line">    ISet familySymbolIds = family.GetFamilySymbolIds();</span><br><span class="line">    <span class="built_in">double</span> x = <span class="number">0.0</span>, y = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">foreach</span> (ElementId id <span class="keyword">in</span> familySymbolIds)</span><br><span class="line">    &#123;</span><br><span class="line">        FamilySymbol symbol = family.Document.GetElement(id) <span class="keyword">as</span> FamilySymbol;</span><br><span class="line">        symbol.Activate();</span><br><span class="line">        XYZ location = <span class="keyword">new</span> XYZ(x, y, <span class="number">10.0</span>);</span><br><span class="line"></span><br><span class="line">        FamilyInstance instance = document.Create.NewFamilyInstance(location, symbol, StructuralType.NonStructural);</span><br><span class="line">        x += <span class="number">10.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>加载桌族并放置每个FamilySymbol的一个实例的结果：</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-5FE17FC0-A248-47AE-A08A-1BBA3156193B-low.png"></p>
<p>图47：在Revit项目中加载族并创建表格 </p>
<h3 id="创建Beam"><a href="#创建Beam" class="headerlink" title="创建Beam"></a>创建Beam</h3><p> 在此示例中，加载的是族符号而不是族，因为加载单个FamilySymbol比加载包含许多FamilySymbol的族要快。</p>
<p>代码区域12-4：创建梁</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function">FamilyInstance <span class="title">CreateBeam</span>(<span class="params">Autodesk.Revit.DB.Document document, View view</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get the given view&#x27;s level for beam creation</span></span><br><span class="line">    Level level = document.GetElement(view.LevelId) <span class="keyword">as</span> Level;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get a family symbol</span></span><br><span class="line">    FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">    collector.OfClass(<span class="keyword">typeof</span>(FamilySymbol)).OfCategory(BuiltInCategory.OST_StructuralFraming);</span><br><span class="line"></span><br><span class="line">    FamilySymbol gotSymbol = collector.FirstElement() <span class="keyword">as</span> FamilySymbol;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create new beam 10&#x27; long starting at origin</span></span><br><span class="line">    XYZ startPoint = <span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    XYZ endPoint = <span class="keyword">new</span> Autodesk.Revit.DB.XYZ(<span class="number">10</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    Autodesk.Revit.DB.Curve beamLine = Line.CreateBound(startPoint, endPoint);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create a new beam</span></span><br><span class="line">    FamilyInstance instance = document.Create.NewFamilyInstance(beamLine, gotSymbol,</span><br><span class="line">                                                                level, StructuralType.Beam);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="创建门"><a href="#创建门" class="headerlink" title="创建门"></a>创建门</h3><p>创建一个长约180’的长墙，并在运行此示例之前选择它。宿主对象必须支持插入实例;否则NewFamilyInstance（）方法将失败。如果没有为必须在宿主中创建的实例提供宿主元素，或者无法将实例插入到指定的宿主元素中，则方法NewFamilyInstance（）不执行任何操作。</p>
<p>代码区域12-5：创建门</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateDoorsInWall</span>(<span class="params">Autodesk.Revit.DB.Document document, Wall wall</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// get wall&#x27;s level for door creation</span></span><br><span class="line">    Level level = document.GetElement(wall.LevelId) <span class="keyword">as</span> Level;</span><br><span class="line"></span><br><span class="line">    FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">    ICollection collection = collector.OfClass(<span class="keyword">typeof</span>(FamilySymbol))</span><br><span class="line">                                                .OfCategory(BuiltInCategory.OST_Doors)</span><br><span class="line">                                                .ToElements();</span><br><span class="line">    IEnumerator symbolItor = collection.GetEnumerator();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">double</span> x = <span class="number">0</span>, y = <span class="number">0</span>, z = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (symbolItor.MoveNext())</span><br><span class="line">    &#123;</span><br><span class="line">        FamilySymbol symbol = symbolItor.Current <span class="keyword">as</span> FamilySymbol;</span><br><span class="line">        symbol.Activate();</span><br><span class="line">        XYZ location = <span class="keyword">new</span> XYZ(x, y, z);</span><br><span class="line">        FamilyInstance instance = document.Create.NewFamilyInstance(location, symbol, wall, level, StructuralType.NonStructural);</span><br><span class="line">        x += <span class="number">10</span>;</span><br><span class="line">        y += <span class="number">10</span>;</span><br><span class="line">        z += <span class="number">1.5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下图显示了在Revit中执行上述代码的结果。请注意，如果指定的位置不在指定的标高上，NewFamilyInstance（）方法将使用位置标高而不是标高。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-3175405A-CD58-4A39-8DC8-696E76652DBB-low.png"></p>
<p>图48：将门插入墙壁</p>
<h3 id="使用参考方向创建族实例"><a href="#使用参考方向创建族实例" class="headerlink" title="使用参考方向创建族实例"></a>使用参考方向创建族实例</h3><p>使用参照方向可在特定方向上插入项目。</p>
<p>代码区域12-6：使用参考方向创建族实例</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Get a floor to place the beds</span></span><br><span class="line">FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">Floor floor = collector.OfClass(<span class="keyword">typeof</span>(Floor)).FirstElement() <span class="keyword">as</span> Floor;</span><br><span class="line"><span class="keyword">if</span> (floor != <span class="literal">null</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Find a Bed-Box family</span></span><br><span class="line">    Family family = <span class="literal">null</span>;</span><br><span class="line">    FilteredElementCollector famCollector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">    famCollector.OfClass(<span class="keyword">typeof</span>(Family));</span><br><span class="line">    ICollection collection = famCollector.ToElements();</span><br><span class="line">    <span class="keyword">foreach</span> (Element element <span class="keyword">in</span> collection)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (element.Name.CompareTo(<span class="string">&quot;双人床 - 箱式&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            family = element <span class="keyword">as</span> Family;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (family != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Enumerate the beds in the Bed-Box family</span></span><br><span class="line">        FilteredElementCollector fsCollector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">        ICollection fsCollection = fsCollector.WherePasses(<span class="keyword">new</span> FamilySymbolFilter(family.Id)).ToElements();</span><br><span class="line">        IEnumerator symbolItor = fsCollection.GetEnumerator();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (symbolItor.MoveNext())</span><br><span class="line">        &#123;</span><br><span class="line">            FamilySymbol symbol = symbolItor.Current <span class="keyword">as</span> FamilySymbol;</span><br><span class="line">            symbol.Activate();</span><br><span class="line">            XYZ location = <span class="keyword">new</span> XYZ(x, y, <span class="number">0</span>);</span><br><span class="line">            XYZ direction = <span class="keyword">new</span> XYZ();</span><br><span class="line">            <span class="keyword">switch</span> (i % <span class="number">3</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                    direction = <span class="keyword">new</span> XYZ(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                    direction = <span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                    direction = <span class="keyword">new</span> XYZ(<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            FamilyInstance instance = document.Create.NewFamilyInstance(location, symbol, direction, floor, StructuralType.NonStructural);</span><br><span class="line">            x += <span class="number">10</span>;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上一个代码的结果显示在下图中：</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-86B0A1C3-988D-4C4B-BA8E-3C8C9BDEAAE0-low.png"></p>
<p>图49：使用不同的参照方向创建族实例</p>
<h2 id="族符号"><a href="#族符号" class="headerlink" title="族符号"></a>族符号</h2><p>FamilySymbol类表示族中的单个类型。</p>
<p>每个族可以包含一个或多个族符号。每个FamilyInstance都有一个关联的FamilySymbol，可以从其Symbol属性访问。</p>
<h3 id="热属性"><a href="#热属性" class="headerlink" title="热属性"></a>热属性</h3><p>某些类型的族（门、窗和幕墙嵌板）包含下面窗的“类型属性”窗口中所示的热属性。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/FamilyThermalProperties2-76173.jpg"></p>
<p>FamilySymbol的热属性由FamilyThermalProperties类表示，并使用FamilySymbol.GetThermalProperties（）方法检索。可以使用SetThermalProperties（）设置FamilySymbol的FamilyThermalProperties。FamilyThermalProperties类本身的属性是只读的。</p>
<p>计算值的单位如下表所示。</p>
<table>
<thead>
<tr>
<th><strong>Property 属性</strong></th>
<th><strong>Unit 单位</strong></th>
</tr>
</thead>
<tbody><tr>
<td>HeatTransferCoefficient 传热系数</td>
<td>watts per meter-squared kelvin (W&#x2F;(m^2<em>K)</em></td>
</tr>
<tr>
<td>ThermalResistance 热阻</td>
<td>meter-squared kelvin per watt ((m^2K)&#x2F;Watt)</td>
</tr>
</tbody></table>
<p>AnalyticConstructionTypeId属性是构造gbXML类型，并返回与Constructions.xml中constructionType节点的“id”属性对应的值。静态FamilyThermalProperties.Find（）方法将通过Constructions.xml中constructionType节点的“id”属性查找FamilyThermalProperties。</p>
<p> #FamilyType参数 </p>
<p>FamilySymbol的某些参数可以是FamilyType参数。对于这些参数，可以使用Family.GetFamilyTypeParameterValues（）方法获取参数的所有适用值。返回的值是与给定参数的定义所指定的类别相匹配的所有族类型的ElementId。这些元素属于类ElementType或NestedFamilyTypeReference。第二种变体适用于嵌套在族中的类型，因此无法以其他方式访问。NestedFamilyTypeReference元素仅存储有关嵌套FamilyType的基本信息，例如Type的名称、Family的名称和Category。这些元素非常低级，因此被标准元素过滤器绕过，因此获取它们的主要方法是通过Family.GetFamilyTypeParameterValues（）方法。 以下示例演示如何获取FamilySymbol的FamilyType参数的所有族类型参数值。然后将参数的值更改为另一个值。此更改将影响使用加载的FamilySymbol的所有FamilySymbol。</p>
<p>代码区域：获取嵌套的FamilyTypes</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetNestedFamilyTypes</span>(<span class="params">FamilyInstance instance</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// find one FamilyType parameter and all values applicable to it</span></span><br><span class="line"></span><br><span class="line">    Parameter aTypeParam = <span class="literal">null</span>;</span><br><span class="line">    ISet values = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    Family family = instance.Symbol.Family;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">foreach</span> (Parameter param <span class="keyword">in</span> instance.Symbol.Parameters)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (param.Definition.ParameterType == ParameterType.FamilyType)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            aTypeParam = param;</span><br><span class="line"></span><br><span class="line">            values = family.GetFamilyTypeParameterValues(param.Id);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (aTypeParam == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        TaskDialog.Show(<span class="string">&quot;Warning&quot;</span>, <span class="string">&quot;The selected family has no FamilyType parameter defined.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (values == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        TaskDialog.Show(<span class="string">&quot;Error&quot;</span>, <span class="string">&quot;A FamilyType parameter does not have any applicable values!?&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        ElementId newValue = values.Last();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (newValue != aTypeParam.AsElementId())</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">using</span> (Transaction trans = <span class="keyword">new</span> Transaction(instance.Document, <span class="string">&quot;Setting parameter value&quot;</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                trans.Start();</span><br><span class="line">                aTypeParam.Set(newValue);</span><br><span class="line">                trans.Commit();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="族"><a href="#族" class="headerlink" title="族"></a>族</h2><p>“族”类表示整个Revit族。它包含FamilySymbols使用的FamilySymbols。</p>
<h3 id="载入族"><a href="#载入族" class="headerlink" title="载入族"></a>载入族</h3><p>Document类包含LoadFamily（）和LoadFamilySymbol（）方法。</p>
<ul>
<li>LoadFamily（）将整个族及其所有类型或符号加载到项目中。</li>
<li>LoadFamilySymbol（）仅将指定的族符号从族文件载入到项目中。</li>
</ul>
<p><strong>注意：</strong>要提高应用程序的性能并减少内存使用，请尽可能加载特定的FamilySymbol，而不是整个Family对象。</p>
<ul>
<li>使用Options.Application对象GetLibraryPaths（）方法检索族文件路径。</li>
<li>Options.Application对象是使用Application对象的Options属性检索的。</li>
<li>在LoadFamilySymbol（）中，输入参数Name与FamilySymbol对象Name属性返回的字符串值相同。</li>
</ul>
<p>有关详细信息，请参阅代码示例。</p>
<p>类别</p>
<p>FamilyCategory属性指示族的类别，例如柱、家具、结构框架或窗。</p>
]]></content>
      <categories>
        <category>Revit二次开发人员指南</category>
      </categories>
      <tags>
        <tag>Revit</tag>
      </tags>
  </entry>
  <entry>
    <title>10视图</title>
    <url>/2024/12/05/Revit%E4%BA%8C%E5%BC%80%E6%8C%87%E5%8D%97/10%E8%A7%86%E5%9B%BE/</url>
    <content><![CDATA[<h1 id="视图"><a href="#视图" class="headerlink" title="视图"></a><a href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_Basic_Interaction_with_Revit_Elements_Views_html">视图</a></h1><p>视图是从 Revit 模型生成的图像，具有对文档中存储的数据的特权访问权限。它们可以是图形 （如计划） 或文本 （如计划）。每个项目文档都有一个或多个不同的视图。最后一个聚焦窗口是活动视图。</p>
<p>Autodesk.Revit.DB.View 类是 Revit 文档中所有视图类型的基类。Autodesk.Revit.UI.UIView 类表示 Revit 用户界面中的窗口视图。</p>
<p>在以下部分中，您将了解如何生成视图、Revit 支持的视图类型、每个视图的功能以及用户界面中视图窗口的可用功能。</p>
<p>Pages in this section 此部分中的页面</p>
<ul>
<li>About views 关于视图</li>
<li>View Graphics 视图图形</li>
<li>View Types 视图类型</li>
<li>Revisions 修改</li>
<li>View Filters 视图筛选器</li>
<li>View Cropping 视图裁剪</li>
<li>Displaced Views 置换视图</li>
<li>UIView</li>
</ul>
<h2 id="关于视图"><a href="#关于视图" class="headerlink" title="关于视图"></a>关于视图</h2><p>Revit API 提供对视图属性的访问，以及以编程方式创建和删除视图的功能。</p>
<p>本节是一个高级概述，其中包括以下内容：</p>
<ul>
<li>视图是如何生成的</li>
<li>视图类型</li>
<li>查看导航工具</li>
<li>创建和删除视图。</li>
</ul>
<h3 id="视图的生成"><a href="#视图的生成" class="headerlink" title="视图的生成"></a>视图的生成</h3><p>下图说明了视图是如何生成的。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-EBFC1A8B-6618-4D25-BAEF-AD97A02830F5-low.png"></p>
<p>图 94： 创建视图过程</p>
<p>每个视图都是通过将三维对象投影到二维投影平面上来生成的。投影分为两个基本类：</p>
<ul>
<li>Perspective 透视</li>
<li>Parallel 平行</li>
</ul>
<p>确定投影类型后，必须指定需要 3D 模型和渲染场景的条件。有关投影的更多信息，请参阅 View3D 部分。</p>
<p>世界坐标包括以下内容：</p>
<ul>
<li>观看者的眼睛位置</li>
<li>显示投影的视图平面位置。</li>
</ul>
<p>Revit 使用两个坐标系：</p>
<ul>
<li>建筑所在的全局空间或模型空间坐标</li>
<li>视图坐标系。</li>
</ul>
<p>视图坐标系表示模型在观察者视图中的呈现方式。它的原点是查看者的眼睛位置，其在模型空间中的坐标由View.Origin属性检索。X、Y和Z轴分别由View.RightDirection、View.UpDirection和View.ViewDirection属性表示。</p>
<ul>
<li>View.RightDirection 朝向屏幕右侧。</li>
<li>View.UpDirection 朝向屏幕的上方。</li>
<li>View.ViewDirection 从屏幕到观察者的方向。</li>
</ul>
<p>视图坐标系是右手坐标系。有关详细信息，请参见View3D和View3D中的平行投影图片。</p>
<p>在投影到投影平面上之前，将排除3D模型空间中不显示的某些部分，例如位于查看器后面或距离太远而无法清晰显示的部分。此操作需要裁剪视图。以下规则适用于裁剪：</p>
<ul>
<li>Elements outside of the crop region are no longer in the view.<br>裁剪区域之外的图元将不再位于视图中。</li>
<li>View.GetCropRegionShapeManager方法返回ViewCropRegionShapeManager，它提供裁剪区域的边界信息，裁剪区域可以是矩形，也可以不是矩形。</li>
<li>View.CropBoxVisible属性确定裁剪框在视图中是否可见。</li>
<li>View.CropBoxActive属性确定裁剪框是否实际用于裁剪视图。</li>
</ul>
<p>裁剪后，模型将投影到投影平面上。以下规则适用于投影：</p>
<ul>
<li>投影内容映射到屏幕视图端口进行显示。</li>
<li>在映射过程中，投影内容会被缩放，以便在屏幕上正确显示。</li>
<li>View.Scale属性是实际模型大小与视图大小的比率。</li>
<li>图纸上的视图边界是裁剪区域，它是裁剪形状在投影平面上的投影。</li>
<li>裁剪区域的大小和位置由View.Outline属性确定。</li>
</ul>
<h3 id="视图导航工具"><a href="#视图导航工具" class="headerlink" title="视图导航工具"></a>视图导航工具</h3><p>您可以访问有关当前在View Cube设置中设置的主视图摄影机的信息。文档只能设置一个主视图摄像机。这对应于用户调用ViewCube UI命令以在ViewCube右键单击关联菜单中“将当前视图设置为主视图”时保存的视图方向和其他摄影机参数。</p>
<p>通过调用静态方法ViewNavigationToolSettings.GetViewNavigationToolSettings（）访问ViewNavigationToolSettings，该方法将返回与文档关联的ViewNavigationToolSettings元素。</p>
<p>ViewNavigationToolSettings将允许您查询是否已使用IsHomeCameraSet（）方法设置主视图，该方法返回指示主视图设置的当前状态的布尔值。</p>
<p>通过使用ViewNavigationToolSettings.GetHomeCamera（）方法获取主摄影机的副本，可以访问有关在ViewCube中设置的主摄影机的只读信息。如果HomeCamera尚未设置，则此函数返回“否”。HomeCamera类提供有关相机和模型中存储的主视图方向（如EyePosition和UpDirection）的视图的信息。</p>
<h3 id="创建和删除视图"><a href="#创建和删除视图" class="headerlink" title="创建和删除视图"></a>创建和删除视图</h3><p>Revit Platform API提供了多种方法来创建从Autodesk.Revit.DB.View类派生的相应视图图元。大多数视图类型都是使用派生视图类的静态方法创建的。如果视图创建成功，这些方法返回对视图的引用，否则返回null。在下面的部分中，将针对每个视图类描述这些方法。</p>
<p>也可以使用View.Duplicate（）方法创建视图。可以从现有视图创建新视图，并可以选择新视图是从属视图还是具有详图。以下示例演示如何创建新的依赖视图。</p>
<p>代码区域：创建依赖视图</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> View <span class="title">CreateDependentCopy</span>(<span class="params">View view</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    View dependentView = <span class="literal">null</span>;</span><br><span class="line">    ElementId newViewId = ElementId.InvalidElementId;</span><br><span class="line">    <span class="keyword">if</span> (view.CanViewBeDuplicated(ViewDuplicateOption.AsDependent))</span><br><span class="line">    &#123;</span><br><span class="line">        newViewId = view.Duplicate(ViewDuplicateOption.AsDependent);</span><br><span class="line">        dependentView = view.Document.GetElement(newViewId) <span class="keyword">as</span> View;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != dependentView)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (dependentView.GetPrimaryViewId() == view.Id)</span><br><span class="line">            &#123;</span><br><span class="line">                TaskDialog.Show(<span class="string">&quot;Dependent View&quot;</span>, <span class="string">&quot;Dependent view created successfully!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dependentView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用Document.Delete（）方法和视图ID删除视图。您还可以删除与视图关联的元素。例如，删除标高图元会导致Revit删除相应的平面视图，或删除相机图元会导致Revit删除相应的三维视图。</p>
<p>依赖视图 如上所述，可以使用View.Duplicate（）方法并传入ViewDuplicationOption枚举器的AsDependent值来创建依赖视图。从属视图将与主视图和所有其他从属视图保持同步，以便在一个视图中进行视图特定更改（如视图比例和注释）时，这些更改将反映在所有视图中。并非所有视图类型都可以复制，并且不能从另一个从属视图创建从属视图。使用View.CanViewBeDuplicated（）确保可以从视图生成依赖视图。此方法采用ViewDuplicationOption枚举来检查是否可以以特定方式复制视图。可以将视图复制为独立视图，但不能复制为从属视图。 从属视图具有有效的主视图元素ID，可以从方法View.GetPrimaryViewId（）获得该ID。独立视图的主视图ID为InvalidElementId。可以使用View.ConvertToIndependent（）方法将依赖视图转换为独立视图。如果视图不是依赖的，这个方法将抛出一个异常。</p>
<p>代码区域：使依赖视图独立</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">MakeViewIndependent</span>(<span class="params">View view</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Independent views will have an InvalidElementId for the Primary View Id</span></span><br><span class="line">    <span class="keyword">if</span> (view.GetPrimaryViewId() != ElementId.InvalidElementId)</span><br><span class="line">    &#123;</span><br><span class="line">        view.ConvertToIndependent();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="视图图形"><a href="#视图图形" class="headerlink" title="视图图形"></a>视图图形</h2><p>视图的许多图形元素和显示选项都是通过API公开的。</p>
<p>视图类具有用于获取和设置显示样式设置和详细程度设置的属性。View. DisplayStyle属性使用DisplayStyle枚举，并与Revit窗口底部可用的显示选项相对应，如下所示。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/DisplayStyles.jpg"></p>
<p>注意：不能从Revit AP将显示样式设置为光线跟踪，因为此显示样式会将Revit置于功能有限的受限模式。View. DetailLevel属性使用ViewDetailLevel枚举，并对应于Revit窗口底部可用的详细程度选项，如下所示。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/DetailLevel.jpg"></p>
<p>ViewDetailLevel枚举在给定View不使用详细级别的情况下包含Undefined。</p>
<h3 id="Thin-Lines-细线"><a href="#Thin-Lines-细线" class="headerlink" title="Thin Lines 细线"></a>Thin Lines 细线</h3><p>“细线”选项（在Revit UI的“视图”选项卡的“图形”面板上可用）控制如何在视图中绘制线。通常，在小比例视图中放大模型时，元素线看起来比实际粗得多。启用“细线”时，无论缩放级别如何，所有线条都将绘制为单一宽度。此选项通过ThinLinesOptions实用程序类提供，该类具有一个名为AreThinLinesEnabled的属性。它是影响整个Revit任务的静态属性。</p>
<h3 id="临时视图模式"><a href="#临时视图模式" class="headerlink" title="临时视图模式"></a>临时视图模式</h3><p>TemporaryViewModes类允许控制临时视图模式。可以从View.TemporaryViewModes属性访问它。对于不支持临时视图模式的视图，此属性将为空。RevealConstraints、RevealHiddenElements和WorksharingDisplay属性可用于获取和设置相应视图中这些模式的当前状态。请注意，某些模式仅在某些视图和&#x2F;或特定上下文中可用。另外，在当前上下文中不一定启用可用模式。TemporaryViewModes方法IsModeAvailable（）和IsModeEnabled（）可用于测试特定模式在使用前是否可用和启用。这些方法采用TemporaryViewMode枚举。可能的选项如下所示。</p>
<table>
<thead>
<tr>
<th><strong>Member Name 成员名称</strong></th>
<th><strong>Description 描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>RevealHiddenElements</td>
<td>显示隐藏元素模式</td>
</tr>
<tr>
<td>TemporaryHideIsolate</td>
<td>临时隐藏&#x2F;隔离模式</td>
</tr>
<tr>
<td>WorksharingDisplay</td>
<td>工作共享显示模式</td>
</tr>
<tr>
<td>TemporaryViewProperties</td>
<td>临时视图属性模式</td>
</tr>
<tr>
<td>Raytrace</td>
<td>在交互式光线跟踪中显示模型的模式</td>
</tr>
<tr>
<td>ExplodedView</td>
<td>以分解视图显示模型并允许用户更改&#x2F;配置的模式</td>
</tr>
<tr>
<td>RevealConstraints</td>
<td>显示模型中元素之间约束的模式</td>
</tr>
</tbody></table>
<p>代码区域：显示视图中的隐藏元素</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">RevealHiddenElementsInView</span>(<span class="params">View view</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">bool</span> hiddenRevealed = <span class="literal">false</span>;</span><br><span class="line">    TemporaryViewModes viewModes = view.TemporaryViewModes;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (viewModes == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        TaskDialog.Show(<span class="string">&quot;Invalid View&quot;</span>, <span class="string">&quot;This view does not support temporary view modes.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Mode must be available and enabled to be activated</span></span><br><span class="line">        <span class="keyword">if</span> (viewModes.IsModeEnabled(TemporaryViewMode.RevealHiddenElements) &amp;&amp; viewModes.IsModeAvailable(TemporaryViewMode.RevealHiddenElements))</span><br><span class="line">        &#123;</span><br><span class="line">            viewModes.RevealHiddenElements = <span class="literal">true</span>;</span><br><span class="line">            hiddenRevealed = viewModes.RevealHiddenElements;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> hiddenRevealed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>IsModeActive（）方法测试给定的模式当前是否在视图中处于活动状态。使用DeactivateAllModes（）方法停用所有当前活动的视图，或使用DeactiveMode（）停用特定模式。 PreviewFamilyVisibility属性获取和设置关联视图中PreviewFamilyVisibility模式的当前状态。仅当视图的文档位于族编辑器的环境中时，此模式才可用。此属性是PreviewFamilyVisibilityMode枚举值而不是bool。此模式的可能状态为：</p>
<table>
<thead>
<tr>
<th>**Member Name **</th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Off</td>
<td>未应用图元可见性。所有族元素均可见。</td>
</tr>
<tr>
<td>On</td>
<td>视图的图元可见性应用于仅显示可见图元。由参照平面剪切的图元将显示其各自的剪切几何图元。</td>
</tr>
<tr>
<td>Uncut</td>
<td>视图的图元可见性应用于在实例未被剪切时显示可见的图元。请注意，此状态仅在某些视图（如楼层平面和天花板）中可用。</td>
</tr>
</tbody></table>
<p>即使视图的PreviewFamilyVisibility模式可用并已启用，也并非所有状态在所有视图中都有效。在将这些状态之一应用于视图之前，调用IsValidState（）以确保可以应用它。</p>
<p>代码区域：关闭预览族可见性模式</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TurnOffFamilyVisibilityMode</span>(<span class="params">View view</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    TemporaryViewModes viewModes = view.TemporaryViewModes;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (viewModes != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (viewModes.IsModeAvailable(TemporaryViewMode.PreviewFamilyVisibility) &amp;&amp; viewModes.IsModeEnabled(TemporaryViewMode.PreviewFamilyVisibility))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (viewModes.IsValidState(PreviewFamilyVisibilityMode.Off))</span><br><span class="line">            &#123;</span><br><span class="line">                viewModes.PreviewFamilyVisibility = PreviewFamilyVisibilityMode.Off;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首次打开视图时，其PreviewFamilyVisibility模式的状态将根据默认设置确定，该默认设置通过静态TemporaryViewModes属性PreviewFamilyVisibilityDefaultOnState和PreviewFamilyVisibilityDefaultUncutState进行控制，如下所示。</p>
<p>代码区域：设置默认预览族可见性状态</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetDefaultPreviewFamilyVisibilityState</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    TemporaryViewModes.PreviewFamilyVisibilityDefaultOnState = <span class="literal">true</span>;</span><br><span class="line">    TemporaryViewModes.PreviewFamilyVisibilityDefaultUncutState = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>PreviewFamilyVisibilityDefaultOnState值控制是否默认打开每个新打开的视图的PreviewFamilyVisibility模式。此属性适用于所有类型的视图。同时支持剪切和未剪切预览的视图（如楼层平面）将使用由PreviewFamilyVisibilityDefaultUncutState属性指示的剪切&#x2F;未剪切状态，但前提是PreviewFamilyVisibilityDefaultOnState属性设置为true。 这些设置适用于整个应用程序，而不是单个族文档;这些值在Revit任务之间保持不变。尽管允许随时设置该值，但在Revit应用程序初始化后所做的任何更改在下一个Revit任务之前都不会生效。 请注意，一旦显式修改PreviewFamilyVisibility属性，即使在关闭视图并稍后再次重新打开之后，应用的设置也会对相应视图保持有效。</p>
<p>视图中元素可见性 </p>
<p>视图跟踪可见元素。所有在视图中可见的图形化元素都可以使用FilteredElementCollector进行检索，该Collector是用文档和视图的id构造的。然而，集合中的某些元素可能被其他元素隐藏或覆盖。可以通过旋转视图或移除覆盖它们的图元来查看它们。删除这些可见图元可能需要Revit重新生成视图的几何图形。当您的代码第一次为给定视图使用此构造函数时，或者当您的代码第一次为显示设置刚刚更改的视图使用此构造函数时，您可能会遇到显著的性能下降。 可以在特定视图中隐藏单个图元。方法Element.IsHidden（）指示元素是否在给定视图中隐藏，Element.CanBeHidden（）返回元素是否可以隐藏。要隐藏单个元素，请使用View.HideElements（），它接受与要隐藏的元素相对应的ElementId集合。 元素可见性也可以按类别更改。 GetCategoryHidden（）方法查询类别ID以确定它在视图中是隐藏还是可见。 方法的作用是：将特定类别中的所有元素设置为隐藏或可见。 * CanCategoryBeHidden（）方法指示是否可以在视图中隐藏特定类别的元素。 基于视图的FilteredElementCollector将仅包含当前视图中可见的元素。不能检索非图形元素或不可见元素。基于文档的FilteredElementCollector检索文档中的所有元素，包括不可见元素和非图形元素。例如，在空项目中创建默认三维视图时，视图中没有元素，但文档中有许多元素，所有这些元素都不可见。 下面的代码示例计算活动文档和活动视图中墙类别元素的数量。活动视图中的元素数量与文档中的元素数量不同，因为文档包含非图形墙类别元素。</p>
<p>代码区域：计算活动视图中的元素</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">CountElements</span>(<span class="params">UIDocument uiDoc</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    StringBuilder message = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    FilteredElementCollector viewCollector = </span><br><span class="line">        <span class="keyword">new</span> FilteredElementCollector(uiDoc.Document, uiDoc.ActiveView.Id);</span><br><span class="line">    viewCollector.OfCategory(BuiltInCategory.OST_Walls);</span><br><span class="line">    message.AppendLine(<span class="string">&quot;Wall category elements within active View: &quot;</span></span><br><span class="line">        + viewCollector.ToElementIds().Count);</span><br><span class="line"></span><br><span class="line">    FilteredElementCollector docCollector = <span class="keyword">new</span> FilteredElementCollector(uiDoc.Document);</span><br><span class="line">    docCollector.OfCategory(BuiltInCategory.OST_Walls);</span><br><span class="line">    message.AppendLine(<span class="string">&quot;Wall category elements within document: &quot;</span></span><br><span class="line">        + docCollector.ToElementIds().Count);</span><br><span class="line"></span><br><span class="line">    TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>, message.ToString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>临时视图模式会影响图元的可见性。IsInTemporaryViewMode（）方法可用于确定View是否处于临时视图模式。方法View.IsElementVisibleInTemporaryViewMode（）标识元素在指定的视图模式中是否应可见。这仅适用于TemporaryHideIsolate和AnalyticalModel视图模式。其他模式将导致异常。 </p>
<p>深度提示 ViewDisplayDepthCueing类提供了对剖面视图和立面视图中远处对象显示的控制。当景深效果处于活动状态时，随着与观察者距离的增加，对象会融入背景色（淡入淡出）。可以使用View.GetDepthCueing（）检索视图的当前深度提示设置。如果对返回的ViewDisplayDepthCueing进行了更改，则在调用View.SetDepthCueing（）之前，这些更改不会应用于视图。 ViewDisplayDepthCueing类具有以下属性：</p>
<table>
<thead>
<tr>
<th><strong>Member Name 成员名称</strong></th>
<th><strong>Description 描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>EnableDepthCueing</td>
<td>为True，则启用深度提示。</td>
</tr>
<tr>
<td>StartPercentage</td>
<td>指示深度提示开始的位置。值为0表示深度提示从视图的前剪辑平面开始。</td>
</tr>
<tr>
<td>EndPercentage</td>
<td>指示深度提示结束的位置。比结束平面更远的对象将与结束平面处的对象淡入淡出相同的量。值100表示远剪裁平面。</td>
</tr>
<tr>
<td>FadeTo</td>
<td>指示通过深度提示淡入淡出对象的最大量。值为100表示完全不可见。</td>
</tr>
</tbody></table>
<p>SetStartEndPerception（）方法可用于在一次调用中设置开始和结束百分比。 下面的示例演示如何获取当前深度提示、更改其属性并将其设置回视图。请注意，并非所有视图都可以使用深度提示。</p>
<p>代码区域：更改视图的深度提示</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">AdjustDepthCueing</span>(<span class="params">View view</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (view.CanUseDepthCueing())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">using</span> (Transaction t = <span class="keyword">new</span> Transaction(view.Document, <span class="string">&quot;Change depth cueing&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            t.Start();</span><br><span class="line">            ViewDisplayDepthCueing depthCueing = view.GetDepthCueing();</span><br><span class="line">            depthCueing.EnableDepthCueing = <span class="literal">true</span>;</span><br><span class="line">            depthCueing.FadeTo = <span class="number">50</span>;    <span class="comment">// set fade to percent</span></span><br><span class="line">            depthCueing.SetStartEndPercentages(<span class="number">0</span>, <span class="number">75</span>);</span><br><span class="line">            view.SetDepthCueing(depthCueing);</span><br><span class="line">            t.Commit();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="视图类型"><a href="#视图类型" class="headerlink" title="视图类型"></a>视图类型</h2><p>不同类型的Revit视图由Revit API中的不同类表示。有关每种视图类型的详细信息，请参阅以下主题。</p>
<p>本节中的页面</p>
<ul>
<li>概述</li>
<li>3D视图</li>
<li>视图平面</li>
<li>视图图纸</li>
<li>剖面图</li>
<li>图纸</li>
<li>图表</li>
</ul>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>一个项目模型可以有几种视图类型。在API中，有三种方法对视图进行分类。第一种方法是使用视图元素View.ViewType属性。它返回指示视图类型的枚举值。下表列出了所有可用的视图类型。</p>
<p>表44：Autodesk.Revit.DB.ViewType</p>
<table>
<thead>
<tr>
<th><strong>Member Name 成员名称</strong></th>
<th><strong>Description 描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>AreaPlan</td>
<td>区域视图。</td>
</tr>
<tr>
<td>CeilingPlan</td>
<td>天花板反射平面图。</td>
</tr>
<tr>
<td>ColumnSchedule</td>
<td>柱表视图。</td>
</tr>
<tr>
<td>CostReport</td>
<td>成本报告视图。</td>
</tr>
<tr>
<td>Detail</td>
<td>局部视图。</td>
</tr>
<tr>
<td>DraftingView</td>
<td>草图视图。</td>
</tr>
<tr>
<td>DrawingSheet</td>
<td>图纸工作表。</td>
</tr>
<tr>
<td>Elevation</td>
<td>立面视图。</td>
</tr>
<tr>
<td>EngineeringPlan</td>
<td>工程视图。</td>
</tr>
<tr>
<td>FloorPlan</td>
<td>楼层平面视图。</td>
</tr>
<tr>
<td>Internal</td>
<td>Revit的内部视图。</td>
</tr>
<tr>
<td>Legend</td>
<td>图例视图。</td>
</tr>
<tr>
<td>LoadsReport</td>
<td>荷载报告视图。</td>
</tr>
<tr>
<td>PanelSchedule</td>
<td>配电盘明细表视图。</td>
</tr>
<tr>
<td>PressureLossReport</td>
<td>压力损失报告视图。</td>
</tr>
<tr>
<td>Rendering</td>
<td>渲染视图。</td>
</tr>
<tr>
<td>Report</td>
<td>报告视图。</td>
</tr>
<tr>
<td>Schedule</td>
<td>视图表。</td>
</tr>
<tr>
<td>Section</td>
<td>剖面视图。</td>
</tr>
<tr>
<td>ThreeD</td>
<td>3D视图。</td>
</tr>
<tr>
<td>Undefined</td>
<td>未定义&#x2F;未指定视图。</td>
</tr>
<tr>
<td>Walkthrough</td>
<td>Walkthrough视图。</td>
</tr>
</tbody></table>
<p>分类视图的第二种方法是按类类型。下表列出了项目浏览器中的视图类型和相应视图。</p>
<p>表45：项目浏览器视图</p>
<table>
<thead>
<tr>
<th><strong>Project Browser Views 项目浏览器视图</strong></th>
<th><strong>View Type 视图类型</strong></th>
<th><strong>Class Type 类类型</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Area Plans</td>
<td>ViewType.AreaPlan</td>
<td>Elements.ViewPlan</td>
</tr>
<tr>
<td>Ceiling Plans</td>
<td>ViewType.CeilingPlan</td>
<td>Elements.ViewPlan</td>
</tr>
<tr>
<td>Graphic Column Schedule</td>
<td>ViewType.ColumnSchedule</td>
<td>Elements.View</td>
</tr>
<tr>
<td>Detail Views</td>
<td>ViewType.Detail</td>
<td>Elements.ViewSection</td>
</tr>
<tr>
<td>Drafting Views</td>
<td>ViewType.DraftingView</td>
<td>Elements.ViewDrafting</td>
</tr>
<tr>
<td>Sheets</td>
<td>ViewType.DrawingSheet</td>
<td>Elements.ViewSheet</td>
</tr>
<tr>
<td>Elevations</td>
<td>ViewType.Elevation</td>
<td>Elements.ViewSection</td>
</tr>
<tr>
<td>Structural Plans</td>
<td>ViewType.EngineeringPlan</td>
<td>Elements.ViewPlan</td>
</tr>
<tr>
<td>Floor Plans</td>
<td>ViewType.FloorPlan</td>
<td>Elements.ViewPlan</td>
</tr>
<tr>
<td>Legends</td>
<td>ViewType.Legend</td>
<td>Elements.View</td>
</tr>
<tr>
<td>Reports (MEP engineering)</td>
<td>ViewType.LoadsReport</td>
<td>Elements.View</td>
</tr>
<tr>
<td>Reports (MEP engineering)</td>
<td>ViewType.PanelSchedule</td>
<td>Elements.PanelScheduleView</td>
</tr>
<tr>
<td>Reports (MEP engineering)</td>
<td>ViewType.PresureLossReport</td>
<td>Elements.View</td>
</tr>
<tr>
<td>Renderings</td>
<td>ViewType.Rendering</td>
<td>Elements.ViewDrafting</td>
</tr>
<tr>
<td>Reports</td>
<td>ViewType.Report</td>
<td>Elements.View</td>
</tr>
<tr>
<td>Schedules&#x2F;Quantities</td>
<td>ViewType.Schedule</td>
<td>Elements.ViewSchedule</td>
</tr>
<tr>
<td>Sections</td>
<td>ViewType.Section</td>
<td>Elements.ViewSection</td>
</tr>
<tr>
<td>3D Views</td>
<td>ViewType.ThreeD</td>
<td>Elements.View3D</td>
</tr>
<tr>
<td>Walkthroughs</td>
<td>ViewType.Walkthrough</td>
<td>Elements.View3D</td>
</tr>
</tbody></table>
<p>此示例说明如何使用视图的ViewType属性来确定视图的类型。</p>
<p>代码区域：确定视图类型</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetViewType</span>(<span class="params">Autodesk.Revit.DB.View view</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">// Get the view type of the given view, and format the prompt string</span></span><br><span class="line">        String prompt = <span class="string">&quot;The view is &quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (view.ViewType)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">case</span> ViewType.AreaPlan:</span><br><span class="line">                        prompt += <span class="string">&quot;an area view.&quot;</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> ViewType.CeilingPlan:</span><br><span class="line">                        prompt += <span class="string">&quot;a reflected ceiling plan view.&quot;</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> ViewType.ColumnSchedule:</span><br><span class="line">                        prompt += <span class="string">&quot;a column schedule view.&quot;</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> ViewType.CostReport:</span><br><span class="line">                        prompt += <span class="string">&quot;a cost report view.&quot;</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> ViewType.Detail:</span><br><span class="line">                        prompt += <span class="string">&quot;a detail view.&quot;</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> ViewType.DraftingView:</span><br><span class="line">                        prompt += <span class="string">&quot;a drafting view.&quot;</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> ViewType.DrawingSheet:</span><br><span class="line">                        prompt += <span class="string">&quot;a drawing sheet view.&quot;</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> ViewType.Elevation:</span><br><span class="line">                        prompt += <span class="string">&quot;an elevation view.&quot;</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> ViewType.EngineeringPlan:</span><br><span class="line">                        prompt += <span class="string">&quot;an engineering view.&quot;</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> ViewType.FloorPlan:</span><br><span class="line">                        prompt += <span class="string">&quot;a floor plan view.&quot;</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">                <span class="literal">default</span>:</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Give the user some information</span></span><br><span class="line">        MessageBox.Show(prompt, <span class="string">&quot;Revit&quot;</span>, MessageBoxButtons.OK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分类视图的第三种方法是使用ViewFamilyType类。大多数视图创建方法需要新视图的ViewFamilyType的ID。可以从View.GetTypeId（）方法中检索ViewFamilyType的ID。ViewFamily属性返回ViewFamily枚举，它指定ViewFamilyType的族，类似于上面记录的ViewType枚举。下面的示例说明如何从View获取ViewFamily。</p>
<p>代码区域：从ViewFamilyType确定视图类型</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ViewFamily <span class="title">GetViewFamily</span>(<span class="params">Document doc, View view</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ViewFamily viewFamily = ViewFamily.Invalid;</span><br><span class="line"></span><br><span class="line">    ElementId viewTypeId = view.GetTypeId();</span><br><span class="line">    <span class="keyword">if</span> (viewTypeId.IntegerValue &gt; <span class="number">1</span>) <span class="comment">// some views may not have a ViewFamilyType</span></span><br><span class="line">    &#123;</span><br><span class="line">        ViewFamilyType viewFamilyType = doc.GetElement(viewTypeId) <span class="keyword">as</span> ViewFamilyType;</span><br><span class="line">        viewFamily = viewFamilyType.ViewFamily;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> viewFamily;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3D视图"><a href="#3D视图" class="headerlink" title="3D视图"></a>3D视图</h3><p>View3D是一个自由导向的三维视图。</p>
<p>有两种三维视图：透视视图和等轴测视图，在Revit用户界面中也称为正交视图。差异基于投影射线关系。View3D.IsPerspective属性指示三维视图是透视视图还是等轴测视图。</p>
<h4 id="透视图"><a href="#透视图" class="headerlink" title="透视图"></a>透视图</h4><p>下图说明了如何创建透视图。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-EF11532A-32D3-40C1-9410-5AADA6FD8701-low.png"></p>
<p>图96：透视投影</p>
<ul>
<li>直投影射线穿过模型中的每个点并与投影平面相交以形成投影内容。</li>
<li>为了便于从世界坐标到视图平面的变换，视图坐标系基于观察者。</li>
<li>它的原点由View.Origin属性表示，是查看者的位置。</li>
<li>使用ViewOrientation3D.EyePosition属性（从View3D.GetOrientation（）检索）检索查看器的世界坐标。因此，在3D视图中，View.Origin始终等于相应的ViewOrientation3D.EyePosition。</li>
<li>如上图所述，<em>观察</em>坐标系确定如下：<ul>
<li>X轴由View.RightDirection确定。</li>
<li>Y轴由View.UpDirection确定。</li>
<li>Z轴由View.ViewDirection确定。</li>
</ul>
</li>
<li>观看方向是在3D空间中从目标点到观看者，以及在屏幕空间中从屏幕到观看者。</li>
</ul>
<p>静态方法View3D.ViewPerspective（）方法可用于创建新的透视图。</p>
<p>代码区域：View3D.CreatePerspective（）</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> View3D View3D.CreatePerspective (Document document, ElementId viewFamilyTypeId;</span><br></pre></td></tr></table></figure>

<p>viewFamilyTypeId参数必须是三维ViewType。 下面的代码示例说明如何创建透视三维视图。</p>
<p>代码区域：创建透视三维视图</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Find a 3D view type</span></span><br><span class="line">IEnumerable viewFamilyTypes = <span class="function"><span class="keyword">from</span> elem <span class="keyword">in</span> <span class="keyword">new</span> <span class="title">FilteredElementCollector</span>(<span class="params">document</span>).<span class="title">OfClass</span>(<span class="params"><span class="keyword">typeof</span>(ViewFamilyType</span>))</span></span><br><span class="line"><span class="function">                                                <span class="keyword">let</span> type</span> = elem <span class="keyword">as</span> ViewFamilyType</span><br><span class="line">                                                <span class="keyword">where</span> type.ViewFamily == ViewFamily.ThreeDimensional</span><br><span class="line">                                                <span class="keyword">select</span> type;</span><br><span class="line"><span class="comment">// Create a new Perspective View3D</span></span><br><span class="line">View3D view3D = View3D.CreatePerspective(document, viewFamilyTypes.First().Id);</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">null</span> != view3D)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// By default, the 3D view uses a default orientation.</span></span><br><span class="line">    <span class="comment">// Change the orientation by creating and setting a ViewOrientation3D </span></span><br><span class="line">    XYZ eye = <span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">-100</span>, <span class="number">10</span>); </span><br><span class="line">    XYZ up = <span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>); </span><br><span class="line">    XYZ forward = <span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>); </span><br><span class="line">    view3D.SetOrientation(<span class="keyword">new</span> ViewOrientation3D(eye, up, forward));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// turn off the far clip plane with standard parameter API</span></span><br><span class="line">    Parameter farClip = view3D.LookupParameter(<span class="string">&quot;Far Clip Active&quot;</span>);</span><br><span class="line">    farClip.Set(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>透视视图裁剪框是锥体的一部分，其顶点位于查看者位置。它是两个平行剪裁平面之间的几何体。裁剪框限定模型中被裁剪并投影到视图平面上的部分。 裁剪框由View.CropBox属性表示，该属性返回一个BoundingBoxXYZ对象。 CropBox.Min和CropBox.Max点在上一张图片中标记。请注意，透视图中的CropBox.Min点是通过将裁剪框前裁剪平面投影到后裁剪平面上而生成的。 裁剪框坐标基于查看坐标系。使用Transform.OfPoint（）将CropBox.Min和CropBox.Max变换到世界坐标系。有关变换的更多详细信息，请参见几何部分中的几何辅助类。 投影平面加上前剪裁平面和后剪裁平面都垂直于视图方向。CropBox.Max和CropBox.Min之间的线与查看方向平行。利用这些因子，可以计算裁剪框几何形状。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-CCAE0F1D-6889-4225-900A-45CF0D207B15-low.png"></p>
<p>图97：透视3D视图</p>
<p>上图显示了裁剪后屏幕上的投影平面。裁剪区域是投影平面和裁剪框的矩形相交。 使用View.CropRegion属性检索几何信息。此属性返回BoundingBoxUV实例。 View.Outline.Max属性指向右上角。 View.Outline.Min属性指向左下角。 与裁剪框类似，裁剪区域坐标基于查看坐标系。下列表达式是相等的。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">View.CropBox.Max.X(Y) / View.OutLine.Max.X(Y) == View.CropBox.Min.X(Y) / View.OutLine.Min.X(Y) </span><br></pre></td></tr></table></figure>

<p>由于物体的透视投影的大小与从该物体到投影中心的距离成反比，因此比例对于透视图来说是没有意义的。透视三维视图的“比例”属性始终返回零。 #管理摄像头目标 相机表示透视视图的查看者正在查看的方向。如果用户或API应用调整裁剪区域以暴露更宽的视场或不对称的视场，则透视图的失真可能变得过于剧烈。可以通过调用View3D方法RestCameraTarget（）将摄像机目标定位在视场的中心，从而将摄像机目标强制定位到观察区域的中心。在调用之前，请检查是否可以使用View3D.CanResetCameraTarget（）方法在此视图中重置摄像机，该方法指示是否可以重置摄像机目标。无法重置目标的主要情况是View3D当前处于等轴测投影中。尝试在等轴测视图中重置相机目标将引发Autodesk. Revit. Exceptions. InvalidOperationException。</p>
<p>等距视图 可以使用静态View3D.NETIsometric（）方法创建新的等轴测视图。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-6B8688A8-D480-4C35-84A2-5CA5CF8D1577-low.png"></p>
<p>图98：平行投影 </p>
<p>等轴测视图是使用平行投影光线通过将模型投影到与光线垂直的平面上而生成的。查看坐标系类似于透视图，但裁剪框是一个平行六面体，其面与投影光线平行或垂直。View.CropBox属性指向两个对角，其坐标基于查看坐标系。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-A25AEAB3-BBF1-41E9-8B40-B1D40168A7AE-low.png"></p>
<p>图99：将视图平面上的窗口缩放到屏幕视口</p>
<p> 模型将投影到视图平面上，然后缩放到屏幕上。View.Scale属性表示实际模型大小与视图大小的比率。相关表达式如下：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">View.CropBox.Max.X(Y) / View.OutLine.Max.X(Y) == View.CropBox.Min.X(Y) / View.OutLine.Min.X(Y) == View.Scale </span><br></pre></td></tr></table></figure>

<p>代码区域：View3D.Other Isometric（）</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> View3D View3D.CreateIsometric (Document document, ElementId viewFamilyTypeId;</span><br></pre></td></tr></table></figure>

<p>viewFamilyTypeId参数必须是三维ViewType。Revit确定以下内容：观察者的位置。 如何使用视图方向创建视图坐标系。 * 如何创建裁剪框来裁剪模型。 创建视图后，可以调整裁剪框的大小以查看模型的不同部分。也可以更改默认方向。API不支持修改查看坐标系。 下面的代码示例说明如何创建等轴测三维视图。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Find a 3D view type</span></span><br><span class="line"></span><br><span class="line">IEnumerable viewFamilyTypes = <span class="function"><span class="keyword">from</span> elem <span class="keyword">in</span> <span class="keyword">new</span> <span class="title">FilteredElementCollector</span>(<span class="params">document</span>).<span class="title">OfClass</span>(<span class="params"><span class="keyword">typeof</span>(ViewFamilyType</span>))</span></span><br><span class="line"><span class="function">                                              <span class="keyword">let</span> type</span> = elem <span class="keyword">as</span> ViewFamilyType</span><br><span class="line">                                              <span class="keyword">where</span> type.ViewFamily == ViewFamily.ThreeDimensional</span><br><span class="line">                                              <span class="keyword">select</span> type;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a new View3D</span></span><br><span class="line">View3D view3D = View3D.CreateIsometric(document, viewFamilyTypes.First().Id);</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">null</span> != view3D)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// By default, the 3D view uses a default orientation.</span></span><br><span class="line">    <span class="comment">// Change the orientation by creating and setting a ViewOrientation3D </span></span><br><span class="line">    XYZ eye = <span class="keyword">new</span> XYZ(<span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line">    XYZ up = <span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    XYZ forward = <span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    ViewOrientation3D viewOrientation3D = newViewOrientation3D(eye, up, forward);</span><br><span class="line">    view3D.SetOrientation(viewOrientation3D);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="在等距和透视之间切换"><a href="#在等距和透视之间切换" class="headerlink" title="在等距和透视之间切换"></a>在等距和透视之间切换</h4><p>大多数情况下，View3D可以在“等轴测”和“透视”之间切换，前提是视图中没有视图特定的元素。View3D类提供了在等轴测和透视模式之间切换视图的方法。在切换之前，使用CanToggleBetweenPerspectiveAndIsometric（）方法，该方法指示是否可以进行切换。</p>
<p>要切换视图，请调用以下两个View 3D类方法之一：ToggleToPerspective（）或ToggleToIsometric（）。如果无法切换视图（可能是由于视图中存在特定于视图的元素），则这两种方法中的任何一种都将引发Autodesk. Revit. Exceptions. InvalidOperationException。</p>
<h4 id="3D视图剖面框"><a href="#3D视图剖面框" class="headerlink" title="3D视图剖面框"></a>3D视图剖面框</h4><p>每个视图都有一个裁剪框。裁剪框聚焦于要投影并显示在视图中的模型部分。对于三维视图，还有另一个名为剖面框的框。</p>
<ul>
<li>剖面框确定在三维视图中显示的模型部分。</li>
<li>剖面框用于剪裁三维模型的可见部分。</li>
<li>即使在裁剪框中，框外的部分也不可见。</li>
<li>剖面框与裁剪框的不同之处在于，剖面框可以随模型一起旋转和移动。</li>
</ul>
<p>剖面框对于大型模型特别有用。例如，如果要渲染大型建筑，请使用剖面框。剖面框限制用于计算的模型部分。若要显示剖面框，请在“三维视图图元属性”对话框的“范围”区域中选择“剖面框”。也可以使用IsSectionBoxActive属性设置它。在下面的示例中，如果活动视图是三维视图，它将设置剖面框是否处于活动状态。</p>
<p>代码区域：显示&#x2F;隐藏剖面框</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ShowHideSectionBox</span>(<span class="params">UIDocument document, <span class="built_in">bool</span> active</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (document.ActiveView <span class="keyword">is</span> View3D)</span><br><span class="line">    &#123;</span><br><span class="line">        View3D view3d = document.ActiveView <span class="keyword">as</span> View3D;</span><br><span class="line">        view3d.IsSectionBoxActive = active;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-016E48BA-138E-4686-B864-D4A978DC406C-low.png"></p>
<p>图100：剖面框</p>
<p> View3D.GetSectionBox（）和View3D.SetSectionBox（）方法用于获取和更改长方体范围。在某些情况下，调用View3D.SetSectionBox（）可能会产生副作用。将该属性设置为某些值可以更改框的容量并将其显示在视图中。若要避免显示剖面框，请将IsSectionBoxActive属性设置为false。 下面的代码示例阐释如何更改剖面框的范围。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ExpandSectionBox</span>(<span class="params">View3D view</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// The original section box</span></span><br><span class="line">    BoundingBoxXYZ sectionBox = view.GetSectionBox();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Expand the section box (doubling in size in all directions while preserving the same center and orientation)</span></span><br><span class="line">    Autodesk.Revit.DB.XYZ deltaXYZ = sectionBox.Max - sectionBox.Min;</span><br><span class="line">    sectionBox.Max += deltaXYZ / <span class="number">2</span>;</span><br><span class="line">    sectionBox.Min -= deltaXYZ / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//After resetting the section box, it will be shown in the view.</span></span><br><span class="line">    <span class="comment">//It only works when the Section Box is active</span></span><br><span class="line">    view.SetSectionBox(sectionBox);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从GetSectionBox（）方法返回的BoundingBoxXYZ的Max和Min点的坐标不是全局坐标。要将Max和Min的坐标转换为全局坐标，需要通过从BoundingBoxXYZ.Transform属性获得的变换来转换每个点。</p>
<p>代码区域：将最大值和最小值转换为全局坐标</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ConvertMaxMinToGlobal</span>(<span class="params">View3D view, <span class="keyword">out</span> XYZ max, <span class="keyword">out</span> XYZ min</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    BoundingBoxXYZ sectionbox = view.GetSectionBox();</span><br><span class="line">    Transform transform = sectionbox.Transform;</span><br><span class="line">    max = transform.OfPoint(sectionbox.Max);</span><br><span class="line">    min = transform.OfPoint(sectionbox.Min);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="视图锁定"><a href="#视图锁定" class="headerlink" title="视图锁定"></a>视图锁定</h4><p>View3D类具有与Revit用户界面中可用的锁定功能相对应的方法和属性。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/3DLocking.jpg"></p>
<p>View3D.SaveOrientationAndLock（）方法将保存方向并锁定视图，而View3D.RestoreOrientationAndLock（）将恢复视图的方向并锁定它。View3D.RestoreOrientationAndLock（）将解锁当前锁定的视图。IsLocked属性将返回3D视图当前是否被锁定。</p>
<h3 id="视图平面"><a href="#视图平面" class="headerlink" title="视图平面"></a>视图平面</h3><p>平面视图是基于标高的。平面视图有三种类型：楼层平面视图、天花板平面视图和面积平面视图。</p>
<h4 id="创建平面视图"><a href="#创建平面视图" class="headerlink" title="创建平面视图"></a>创建平面视图</h4><ul>
<li>通常，楼层平面视图是在新项目中打开的默认视图。</li>
<li>大多数项目至少包括一个楼层平面视图和一个天花板平面视图。</li>
<li>通常在向项目中添加新标高后创建平面视图。</li>
</ul>
<p>使用API添加新标高不会自动添加平面视图。使用静态ViewPlan.Create（）方法创建新的地板和天花板平面视图。使用静态ViewPlan. ViewAreaPlan（）方法创建新的面积平面视图。</p>
<p>代码区域：创建平面视图</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ViewPlan ViewPlan.Create(Document document, ElementId viewFamilyTypeId, ElementId levelId);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ViewPlan ViewPlan.CreateAreaPlan(Document document, ElementId areaSchemeId, ElementId levelId);</span><br></pre></td></tr></table></figure>

<p>ViewPlan.Create（）中的viewFamilyTypeId参数必须是FloorPlan、CeilingPlan、AreaPlan或StructuralPlan ViewType。levelId参数表示与平面视图关联的项目中标高图元的ID。 下面的代码基于某个标高创建楼层平面和天花板平面。</p>
<p>代码区域：创建楼层平面和天花板平面</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">CreateViewPlan</span>(<span class="params">Autodesk.Revit.DB.Document document</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">    IList viewFamilyTypes = collector.OfClass(<span class="keyword">typeof</span>(ViewFamilyType)).ToElements();</span><br><span class="line">    ElementId floorPlanId = <span class="keyword">new</span> ElementId(<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">foreach</span> (Element e <span class="keyword">in</span> viewFamilyTypes)</span><br><span class="line">    &#123;</span><br><span class="line">        ViewFamilyType v = e <span class="keyword">as</span> ViewFamilyType;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (v != <span class="literal">null</span> &amp;&amp; v.ViewFamily == ViewFamily.FloorPlan)</span><br><span class="line">        &#123;</span><br><span class="line">            floorPlanId = e.Id;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ElementId ceilingPlanId = <span class="keyword">new</span> ElementId(<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">foreach</span> (Element e <span class="keyword">in</span> viewFamilyTypes)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.Name == <span class="string">&quot;Ceiling Plan&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ceilingPlanId = e.Id;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create a Level and a Floor Plan based on it</span></span><br><span class="line">    <span class="built_in">double</span> elevation = <span class="number">10.0</span>;</span><br><span class="line">    Level level1 = Level.Create(document, elevation);</span><br><span class="line">    ViewPlan floorView = ViewPlan.Create(document, floorPlanId, level1.Id);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create another Level and a Ceiling Plan based on it</span></span><br><span class="line">    elevation += <span class="number">10.0</span>;</span><br><span class="line">    Level level2 = Level.Create(document, elevation);</span><br><span class="line">    ViewPlan ceilingView = ViewPlan.Create(document, ceilingPlanId, level2.Id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="平面视图属性"><a href="#平面视图属性" class="headerlink" title="平面视图属性"></a>平面视图属性</h4><p>创建新平面视图后，可以使用类型为ViewDiscipline的Discipline参数设置视图的Discipline。选项包括建筑、结构、机械、电气、管道和协调。</p>
<p>对于结构平面视图，可以使用ViewFamilyType.PlanViewDirection属性将视图方向设置为“向上”或“向下”。尽管它是ViewFamilyType类的属性，但如果为StructuralPlan视图以外的视图访问该属性，则将引发异常。</p>
<h4 id="视图范围"><a href="#视图范围" class="headerlink" title="视图范围"></a>视图范围</h4><p>可以通过ViewPlan.GetViewRange（）方法检索平面视图的视图范围。返回的PlanViewRange对象可用于查找平面相对的标高以及每个平面与该标高的偏移量。该信息与Revit用户界面的“视图范围”对话框中提供的信息相同：</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/ViewRange-76168.jpg"></p>
<p>以下示例显示如何获取平面视图的顶部剪裁平面和关联偏移</p>
<p>代码区域：获取视图范围的信息</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ViewRange</span>(<span class="params">Document doc, View view</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (view <span class="keyword">is</span> ViewPlan)</span><br><span class="line">    &#123;</span><br><span class="line">        ViewPlan viewPlan = view <span class="keyword">as</span> ViewPlan;</span><br><span class="line">        PlanViewRange viewRange = viewPlan.GetViewRange();</span><br><span class="line"></span><br><span class="line">        ElementId topClipPlane = viewRange.GetLevelId(PlanViewPlane.TopClipPlane);</span><br><span class="line">        <span class="built_in">double</span> dOffset = viewRange.GetOffset(PlanViewPlane.TopClipPlane);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (topClipPlane.IntegerValue &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Element levelAbove = doc.GetElement(topClipPlane);</span><br><span class="line">            TaskDialog.Show(view.Name, <span class="string">&quot;Top Clip Plane: &quot;</span> + levelAbove.Name + <span class="string">&quot;\r\nTop Offset: &quot;</span> + dOffset + <span class="string">&quot; ft&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="平面图underlay"><a href="#平面图underlay" class="headerlink" title="平面图underlay"></a>平面图underlay</h4><p>可以从ViewPlan中检索和设置顶层和底层范围。使用GetUnderlayBaseLevel（）和SetUnderlayBaseLevel（）访问对象范围的基准标高。如果基本级别ID为InvalidElementId，则不设置无效基本级别，并且没有元素显示为无效。设置参考底图范围的基准标高时，下一个最高标高的高程将用于确定参考底图范围的顶部。如果为基准标高指定的标高是最高标高，则该范围将是无边界的，并且将由指定标高以上的所有内容组成。</p>
<p>使用GetUnderlayTopLevel（）和SetUnderlayRange（）访问对象范围的顶级。如果GetUnderlayTopLevel（）返回InvalidElementId，并且XML基础级别是有效级别，则XML范围是无边界的，并且包含XML基础级别之上的所有内容。若要设置顶层，必须使用SetUnderlayRange（），该方法将ElementIds用于底层和顶层。如果顶层的高程不大于底层的高程，此方法将引发异常。</p>
<p>使用GetUnderlayOrientation（）和SetUnderlayOrientation（）方法控制如何查看视图中的元素。UnderlayOrientation可以是LookingDown（向下查看图元，就像从上面向下查看一样）或LookingUp（向上查看图元，就像从下面向上查看一样）。</p>
<p>如果当前方向为LookingDown且顶级Id与新值不同，则以下代码设置范围。然后方向更改为LookingUp。</p>
<p>代码区域：更改视图范围</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ViewUnderlay</span>(<span class="params">ViewPlan planView, ElementId topLevelId, ElementId baseLevelId</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (planView.GetUnderlayOrientation() == UnderlayOrientation.LookingDown)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (planView.GetUnderlayTopLevel() != topLevelId)</span><br><span class="line">        &#123;</span><br><span class="line">            planView.SetUnderlayRange(baseLevelId, topLevelId);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        planView.SetUnderlayOrientation(UnderlayOrientation.LookingUp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="视图图纸"><a href="#视图图纸" class="headerlink" title="视图图纸"></a>视图图纸</h3><p>视图，用于创建不属于建模设计的、不关联的视图专有详图。</p>
<p>图纸视图未与模型关联。它允许用户创建不包括在模型中的详图。</p>
<ul>
<li><p>在绘图视图中，用户可以以不同的视图比例（粗略、精细或中等）创建详图。</p>
</li>
<li><p>您可以使用2D详图工具，包括：</p>
<table>
<thead>
<tr>
<th><em>Detail lines</em> Detail regions <em>Detail components</em> Insulation <em>详图线</em>详图区域<em>详图构件</em>隔热层</th>
<th><em>Reference planes</em> Dimensions <em>Symbols</em> Text <em>参照平面</em>尺寸<em>符号</em>文字</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>这些工具与用于创建局部视图的工具相同。</p>
</li>
<li><p>图纸视图不显示模型图元。</p>
</li>
</ul>
<p>使用静态ViewDrafting.Create（）方法创建图纸视图。模型图元不显示在图纸视图中。</p>
<h4 id="图片视图"><a href="#图片视图" class="headerlink" title="图片视图"></a>图片视图</h4><p>ImageView类派生自ViewDrafting。它可用于创建包含从磁盘导入的图像的渲染视图。使用静态ImageView.Create（）方法创建新的呈现视图。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/RenderingView-76170.jpg"></p>
<h3 id="剖面视图"><a href="#剖面视图" class="headerlink" title="剖面视图"></a>剖面视图</h3><p>表示剖面视图、局部视图、俯视图和立面视图，以及参照详图索引和参照剖面。</p>
<p>ViewSection类可用于创建剖面视图、局部视图、局部视图、参照详图索引和参照剖面。它还表示立面视图。</p>
<p>剖面视图和参照剖面</p>
<p>剖面视图剖切模型以显示内部结构。ViewSection.ViewSection（）方法创建剖面视图。</p>
<p>代码区域：ViewSection. ViewSection（）</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ViewSection ViewSection.CreateSection(Document document, ElementId viewFamilyTypeId, BoundingBoxXYZ sectionBox);</span><br></pre></td></tr></table></figure>

<p>viewFamilyTypeId参数是新ViewSection将使用的ViewFamilyType的ID。类型必须是截面视图族。sectionBox参数是剖面视图裁剪框。它提供剖面视图所需的方向和范围。通常，另一个视图的裁剪框用作参数。您还可以构建自定义BoundingBoxXYZ实例来表示方向和范围。 下面的代码演示如何创建剖面视图。将在墙的中心创建剖面视图的边界框。生成的剖面视图将位于项目浏览器的“剖面（建筑剖面）”节点中。请注意，远裁剪距离将等于创建时边界框的最小值和最大值的z坐标之差。</p>
<p>代码区域：创建剖面图</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Find a section view type</span></span><br><span class="line">IEnumerable viewFamilyTypes = <span class="function"><span class="keyword">from</span> elem <span class="keyword">in</span> <span class="keyword">new</span> <span class="title">FilteredElementCollector</span>(<span class="params">document</span>).<span class="title">OfClass</span>(<span class="params"><span class="keyword">typeof</span>(ViewFamilyType</span>))</span></span><br><span class="line"><span class="function">                                                <span class="keyword">let</span> type</span> = elem <span class="keyword">as</span> ViewFamilyType</span><br><span class="line">                                                <span class="keyword">where</span> type.ViewFamily == ViewFamily.Section</span><br><span class="line">                                                <span class="keyword">select</span> type;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a BoundingBoxXYZ instance centered on wall</span></span><br><span class="line">LocationCurve lc = wall.Location <span class="keyword">as</span> LocationCurve;</span><br><span class="line">Transform curveTransform = lc.Curve.ComputeDerivatives(<span class="number">0.5</span>, <span class="literal">true</span>);</span><br><span class="line"><span class="comment">// using 0.5 and &quot;true&quot; (to specify that the parameter is normalized) </span></span><br><span class="line"><span class="comment">// places the transform&#x27;s origin at the center of the location curve)</span></span><br><span class="line"></span><br><span class="line">XYZ origin = curveTransform.Origin; <span class="comment">// mid-point of location curve</span></span><br><span class="line">XYZ viewDirection = curveTransform.BasisX.Normalize(); <span class="comment">// tangent vector along the location curve</span></span><br><span class="line">XYZ normal = viewDirection.CrossProduct(XYZ.BasisZ).Normalize(); <span class="comment">// location curve normal @ mid-point</span></span><br><span class="line"></span><br><span class="line">Transform transform = Transform.Identity;</span><br><span class="line">transform.Origin = origin;</span><br><span class="line">transform.BasisX = normal;</span><br><span class="line">transform.BasisY = XYZ.BasisZ;</span><br><span class="line"></span><br><span class="line"><span class="comment">// can use this simplification because wall&#x27;s &quot;up&quot; is vertical.</span></span><br><span class="line"><span class="comment">// For a non-vertical situation (such as section through a sloped floor the surface normal would be needed)</span></span><br><span class="line">transform.BasisZ = normal.CrossProduct(XYZ.BasisZ);</span><br><span class="line"></span><br><span class="line">BoundingBoxXYZ sectionBox = <span class="keyword">new</span> BoundingBoxXYZ();</span><br><span class="line">sectionBox.Transform = transform;</span><br><span class="line">sectionBox.Min = <span class="keyword">new</span> XYZ(<span class="number">-10</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">sectionBox.Max = <span class="keyword">new</span> XYZ(<span class="number">10</span>,<span class="number">12</span>,<span class="number">5</span>);</span><br><span class="line"><span class="comment">// Min &amp; Max X values (-10 &amp; 10) define the section line length on each side of the wall</span></span><br><span class="line"><span class="comment">// Max Y (12) is the height of the section box// Max Z (5) is the far clip offset</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a new view section.</span></span><br><span class="line">ViewSection viewSection = ViewSection.CreateSection(document, viewFamilyTypes.First().Id, sectionBox);</span><br></pre></td></tr></table></figure>

<p>参照剖面是参照现有视图的剖面。创建新参照剖面时，Revit不会添加新视图。</p>
<p>代码区域：ViewSection. ViewReferenceSection（）</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ViewSection ViewSection.CreateReferenceSection(Document document, </span><br><span class="line">                                                      ElementId parentViewId,</span><br><span class="line">                                                      ElementId viewIdToReference, </span><br><span class="line">                                                      XYZ headPoint, </span><br><span class="line">                                                      XYZ tailPoint);</span><br></pre></td></tr></table></figure>

<p>parentViewId参数是将在其中显示新引用截面标记的视图的ID。可以在“楼层平面”、“天花板平面”、“结构平面”、“剖面”、“立面”、“绘图”和“详图”视图中创建参照剖面。viewIdToReference可以是详图、绘图或剖面视图的ID。新参照截面将使用参照视图的ViewFamilyType。这两个XYZ点将确定父视图中截面标记标头的位置。 #详细视图 局部视图是模型的视图，在其他视图中显示为剖面或截面。这种类型的视图通常以比父视图中更精细的细节比例来表示模型。它用于向模型的特定部分添加更多信息。静态ViewSection. ViewDetail（）方法用于创建新的细节ViewSection。</p>
<p>代码区域：ViewSection. ViewDetail（）</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ViewSection ViewSection.CreateDetail(Document document, ElementId viewFamilyTypeId, BoundingBoxXYZ sectionBox);</span><br></pre></td></tr></table></figure>

<p>viewFamilyTypeId参数是新ViewSection将使用的ViewFamilyType的ID。类型必须是详图视图族。与标准剖面视图一样，sectionBox参数是剖面视图裁剪框。它提供剖面视图所需的方向和范围。 添加新详图ViewSection后，它将显示在项目浏览器的“详图视图（Detail）”节点中。 #立面视图 立面视图是模型的横截面，其中显示标高线。立面视图由ViewSection类表示。但是，与其他类型的横断面图不同，不能使用ViewSection类的静态方法创建立面视图。要创建立面视图，请先创建立面标记，然后使用该标记生成立面视图。新创建的立面视图将显示在项目浏览器的“立面（建筑立面）”节点中。它将被分配一个唯一的名称。 以下示例基于梁的位置创建立面视图。</p>
<p>代码区域：创建立面视图</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function">ViewSection <span class="title">CreateElevationView</span>(<span class="params">Document document, FamilyInstance beam</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Find an elevation view type</span></span><br><span class="line">    IEnumerable viewFamilyTypes = <span class="function"><span class="keyword">from</span> elem <span class="keyword">in</span> <span class="keyword">new</span> <span class="title">FilteredElementCollector</span>(<span class="params">document</span>).<span class="title">OfClass</span>(<span class="params"><span class="keyword">typeof</span>(ViewFamilyType</span>))</span></span><br><span class="line"><span class="function">                                                    <span class="keyword">let</span> type</span> = elem <span class="keyword">as</span> ViewFamilyType</span><br><span class="line">                                                    <span class="keyword">where</span> type.ViewFamily == ViewFamily.Elevation</span><br><span class="line">                                                    <span class="keyword">select</span> type;</span><br><span class="line"></span><br><span class="line">    LocationCurve lc = beam.Location <span class="keyword">as</span> LocationCurve;</span><br><span class="line">    XYZ xyz = lc.Curve.GetEndPoint(<span class="number">0</span>);</span><br><span class="line">    ElevationMarker marker = ElevationMarker.CreateElevationMarker(document, viewFamilyTypes.First().Id, xyz, <span class="number">1</span>);</span><br><span class="line">    ViewSection elevationView = marker.CreateElevation(document, document.ActiveView.Id, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> elevationView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ElevationMarker. Elevation（）方法将ViewPlan的id作为参数。这是ElevationMarker可见的ViewPlan。新的立面ViewSection将从ViewPlan中导出其范围并继承设置。最后一个参数是将放置新立面视图的ElevationMarker上的索引。ElevationMarker上的索引必须有效且未使用。视图的方向由索引决定。 #标注和参考标注 视图以较大比例显示另一个视图的一部分。可以使用静态方法ViewSection. callout（）创建标注视图。详图索引可以在“楼层平面”、“天花板平面”、“结构平面”、“剖面”、“立面”、“绘图”和“详图”视图中创建。生成的视图将是ViewSection、ViewPlan或ViewDetail，具体取决于所使用的ViewFamilyType，并将显示在项目浏览器的相应节点中。</p>
<p>代码区域：ViewSection. callout（）</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ViewSection ViewSection.CreateCallout(Document document, </span><br><span class="line">                                            ElementId parentViewId, </span><br><span class="line">                                            ElementId viewFamilyTypeId,</span><br><span class="line">                                            XYZ point1,</span><br><span class="line">                                            XYZ point2);</span><br></pre></td></tr></table></figure>

<p>父视图ID参数可以是可在其上创建详图索引的任何类型的视图的ID。点参数确定父视图中的图元符号的范围。参照图元是指引用现有视图的图元。添加参照视图时，Revit不会在项目中创建视图。相反，它创建一个指向指定的现有视图的指针。多个参照详图索引可以指向同一视图。</p>
<p>代码区域：ViewSection. ViewReferenceCallout（）</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ViewSection ViewSection.CreateReferenceCallout(Document document, </span><br><span class="line">                                                      ElementId parentViewId, </span><br><span class="line">                                                      ElementId viewIdToReference,</span><br><span class="line">                                                      XYZ point1,</span><br><span class="line">                                                      XYZ point2);</span><br></pre></td></tr></table></figure>

<p>创建引用对象与创建对象类似。但是，与其将视图的ViewFamilyType的Id作为参数，还不如将视图ReferenceCallout（）方法作为要引用的视图的Id。被引用视图的ViewFamilyType将由新引用对象使用。 只能参照裁剪的视图，除非参照的视图是“绘图”视图。无论父视图类型如何，始终可以参照绘图视图。立面视图可以从立面父视图和图纸父视图中参照。可以从“截面”和“绘图”父视图中参照截面视图。可以从所有父视图中参照详图视图，但在FloorPlan、CeilingPlan和StructuralPlan父视图中除外，在这些父视图中只能参照水平方向的详图视图。FloorPlan、CeilingPlan和StructuralPlan视图可以从FloorPlan、CeilingPlan和StructuralPlan父视图中引用。 下面的示例使用Detail ViewFamilyType创建新的图元，然后使用新的图元视图创建引用图元。</p>
<p>代码区域：创建对象和引用对象</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">CreateCalloutView</span>(<span class="params">Document document, View parentView</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Find a detail view type</span></span><br><span class="line">    IEnumerable viewFamilyTypes = <span class="function"><span class="keyword">from</span> elem <span class="keyword">in</span> <span class="keyword">new</span> <span class="title">FilteredElementCollector</span>(<span class="params">document</span>).<span class="title">OfClass</span>(<span class="params"><span class="keyword">typeof</span>(ViewFamilyType</span>))</span></span><br><span class="line"><span class="function">                                                    <span class="keyword">let</span> type</span> = elem <span class="keyword">as</span> ViewFamilyType</span><br><span class="line">                                                    <span class="keyword">where</span> type.ViewFamily == ViewFamily.Detail</span><br><span class="line">                                                    <span class="keyword">select</span> type;</span><br><span class="line"></span><br><span class="line">    ElementId viewFamilyTypeId = viewFamilyTypes.First().Id;    XYZ point1 = <span class="keyword">new</span> XYZ(<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">    XYZ point2 = <span class="keyword">new</span> XYZ(<span class="number">30</span>, <span class="number">30</span>, <span class="number">30</span>);</span><br><span class="line">    ElementId parentViewId = parentView.Id;  <span class="comment">// a ViewPlan</span></span><br><span class="line">    View view = ViewSection.CreateCallout(document, parentViewId, viewFamilyTypeId, point1, point2);</span><br><span class="line"></span><br><span class="line">    ViewSection.CreateReferenceCallout(document, parentViewId, view.Id, point1, point2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="图纸"><a href="#图纸" class="headerlink" title="图纸"></a>图纸</h3><p>图纸包含视图和标题栏。使用ViewSheet.Create（）方法创建图纸视图时，标题栏族符号Id是该方法的必需参数。可以使用FilteredElementCollector找到标题栏族符号。</p>
<p>代码区域：ViewSheet.Create（）</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ViewSheet ViewSheet.Create(Document document, ElementId titleBlockTypeId);</span><br></pre></td></tr></table></figure>

<p>新创建的图纸没有视图。Viewport.Create（）方法用于添加视图。Viewport类用于将常规视图添加到视图工作表，即平面、立面、绘图和三维视图。若要向视图添加明细表，请改用ScheduleSheetInstance.Create（）。</p>
<p>代码区域：添加两个在左角对齐的视图</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PlaceAlignedViewsAtLeftCorner</span>(<span class="params">Document doc</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    FilteredElementCollector fec = <span class="keyword">new</span> FilteredElementCollector(doc);</span><br><span class="line">    fec.OfClass(<span class="keyword">typeof</span>(ViewPlan));</span><br><span class="line">    <span class="keyword">var</span> viewPlans = fec.Cast().Where(vp =&gt; !vp.IsTemplate &amp;&amp; vp.ViewType == ViewType.CeilingPlan);</span><br><span class="line"></span><br><span class="line">    ViewPlan vp1 = viewPlans.ElementAt(<span class="number">0</span>);</span><br><span class="line">    ViewPlan vp2 = viewPlans.ElementAt(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> (Transaction t = <span class="keyword">new</span> Transaction(doc, <span class="string">&quot;Place on sheet&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        t.Start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Add two viewports distinct from one another</span></span><br><span class="line">        ViewSheet vs = ViewSheet.Create(doc, ElementId.InvalidElementId);</span><br><span class="line">        Viewport viewport1 = Viewport.Create(doc, vs.Id, vp1.Id, <span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">        Viewport viewport2 = Viewport.Create(doc, vs.Id, vp2.Id, <span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">5</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">        doc.Regenerate();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Calculate the necessary move vector to align the lower left corner</span></span><br><span class="line">        Outline outline1 = viewport1.GetBoxOutline();</span><br><span class="line">        Outline outline2 = viewport2.GetBoxOutline();</span><br><span class="line">        XYZ boxCenter = viewport2.GetBoxCenter();</span><br><span class="line">        XYZ vectorToCenter = boxCenter - outline2.MinimumPoint;</span><br><span class="line">        XYZ newCenter = outline1.MinimumPoint + vectorToCenter;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Move the viewport to the new location</span></span><br><span class="line">        viewport2.SetBoxCenter(newCenter);</span><br><span class="line"></span><br><span class="line">        t.Commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>XYZ位置参数标识添加的视图所在的位置。它指向添加的视图的中心坐标（以英寸为单位）。 坐标[0，0]是相对于工作表左下角的坐标。 在完整的图形集中，每张图纸都有唯一的图纸编号。该编号将显示在项目浏览器中图纸名称的前面。使用视图标题中的图纸编号可以方便地交叉参考图形集中的图纸。可以使用SheetNumber属性检索或修改编号。数字必须是唯一的;否则，当您将数字设置为重复值时，将引发异常。 下面的示例说明如何创建和打印工作表视图。开始，在文档中查找可用的标题栏（在本例中使用过滤器），然后使用它创建图纸视图。接下来，添加三维视图。视图将以其左下角位于图纸中心的方式放置。最后，通过调用View.Print（）方法打印工作表。</p>
<p>代码区域：创建图纸视图</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">CreateSheetView</span>(<span class="params">Autodesk.Revit.DB.Document document, View3D view3D</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get an available title block from document</span></span><br><span class="line">    FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">    collector.OfClass(<span class="keyword">typeof</span>(FamilySymbol));</span><br><span class="line">    collector.OfCategory(BuiltInCategory.OST_TitleBlocks);</span><br><span class="line"></span><br><span class="line">    FamilySymbol fs = collector.FirstElement() <span class="keyword">as</span> FamilySymbol;</span><br><span class="line">    <span class="keyword">if</span> (fs != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">using</span> (Transaction t = <span class="keyword">new</span> Transaction(document, <span class="string">&quot;Create a new ViewSheet&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            t.Start();</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// Create a sheet view</span></span><br><span class="line">                ViewSheet viewSheet = ViewSheet.Create(document, fs.Id);</span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">null</span> == viewSheet)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Failed to create new ViewSheet.&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Add passed in view onto the center of the sheet</span></span><br><span class="line">                UV location = <span class="keyword">new</span> UV((viewSheet.Outline.Max.U - viewSheet.Outline.Min.U) / <span class="number">2</span>,</span><br><span class="line">                                        (viewSheet.Outline.Max.V - viewSheet.Outline.Min.V) / <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//viewSheet.AddView(view3D, location);</span></span><br><span class="line">                Viewport.Create(document, viewSheet.Id, view3D.Id, <span class="keyword">new</span> XYZ(location.U, location.V, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Print the sheet out</span></span><br><span class="line">                <span class="keyword">if</span> (viewSheet.CanBePrinted)</span><br><span class="line">                &#123;</span><br><span class="line">                    TaskDialog taskDialog = <span class="keyword">new</span> TaskDialog(<span class="string">&quot;Revit&quot;</span>);</span><br><span class="line">                    taskDialog.MainContent = <span class="string">&quot;Print the sheet?&quot;</span>;</span><br><span class="line">                    TaskDialogCommonButtons buttons = TaskDialogCommonButtons.Yes | TaskDialogCommonButtons.No;</span><br><span class="line">                    taskDialog.CommonButtons = buttons;</span><br><span class="line">                    TaskDialogResult result = taskDialog.Show();</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (result == TaskDialogResult.Yes)</span><br><span class="line">                    &#123;</span><br><span class="line">                        viewSheet.Print();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                t.Commit();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span></span><br><span class="line">            &#123;</span><br><span class="line">                t.RollBack();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：不能将工作表视图添加到另一个工作表，也不能将视图添加到多个工作表;否则会发生参数异常。</p>
<p>表单修订</p>
<p>ViewSheet类有几种用于处理图纸上的修订和云线批注的方法。</p>
<ul>
<li>GetAllRevisionIds（）-获取参与图纸修订明细表的修订的有序数组。</li>
<li>GetAdditionalRevisionIds（）-获取图纸修订明细表中额外包含的修订。SetAdditionalRevisionIds（）-设置要另外包含在图纸修订明细表中的修订。</li>
<li>GetCurrentRevision（）-返回此视图表中显示的最新编号版本。</li>
<li>GetRevisionCloudNumberOnSheet（）-当项目中的编号是按图纸编号时，获取此图纸上RevisionCloud的修订号。</li>
<li>GetRevisionNumberOnSheet（）-获取特定修订的修订号，当项目中的编号是按图纸编号时，该修订号将显示在此图纸上。</li>
</ul>
<p> 根据项目中的修订顺序对修订进行排序。附加包含的修订将始终参与图纸的修订明细表。通常，修订明细表中会列出修订明细表，因为其关联的RevisionClouds之一存在于图纸中。 下面的代码示例演示如何向图纸添加与给定条件匹配的其他修订。</p>
<p>代码区域：向图纸添加其他修订</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">AddAdditionalRevisionsToSheet</span>(<span class="params">ViewSheet viewSheet, String toMatch</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Document doc = viewSheet.Document;</span><br><span class="line"></span><br><span class="line">    ICollection revisions = viewSheet.GetAdditionalRevisionIds();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find revisions whose description matches input string</span></span><br><span class="line">    FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(doc);</span><br><span class="line">    collector.OfCategory(BuiltInCategory.OST_Revisions);</span><br><span class="line">    collector.WhereElementIsNotElementType();</span><br><span class="line">    <span class="keyword">if</span> (revisions.Count &gt; <span class="number">0</span>)</span><br><span class="line">        collector.Excluding(revisions);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check if revision should be added</span></span><br><span class="line">    <span class="keyword">foreach</span> (Element revision <span class="keyword">in</span> collector)</span><br><span class="line">    &#123;</span><br><span class="line">        Parameter descriptionParam = revision.get_Parameter(BuiltInParameter.PROJECT_REVISION_REVISION_DESCRIPTION);</span><br><span class="line">        String description = descriptionParam.AsString();</span><br><span class="line">        <span class="keyword">if</span> (description.Contains(toMatch))</span><br><span class="line">            revisions.Add(revision.Id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (revisions.Count &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Apply the new list of revisions</span></span><br><span class="line">        <span class="keyword">using</span> (Transaction t = <span class="keyword">new</span> Transaction(doc, <span class="string">&quot;Add revisions to sheet&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            t.Start();</span><br><span class="line">            viewSheet.SetAdditionalRevisionIds(revisions);</span><br><span class="line">            t.Commit();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="打印机设置"><a href="#打印机设置" class="headerlink" title="打印机设置"></a>打印机设置</h4><p>在打印纸张之前，您可能需要更改打印机的设置。API使用PrintManager类和相关的Autodesk. Revit. DB类公开打印机的设置：</p>
<table>
<thead>
<tr>
<th><strong>Class 类</strong></th>
<th><strong>Functionality 功能</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Autodesk.Revit.DB.PrintManager</td>
<td>表示Revit UI中“打印”对话框（文件-&gt;Print）中的打印信息。</td>
</tr>
<tr>
<td>Autodesk.Revit.DB.PrintParameters</td>
<td>包含用于打印文档的设置的对象。</td>
</tr>
<tr>
<td>Autodesk.Revit.DB.PrintSetup</td>
<td>表示打印设置（文件-&gt;Print Setup…）在Revit UI中。</td>
</tr>
<tr>
<td>Autodesk.Revit.DB.PaperSize</td>
<td>表示Autodesk Revit项目中打印设置纸张尺寸的对象。</td>
</tr>
<tr>
<td>Autodesk.Revit.DB.PaperSizeSet</td>
<td>可以包含任意数量的纸张大小对象的集合。</td>
</tr>
<tr>
<td>Autodesk.Revit.DB.PaperSource</td>
<td>表示Autodesk Revit项目中打印设置的纸张来源的对象。</td>
</tr>
<tr>
<td>Autodesk.Revit.DB.PaperSourceSet</td>
<td>可以包含任意数量纸张源对象的集合。</td>
</tr>
<tr>
<td>Autodesk.Revit.DB.ViewSheetSetting</td>
<td>表示Revit UI中的视图&#x2F;图纸集（文件-&gt;Print）。</td>
</tr>
<tr>
<td>Autodesk.Revit.DB.PrintSetting</td>
<td>表示打印设置（文件-&gt;Print Setup…）在Revit UI中。</td>
</tr>
</tbody></table>
<p>有关使用这些对象的代码示例，请参见随Revit Platform SDK提供的ViewPrinter示例应用程序。</p>
<h3 id="图表"><a href="#图表" class="headerlink" title="图表"></a>图表</h3><p>此类表示显示数据表的视图。</p>
<p>TableView是ViewSchedule和PanelScheduleView的基类。</p>
<p>本节中的页面</p>
<ul>
<li>Schedule Classes 明细表类</li>
<li>ViewSchedule 视图明细表</li>
<li>PanelScheduleView 配电盘明细表</li>
</ul>
<h4 id="明细表类"><a href="#明细表类" class="headerlink" title="明细表类"></a>明细表类</h4><p>明细表视图使用多个支持类。</p>
<p>TableView是一个表示显示表的视图的类，它是ViewSchedule和PanelScheduleView的基类。它有一个关联的TableData类，其中包含一个或多个节。对于ViewSchedule，只有一个页眉和一个正文部分。</p>
<p>TableSectionData类表示按行和列排列的一组连续单元格。对于ViewSchedule，TableSectionData的单元格内容由ScheduleDefinition和参数生成。此外，对于ViewSchedules，虽然头部分具有读&#x2F;写权限，但主体部分是只读的。</p>
<h5 id="使用明细表中的数据"><a href="#使用明细表中的数据" class="headerlink" title="使用明细表中的数据"></a>使用明细表中的数据</h5><p>表的实际数据包含在TableData类中。虽然无法直接从TableView类获取TableData对象，但两个子类都有GetTableData（）方法。对于ViewSchedule，此方法返回一个TableData对象。对于PanelScheduleView，GetTableData（）返回PanelScheduleData对象，该对象派生自TableData基类。TableData类保存描述表中行、列和单元格样式的大部分数据。PanelScheduleData提供了专门与配电盘明细表相关的其他方法。</p>
<p>使用行、列和单元格<br>表中的数据被分解为多个部分。要使用TableData的行、列和单元格，需要获取TableSectionData对象。GetSectionData（）可以使用请求的节数据的整数或使用SectionType（即Header或Body）调用。</p>
<p>TableSectionData类可用于插入或删除行或列，格式化单元格，以及获取组成该明细表部分的单元格的详细信息，例如单元格类型（即文本或图形）或单元格的类别ID。</p>
<p>在下面的示例中，将新行添加到明细表的页眉部分，并为新创建的单元格设置文本。请注意，在使用UI创建时，页眉部分的第一行默认为标题。</p>
<p>代码区域：插入行</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">CreateSubtitle</span>(<span class="params">ViewSchedule schedule</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    TableData colTableData = schedule.GetTableData();</span><br><span class="line"></span><br><span class="line">    TableSectionData tsd = colTableData.GetSectionData(SectionType.Header);</span><br><span class="line">    tsd.InsertRow(tsd.FirstRowNumber + <span class="number">1</span>);</span><br><span class="line">    tsd.SetCellText(tsd.FirstRowNumber + <span class="number">1</span>, tsd.FirstColumnNumber, <span class="string">&quot;Schedule of column top and base levels with offsets&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另请注意，在上面的代码示例中，它使用了FirstRowNumber和FirstColumnNumber属性。在某些部分中，行或列编号可能以0开头，也可能以1开头。这些属性应始终用于代替硬编码的0或1。 在下面的示例中，将创建一个带有自定义页眉节的新单类别明细表。</p>
<p>代码区域：自定义标题部分</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CreateSingleCategoryScheduleWithSimpleHeaderSection</span>(<span class="params">Document doc</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> (Transaction t = <span class="keyword">new</span> Transaction(doc, <span class="string">&quot;Create single-category with custom headers&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Build schedule</span></span><br><span class="line">        t.Start();</span><br><span class="line">        ViewSchedule vs = ViewSchedule.CreateSchedule(doc, <span class="keyword">new</span> ElementId(BuiltInCategory.OST_Windows));</span><br><span class="line"></span><br><span class="line">        AddRegularFieldToSchedule(vs, <span class="keyword">new</span> ElementId(BuiltInParameter.WINDOW_HEIGHT));</span><br><span class="line">        AddRegularFieldToSchedule(vs, <span class="keyword">new</span> ElementId(BuiltInParameter.WINDOW_WIDTH));</span><br><span class="line">        AddRegularFieldToSchedule(vs, <span class="keyword">new</span> ElementId(BuiltInParameter.ALL_MODEL_MARK));</span><br><span class="line">        AddRegularFieldToSchedule(vs, <span class="keyword">new</span> ElementId(BuiltInParameter.ALL_MODEL_COST));</span><br><span class="line"></span><br><span class="line">        doc.Regenerate();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Get header section</span></span><br><span class="line">        TableSectionData data = vs.GetTableData().GetSectionData(SectionType.Header);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">int</span> rowNumber = data.LastRowNumber;</span><br><span class="line">        <span class="built_in">int</span> columnNumber = data.LastColumnNumber;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Get the overall width of the table so that the new columns can be resized properly</span></span><br><span class="line">        <span class="built_in">double</span> tableWidth = data.GetColumnWidth(columnNumber);</span><br><span class="line"></span><br><span class="line">        data.InsertColumn(columnNumber);</span><br><span class="line">        data.InsertColumn(columnNumber);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Refresh data to be sure that schedule is ready for text insertion</span></span><br><span class="line">        vs.RefreshData();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Set text to the first header cell</span></span><br><span class="line">        data.SetCellText(rowNumber, data.FirstColumnNumber, <span class="string">&quot;Special Window Schedule Text&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Set width of first column</span></span><br><span class="line">        data.SetColumnWidth(data.FirstColumnNumber, tableWidth / <span class="number">3.0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Set a different parameter to the second cell - the project name</span></span><br><span class="line">        data.SetCellParamIdAndCategoryId(rowNumber, data.FirstRowNumber + <span class="number">1</span>, <span class="keyword">new</span> ElementId(BuiltInParameter.PROJECT_NAME),</span><br><span class="line">                                            <span class="keyword">new</span> ElementId(BuiltInCategory.OST_ProjectInformation));</span><br><span class="line">        data.SetColumnWidth(data.FirstColumnNumber + <span class="number">1</span>, tableWidth / <span class="number">3.0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Set the third column as the schedule view name - use the special category for schedule parameters for this</span></span><br><span class="line">        data.SetCellParamIdAndCategoryId(rowNumber, data.LastColumnNumber, <span class="keyword">new</span> ElementId(BuiltInParameter.VIEW_NAME),</span><br><span class="line">                                            <span class="keyword">new</span> ElementId(BuiltInCategory.OST_ScheduleViewParamGroup));</span><br><span class="line">        data.SetColumnWidth(data.LastColumnNumber, tableWidth / <span class="number">3.0</span>);</span><br><span class="line"></span><br><span class="line">        t.Commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">AddRegularFieldToSchedule</span>(<span class="params">ViewSchedule schedule, ElementId paramId</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ScheduleDefinition definition = schedule.Definition;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find a matching SchedulableField</span></span><br><span class="line">    SchedulableField schedulableField =</span><br><span class="line">        definition.GetSchedulableFields().FirstOrDefault(sf =&gt; sf.ParameterId == paramId);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (schedulableField != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Add the found field</span></span><br><span class="line">        definition.AddField(schedulableField);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以为明细表自定义行、列或单个单元格的样式。这包括为单元格的所有四边设置边框线样式，以及单元格颜色和文本外观（即颜色，字体，大小）的能力。对于常规计划，只能在表格的标题部分执行此操作。 在下面的示例中，ViewSchedule的副标题（假定为标题部分的第二行）的字体设置为粗体，字体大小设置为10。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">FormatSubtitle</span>(<span class="params">ViewSchedule colSchedule</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    TableData colTableData = colSchedule.GetTableData();</span><br><span class="line"></span><br><span class="line">    TableSectionData tsd = colTableData.GetSectionData(SectionType.Header);</span><br><span class="line">    <span class="comment">// Subtitle is second row, first column</span></span><br><span class="line">    <span class="keyword">if</span> (tsd.AllowOverrideCellStyle(tsd.FirstRowNumber + <span class="number">1</span>, tsd.FirstColumnNumber))</span><br><span class="line">    &#123;</span><br><span class="line">        TableCellStyle tcs = <span class="keyword">new</span> TableCellStyle();</span><br><span class="line">        TableCellStyleOverrideOptions options = <span class="keyword">new</span> TableCellStyleOverrideOptions();</span><br><span class="line">        options.FontSize = <span class="literal">true</span>;</span><br><span class="line">        options.Bold = <span class="literal">true</span>;</span><br><span class="line">        tcs.SetCellStyleOverrideOptions(options);</span><br><span class="line">        tcs.IsFontBold = <span class="literal">true</span>;</span><br><span class="line">        tcs.TextSize = <span class="number">10</span>;</span><br><span class="line">        tsd.SetCellStyle(tsd.FirstRowNumber + <span class="number">1</span>, tsd.FirstColumnNumber, tcs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="视图明细表"><a href="#视图明细表" class="headerlink" title="视图明细表"></a>视图明细表</h4><p>明细表是数据的表格表示形式。典型明细表显示类别的所有图元（门、房间等）。每行表示一个元素，每列表示一个参数。</p>
<p>ViewSchedule类表示明细表和其他类似明细表的视图，包括单类别和多类别明细表、关键字明细表、材质提取、视图列表、图纸列表、注释记号图例、修订明细表和注释块。</p>
<p>ViewSchedule.Export（）方法将日程数据导出到文本文件中。</p>
<p>在图纸上放置明细表</p>
<p>静态ScheduleSheetInstance.Create（）方法在工作表上创建明细表的实例。它需要要放置明细表的图纸的ID、明细表视图的ID以及要放置明细表的图纸上的XYZ位置。ScheduleSheetInstance对象具有用于访问生成此ScheduleSheetInstance的“主”明细表的ID、明细表在图纸上的旋转、明细表在图纸上的放置位置（在图纸坐标中）以及标识ScheduleSheetInstance是否为标题栏族中的修订明细表的标志的属性。</p>
<p>本节中的页面</p>
<ul>
<li>创建明细表</li>
<li>使用视图明细表</li>
</ul>
<h5 id="创建明细表"><a href="#创建明细表" class="headerlink" title="创建明细表"></a>创建明细表</h5><p>ViewSchedule类有几种方法用于根据计划类型创建新明细表。所有这些方法都有一个Document参数，该参数是要向其中添加新明细表或类似明细表的视图的文档。新创建的明细表视图将显示在项目浏览器中的“明细表&#x2F;明细表”节点下。</p>
<p>标准的单类别或多类别明细表可以用静态ViewSchedule. fullSchedule（）方法创建。</p>
<p>代码区域：创建具有2个字段的单一类别明细表</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CreateSingleCategorySchedule</span>(<span class="params">Document doc</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> (Transaction t = <span class="keyword">new</span> Transaction(doc, <span class="string">&quot;Create single-category&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        t.Start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create schedule</span></span><br><span class="line">        ViewSchedule vs = ViewSchedule.CreateSchedule(doc, <span class="keyword">new</span> ElementId(BuiltInCategory.OST_Windows));</span><br><span class="line"></span><br><span class="line">        doc.Regenerate();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Add fields to the schedule</span></span><br><span class="line">        AddRegularFieldToSchedule(vs, <span class="keyword">new</span> ElementId(BuiltInParameter.WINDOW_HEIGHT));</span><br><span class="line">        AddRegularFieldToSchedule(vs, <span class="keyword">new</span> ElementId(BuiltInParameter.WINDOW_WIDTH));</span><br><span class="line"></span><br><span class="line">        t.Commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> </span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> Adds a single parameter field to the schedule</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">AddRegularFieldToSchedule</span>(<span class="params">ViewSchedule schedule, ElementId paramId</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ScheduleDefinition definition = schedule.Definition;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find a matching SchedulableField</span></span><br><span class="line">    SchedulableField schedulableField =</span><br><span class="line">        definition.GetSchedulableFields().FirstOrDefault(sf =&gt; sf.ParameterId == paramId);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (schedulableField != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Add the found field</span></span><br><span class="line">        definition.AddField(schedulableField);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二个参数是其图元将包含在明细表中的类别的ID，或者是多类别明细表的InvalidElementId。 第二个RISKSchedule（）方法可用于创建面积明细表，并接受一个附加参数，即明细表的面积方案ID。</p>
<p>代码区域：创建面积明细表</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(doc);</span><br><span class="line">collector.OfCategory(BuiltInCategory.OST_AreaSchemes);</span><br><span class="line"><span class="comment">//Get first ElementId of AreaScheme.</span></span><br><span class="line">ElementId areaSchemeId = collector.FirstElementId();</span><br><span class="line"><span class="keyword">if</span> (areaSchemeId != <span class="literal">null</span> &amp;&amp; areaSchemeId != ElementId.InvalidElementId)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// If you want to create an area schedule, you must use CreateSchedule method with three arguments. </span></span><br><span class="line">    <span class="comment">// The value of the second argument must be ElementId of BuiltInCategory.OST_Areas category</span></span><br><span class="line">    <span class="comment">// and the value of third argument must be ElementId of an AreaScheme.</span></span><br><span class="line">    areaSchedule = Autodesk.Revit.DB.ViewSchedule.CreateSchedule(doc, <span class="keyword">new</span> ElementId(BuiltInCategory.OST_Areas), areaSchemeId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关键字明细表显示抽象的“关键”元素，这些元素可用于填充普通模型元素的参数，并且可以使用静态ViewSchedule.CreateKeySchedule（）方法创建，该方法的第二个参数是明细表的关键字将与之关联的元素类别的ID。材料提取是一个明细表，显示有关构成模型中元素的材料的信息。与每行（分组前）表示单个元素的常规明细表不同，材料提取中的每行表示单个&lt;元素、材料&gt;对。ViewSchedule. AccessMaterialTakeoff（）方法具有与ViewSchedule. AccessSchedule（）方法相同的参数，并且允许单类别和多类别材质提取明细表。 视图列表、图纸列表和注释记号图例与指定类别相关联，因此它们的创建方法将类别ID作为参数。视图列表是项目中视图的明细表。它是视图类别的明细表，使用ViewSchedule. ViewList（）创建。 图纸列表是项目中图纸的明细表。它是“图纸”类别的明细表，使用ViewSchedule. SetSheetList（）方法创建。 注释记号图例是“注释记号标记”类别的明细表，可使用ViewSchedule.CreateKeynoteLegend（）创建。 修订明细表将添加到标题栏族中，并作为图纸上标题栏的一部分可见。如果传入的文档不是标题栏族，ViewSchedule. RevisionSchedule（）方法将引发异常。 注释块是“常规注释”类别的明细表，它显示单个族的图元，而不是类别中的所有图元。</p>
<p>代码区域：ViewSchedule. NoteBlock（）</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ViewSchedule ViewSchedule.CreateNoteBlock(Document document, ElementId familyId);</span><br></pre></td></tr></table></figure>

<p>第二个参数是其图元将包含在明细表中的族的ID。</p>
<p>代码区域：创建注释块明细表</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> (Transaction transaction = <span class="keyword">new</span> Transaction(doc, <span class="string">&quot;Creating Note BLock&quot;</span>))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//Get first ElementId of a Note Block family.</span></span><br><span class="line">    ICollection noteblockFamilies = ViewSchedule.GetValidFamiliesForNoteBlock(doc);</span><br><span class="line">    ElementId symbolId = noteblockFamilies.First();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!symbolId.Equals(ElementId.InvalidElementId))</span><br><span class="line">    &#123;</span><br><span class="line">        transaction.Start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Create a note-block view schedule.</span></span><br><span class="line">        noteBlockSchedule = ViewSchedule.CreateNoteBlock(doc, symbolId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> != areaSchedule)</span><br><span class="line">    &#123;</span><br><span class="line">        transaction.Commit();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        transaction.RollBack();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="使用ViewSchedule"><a href="#使用ViewSchedule" class="headerlink" title="使用ViewSchedule"></a>使用ViewSchedule</h5><p>ScheduleDefinition类帮助定义ViewSchedule。</p>
<p>ScheduleDefinition类包含与明细表视图内容相关的各种设置，包括：</p>
<ul>
<li>明细表的类别和其他确定明细表类型的基本属性。</li>
<li>成为明细表列的一组字段。</li>
<li>排序和分组标准。</li>
<li>限制明细表中可见图元集的过滤器。</li>
<li>控制标题和&#x2F;或页眉可见性的设置。</li>
</ul>
<p>大多数计划都包含一个通过ViewSchedule.Definition属性检索的ScheduleDefinition。在Revit中，某些类别的明细表可以包含一个“嵌入式明细表”，其中包含与主明细表中的图元相关联的图元，例如，显示每个房间内图元的房间明细表或显示与每个系统相关联的图元的风管系统明细表。嵌入的计划有自己的类别、字段、过滤器等。这些设置存储在第二个ScheduleDefinition对象中。如果存在，则从ScheduleDefinition.EmbeddedDefinition属性获取嵌入的ScheduleDefinition。</p>
<h6 id="添加字段"><a href="#添加字段" class="headerlink" title="添加字段"></a>添加字段</h6><p>创建视图明细表后，可以添加字段。ScheduleDefinition. GetControlableFields（）方法将返回一个ControlableField对象的列表，这些对象表示可能包含在计划中的非计算字段。新字段可以从可扩展字段对象或使用ScheduleFieldType添加。下表描述了可从ScheduleFieldType枚举中使用的选项。</p>
<table>
<thead>
<tr>
<th><strong>Member name 成员名称</strong></th>
<th><strong>Description 描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Instance</td>
<td>明细表图元的实例参数。所有共享参数也都使用此类型，无论它们是实例参数还是类型参数。</td>
</tr>
<tr>
<td>ElementType</td>
<td>明细表图元的类型参数。</td>
</tr>
<tr>
<td>Count</td>
<td>明细表行上显示的图元数。</td>
</tr>
<tr>
<td>ViewBased</td>
<td>用于一些参数的专用字段类型，这些参数的显示值可以根据视图的设置而更改：<em>房间明细表和空间明细表中的ROOM_AREA和ROOM_PERIMETER。</em>修订明细表中的PROJECT_REVISION_REVISION_NUM。<em>注释记号图例中按图纸编号的KEYNOTE_NUMBER。</em></td>
</tr>
<tr>
<td>Formula</td>
<td>根据明细表中其他字段的值计算的公式。</td>
</tr>
<tr>
<td>Percentage</td>
<td>一个值，指示每个元素表示的另一个字段的总和的百分比。</td>
</tr>
<tr>
<td>Room</td>
<td>明细表图元所属房间的参数。</td>
</tr>
<tr>
<td>FromRoom</td>
<td>门或窗的“从”侧房间的参数。</td>
</tr>
<tr>
<td>ToRoom</td>
<td>门或窗“向”侧的房间参数。</td>
</tr>
<tr>
<td>ProjectInfo</td>
<td>明细表图元所属项目中的“项目信息”图元的参数，可以是链接文件。仅允许在包含链接文件图元的明细表中使用。</td>
</tr>
<tr>
<td>Material</td>
<td>在材质提取中，明细表图元的一种材质的参数。</td>
</tr>
<tr>
<td>MaterialQuantity</td>
<td>在材质提取中，表示如何在明细表图元中使用特定材质的值。参数ID可以是MATERIAL_AREA、MATERIAL_VOLUME或MATERIAL_ASPAINT。</td>
</tr>
<tr>
<td>RevitLinkInstance</td>
<td>链接文件中的元素所属的RevitLinkInstance的参数。当前，RVT_LINK_RELANCE_NAME是唯一受支持的参数。仅允许在包含链接文件图元的明细表中使用。</td>
</tr>
<tr>
<td>RevitLinkType</td>
<td>链接文件中的元素所属的RevitLinkType的参数。当前，RVT_LINK_FILE_NAME_WITHOUT_EXT是唯一受支持的参数。仅允许在包含链接文件图元的明细表中使用。</td>
</tr>
<tr>
<td>StructuralMaterial</td>
<td>明细表图元的结构材质参数。</td>
</tr>
<tr>
<td>Space</td>
<td>明细表图元所属空间的参数。</td>
</tr>
</tbody></table>
<p>使用一个ScheduleDefinition.AddField（）方法将把字段添加到字段列表的末尾。若要将新字段放置在字段列表中的特定位置，请使用ScheduleDefinition.InsertField（）方法之一。还可以在事后使用ScheduleDefinition.SetFieldOrder（）对字段进行排序。 下面是一个简单的示例，显示了如何在视图明细表中没有字段的情况下向视图添加字段。</p>
<p>代码区域：向明细表添加字段</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> </span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> Add fields to view schedule.</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> </span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> List of view schedule.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddFieldToSchedule</span>(<span class="params">List schedules</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    IList schedulableFields = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">foreach</span> (ViewSchedule vs <span class="keyword">in</span> schedules)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//Get all schedulable fields from view schedule definition.</span></span><br><span class="line">        schedulableFields = vs.Definition.GetSchedulableFields();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">foreach</span> (SchedulableField sf <span class="keyword">in</span> schedulableFields)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">bool</span> fieldAlreadyAdded = <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">//Get all schedule field ids</span></span><br><span class="line">            IList ids = vs.Definition.GetFieldOrder();</span><br><span class="line">            <span class="keyword">foreach</span> (ScheduleFieldId id <span class="keyword">in</span> ids)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//If the GetSchedulableField() method of gotten schedule field returns same schedulable field,</span></span><br><span class="line">                <span class="comment">// it means the field is already added to the view schedule.</span></span><br><span class="line">                <span class="keyword">if</span> (vs.Definition.GetField(id).GetSchedulableField() == sf)</span><br><span class="line">                &#123;</span><br><span class="line">                    fieldAlreadyAdded = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//If schedulable field doesn&#x27;t exist in view schedule, add it.</span></span><br><span class="line">            <span class="keyword">if</span> (fieldAlreadyAdded == <span class="literal">false</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                vs.Definition.AddField(sf);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ScheduleField类表示ScheduleDefinition的字段列表中的单个字段。每个（非隐藏）字段都将成为明细表中的一列。 最常见的情况是，字段表示明细表中出现的图元的实例或类型参数。某些字段表示其他相关图元的参数，如明细表图元所属的房间。字段还可以表示从明细表中的其他字段（特别是公式和百分比字段）计算的数据。 ScheduleField类具有控制列标题（包括文本和方向）的属性。也可以定义列内文本的列宽和水平对齐方式。 ScheduleField.IsHidden属性可用于隐藏字段。隐藏字段不显示在明细表中，但可用于筛选、排序、分组和条件格式设置，并且可由公式和百分比字段引用。</p>
<p>DisplayType</p>
<p>ScheduleField有一个DisplayType属性，用于指示字段的显示类型。可能的值为： 标准-如果元素的值不同，则不显示任何内容，否则将显示公共值总计-计算并显示总计值最小值最大值-计算并显示最小值和最大值最小值-计算并显示最大值最大值-计算并显示最小值 方法指示此字段是否可以显示最小值和最大值。 在非分项明细表中，当多个图元显示在同一行中时，非标准显示类型的值将显示在常规行中。 #字段的样式和格式 ScheduleField.GetStyle（）和ScheduleField.SetStyle（）使用TableCellStyle类来处理明细表中字段的样式。使用SetStyle（），可以设置字段的各种属性，包括单元格边框的线条样式以及文本字体、颜色和大小。 ScheduleField. SetOptions（）和ScheduleField. GetOptions（）使用DataOptions类来处理字段数据的格式。FormatOptions类包含控制如何将数字与单位格式化为字符串的设置。它包含通常由最终用户在“格式”对话框中选择并存储在文档中的设置。 在以下示例中，ViewSchedule中的所有长度字段都设置为以英尺和小数英寸为单位显示。</p>
<p>代码区域：格式化字段</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// format length units to display in feet and inches format</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">FormatLengthFields</span>(<span class="params">ViewSchedule schedule</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> nFields = schedule.Definition.GetFieldCount();</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> n = <span class="number">0</span>; n &lt; nFields; n++)</span><br><span class="line">    &#123;</span><br><span class="line">        ScheduleField field = schedule.Definition.GetField(n);</span><br><span class="line">        <span class="keyword">if</span> (field.UnitType == UnitType.UT_Length)</span><br><span class="line">        &#123;</span><br><span class="line">            FormatOptions formatOpts = <span class="keyword">new</span> FormatOptions();</span><br><span class="line">            formatOpts.UseDefault = <span class="literal">false</span>;</span><br><span class="line">            formatOpts.DisplayUnits = DisplayUnitType.DUT_FEET_FRACTIONAL_INCHES;</span><br><span class="line">            field.SetFormatOptions(formatOpts);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面的示例将格式和样式重写应用于给定字段。</p>
<p>代码区域：对字段应用格式和样式重写</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ApplyFormattingToField</span>(<span class="params">ViewSchedule schedule, <span class="built_in">int</span> fieldIndex</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Get the field.</span></span><br><span class="line">    ScheduleDefinition definition = schedule.Definition;</span><br><span class="line">    ScheduleField field = definition.GetField(fieldIndex);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Build unit formatting for the field.</span></span><br><span class="line">    FormatOptions options = field.GetFormatOptions();</span><br><span class="line">    options.UseDefault = <span class="literal">false</span>;</span><br><span class="line">    options.DisplayUnits = DisplayUnitType.DUT_SQUARE_INCHES;</span><br><span class="line">    options.UnitSymbol = UnitSymbolType.UST_IN_SUP_2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Build style overrides for the field</span></span><br><span class="line">    <span class="comment">// Use override options to indicate fields that are overridden and apply changes</span></span><br><span class="line">    TableCellStyle style = field.GetStyle();</span><br><span class="line">    TableCellStyleOverrideOptions overrideOptions = style.GetCellStyleOverrideOptions();</span><br><span class="line">    overrideOptions.BackgroundColor = <span class="literal">true</span>;</span><br><span class="line">    style.BackgroundColor = <span class="keyword">new</span> Color(<span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xFF</span>);</span><br><span class="line">    overrideOptions.FontColor = <span class="literal">true</span>;</span><br><span class="line">    style.TextColor = <span class="keyword">new</span> Color(<span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>);</span><br><span class="line">    overrideOptions.Italics = <span class="literal">true</span>;</span><br><span class="line">    style.IsFontItalic = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    style.SetCellStyleOverrideOptions(overrideOptions);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">double</span> width = field.GridColumnWidth;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> (Transaction t = <span class="keyword">new</span> Transaction(schedule.Document, <span class="string">&quot;Set style etc&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        t.Start();</span><br><span class="line">        field.SetStyle(style);</span><br><span class="line">        field.SetFormatOptions(options);</span><br><span class="line">        <span class="comment">// Change column width (affects width in grid and on sheet) - units are in Revit length units - ft.</span></span><br><span class="line">        field.GridColumnWidth = width + <span class="number">0.5</span>;</span><br><span class="line">        t.Commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="标题和标头"><a href="#标题和标头" class="headerlink" title="标题和标头"></a>标题和标头</h6><p>明细表标题和&#x2F;或页眉的显示是可选的。是否显示标题或标头可以使用ScheduleDefinition属性ShowTitle和ShowHeaders控制。</p>
<h6 id="明细表中的查询和排序"><a href="#明细表中的查询和排序" class="headerlink" title="明细表中的查询和排序"></a>明细表中的查询和排序</h6><p>可以按计划的一个或多个字段对计划进行排序或分组。有几种方法可用于控制字段的分组和排序。ScheduleSortGroupField类表示用于对计划进行排序或分组的字段之一。排序和分组是相关的操作。无论哪种情况，明细表中出现的元素都将根据其字段值进行排序，明细表将根据该字段值进行排序&#x2F;分组，这会自动将具有相同值的元素分组在一起。通过启用额外的页眉、页脚或空白行，可以实现组之间的视觉分隔。</p>
<p>如果ScheduleDefinition.IsItemized属性为false，则用于排序&#x2F;分组的所有字段具有相同值的元素将合并到同一行中。否则，明细表将在单独的行中显示每个元素</p>
<p>通过使用ScheduleField.IsHidden属性将用于排序&#x2F;分组的字段标记为隐藏，可以按计划中未显示的数据对计划进行排序或分组。</p>
<p>代码区域：将分组&#x2F;排序添加到计划</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">AddGroupingToSchedule</span>(<span class="params">ViewSchedule schedule, BuiltInParameter paramEnum, <span class="built_in">bool</span> withTotalsAndDecoration, ScheduleSortOrder order</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Find field </span></span><br><span class="line">    ScheduleField field = FindField(schedule, paramEnum);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (field == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Unable to find field.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Build sort/group field.</span></span><br><span class="line">    ScheduleSortGroupField sortGroupField = <span class="keyword">new</span> ScheduleSortGroupField(field.FieldId, order);</span><br><span class="line">    <span class="keyword">if</span> (withTotalsAndDecoration)</span><br><span class="line">    &#123;</span><br><span class="line">        sortGroupField.ShowFooter = <span class="literal">true</span>;</span><br><span class="line">        sortGroupField.ShowFooterTitle = <span class="literal">true</span>;</span><br><span class="line">        sortGroupField.ShowFooterCount = <span class="literal">true</span>;</span><br><span class="line">        sortGroupField.ShowHeader = <span class="literal">true</span>;</span><br><span class="line">        sortGroupField.ShowBlankLine = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add the sort/group field</span></span><br><span class="line">    ScheduleDefinition definition = schedule.Definition;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> (Transaction t = <span class="keyword">new</span> Transaction(schedule.Document, <span class="string">&quot;Add sort/group field&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        t.Start();</span><br><span class="line">        definition.AddSortGroupField(sortGroupField);</span><br><span class="line">        t.Commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduleField <span class="title">FindField</span>(<span class="params">ViewSchedule schedule, BuiltInParameter paramEnum</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ScheduleDefinition definition = schedule.Definition;</span><br><span class="line">    ScheduleField foundField = <span class="literal">null</span>;</span><br><span class="line">    ElementId paramId = <span class="keyword">new</span> ElementId(paramEnum);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">foreach</span> (ScheduleFieldId fieldId <span class="keyword">in</span> definition.GetFieldOrder())</span><br><span class="line">    &#123;</span><br><span class="line">        foundField = definition.GetField(fieldId);</span><br><span class="line">        <span class="keyword">if</span> (foundField.ParameterId == paramId)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> foundField;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>标头也可以分组。GroupHeaders（）方法可用于指定在标题部分的分组中包括哪些行和列。最后一个参数是一个字符串，表示分组的行和列的标头。 在下面的示例中，将为新创建的单类别明细表对列进行分组。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CreateSingleCategoryScheduleWithGroupedColumnHeaders</span>(<span class="params">Document doc</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> (Transaction t = <span class="keyword">new</span> Transaction(doc, <span class="string">&quot;Create single-category with grouped column headers&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Build the schedule</span></span><br><span class="line">        t.Start();</span><br><span class="line">        ViewSchedule vs = ViewSchedule.CreateSchedule(doc, <span class="keyword">new</span> ElementId(BuiltInCategory.OST_Windows));</span><br><span class="line"></span><br><span class="line">        AddRegularFieldToSchedule(vs, <span class="keyword">new</span> ElementId(BuiltInParameter.WINDOW_HEIGHT));</span><br><span class="line">        AddRegularFieldToSchedule(vs, <span class="keyword">new</span> ElementId(BuiltInParameter.WINDOW_WIDTH));</span><br><span class="line">        AddRegularFieldToSchedule(vs, <span class="keyword">new</span> ElementId(BuiltInParameter.ALL_MODEL_MARK));</span><br><span class="line">        AddRegularFieldToSchedule(vs, <span class="keyword">new</span> ElementId(BuiltInParameter.ALL_MODEL_COST));</span><br><span class="line"></span><br><span class="line">        doc.Regenerate();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Group the headers in the body section using ViewSchedule methods</span></span><br><span class="line">        vs.GroupHeaders(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="string">&quot;Size&quot;</span>);</span><br><span class="line">        vs.GroupHeaders(<span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="string">&quot;Other&quot;</span>);</span><br><span class="line">        vs.GroupHeaders(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="string">&quot;All&quot;</span>);</span><br><span class="line"></span><br><span class="line">        t.Commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">AddRegularFieldToSchedule</span>(<span class="params">ViewSchedule schedule, ElementId paramId</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ScheduleDefinition definition = schedule.Definition;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find a matching SchedulableField</span></span><br><span class="line">    SchedulableField schedulableField =</span><br><span class="line">        definition.GetSchedulableFields().FirstOrDefault(sf =&gt; sf.ParameterId == paramId);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (schedulableField != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Add the found field</span></span><br><span class="line">        definition.AddField(schedulableField);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h6><p>可使用“明细表过滤器”来过滤将在明细表中显示的图元。过滤器是要使图元显示在明细表中必须满足的条件。要使图元显示在明细表中，必须满足所有筛选条件。</p>
<p>通过使用ScheduleField.IsHidden属性将用于筛选的字段标记为隐藏，可以按未显示在计划中的数据筛选计划。</p>
<p>代码区域：将筛选器添加到计划</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">AddFilterToSchedule</span>(<span class="params">ViewSchedule schedule, ElementId levelId</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Find level field</span></span><br><span class="line">    ScheduleDefinition definition = schedule.Definition;</span><br><span class="line"></span><br><span class="line">    ScheduleField levelField = FindField(schedule, BuiltInParameter.ROOM_LEVEL_ID);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add filter</span></span><br><span class="line">    <span class="keyword">using</span> (Transaction t = <span class="keyword">new</span> Transaction(schedule.Document, <span class="string">&quot;Add filter&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        t.Start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If field not present, add it</span></span><br><span class="line">        <span class="keyword">if</span> (levelField == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            levelField = definition.AddField(ScheduleFieldType.Instance, <span class="keyword">new</span> ElementId(BuiltInParameter.ROOM_LEVEL_ID));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Set field to hidden</span></span><br><span class="line">        levelField.IsHidden = <span class="literal">true</span>;</span><br><span class="line">        ScheduleFilter filter = <span class="keyword">new</span> ScheduleFilter(levelField.FieldId, ScheduleFilterType.Equal, levelId);</span><br><span class="line">        definition.AddFilter(filter);</span><br><span class="line"></span><br><span class="line">        t.Commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> </span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> Finds an existing ScheduleField matching the given parameter</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> </span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> </span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> </span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduleField <span class="title">FindField</span>(<span class="params">ViewSchedule schedule, BuiltInParameter paramEnum</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ScheduleDefinition definition = schedule.Definition;</span><br><span class="line">    ScheduleField foundField = <span class="literal">null</span>;</span><br><span class="line">    ElementId paramId = <span class="keyword">new</span> ElementId(paramEnum);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">foreach</span> (ScheduleFieldId fieldId <span class="keyword">in</span> definition.GetFieldOrder())</span><br><span class="line">    &#123;</span><br><span class="line">        foundField = definition.GetField(fieldId);</span><br><span class="line">        <span class="keyword">if</span> (foundField.ParameterId == paramId)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> foundField;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="使用明细表数据"><a href="#使用明细表数据" class="headerlink" title="使用明细表数据"></a>使用明细表数据</h6><p>下面的示例说明如何确定明细表中的图元列表。</p>
<p>代码区域：获取计划的内容</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">GetScheduleContents</span>(<span class="params">ViewSchedule viewSchedule</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Collect types displayed in the schedule</span></span><br><span class="line">    FilteredElementCollector typeCollector = <span class="keyword">new</span> FilteredElementCollector(viewSchedule.Document, viewSchedule.Id);</span><br><span class="line">    typeCollector.WhereElementIsElementType();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> numberOfTypes = typeCollector.Count();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Collect instances displayed in the schedule</span></span><br><span class="line">    FilteredElementCollector instCollector = <span class="keyword">new</span> FilteredElementCollector(viewSchedule.Document, viewSchedule.Id);</span><br><span class="line">    instCollector.WhereElementIsNotElementType();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> numberOfInstances = instCollector.Count();</span><br><span class="line"></span><br><span class="line">    TaskDialog.Show(<span class="string">&quot;Elements in schedule&quot;</span>, String.Format(<span class="string">&quot;Types &#123;0&#125; instances &#123;1&#125;&quot;</span>, numberOfTypes, numberOfInstances));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>若要使用明细表中的实际数据，ViewSchedule.GetTableData（）返回一个TableData对象，该对象包含描述表中行、列和单元格的样式和内容的大部分数据。更多信息可以在TableView中找到。</p>
<h4 id="配电盘明细表"><a href="#配电盘明细表" class="headerlink" title="配电盘明细表"></a>配电盘明细表</h4><p>PanelScheduleView表示配电盘明细表，其中显示有关配电盘、连接到配电盘的线路及其相应负荷的信息。</p>
<p>可以创建一个明细表，其中列出连接到配电盘的线路，并显示有关每个线路的信息，例如配电盘上的位置、线路名称和视在负荷。配电盘明细表显示四个主要信息部分：页眉、线路表、负荷汇总和页脚。选定配电盘的新配电盘明细表视图将显示在绘图区域中，并且配电盘明细表将添加到项目浏览器的“配电盘明细表”文件夹下。配电盘明细表显示以下数据：</p>
<ul>
<li>面板名称</li>
<li>配电盘支持的配电系统</li>
<li>面板上可用的相数</li>
<li>为分配给此配电盘的配电系统指定的导线数</li>
<li>配电盘供电电源的额定值</li>
<li>安装类型（表面或嵌入式）</li>
<li>嵌板外壳类型</li>
<li>安装面板的房间</li>
<li>分配给负载电路的名称</li>
<li>断路器的额定跳闸电流</li>
<li>断路器上的极数</li>
<li>电路号</li>
<li>Phases 阶段</li>
<li>各相视在负荷（VA）</li>
<li>所有三相的总视在负荷</li>
<li>制造商</li>
<li>对面板进行的任何更改的注释</li>
<li>均方根安培数要显示的其他回路和配电盘信息可以在配电盘明细表样板中指定，在Revit API中由PanelScheduleTemplate类表示。</li>
</ul>
<p>PanelScheduleView和ViewSchedule一样，都是从TableView类派生的。明细表和配电盘明细表之间的一些常用功能可以在“明细表类”主题中找到。</p>
<h6 id="配电盘明细表创建"><a href="#配电盘明细表创建" class="headerlink" title="配电盘明细表创建"></a>配电盘明细表创建</h6><p>有两种用于创建PanelScheduleView的静态重载。PanelScheduleView. rnInstanceView（）的一个重载只需要在其中创建配电盘明细表的文档以及与明细表关联的电气配电盘元素的ID。此方法使用默认配电盘明细表样板创建新视图。另一个重载接受要使用的特定PanelScheduleTemplate的ID。</p>
<p>以下示例使用默认样板从用户选择的配电盘创建新配电盘明细表，并将活动视图切换到新配电盘明细表视图。</p>
<p>代码区域：创建配电盘明细表</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Create a new panel schedule and switch to that view</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">CreatePanelSchedule</span>(<span class="params">UIDocument uiDocument</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Document doc = uiDocument.Document;</span><br><span class="line"></span><br><span class="line">    Reference selected = uiDocument.Selection.PickObject(ObjectType.Element, <span class="string">&quot;Select an electrical panel&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Element panel = doc.GetElement(selected);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> != panel)</span><br><span class="line">    &#123;</span><br><span class="line">        PanelScheduleView psv = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">using</span> (Transaction trans = <span class="keyword">new</span> Transaction(doc, <span class="string">&quot;Create a new panel schedule&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            trans.Start();</span><br><span class="line">            psv = PanelScheduleView.CreateInstanceView(doc, panel.Id);</span><br><span class="line">            trans.Commit();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != psv)</span><br><span class="line">        &#123;</span><br><span class="line">            uiDocument.ActiveView = psv;    <span class="comment">// make new view the active view</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>, <span class="string">&quot;Please select one electrical panel.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="使用配电盘明细表"><a href="#使用配电盘明细表" class="headerlink" title="使用配电盘明细表"></a>使用配电盘明细表</h6><p>创建计划后，您可能需要对其进行修改。有几种方法有助于在计划中移动数据。若要移动数据，请使用PanelScheduleView.GetCellsBySlotNumber（）获取指定插槽号的单元格范围。PanelScheduleView.MoveSlotTo（）将源插槽中的回路移动到特定插槽。在移动回路之前，调用PanelScheduleView.CanMoveSlotTo（）以确保允许移动。</p>
<p>如果移动回路在一个组中，则该组中的所有回路都将相应地移动。IsSlotGrouped（）方法将检查插槽是否在组中。如果插槽不在组中，则此方法返回0。如果它在一个组中，则返回的值为组号（大于0的值）。</p>
<h2 id="修订"><a href="#修订" class="headerlink" title="修订"></a>修订</h2><p>Revit API提供了多个类和成员，用于访问项目修订、其设置和关联的云线批注。</p>
<h3 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h3><p>RevisionSettings类允许应用程序读取和修改影响修订和修订云线的项目范围设置。静态RevisionSettings.GetRevisionSettings（）方法返回给定项目文档的RevisionSettings对象。以下属性可用于访问项目范围的修订设置：</p>
<ul>
<li><p>RevisionCloudSpacing -确定项目中绘制的云线批注在图纸空间中的大小。</p>
</li>
<li><p>修订编号-确定项目的修订编号是按每张图纸还是按整个项目确定。AlphanumericRevisionSettings类包含应用于具有Alphanumeric RevisionNumberType的修订的设置。RevisionSettings方法GetAlphanumericRevisionSettings（）和SetAlphanumericRevisionSettings（）提供对AlphanumericRevisionSettings的读写访问。AlphanumericRevisionSettings提供以下成员：</p>
</li>
<li><p>前缀-前缀将被添加到每个版本号与字母数字类型。</p>
</li>
<li><p>后缀-要附加到每个版本号的字母数字类型的后缀。</p>
</li>
<li><p>GetSequence（）-获取字符串列表，这些字符串将用作字母数字类型的修订的编号序列。</p>
</li>
<li><p>SetSequence（）-设置此类型的修订编号的字符串列表。同样，NumericRevisionSettings类包含应用于具有Numeric</p>
</li>
</ul>
<p>RevisionNumberType的修订的设置。RevisionSettings方法GetNumericRevisionSettings（）和SetNumericRevisionSettings（）提供对这些设置的读写访问。NumericRevisionSettings提供以下成员：</p>
<ul>
<li>Prefix -每个版本号前面的数字类型前缀。</li>
<li>Suffix -要附加到每个版本号的数字类型的后缀。</li>
<li>StartNumber Property-用作数字修订序列中第一个数字的值。</li>
</ul>
<p>当修订云线显示在图纸上时，可以通过标记修订云线或通过图纸标题栏中的修订明细表来显示每个修订的修订编号。有两种方法可以确定数量：</p>
<p><strong>每个项目</strong>：版本号的值将始终对应于分配给该版本的项目范围的版本序号。例如，如果将序号为5、7和8的修订的云线批注放置在图纸上，则该图纸上的修订标记和明细表将显示5、7和8。</p>
<p><strong>每张图纸</strong>：将根据图纸上可见的修订云线为修订编号分配连续编号。例如，如果将指定了项目范围修订序号5、7和8的修订的云线批注放置在图纸上，则该图纸上的修订标记和明细表将显示1、2和3。图纸上的序列仍将遵循修订序列号的相对顺序，因此在本例中，修订5将在图纸上显示为1，修订7将显示为2，依此类推。</p>
<p>Revision类允许应用程序读取和修改项目中的现有修订以及创建新修订。Revision对象表示与项目中的单个修订相关的数据。它具有IssuedBy、IssuedTo、RevisionNumber、SequenceNumber和RevisionDate等属性。云线批注和标记可以与特定Revision对象关联，以在图纸上显示其特性。</p>
<p>项目中的修订以称为修订顺序的特定顺序存储。修订顺序表示将发布修订的概念顺序。静态方法Revision.GetAllRevisionIds（）将按此顺序返回所有Revision的ID。静态方法Revision.ReorderRevisionSequence（）可用于更改项目的修订顺序。请注意，新指定的序列必须只包含项目中的每个修订一次，并且更改修订的序列可能会更改已发布的修订的SequenceNumber和RevisionNumber。</p>
<p>静态Create（）方法将在指定的文档中创建一个新的Revision。在下面的示例中，添加了多个修订并设置了它们的属性。</p>
<p>代码区域：创建新修订</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> IList <span class="title">AddRevisions</span>(<span class="params">Document document</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    IList newRevisions = <span class="keyword">new</span> List();</span><br><span class="line">    <span class="keyword">using</span> (Transaction createRevision = <span class="keyword">new</span> Transaction(document, <span class="string">&quot;createRevision&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        createRevision.Start();</span><br><span class="line">        newRevisions.Add(AddNewRevision(document, <span class="string">&quot;Include door tags&quot;</span>, <span class="string">&quot;manager1&quot;</span>, <span class="string">&quot;employee1&quot;</span>, <span class="number">1</span>, DateTime.Now));</span><br><span class="line">        newRevisions.Add(AddNewRevision(document, <span class="string">&quot;Add a section view&quot;</span>, <span class="string">&quot;manager1&quot;</span>, <span class="string">&quot;employee1&quot;</span>, <span class="number">2</span>, DateTime.Now));</span><br><span class="line">        newRevisions.Add(AddNewRevision(document, <span class="string">&quot;Make callout view larger&quot;</span>, <span class="string">&quot;manager1&quot;</span>, <span class="string">&quot;employee1&quot;</span>, <span class="number">3</span>, DateTime.Now));</span><br><span class="line">        createRevision.Commit();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> newRevisions;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Revision <span class="title">AddNewRevision</span>(<span class="params">Document document, <span class="built_in">string</span> description, <span class="built_in">string</span> issuedBy, <span class="built_in">string</span> issuedTo, <span class="built_in">int</span> sequenceNumber, DateTime date</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Revision newRevision = Revision.Create(document);</span><br><span class="line">    newRevision.Description = description;</span><br><span class="line">    newRevision.IssuedBy = issuedBy;</span><br><span class="line">    newRevision.IssuedTo = issuedTo;</span><br><span class="line">    newRevision.NumberType = RevisionNumberType.Alphanumeric;</span><br><span class="line">    newRevision.RevisionDate = date.ToShortDateString();</span><br><span class="line">    <span class="keyword">return</span> newRevision;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CombineWithNext（）和CombineWithPrevious（）这两个方法允许应用程序将指定的Revision与模型中的下一个或上一个Revision合并。合并修订意味着与指定修订相关联的修订云和修订标签将与下一个修订重新关联，并且指定修订将从模型中删除。此方法返回重新关联的RevisionClouds的ID。但是，这些操作只能在两个修订版本都未发布的情况下实施。 下面的示例演示CombineWithNext（）方法的用法。它还使用GetAllRevisionIds（）方法查找下一个修订，以确保CombineWithNext（）方法成功。</p>
<p>代码区域：合并修订</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="built_in">bool</span> <span class="title">CombineRevision</span>(<span class="params">Document document, Revision revision</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">bool</span> combined = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// Can only combine two revisions if neither have been issued</span></span><br><span class="line">    <span class="keyword">if</span> (revision.Issued == <span class="literal">false</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ElementId revisionId = revision.Id;</span><br><span class="line">        Revision nextRevsion = GetNextRevision(document, revisionId);</span><br><span class="line">        <span class="keyword">if</span> (nextRevsion != <span class="literal">null</span> &amp;&amp; nextRevsion.Issued == <span class="literal">false</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ISet revisionCloudIds = Revision.CombineWithNext(document, revisionId);</span><br><span class="line">            combined = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">int</span> movedClouds = revisionCloudIds.Count;</span><br><span class="line">            <span class="keyword">if</span> (movedClouds &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                RevisionCloud cloud = document.GetElement(revisionCloudIds.ElementAt(<span class="number">0</span>)) <span class="keyword">as</span> RevisionCloud;</span><br><span class="line">                <span class="keyword">if</span> (cloud != <span class="literal">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">string</span> msg = <span class="built_in">string</span>.Format(<span class="string">&quot;Revision &#123;0&#125; deleted and &#123;1&#125; revision clouds were added to Revsion &#123;2&#125;&quot;</span>,</span><br><span class="line">                        revisionId.ToString(), movedClouds, cloud.RevisionId.ToString());</span><br><span class="line">                    TaskDialog.Show(<span class="string">&quot;Revision Combined&quot;</span>, msg);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> combined;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Revision <span class="title">GetNextRevision</span>(<span class="params">Document document, ElementId currentRevisionId</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Revision nextRevision = <span class="literal">null</span>;</span><br><span class="line">    IList revisionIds = Revision.GetAllRevisionIds(document);</span><br><span class="line">    <span class="built_in">int</span> currentRevisionIndex = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> n = <span class="number">0</span>; n &lt; revisionIds.Count; n++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (revisionIds[n] == currentRevisionId)</span><br><span class="line">        &#123;</span><br><span class="line">            currentRevisionIndex = n;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if the current revision id was found and is not the last index</span></span><br><span class="line">    <span class="keyword">if</span> (currentRevisionIndex &gt;= <span class="number">0</span> &amp;&amp; currentRevisionIndex &lt; revisionIds.Count - <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ElementId nextRevisionId = revisionIds[currentRevisionIndex + <span class="number">1</span>];</span><br><span class="line">        nextRevision = document.GetElement(nextRevisionId) <span class="keyword">as</span> Revision;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> nextRevision;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="修订云线"><a href="#修订云线" class="headerlink" title="修订云线"></a>修订云线</h3><p>RevisionCloud是一种图形化的“云”，可以显示在视图或图纸上，以指示模型中发生修订的位置。RevisionCloud类允许应用程序访问有关模型中存在的云线批注的信息，并创建新的云线批注。</p>
<p>RevisionCloud是特定于视图的，可以在大多数图形视图中创建，但3D视图除外。</p>
<p>另请注意，当在ViewLegend中创建RevisionCloud时，它会被视为RevisionCloud外观的图例表示，而不是模型更改的实际指示。因此，ViewLegends中的RevisionClouds不会影响修订明细表的内容。</p>
<h3 id="创建云线批注"><a href="#创建云线批注" class="headerlink" title="创建云线批注"></a>创建云线批注</h3><p>静态Create（）方法允许应用程序基于一系列直线和曲线在指定视图中创建新的RevisionCloud。只有在关联的Revision尚未发布时，才能创建RevisionClouds。</p>
<p>可以在大多数图形视图中创建RevisionClouds，但三维视图和图形柱明细表除外。与大多数其他元素不同，RevisionClouds可以直接在ViewSheet上创建。</p>
<p>RevisionCloud基于一系列草图曲线创建。不要求曲线形成闭合回路，也允许自相交。曲线将自动投影到视图的适当平面上。曲线列表不能为空，并且没有直线可以垂直于视图平面。如果视图是模型视图，则将在模型空间中解释为曲线指定的坐标。如果视图是非模型视图（例如ViewSheet），则坐标将在视图的空间中解释。</p>
<p>每条曲线都将有一系列的“云凸点”沿着它绘制沿着，形成云的外观。云图形将附加到假设每条曲线都是顺时针方向的曲线上。对于线，这意味着云的外部在视图平面内的线的法向量的方向上。因此，任何闭合的环都应该顺时针定向，以创建典型的云形状。</p>
<p>代码区域：创建修订云线</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">CreateRevisionCloudInActiveView</span>(<span class="params">Document document, Revision revision, IList curves</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> (Transaction newRevisionCloud = <span class="keyword">new</span> Transaction(document, <span class="string">&quot;Create Revision Cloud&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        newRevisionCloud.Start();</span><br><span class="line">        <span class="comment">// Can only create revision cloud for revision that is not issued</span></span><br><span class="line">        <span class="keyword">if</span> (revision.Issued == <span class="literal">false</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            RevisionCloud.Create(document, document.ActiveView, revision.Id, curves);</span><br><span class="line">            newRevisionCloud.Commit();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            newRevisionCloud.RollBack();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="修订云线几何图形"><a href="#修订云线几何图形" class="headerlink" title="修订云线几何图形"></a>修订云线几何图形</h3><p>RevisionCloud派生自Element类。云线批注的Element.Geometry属性将返回组成云线的实际曲线。另一方面，RevisionCloud.GetSketchCurves（）方法将返回定义云的基本轮廓的草图曲线，而不是Revit附着到这些曲线以创建云外观的弧。</p>
<h3 id="与RevisionCloud关联的修订版本"><a href="#与RevisionCloud关联的修订版本" class="headerlink" title="与RevisionCloud关联的修订版本"></a>与RevisionCloud关联的修订版本</h3><p>每个RevisionCloud与一个Revision相关联。关联的修订ID在调用Create（）时指定，可以从RevisionCloud.RevisionId属性中检索。如果RevisionCloud的RevisionId属性未与已发布的修订版本关联，则可以更改该属性。它只能更改为另一个尚未发布的修订版本的ID。IsRevisionIssued（）返回关联的Revision是否已发布。</p>
<h3 id="图纸-1"><a href="#图纸-1" class="headerlink" title="图纸"></a>图纸</h3><p>当RevisionCloud在ViewSheet上可见时（因为它直接放置在ViewSheet上，或者因为它在ViewSheet上放置的视图中可见），ViewSheet上显示的任何修订明细表将自动包括与RevisionCloud关联的修订。</p>
<p>RevisionCloud.GetSheetIds（）方法返回ViewSheets的ID，ViewSheets可能会出现在该ID中，并参与到图纸的修订明细表中。RevisionCloud可以出现在ViewSheet上，因为它是直接在ViewSheet上绘制的，或者因为它的所有者视图放置在ViewSheet上。如果RevisionCloud属于从属视图或具有关联从属视图的视图，则RevisionCloud也可以在放置相关从属视图或主视图的图纸上可见。</p>
<p>此RevisionCloud可能在此方法报告的所有ViewSheets中不可见。其他因素（例如视图的可见性设置或注释裁剪或关联修订的可见性设置）仍可能导致此RevisionCloud不显示在特定ViewSheet上。</p>
<p>如果此RevisionCloud归ViewLegend所有，则不会返回图纸，因为RevisionCloud不会参与修订明细表。ViewSheet类包括用于在图纸上使用Revisionsand RevisionClouds的方法。有关详细信息，请参见ViewSheet主题。</p>
<h2 id="视图过滤器"><a href="#视图过滤器" class="headerlink" title="视图过滤器"></a>视图过滤器</h2><p>过滤器是独立于视图的元素。它们可以使用ParameterFilterElement类或SelectionFilterElement类应用于视图。</p>
<h3 id="ParameterFilterElement"><a href="#ParameterFilterElement" class="headerlink" title="ParameterFilterElement"></a>ParameterFilterElement</h3><p>参数过滤元素根据其类别和一系列过滤规则过滤元素。可以指定一个或多个类别作为筛选器的允许类别。</p>
<p>定义过滤器（具有一个或多个类别和一个或多个过滤器规则）后，可以使用多种方法之一将其应用于视图。AddFilter（）方法将过滤器应用于视图，但使用默认覆盖，这意味着视图的显示不会更改。View.SetFilterOverrides（）将设置与过滤器关联的图形覆盖。而View.SetFilterVisibility（）将设置通过过滤器的元素在视图中是否可见。AddFilter（）和SetFilterVisibility（）都将过滤器应用到视图（如果它还没有应用），因此没有必要单独调用AddFilter（）。</p>
<p>下面的示例创建一个匹配多个条件的新视图筛选器，然后在视图中隐藏这些元素。</p>
<p>代码区域：将参数过滤器应用于视图</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CreateViewFilter</span>(<span class="params">Document doc, View view</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    List categories = <span class="keyword">new</span> List();</span><br><span class="line">    categories.Add(<span class="keyword">new</span> ElementId(BuiltInCategory.OST_Walls));</span><br><span class="line">    List filterRules = <span class="keyword">new</span> List();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> (Transaction t = <span class="keyword">new</span> Transaction(doc, <span class="string">&quot;Add view filter&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        t.Start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create filter element associated to the input categories</span></span><br><span class="line">        ParameterFilterElement parameterFilterElement = ParameterFilterElement.Create(doc, <span class="string">&quot;Example view filter&quot;</span>, categories);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Criterion 1 - wall type Function is &quot;Exterior&quot;</span></span><br><span class="line">        ElementId exteriorParamId = <span class="keyword">new</span> ElementId(BuiltInParameter.FUNCTION_PARAM);</span><br><span class="line">        filterRules.Add(ParameterFilterRuleFactory.CreateEqualsRule(exteriorParamId, (<span class="built_in">int</span>)WallFunction.Exterior));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Criterion 2 - wall height &gt; some number</span></span><br><span class="line">        ElementId lengthId = <span class="keyword">new</span> ElementId(BuiltInParameter.CURVE_ELEM_LENGTH);</span><br><span class="line">        filterRules.Add(ParameterFilterRuleFactory.CreateGreaterOrEqualRule(lengthId, <span class="number">28.0</span>, <span class="number">0.0001</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Criterion 3 - custom shared parameter value matches string pattern</span></span><br><span class="line">        <span class="comment">// Get the id for the shared parameter - the ElementId is not hardcoded, so we need to get an instance of this type to find it</span></span><br><span class="line">        Guid spGuid = <span class="keyword">new</span> Guid(<span class="string">&quot;96b00b61-7f5a-4f36-a828-5cd07890a02a&quot;</span>);</span><br><span class="line">        FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(doc);</span><br><span class="line">        collector.OfClass(<span class="keyword">typeof</span>(Wall));</span><br><span class="line">        Wall wall = collector.FirstElement() <span class="keyword">as</span> Wall;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (wall != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Parameter sharedParam = wall.get_Parameter(spGuid);</span><br><span class="line">            ElementId sharedParamId = sharedParam.Id;</span><br><span class="line"></span><br><span class="line">            filterRules.Add(ParameterFilterRuleFactory.CreateBeginsWithRule(sharedParamId, <span class="string">&quot;15.&quot;</span>, <span class="literal">true</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        parameterFilterElement.SetRules(filterRules);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Apply filter to view</span></span><br><span class="line">        view.AddFilter(parameterFilterElement.Id);</span><br><span class="line">        view.SetFilterVisibility(parameterFilterElement.Id, <span class="literal">false</span>);</span><br><span class="line">        t.Commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="SelectionFilterElement"><a href="#SelectionFilterElement" class="headerlink" title="SelectionFilterElement"></a>SelectionFilterElement</h3><p>SelectionFilterElement是一种特殊的视图筛选器，它不基于规则，而是基于一组可能不相关的元素。可以根据需要将特定元素添加到过滤器中，并且可以像ParameterFilterElement一样覆盖所产生的选择。</p>
<p>下面的示例创建一个新的选择筛选器并对其应用重写。</p>
<p>代码区域：将选择筛选器应用于视图</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CreateSelectionFilter</span>(<span class="params">Document doc, View view</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// find room tags in this view</span></span><br><span class="line">    FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(doc, view.Id);</span><br><span class="line">    collector.WherePasses(<span class="keyword">new</span> RoomTagFilter());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// collect tags whose room number matches criteria</span></span><br><span class="line">    List tagIds = <span class="keyword">new</span> List();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">foreach</span> (RoomTag tag <span class="keyword">in</span> collector.Cast())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> number = Int32.Parse(tag.Room.Number);</span><br><span class="line">        <span class="keyword">if</span> (number % <span class="number">3</span> == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            tagIds.Add(tag.Id);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> (Transaction t = <span class="keyword">new</span> Transaction(doc, <span class="string">&quot;Create SelectionFilterElement&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        t.Start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create selection filter and assign ids</span></span><br><span class="line">        SelectionFilterElement filterElement = SelectionFilterElement.Create(doc, <span class="string">&quot;Room tags filter&quot;</span>);</span><br><span class="line">        filterElement.SetElementIds(tagIds);</span><br><span class="line"></span><br><span class="line">        ElementId filterId = filterElement.Id;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Add the filter to the view</span></span><br><span class="line">        view.AddFilter(filterId);</span><br><span class="line"></span><br><span class="line">        doc.Regenerate();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Use the existing graphics settings, and change the color to Blue</span></span><br><span class="line">        OverrideGraphicSettings overrideSettings = view.GetFilterOverrides(filterId);</span><br><span class="line"></span><br><span class="line">        overrideSettings.SetProjectionLineColor(<span class="keyword">new</span> Color(<span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xFF</span>));</span><br><span class="line"></span><br><span class="line">        view.SetFilterOverrides(filterId, overrideSettings);</span><br><span class="line"></span><br><span class="line">        t.Commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Modifying filters</p>
<p>应用于视图的所有过滤器都可以使用View.GetFilters（）方法检索，该方法将返回过滤器ID列表。可以分别使用View.GetFilterVisibility（）和View.GetFilterOverrides（）方法检查特定筛选器的筛选器可见性和图形覆盖。RemoveFilter将从视图中删除筛选器。</p>
<p>下面的示例演示如何获取视图中的过滤器，然后修改与当前将剪切颜色设置为红色的任何过滤器关联的覆盖。</p>
<p>代码区域：修改现有筛选器</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ModifyExistingFilter</span>(<span class="params">Document doc, View view</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Find any filter with overrides setting cut color to Red</span></span><br><span class="line">    Dictionary&lt;ElementId, OverrideGraphicSettings&gt; filterIdsToChange = <span class="keyword">new</span> Dictionary&lt;ElementId, OverrideGraphicSettings&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">foreach</span> (ElementId filterId <span class="keyword">in</span> view.GetFilters())</span><br><span class="line">    &#123;</span><br><span class="line">        OverrideGraphicSettings overrideSettings = view.GetFilterOverrides(filterId);</span><br><span class="line"></span><br><span class="line">        Color lineColor = overrideSettings.CutLineColor;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (lineColor == Color.InvalidColorValue)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Save overrides setting the cut color to green</span></span><br><span class="line">        <span class="keyword">if</span> (lineColor.Red == <span class="number">0xFF</span> &amp;&amp; lineColor.Green == <span class="number">0x00</span> &amp;&amp; lineColor.Blue == <span class="number">0x00</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            overrideSettings.SetCutLineColor(<span class="keyword">new</span> Color(<span class="number">0x00</span>, <span class="number">0xFF</span>, <span class="number">0x00</span>));</span><br><span class="line">            filterIdsToChange[filterId] = overrideSettings;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make the change to all found filters</span></span><br><span class="line">    <span class="keyword">using</span> (Transaction t = <span class="keyword">new</span> Transaction(doc, <span class="string">&quot;Change override filters&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        t.Start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">foreach</span> (ElementId filterId <span class="keyword">in</span> filterIdsToChange.Keys)</span><br><span class="line">        &#123;</span><br><span class="line">            view.SetFilterOverrides(filterId, filterIdsToChange[filterId]);</span><br><span class="line">        &#125;</span><br><span class="line">        t.Commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="视图裁剪"><a href="#视图裁剪" class="headerlink" title="视图裁剪"></a>视图裁剪</h2><p>可以使用Revit API修改某些视图的裁剪区域。ViewCropRegionShapeManager.CanHaveShape属性指示是否允许视图管理裁剪区域形状，而ShapeSet属性指示是否已设置形状。下面的示例裁剪房间边界周围的视图。</p>
<p>代码区域：裁剪视图</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">CropAroundRoom</span>(<span class="params">Room room, View view</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (view != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        IList&lt;IList&lt;Autodesk.Revit.DB.BoundarySegment&gt;&gt; segments = room.GetBoundarySegments(<span class="keyword">new</span> SpatialElementBoundaryOptions());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != segments)  <span class="comment">//the room may not be bound</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">foreach</span> (IList&lt;Autodesk.Revit.DB.BoundarySegment&gt; segmentList <span class="keyword">in</span> segments)</span><br><span class="line">            &#123;</span><br><span class="line">                CurveLoop loop = <span class="keyword">new</span> CurveLoop();</span><br><span class="line">                <span class="keyword">foreach</span> (Autodesk.Revit.DB.BoundarySegment boundarySegment <span class="keyword">in</span> segmentList)</span><br><span class="line">                &#123;</span><br><span class="line">                    loop.Append(boundarySegment.GetCurve());</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                ViewCropRegionShapeManager vcrShapeMgr = view.GetCropRegionShapeManager();</span><br><span class="line">                vcrShapeMgr.SetCropShape(loop);</span><br><span class="line">                <span class="keyword">break</span>;  <span class="comment">// if more than one set of boundary segments for room, crop around the first one</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="置换视图"><a href="#置换视图" class="headerlink" title="置换视图"></a>置换视图</h2><p>使用DisplacementElement类创建置换视图。DisplacementElement是视图专有的元素，可用于使元素显示为从其实际位置偏移。置换视图对于说明模型元素与整个模型的关系非常有用。DisplacementElement实际上不会更改任何模型元素的位置;它只是使它们显示在不同的位置。</p>
<p>有关创建置换视图的详细示例，请参见Revit SDK中的DisplacementElementAnimation示例。</p>
<h3 id="创建置换视图"><a href="#创建置换视图" class="headerlink" title="创建置换视图"></a>创建置换视图</h3><p>静态DisplacementElement.Create（）方法创建一个新的DisplacementElement。如果parentDisplacementElement参数不为空，则新DisplacementElement可以是父DisplacementElement的子元素。如果指定了父代，则子DisplacementElement的转换将与父代的转换连接在一起，并且其关联元素的位移将相对于父代DisplacementElement。</p>
<p>Create（）方法还需要一个文档、一个要置换的元素列表、所有者视图以及要应用于置换元素图形的转换。在任何视图中，一个元素只能被单个DisplacementElement置换。将一个元素替换为多个DisplacementElement将导致异常。</p>
<p>可以在调用Create（）之前使用DisplaceementElement的其他静态方法来帮助防止任何异常。CanCategoryBeDisplaced（）测试属于特定类别的元素是否可以被置换，而重载的静态方法CanElementsBeDisplaced（）指示特定元素是否可以被分配给新的DisplacementElement。IsAllowedAsDisplacedElement（）测试单个元素是否有资格被置换。</p>
<p>静态GetAdditionalElementsToDisplace（）方法将返回任何其他元素，这些元素应与指定视图中的指定元素一起沿着移位。例如，当墙被置换时，所有插入对象或主体图元也应该被置换。</p>
<p>创建子DisplacementElement时，静态IsValidAsParentInView（）可用于验证特定DisplacementElement是否可用作特定View中的父代。</p>
<p>DisplacementElement的其他静态方法可用于查找包含特定元素的DisplacementElement，以获取View中所有移位元素的列表，或获取指定View所拥有的所有DisplacementElements。</p>
<h3 id="使用置换图元"><a href="#使用置换图元" class="headerlink" title="使用置换图元"></a>使用置换图元</h3><p>一旦创建了新的DisplacementElement，就可以使用方法来获取任何子DisplacementElements，以获取受DisplacementElement影响的所有元素的id，或者获取受DisplacementElement影响的所有元素以及任何子DisplacementElements的id。ParentId属性将返回父DisplacementElement的元素ID（如果存在）。</p>
<p>创建后，可以使用SetDisplacedElementIds（）或RemoveDisplacedElement（）修改受DisplacementElement影响的元素集。另外，相对位移可以改变。</p>
<p>方法ResetDisplacedElements（）将DisplacementElement的平移设置为（0，0，0）。DisplacementElement继续存在，但其元素显示在其实际位置。</p>
<h3 id="创建位移路径"><a href="#创建位移路径" class="headerlink" title="创建位移路径"></a>创建位移路径</h3><p>DisplacementPath是与DisplacementElement相关的视图特定注释。DisplacementPath类创建一个注释，该注释描述元素从其实际位置到其位移位置的移动。通过对DisplacementElement的已移位元素的边缘上的点的引用，将DisplacementPath锚定到DisplacementElement。它由一条直线或一系列折弯线表示，这些直线起源于位移元素上的指定点。</p>
<p>静态DisplacementPath.Create（）方法需要一个文档、关联DisplacementElement的ID、一个引用被DisplacementElement置换的元素之一的边或曲线的引用，以及一个在[0，1]范围内的值，该值是沿指定边的沿着参数。创建后，可以使用PathStyle属性设置DisplacementPath的路径样式。也可以使用SetAnchorPoint（）更改锚点。</p>
<p>下面的示例通过垂直和水平移动找到的第一面墙来创建新的位移，然后为其添加位移路径。</p>
<p>代码区域：创建位移和路径</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CreateDisplacementAndPath</span>(<span class="params">Document doc, View view</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Find roof</span></span><br><span class="line">    FilteredElementCollector fec = <span class="keyword">new</span> FilteredElementCollector(doc);</span><br><span class="line">    fec.OfClass(<span class="keyword">typeof</span>(RoofBase));</span><br><span class="line">    RoofBase roof = fec.FirstElement() <span class="keyword">as</span> RoofBase;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get a geometric reference for the path</span></span><br><span class="line">    Reference edgeRef = GetHorizontalEdgeReference(roof);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> (Transaction t = <span class="keyword">new</span> Transaction(doc, <span class="string">&quot;CreateDisplacementAndPath&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        t.Start();</span><br><span class="line">        <span class="comment">// Create a new top level DisplacementElement</span></span><br><span class="line">        DisplacementElement dispElem = DisplacementElement.Create(doc, <span class="keyword">new</span> ElementId[] &#123; roof.Id &#125;, <span class="keyword">new</span> XYZ(<span class="number">10</span>, <span class="number">0</span>, <span class="number">20</span>), view, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create the path associated to the element</span></span><br><span class="line">        DisplacementPath.Create(doc, dispElem, edgeRef, <span class="number">0.5</span>);</span><br><span class="line">        t.Commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Reference <span class="title">GetHorizontalEdgeReference</span>(<span class="params">Element elem</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//Find target edge from lower face of roof</span></span><br><span class="line">    Options options = <span class="keyword">new</span> Options();</span><br><span class="line">    options.ComputeReferences = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    GeometryElement geomElem = elem.get_Geometry(options);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> geomObj <span class="keyword">in</span> geomElem)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (geomObj <span class="keyword">is</span> Solid)</span><br><span class="line">        &#123;</span><br><span class="line">            Solid solid = geomObj <span class="keyword">as</span> Solid;</span><br><span class="line">            <span class="keyword">var</span> faces = solid.Faces;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">foreach</span> (Face face <span class="keyword">in</span> faces)</span><br><span class="line">            &#123;</span><br><span class="line">                BoundingBoxUV box = face.GetBoundingBox();</span><br><span class="line">                UV midpoint = (box.Min + box.Max) / <span class="number">2.0</span>;</span><br><span class="line">                <span class="keyword">if</span> (face.ComputeNormal(midpoint).Normalize().Z &lt; <span class="number">-0.1</span>) <span class="comment">// Downward facing, this is good enough</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">var</span> edgeLoops = face.EdgeLoops;</span><br><span class="line">                    <span class="keyword">foreach</span> (EdgeArray edgeArray <span class="keyword">in</span> edgeLoops)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">foreach</span> (Edge edge <span class="keyword">in</span> edgeArray)</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="comment">// horizontal?</span></span><br><span class="line">                            <span class="keyword">if</span> (Math.Abs(edge.AsCurve().ComputeDerivatives(<span class="number">0.0</span>, <span class="literal">true</span>).BasisX.DotProduct(XYZ.BasisZ)) - <span class="number">1</span> &lt;= <span class="number">0.00001</span>)</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="keyword">return</span> edge.Reference;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相关联的DisplacementElement可以具有父DisplacementElement，并且该父DisplacementElement可以具有其自己的父DisplacementElement，从而产生一系列祖先。终点可以是点的原始（未移位）位置，或者是与这些祖先DisplacementElements相对应的任何中间移位位置上的对应点。位移路径。PistorIdx属性指定路径的终点。</p>
<h2 id="UIView"><a href="#UIView" class="headerlink" title="UIView"></a>UIView</h2><p>View类是Revit中所有视图类型的基类，并跟踪视图中的图元，而UIView类则包含有关Revit用户界面中视图窗口的数据。可以使用GetOpenUIViews（）方法从UID目录中检索所有打开视图的列表。UIView类具有获取有关视图绘图区域的信息以及平移和缩放活动视图的方法。</p>
<p>GetWindowRectangle（）返回一个描述UIView窗口大小和位置的矩形。它不包括窗口边框或标题栏。</p>
<h3 id="缩放操作"><a href="#缩放操作" class="headerlink" title="缩放操作"></a>缩放操作</h3><p>UIView有几种与缩放活动视图相关的方法。UIView.GetZoomCorners（）获取模型坐标中视图矩形的角点，UIView.ZoomAndCenterRectangle（）提供缩放和平移活动视图的能力，使其以模型的输入区域为中心。</p>
<p>ZoomToFit（）和ZoomSheetSize（）方法提供了调整窗口缩放的快速方法，而Zoom（）方法可用于按指定因子放大或缩小。</p>
<h3 id="关闭视图"><a href="#关闭视图" class="headerlink" title="关闭视图"></a>关闭视图</h3><p>UIView.Close（）可以关闭可见窗口。但是，它不能用于关闭最后一个活动窗口。尝试关闭最后一个活动窗口将引发异常。</p>
<h2 id="注：翻译自Revit-API-Developers-Guide"><a href="#注：翻译自Revit-API-Developers-Guide" class="headerlink" title="注：翻译自Revit API Developers Guide"></a><em><strong>注：</strong></em>翻译自<a href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_html">Revit API Developers Guide</a></h2>]]></content>
      <categories>
        <category>Revit二次开发人员指南</category>
      </categories>
      <tags>
        <tag>Revit</tag>
      </tags>
  </entry>
  <entry>
    <title>17注释元素</title>
    <url>/2024/12/10/Revit%E4%BA%8C%E5%BC%80%E6%8C%87%E5%8D%97/17%E6%B3%A8%E9%87%8A%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<h1 id="注释元素"><a href="#注释元素" class="headerlink" title="注释元素"></a><a href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_Revit_Geometric_Elements_Annotation_Elements_html">注释元素</a></h1><p>本节介绍Revit注释元素，例如尺寸标注、文字注释、注释记号、标记和符号。</p>
<p>请注意：</p>
<ul>
<li>尺寸标注是视图专有的图元，用于显示项目中的尺寸和距离。</li>
<li>为详图创建详图曲线。它们仅在绘制它们的视图中可见。它们通常绘制在模型视图上。</li>
<li>标签是用于标识图形中图元的注释。与标签关联的特性可以显示在明细表中。</li>
<li>AnnotationSymbol在加载到项目中时具有多个引线选项。</li>
</ul>
<p>有关Revit Element分类的详细信息，请参见元素要点。</p>
<h2 id="尺寸标注和约束"><a href="#尺寸标注和约束" class="headerlink" title="尺寸标注和约束"></a>尺寸标注和约束</h2><p>永久性尺寸标注和尺寸标注相关约束。</p>
<p>Dimension类表示永久性尺寸标注和与尺寸标注相关的约束元素。在UI中编辑元素时创建的临时尺寸标注不可访问。高程点和高程点坐标由SpotDimension类表示。</p>
<p>下面的代码示例在结尾处说明了如何区分永久性尺寸标注和约束元素。</p>
<p>代码区域16-1：区分永久性尺寸标注和约束</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetInfo_Dimension</span>(<span class="params">Dimension dimension</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> message = <span class="string">&quot;Dimension : &quot;</span>;</span><br><span class="line">    <span class="comment">// Get Dimension name</span></span><br><span class="line">    message += <span class="string">&quot;\nDimension name is : &quot;</span> + dimension.Name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get Dimension Curve</span></span><br><span class="line">    Autodesk.Revit.DB.Curve curve = dimension.Curve;</span><br><span class="line">    <span class="keyword">if</span> (curve != <span class="literal">null</span> &amp;&amp; curve.IsBound)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Get curve start point</span></span><br><span class="line">        message += <span class="string">&quot;\nCurve start point:(&quot;</span> + curve.GetEndPoint(<span class="number">0</span>).X + <span class="string">&quot;, &quot;</span></span><br><span class="line">                + curve.GetEndPoint(<span class="number">0</span>).Y + <span class="string">&quot;, &quot;</span> + curve.GetEndPoint(<span class="number">0</span>).Z + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">        <span class="comment">// Get curve end point</span></span><br><span class="line">        message += <span class="string">&quot;; Curve end point:(&quot;</span> + curve.GetEndPoint(<span class="number">1</span>).X + <span class="string">&quot;, &quot;</span></span><br><span class="line">                + curve.GetEndPoint(<span class="number">1</span>).Y + <span class="string">&quot;, &quot;</span> + curve.GetEndPoint(<span class="number">1</span>).Z + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get Dimension type name</span></span><br><span class="line">    message += <span class="string">&quot;\nDimension type name is : &quot;</span> + dimension.DimensionType.Name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get Dimension view name</span></span><br><span class="line">    message += <span class="string">&quot;\nDimension view name is : &quot;</span> + dimension.View.Name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get Dimension reference count</span></span><br><span class="line">    message += <span class="string">&quot;\nDimension references count is &quot;</span> + dimension.References.Size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((<span class="built_in">int</span>)BuiltInCategory.OST_Dimensions == dimension.Category.Id.IntegerValue)</span><br><span class="line">    &#123;</span><br><span class="line">        message += <span class="string">&quot;\nDimension is a permanent dimension.&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((<span class="built_in">int</span>)BuiltInCategory.OST_Constraints == dimension.Category.Id.IntegerValue)</span><br><span class="line">    &#123;</span><br><span class="line">        message += <span class="string">&quot;\nDimension is a constraint element.&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>,message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="尺寸标注"><a href="#尺寸标注" class="headerlink" title="尺寸标注"></a>尺寸标注</h3><p>有五种永久尺寸标注：</p>
<ul>
<li>Linear dimension 线性尺寸标注</li>
<li>Radial dimension 半径尺寸标注</li>
<li>Diameter Dimension 直径尺寸标注</li>
<li>Angular dimension 角度尺寸标注</li>
<li>Arc length dimension 弧长尺寸标注</li>
</ul>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/Dims.png"></p>
<p>图66：永久尺寸标注</p>
<p>所有永久性尺寸标注的BuiltInCategory为OST_Dimensions。没有一种使用API区分四个维度的简单方法。</p>
<p>除半径尺寸标注和直径尺寸标注外，每个尺寸标注都有一条尺寸线。尺寸线可从始终未绑定的Dimension.Curve属性中获得。换句话说，尺寸线没有起点或终点。基于上一张图片：</p>
<ul>
<li>将为线性标注返回Line对象。</li>
<li>将为半径标注或角度标注返回弧对象。</li>
<li>径向尺寸标注返回空。</li>
<li>直径尺寸标注返回空。</li>
</ul>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-4C8DCD73-DFD8-4185-A1EA-2C890D176FBF-low.png"></p>
<p>图67：尺寸参考</p>
<p>如上图所示，通过选择几何参照来创建尺寸。几何参照在API中表示为Reference类。以下尺寸参照可从“参照”（References）属性中获得。有关参考的更多信息，请参见几何部分中的几何辅助程序类。</p>
<ul>
<li>半径和直径尺寸标注-返回曲线的一个参考对象</li>
<li>角度和弧长尺寸标注-返回两个参照对象。</li>
<li>线性尺寸标注-返回两个或多个参照对象。在下图中，线性标注有五个Reference对象。</li>
</ul>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-A976B817-2D4B-471B-BF79-27E9262A8A85-low.png"></p>
<p>图68：线性尺寸参考</p>
<p>与其他注释元素一样，尺寸标注也是视图专有的。它们仅显示在添加它们的视图中。Dimension.View属性返回特定的视图。</p>
<h3 id="约束元素"><a href="#约束元素" class="headerlink" title="约束元素"></a>约束元素</h3><p>具有类别约束的标注对象（BuitInCategory.OST_Constraints）表示两种与标注相关的约束：</p>
<ul>
<li>Linear and radial dimension constraints<br>线性和半径尺寸标注约束</li>
<li>Equality constraints 等式约束</li>
</ul>
<p>在下图中，两种锁定约束分别对应于线性标注和半径标注。在应用程序中，它们显示为带有绿色虚线的挂锁。(绿色虚线可从“尺Dimension.Curve”属性中获得。）线性标注约束和半径标注约束都从Dimension.References属性返回两个Reference对象。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-370D4754-3BC7-4A6C-8531-41B7A5B424D9-low.png"></p>
<p>图69：线性和半径尺寸约束</p>
<p>约束图元不是视图专有的，可以显示在不同的视图中。因此，View属性总是返回null。在下图中，上一图中的约束元素在3D视图中也可见。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-8365F25E-7304-413D-BABE-1C495BD8ADAD-low.png"></p>
<p>图70：3D视图中的线性和半径尺寸约束</p>
<p>虽然等分约束基于尺寸标注，但它们也由Dimension类表示。在API中，没有使用类别或类型区分线性标注约束和等式约束的直接方法。相等约束返回三个或更多引用，而线性尺寸约束返回两个或更多引用。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-FB6F70CD-8913-4C3A-A036-2108550BA25C-low.png"></p>
<p>图71：等分约束</p>
<p>注意：并非所有约束元素都由Dimension类表示，但都属于约束（OST_Constraints）类别，如对齐约束。</p>
<h3 id="高程点标注"><a href="#高程点标注" class="headerlink" title="高程点标注"></a>高程点标注</h3><p>高程点坐标和高程点由SpotDimension类表示，并按类别区分。与永久性尺寸标注一样，高程点尺寸标注也是视图专有的。下表列出了每个高程点标注的类型和类别：</p>
<p>表35：点尺寸类型和类别</p>
<table>
<thead>
<tr>
<th><strong>Type 类型</strong></th>
<th><strong>Category 类别</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Spot Coordinates 高程点坐标</td>
<td>OST_SpotCoordinates</td>
</tr>
<tr>
<td>Spot Elevations 高程点</td>
<td>OST_SpotElevations</td>
</tr>
</tbody></table>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-BDB09C60-D4AC-4F6A-8100-6BA2FA165228-low.png"></p>
<p>图72：SpotCoordinates和SpotElevations</p>
<p>可以将SpotDimension Location向下转换为LocationPoint，以便可以从LocationPoint.Point属性中获得点尺寸所指向的点坐标。SpotDimensions没有尺寸曲线，因此其Curve属性始终返回null。SpotDimension References属性返回一个Reference，表示高程点标注引用的点或边。* 若要控制文本和标记显示样式，请修改SpotDimension和SpotExpressionType参数。</p>
<p>对比下表对比了API中不同类型的维度和约束：</p>
<p>表36：Dimension类别对比</p>
<table>
<thead>
<tr>
<th>Dimension or Constraint</th>
<th>Dimension or Constraint</th>
<th>API Class</th>
<th>BuiltInCategory</th>
<th>Curve</th>
<th>Geometry Helper Classes</th>
<th>View</th>
<th>Location</th>
</tr>
</thead>
<tbody><tr>
<td>Permanent Dimension</td>
<td>linear dimension</td>
<td>Dimension</td>
<td>OST_Dimensions</td>
<td>A Line</td>
<td>&#x3D;2</td>
<td>Specific view</td>
<td>null</td>
</tr>
<tr>
<td>Permanent Dimension</td>
<td>radial dimension</td>
<td>Dimension</td>
<td>OST_Dimensions</td>
<td>Null</td>
<td>1</td>
<td>Specific view</td>
<td>null</td>
</tr>
<tr>
<td>Permanent Dimension</td>
<td>diameter dimension</td>
<td>Dimension</td>
<td>OST_Dimensions</td>
<td>Null</td>
<td>1</td>
<td>Specific view</td>
<td>null</td>
</tr>
<tr>
<td>Permanent Dimension</td>
<td>angular dimension</td>
<td>Dimension</td>
<td>OST_Dimensions</td>
<td>An Arc</td>
<td>2</td>
<td>Specific view</td>
<td>null</td>
</tr>
<tr>
<td>Permanent Dimension</td>
<td>arc length dimension</td>
<td>Dimension</td>
<td>OST_Dimensions</td>
<td>An Arc</td>
<td>2</td>
<td>Specific view</td>
<td>null</td>
</tr>
<tr>
<td>Dimension Constraint</td>
<td>linear dimension constraint</td>
<td>Dimension</td>
<td>OST_Constraints</td>
<td>An Arc</td>
<td>2</td>
<td></td>
<td>null</td>
</tr>
<tr>
<td>Dimension Constraint</td>
<td>angular dimension</td>
<td>Dimension</td>
<td>OST_Constraints</td>
<td>An Arc</td>
<td>2</td>
<td></td>
<td>null</td>
</tr>
<tr>
<td>Equality Constraint</td>
<td>Equality Constraint</td>
<td>Dimension</td>
<td>OST_Constraints</td>
<td>A Line</td>
<td>&#x3D;3</td>
<td></td>
<td>null</td>
</tr>
</tbody></table>
<h3 id="创建和删除"><a href="#创建和删除" class="headerlink" title="创建和删除"></a>创建和删除</h3><p>NewDimension（）方法在Creation.Document类中可用。此方法只能创建线性标注。</p>
<p>代码区域16-2：NewDimension（）</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Dimension <span class="title">NewDimension</span> (<span class="params">View view, Line line, ReferenceArray references</span>)</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Dimension <span class="title">NewDimension</span> (<span class="params">View view, Line line, ReferenceArray references, </span></span></span><br><span class="line"><span class="params"><span class="function">DimensionType dimensionType</span>)</span></span><br></pre></td></tr></table></figure>

<p>使用NewDimension（）方法输入参数，可以定义可见的View、尺寸线和References（两个或多个）。但是，没有简单的方法将线性标注类型与其他类型区分开来。很少使用带有ExcisionType参数的重载NewDimension（）方法。 下面的代码演示如何使用NewDimension（）方法复制标注。</p>
<p>代码区域16-3：使用NewDimension（）复制标注</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DuplicateDimension</span>(<span class="params">Document document, Dimension dimension</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        Line line = dimension.Curve <span class="keyword">as</span> Line;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != line)</span><br><span class="line">        &#123;</span><br><span class="line">                Autodesk.Revit.DB.View view = dimension.View;</span><br><span class="line">                ReferenceArray references = dimension.References;</span><br><span class="line">                Dimension newDimension = document.Create.NewDimension(view, line, references);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>尽管只创建了线性标注，但您可以使用Document.Delete（）方法删除由Dimension和SpotDimension表示的所有标注和约束。 </p>
<p>标注文本操作 Dimension和ExpressionSegment类提供了类似的属性和方法，用于查询和调整文本相对于尺寸曲线的位置。 Dimension.Origin返回尺寸曲线中点的XYZ值，而ExpressionSegment.Origin将返回组成线段的直线的中点。 通过调用IsTextPositionAdjustable（）方法确定标注或标注段的文本位置是否可调，该方法将指示是否可以设置文本和引线位置。 使用属性TextPosition和LeaderEndPosition查询或修改文本或引线（标注或标注段）的位置。 通过调用ResetTextPosition（）方法将文本重置为其在尺寸上的默认位置。</p>
<p>注意：TextPosition和LeaderEndPosition不一定适用于所有标注（例如，标注样式为纵坐标时，使用相等约束的高程点标注、多段标注）。如果这些值不适用，它们将返回NULL，并且不允许设置值。</p>
<p>代码区域：重新定位标注文字</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Moves all of the text in this dimension one unit in the Y direction</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">DimensionTextReposition</span>(<span class="params">Dimension dimToModify</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">bool</span> modified = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (dimToModify == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check to see if we have a non-multisegment dimension and if text position is adjustable</span></span><br><span class="line">    <span class="keyword">if</span> (dimToModify.NumberOfSegments == <span class="number">0</span> &amp;&amp; dimToModify.IsTextPositionAdjustable())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Get the current text XYZ position</span></span><br><span class="line">        XYZ currentTextPosition = dimToModify.TextPosition;</span><br><span class="line">        <span class="comment">// Calculate a new XYZ position by transforming the current text position</span></span><br><span class="line">        XYZ newTextPosition = Transform.CreateTranslation(<span class="keyword">new</span> XYZ(<span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>)).OfPoint(currentTextPosition);</span><br><span class="line">        <span class="comment">// Set the new text position</span></span><br><span class="line">        dimToModify.TextPosition = newTextPosition;</span><br><span class="line"></span><br><span class="line">        modified = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (dimToModify.NumberOfSegments &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">foreach</span> (DimensionSegment currentSegment <span class="keyword">in</span> dimToModify.Segments)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (currentSegment != <span class="literal">null</span> &amp;&amp; currentSegment.IsTextPositionAdjustable())</span><br><span class="line">            &#123;</span><br><span class="line">                modified = <span class="literal">true</span>;</span><br><span class="line">                <span class="comment">// Get the current text XYZ position</span></span><br><span class="line">                XYZ currentTextPosition = currentSegment.TextPosition;</span><br><span class="line">                <span class="comment">// Calculate a new XYZ position by transforming the current text position</span></span><br><span class="line">                XYZ newTextPosition = Transform.CreateTranslation(<span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>)).OfPoint(currentTextPosition);</span><br><span class="line">                <span class="comment">// Set the new text position for the segment&#x27;s text</span></span><br><span class="line">                currentSegment.TextPosition = newTextPosition;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> modified;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="详图线"><a href="#详图线" class="headerlink" title="详图线"></a>详图线</h2><p>详图线是一种重要的详图构件，通常用于详图或绘图视图中。可以在DetailCurve类及其派生类中访问详图曲线。</p>
<p>DetailCurve与其他注释元素一样，是视图专有的。但是，没有DetailCurve.View属性。创建详图曲线时，必须将详图曲线与模型曲线视图进行比较。</p>
<p>代码区域16-4：NewDetailCurve（）和NewModelCurve（）</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> DetailCurve <span class="title">NewDetailCurve</span> (<span class="params">View, Curve, SketchPlane</span>)</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ModelCurve <span class="title">NewModelCurve</span> (<span class="params">Curve, SketchPlane</span>)</span></span><br></pre></td></tr></table></figure>

<p>通常，只有二维视图（如平面视图和立面视图）是可接受的，否则将引发异常。</p>
<p>除了与视图相关的功能外，DetailCurve与ModelCurve非常相似。有关ModelCurve属性和用法的详细信息，请参见“草图”部分中的ModelCurve。</p>
<h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><p>标签是用于标识图形元素的注释。API公开IndependentTag和RoomTag类，以涵盖Revit应用程序中使用的大多数标签。有关RoomTag的更多详细信息，请参阅房间。</p>
<p>注意：IndependentTag类表示Revit中的标签图元和其他特定标记，如注释标签、梁系统标签、电子电路符号等。在Revit内部代码中，特定标记具有从IndependentTag派生的相应类。因此，特定功能不会由API公开，并且无法使用IndependentTag.xml创建。它们可按以下类别加以区分：</p>
<p>表37：标签名称和类别</p>
<table>
<thead>
<tr>
<th><strong>Tag Name 标记名称</strong></th>
<th><strong>BuiltInCategory</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Keynote Tag</td>
<td>OST_KeynoteTags</td>
</tr>
<tr>
<td>Beam System Tag</td>
<td>OST_BeamSystemTags</td>
</tr>
<tr>
<td>Electronic Circuit Tag</td>
<td>OST_ElectricalCircuitTags</td>
</tr>
<tr>
<td>Span Direction Tag</td>
<td>OST_SpanDirectionSymbol</td>
</tr>
<tr>
<td>Path Reinforcement Span Tag</td>
<td>OST_PathReinSpanSymbol</td>
</tr>
<tr>
<td>Rebar System Span Tag</td>
<td>OST_IOSRebarSystemSpanSymbolCtrl</td>
</tr>
</tbody></table>
<p>族库中的每个类别都有一个预先制作的标记。某些标记会随默认的Revit应用程序样板自动加载，而其他标记则会手动加载。如果主体元素是使用“按类别”选项创建的，则IndependentTag对象将根据主体元素返回不同的类别。例如，Wall和Floor IndependentTag分别是OST_WallTags和OST_FloorTags。</p>
<p>如果标记是使用“Multi-Category ”或“Material”样式创建的，则它们的类别分别为OST_MultiCategoryTags和OST_MaterialTags。</p>
<p>请注意IndependentTag.Create只在2D视图或锁定的3D视图中工作，否则将引发异常。下面的代码是创建IndependentTag的示例。当标高视图为活动视图时运行该命令。</p>
<p>注意：您无法直接更改IndependentTag中显示的文本。您需要修改用于在要标记的图元的族类型中填充标记文字的参数。在下面的示例中，该参数为“Type Mark”，但可以在Revit UI的族编辑器中更改此设置。</p>
<p>代码区域16-5：创建IndependentTag</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> IndependentTag <span class="title">CreateIndependentTag</span>(<span class="params">Autodesk.Revit.DB.Document document, Reference reference</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// make sure active view is not a 3D view</span></span><br><span class="line">    Autodesk.Revit.DB.View view = document.ActiveView;</span><br><span class="line">    <span class="keyword">if</span> (view <span class="keyword">is</span> View3D)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// define tag mode and tag orientation for new tag</span></span><br><span class="line">    TagMode tagMode = TagMode.TM_ADDBY_CATEGORY;</span><br><span class="line">    TagOrientation tagorn = TagOrientation.Horizontal;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add the tag to the middle of the wall</span></span><br><span class="line">    Wall wall = document.GetElement(reference) <span class="keyword">as</span> Wall;</span><br><span class="line">    <span class="keyword">if</span> (wall == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    LocationCurve wallLoc = wall.Location <span class="keyword">as</span> LocationCurve;</span><br><span class="line">    XYZ wallStart = wallLoc.Curve.GetEndPoint(<span class="number">0</span>);</span><br><span class="line">    XYZ wallEnd = wallLoc.Curve.GetEndPoint(<span class="number">1</span>);</span><br><span class="line">    XYZ wallMid = wallLoc.Curve.Evaluate(<span class="number">0.5</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    IndependentTag newTag = IndependentTag.Create(document, view.Id, reference, <span class="literal">true</span>, tagMode, tagorn, wallMid);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> == newTag)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Create IndependentTag Failed.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// newTag.TagText is read-only, so we change the Type Mark type parameter to </span></span><br><span class="line">    <span class="comment">// set the tag text.  The label parameter for the tag family determines</span></span><br><span class="line">    <span class="comment">// what type parameter is used for the tag text.</span></span><br><span class="line"></span><br><span class="line">    WallType type = wall.WallType;</span><br><span class="line"></span><br><span class="line">    Parameter foundParameter = type.LookupParameter(<span class="string">&quot;Type Mark&quot;</span>);</span><br><span class="line">    <span class="built_in">bool</span> result = foundParameter.Set(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set leader mode free</span></span><br><span class="line">    <span class="comment">// otherwise leader end point move with elbow point</span></span><br><span class="line"></span><br><span class="line">    newTag.LeaderEndCondition = LeaderEndCondition.Free;</span><br><span class="line">    XYZ elbowPnt = wallMid + <span class="keyword">new</span> XYZ(<span class="number">5.0</span>, <span class="number">5.0</span>, <span class="number">0.0</span>);</span><br><span class="line">    newTag.LeaderElbow = elbowPnt;</span><br><span class="line">    XYZ headerPnt = wallMid + <span class="keyword">new</span> XYZ(<span class="number">10.0</span>, <span class="number">10.0</span>, <span class="number">0.0</span>);</span><br><span class="line">    newTag.TagHeadPosition = headerPnt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> newTag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-6FE76534-FEA8-4573-A2D7-747AB527B335-low.png"></p>
<p>图74：使用示例代码创建IndependentTag</p>
<h2 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h2><p>可以从TextNote类访问文本和关联的引线。注意TextNote可以包含纯文本或格式化文本。重载的TextNote.Create（）方法提供了用于创建展开和换行文本注释元素的选项。文本内容区域的宽度可以在创建时指定，但受基于文本及其类型的属性的最小和最大宽度的限制。从TextElement继承的重载方法GetMinimumAllowedWidth（）和GetMaximumAllowedWidth（）返回特定TextNote或给定文档和文本类型ID的约束。</p>
<p>下面的示例在用户指定的点处使用给定的宽度和TextNoteOptions创建一个新的TextNote。</p>
<p>代码区域：创建文本注释</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TextNote <span class="title">AddNewTextNote</span>(<span class="params">UIDocument uiDoc</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Document doc = uiDoc.Document;</span><br><span class="line">    XYZ textLoc = uiDoc.Selection.PickPoint(<span class="string">&quot;Pick a point for sample text.&quot;</span>);</span><br><span class="line">    ElementId defaultTextTypeId = doc.GetDefaultElementTypeId(ElementTypeGroup.TextNoteType);</span><br><span class="line">    <span class="built_in">double</span> noteWidth = <span class="number">.2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// make sure note width works for the text type</span></span><br><span class="line">    <span class="built_in">double</span> minWidth = TextNote.GetMinimumAllowedWidth(doc, defaultTextTypeId);</span><br><span class="line">    <span class="built_in">double</span> maxWidth = TextNote.GetMaximumAllowedWidth(doc, defaultTextTypeId);</span><br><span class="line">    <span class="keyword">if</span> (noteWidth &lt; minWidth)</span><br><span class="line">    &#123;</span><br><span class="line">        noteWidth = minWidth;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (noteWidth &gt; maxWidth)</span><br><span class="line">    &#123;</span><br><span class="line">        noteWidth = maxWidth;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TextNoteOptions opts = <span class="keyword">new</span> TextNoteOptions(defaultTextTypeId);</span><br><span class="line">    opts.HorizontalAlignment = HorizontalTextAlignment.Left;</span><br><span class="line">    opts.Rotation = Math.PI / <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    TextNote textNote = TextNote.Create(doc, doc.ActiveView.Id, textLoc, noteWidth, <span class="string">&quot;New sample text&quot;</span>, opts);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> textNote;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>无论TextNote具有纯文本还是格式化文本，始终可以从TextNote.Text属性检索未格式化的文本。</p>
<p>格式化文本 当第一次创建时，TextNote将具有纯文本。使用TextNote. GetNotedText（）方法获取TextNote的NotedText对象。类可以用于对文本应用各种格式，如粗体、下划线、上标或全部大写。在使用修改后的TextText调用SetSetNotedText（）之前，TextNote不会更新。 可以使用TextRange全部或部分地格式化已删除文本中的文本。TextRange基于TextedText对象中的文本指定起始索引和长度。当格式化方法（如SetItalicStatus（）或SetAllCapsStatus（））的重载使用TextRange时，将只修改该范围内的字符。TextRange可以使用其构造函数显式定义，也可以使用FormattedText.Find（）方法检索以获取给定搜索字符串的范围。Find（）方法指定搜索的开始索引，以及是否匹配搜索字符串的大小写或是否进行全词搜索。如果在搜索字符串中找不到文本，或者如果给定的起始索引超出了整个文本的长度，则将返回一个空的TextRange。在使用返回的范围设置文本格式之前，请确保该范围不为空，以避免异常。 下面的示例演示如何设置TextNote中的文本格式并将其设置回TextNote。它使用Find（）方法对文本中的特定单词加粗体和下划线。</p>
<p>代码区域：设置TextNote中的文本格式</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">FormatText</span>(<span class="params">TextNote textNote</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// TextNote created with &quot;New sample text&quot;</span></span><br><span class="line">    FormattedText formatText = textNote.GetFormattedText();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// italicize &quot;New&quot;</span></span><br><span class="line">    TextRange range = <span class="keyword">new</span> TextRange(<span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">    formatText.SetItalicStatus(range, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// make &quot;sample&quot; bold</span></span><br><span class="line">    range = formatText.Find(<span class="string">&quot;sample&quot;</span>, <span class="number">0</span>, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">if</span> (range.Length &gt; <span class="number">0</span>)</span><br><span class="line">        formatText.SetBoldStatus(range, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// make &quot;text&quot; underlined</span></span><br><span class="line">    range = formatText.Find(<span class="string">&quot;text&quot;</span>, <span class="number">0</span>, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">if</span> (range.Length &gt; <span class="number">0</span>)</span><br><span class="line">        formatText.SetUnderlineStatus(range, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// make all text uppercase</span></span><br><span class="line">    formatText.SetAllCapsStatus(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    textNote.SetFormattedText(formatText);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以将新文本添加到已添加文本对象中的现有文本中。如果使用了具有TextRange参数的重载，SetPlainText（）方法将替换某些现有文本，否则将替换整个文本。若要插入文本而不替换现有文本，请使用Length为0的TextRange。新文本将插入到TextRange.Start属性指定的索引处。请注意，插入文本时，它可能会选择相邻文本的格式，类似于将未格式化的文本粘贴到Word文档中将导致文本具有插入点的当前格式。如果格式设置已经应用于整个multitedText，如上面示例中的SetAllCapsStatus（true）调用，则该格式设置将应用于插入的任何新文本。 在下面的示例中，通过首先查找当前文本的结尾并将其设置为要添加的范围的开始，新文本将被追加到现有文本的结尾。它还演示了如何创建一个列表（可以是项目符号，编号或字母）。请注意，它还为新文本的范围调用GetAllCapsStatus（），并在状态不是“大写状态.无”（其他选项是“全部”和“混合”）时关闭大写。</p>
<p>代码区域：插入新文本</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AppendText</span>(<span class="params">TextNote textNote</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    FormattedText formatText = textNote.GetFormattedText();</span><br><span class="line"></span><br><span class="line">    TextRange range = formatText.AsTextRange();</span><br><span class="line"></span><br><span class="line">    range.Start = range.End - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// set Length to 0 to insert</span></span><br><span class="line">    range.Length = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">string</span> someNewText = <span class="string">&quot;\rThis is a new paragraph\vThis is a new line without a paragraph break\r&quot;</span>;</span><br><span class="line">    formatText.SetPlainText(range, someNewText);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get range for entire text</span></span><br><span class="line">    range = formatText.AsTextRange();</span><br><span class="line">    range.Start = range.End - <span class="number">1</span>;</span><br><span class="line">    range.Length = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">string</span> someListText = <span class="string">&quot;\rBulleted List item 1\rItem 2\vSecond line for Item 2\rThird bullet point&quot;</span>;</span><br><span class="line">    formatText.SetPlainText(range, someListText);</span><br><span class="line">    range.Start++;</span><br><span class="line">    range.Length = someListText.Length;</span><br><span class="line">    formatText.SetListType(range, ListType.Bullet);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (formatText.GetAllCapsStatus(range) != FormatStatus.None)</span><br><span class="line">    &#123;</span><br><span class="line">        formatText.SetAllCapsStatus(range, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    textNote.SetFormattedText(formatText);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码显示了如何使用\r创建换行符，使用\v创建不打断段落的垂直制表符。在项目符号列表的文本中，“\v”用于创建两行项目符号。仅在使用“\r”时才插入新项目符号。 </p>
<p>文本编辑器 TextEditorOptions类可用于控制Revit中文本编辑器的外观和功能。这些设置保存在Revit.ini文件中，不与文档绑定。</p>
<p>代码区域：设置文本编辑器选项</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetEditorOptions</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    TextEditorOptions editorOptions = TextEditorOptions.GetTextEditorOptions();</span><br><span class="line">    editorOptions.ShowBorder = <span class="literal">false</span>;</span><br><span class="line">    editorOptions.ShowOpaqueBackground = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="引线"><a href="#引线" class="headerlink" title="引线"></a>引线</h3><p>Revit支持两种引线：直线引线和圆弧引线。可以使用AddLeader（）方法将引线添加到TextNote，并使用TextNoteLeaderType枚举类型指定引线类型：</p>
<p>表39：引线类型</p>
<table>
<thead>
<tr>
<th><strong>Function 功能</strong></th>
<th><strong>Member Name 成员名称</strong></th>
</tr>
</thead>
<tbody><tr>
<td><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-0A443B27-ACDB-401E-8486-62165414529F-low.png" alt="img"> -添加右弧引线</td>
<td>TNLT_ARC_R</td>
</tr>
<tr>
<td><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-EE3246C4-B4F8-443D-9958-66CE5E62BB12-low.png" alt="img"> -添加左弧引线</td>
<td>TNLT_ARC_L</td>
</tr>
<tr>
<td><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-0D7DA193-EC77-4E99-A864-CA1E69BB3A62-low.png" alt="img"> -添加右引线。</td>
<td>TNLT_STRAIGHT_R</td>
</tr>
<tr>
<td><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-60BA1957-992C-468D-8459-7A26E418BF57-low.png" alt="img"> -添加左引线。</td>
<td>TNLT_STRAIGHT_L</td>
</tr>
</tbody></table>
<p>注意：直线引线和圆弧引线不能同时添加到文本类型。</p>
<p>TextNote.LeaderCount属性返回引线数，GetLeaders（）方法返回当前附加到文本组件的所有引线。LeaderLeftAttachment和LeaderRightAttachment指示引线在TextNote的相应侧上的附着位置。LeaderAttachment的选项有TopLine、MidPoint和BottomLine。使用RemoveLeaders（）方法从TextNote中删除所有引线。</p>
<h2 id="注释符号"><a href="#注释符号" class="headerlink" title="注释符号"></a>注释符号</h2><p>注释符号是应用于族的符号，用于在项目中唯一标识该族。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-75864163-28D5-496D-9077-98DFECA07E75-low.png"></p>
<p>图76：带有两条引线的注释符号</p>
<h3 id="创建和删除-1"><a href="#创建和删除-1" class="headerlink" title="创建和删除"></a>创建和删除</h3><p>可以使用Creation.Document.NewFamilyInstance（）方法的以下重载创建注释符号：</p>
<p>代码区域16-6：创建新注释符号</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> FamilyInstance NewFamilyInstance <span class="title">Method</span> (<span class="params">XYZ origin, FamilySymbol symbol, View specView</span>)</span></span><br></pre></td></tr></table></figure>

<p>可以使用Document.Delete（）方法删除注释符号。 </p>
<p>添加和删除Leader 使用addLeader（）和removeLeader（）方法添加和删除引线。</p>
<p>代码区域16-7：使用addLeader（）和removeLeader（）</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddAndRemoveLeaders</span>(<span class="params">AnnotationSymbol symbol</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// check if there are any leaders currently attached, and remove them</span></span><br><span class="line">    IList leaders = symbol.GetLeaders();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (leaders != <span class="literal">null</span> &amp;&amp; leaders.Count &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = leaders.Count; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            symbol.removeLeader();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// add one new leader instead</span></span><br><span class="line">    symbol.addLeader();&#125;</span><br></pre></td></tr></table></figure>

<h2 id="注：翻译自Revit-API-Developers-Guide"><a href="#注：翻译自Revit-API-Developers-Guide" class="headerlink" title="注：翻译自Revit API Developers Guide"></a><em><strong>注：</strong></em>翻译自<a href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_html">Revit API Developers Guide</a></h2>]]></content>
      <categories>
        <category>Revit二次开发人员指南</category>
      </categories>
      <tags>
        <tag>Revit</tag>
      </tags>
  </entry>
  <entry>
    <title>20材料</title>
    <url>/2024/12/15/Revit%E4%BA%8C%E5%BC%80%E6%8C%87%E5%8D%97/20%E6%9D%90%E6%96%99/</url>
    <content><![CDATA[<h1 id="材质"><a href="#材质" class="headerlink" title="材质"></a><a href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_Revit_Geometric_Elements_Material_html">材质</a></h1><p>在Revit Platform API中，材质数据作为图元进行存储和管理。就像在Revit UI中一样，材质可以有多个与之关联的资源，但只能使用API指定热学和结构（在Revit UI中称为物理）资源。</p>
<p>某些材质特征由材质类本身的属性（例如FillPattern、Color或Render）表示，而其他材质特征则可用作与材质关联的结构资源或热资源的属性。</p>
<p>在本章中，您将学习如何访问Material元素以及如何管理文档中的Material对象。“元素材质”提供了一个演练，演示如何获取窗材质。</p>
<p>本节中的页面</p>
<ul>
<li>一般材质信息</li>
<li>材质管理</li>
<li>元素材质</li>
<li>材质数量</li>
<li>绘制元素的表面</li>
</ul>
<h2 id="一般材质信息"><a href="#一般材质信息" class="headerlink" title="一般材质信息"></a>一般材质信息</h2><p>在开始演练之前，请通读以下部分以更好地理解Material类。</p>
<p>所有材质对象都可以使用材质类过滤器进行检索。材质对象也可在文档、类别、元素、面等中使用，并在本章的相关部分中进行讨论。无论你在哪里得到一个材质对象，它都被表示为Material类。</p>
<p><strong>属性</strong></p>
<p>材质将具有与渲染外观、结构或其他主要材质类别相关的一个或多个方面。每个方面都由Material类本身的属性或通过其结构或热资产之一表示。StructuralAsset类表示与结构分析相关的材料属性。ThermalAsset类表示与能量分析相关的材料属性。</p>
<p>代码区域19-3：获取材料属性</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ReadMaterialProps</span>(<span class="params">Document document, Material material</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ElementId strucAssetId = material.StructuralAssetId;</span><br><span class="line">    <span class="keyword">if</span> (strucAssetId != ElementId.InvalidElementId)</span><br><span class="line">    &#123;</span><br><span class="line">        PropertySetElement pse = document.GetElement(strucAssetId) asPropertySetElement;</span><br><span class="line">        <span class="keyword">if</span> (pse != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            StructuralAsset asset = pse.GetStructuralAsset();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Check the material behavior and only read if Isotropic</span></span><br><span class="line">            <span class="keyword">if</span> (asset.Behavior == StructuralBehavior.Isotropic)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// Get the class of material</span></span><br><span class="line">                StructuralAssetClass assetClass = asset.StructuralAssetClass; <span class="comment">// Get other material properties</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// Get other material properties</span></span><br><span class="line">                <span class="built_in">double</span> poisson = asset.PoissonRatio.X;</span><br><span class="line">                <span class="built_in">double</span> youngMod = asset.YoungModulus.X;</span><br><span class="line">                <span class="built_in">double</span> thermCoeff = asset.ThermalExpansionCoefficient.X;</span><br><span class="line">                <span class="built_in">double</span> unitweight = asset.Density;</span><br><span class="line">                <span class="built_in">double</span> shearMod = asset.ShearModulus.X;</span><br><span class="line">                <span class="built_in">double</span> dampingRatio = asset.DampingRatio;</span><br><span class="line">                <span class="keyword">if</span> (assetClass == StructuralAssetClass.Metal)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">double</span> dMinStress = asset.MinimumYieldStress;</span><br><span class="line">                &#125;</span><br><span class="line">                elseif (assetClass == StructuralAssetClass.Concrete)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">double</span> dConcComp = asset.ConcreteCompression;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Classification</strong> </p>
<p>与结构分析相关的材料分类（即钢、混凝土、木材）可以从与材料关联的StructuralAsset的StructuralAssetClass属性中获得。</p>
<p>注意：API不提供对混凝土材料的混凝土类型值的访问。</p>
<p>与能量分析相关的材料分类（即固体、液体、气体）可以从与材料关联的ThermalAsset的ThermalMaterialType属性中获得。</p>
<p><strong>其它性质</strong></p>
<p>材质对象属性标识特定类型的材质，包括颜色、填充图案等。</p>
<p>属性和参数</p>
<p>某些“材质”属性只能作为“参数”使用。有一些，如颜色，可作为属性或作为参数使用内置参数MATERIAL_PARAM_COLOR。</p>
<p>渲染信息</p>
<p>渲染数据的集合被组织到称为资源的对象中，这些对象是只读的。您可以从Application.Assets属性获取所有可用的与外观相关的资产。可以通过Material.AppearanceAssetId属性从材质访问外观资源。</p>
<p>下图显示了“资源浏览器”对话框的“外观库”部分，其中显示了某些渲染资源在UI中的显示方式。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/AssetBrowser.jpg"></p>
<p>图106：外观库</p>
<p>SDK附带的Materials示例应用程序显示了如何将RenderApperance属性设置为对话框中选定的材质。该对话框将填充Application.Assets中的所有Asset对象。</p>
<p>填充模式</p>
<p>文档中的所有FillPatterns都可以使用FilteredElementCollector过滤类FillPatternElement。FillPatternElement是包含FillPattern的元素，而FillPattern类提供对模式名称和组成模式的FillGrid集的访问。</p>
<p>FillPatterns有两种：Drafting和Model。在UI中，只能将“绘图”填充样式设置为Material.CutPatternId。填充图案类型通过FillPattern.Target属性公开。下面的示例显示如何更改材质FillPattern。</p>
<p>代码区域19-4：设置填充图案</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetFillPattern</span>(<span class="params">Document document, Material material</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">    ICollection fillPatternElements = collector.OfClass(<span class="keyword">typeof</span>(FillPatternElement)).ToElementIds();</span><br><span class="line">    <span class="keyword">foreach</span> (ElementId fillPatternId <span class="keyword">in</span> fillPatternElements)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// always set successfully</span></span><br><span class="line">        material.CutPatternId = fillPatternId;</span><br><span class="line">        material.SurfacePatternId = fillPatternId;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="材质管理"><a href="#材质管理" class="headerlink" title="材质管理"></a>材质管理</h2><p>您可以使用过滤来检索文档中的所有材料。文档中的每个Material对象都由唯一的名称标识。</p>
<p>以下示例说明如何使用材质名称获取材质。</p>
<p>代码区域19-5：按名称获取材质</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">FilteredElementCollector elementCollector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">elementCollector.WherePasses(<span class="keyword">new</span> ElementClassFilter(<span class="keyword">typeof</span>(Material)));</span><br><span class="line">IList materials = elementCollector.ToElements();</span><br><span class="line"></span><br><span class="line">Material floorMaterial = <span class="literal">null</span>;</span><br><span class="line"><span class="built_in">string</span> floorMaterialName = <span class="string">&quot;Default Floor&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> (Element materialElement <span class="keyword">in</span> materials)</span><br><span class="line">&#123;</span><br><span class="line">    Material material = materialElement <span class="keyword">as</span> Material;</span><br><span class="line">    <span class="keyword">if</span> (floorMaterialName == material.Name)</span><br><span class="line">    &#123;</span><br><span class="line">        floorMaterial = material;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">null</span> != floorMaterial)</span><br><span class="line">&#123;</span><br><span class="line">    TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>,<span class="string">&quot;Material found.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：要运行示例代码，请确保文档中存在材质名称。当前文档的所有材质名称都位于“管理”选项卡（“项目设置”面板  Materials）下。</p>
<p>创建材质</p>
<p>有两种方法可以在API中创建新的Material对象。</p>
<ul>
<li>复制现有材质</li>
<li>添加新材质。</li>
</ul>
<p>使用Duplicate（）方法时，返回的Material对象与原始对象的类型相同。</p>
<p>代码区域19-6：复制材料</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="built_in">bool</span> <span class="title">DuplicateMaterial</span>(<span class="params">Material material</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="built_in">bool</span> duplicated = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//try to duplicate a new instance of Material class using duplicate method</span></span><br><span class="line">        <span class="comment">//make sure the name of new material is unique in MaterailSet</span></span><br><span class="line">        <span class="built_in">string</span> newName = <span class="string">&quot;new&quot;</span> + material.Name;</span><br><span class="line">        Material myMaterial = material.Duplicate(newName);</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == myMaterial)</span><br><span class="line">        &#123;</span><br><span class="line">                TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>, <span class="string">&quot;Failed to duplicate a material!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">                duplicated = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> duplicated;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用静态方法Material.Create（）直接添加新Material。无论如何应用，都必须为材质和属于该材质的任何资产指定唯一的名称。唯一名称是“材质”对象键。</p>
<p>代码区域19-7：添加新材质</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Create the material</span></span><br><span class="line">ElementId materialId = Material.Create(document, <span class="string">&quot;My Material&quot;</span>);</span><br><span class="line">Material material = document.GetElement(materialId) <span class="keyword">as</span> Material;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Create a new property set that can be used by this material</span></span><br><span class="line">StructuralAsset strucAsset = <span class="keyword">new</span> StructuralAsset(<span class="string">&quot;My Property Set&quot;</span>, StructuralAssetClass.Concrete);</span><br><span class="line">strucAsset.Behavior = StructuralBehavior.Isotropic;</span><br><span class="line">strucAsset.Density = <span class="number">232.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Assign the property set to the material.</span></span><br><span class="line">PropertySetElement pse = PropertySetElement.Create(document, strucAsset);</span><br><span class="line">material.SetMaterialAspectByPropertySet(MaterialAspect.Structural, pse.Id);</span><br></pre></td></tr></table></figure>

<p>删除材质</p>
<p>要删除材料，用：</p>
<ul>
<li>Document.Delete()</li>
</ul>
<p>Document.Delete() 是一个泛型方法。有关详细信息，请参见编辑元素。</p>
<h2 id="元素材质"><a href="#元素材质" class="headerlink" title="元素材质"></a>元素材质</h2><p>一个元素可以有多个元素和组件。例如，FamilyInstance具有SubComponents，Wall具有CompoundStructure，其中包含多个CompoundStructureLayers。(有关“子构件”的详细信息，请参阅“族”部分，有关“复合结构”的详细信息，请参阅“墙、楼板、屋顶和洞口”。）</p>
<p>在Revit Platform API中，使用以下准则获取图元的材质：</p>
<ul>
<li>如果元素包含元素，则单独获取材料。</li>
<li>如果图元包含构件，请从参数或以特定方式获取每个构件的材质（请参见墙、楼板、屋顶和洞口中的“材质”部分）。</li>
<li>如果构件的材质返回null，则从相应的Element.Category子类别中获取物料。</li>
</ul>
<p><strong>参数中的材质</strong></p>
<p>如果Element对象有一个参数，其中的参数类型是参数类型.材料，您可以从参数中获取元素材料。例如，结构柱FamilySymbol（类别为BuiltInCategory.OST_StructuralColumns的FamilyInstance）具有“结构材质”参数。使用ElementId获取材质。下面的代码示例阐释如何获取具有一个构件的结构柱Material。</p>
<p>代码区域：从参数获取元素材质</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetMaterial</span>(<span class="params">Document document, FamilyInstance familyInstance</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">foreach</span> (Parameter parameter <span class="keyword">in</span> familyInstance.Parameters)</span><br><span class="line">    &#123;</span><br><span class="line">        Definition definition = parameter.Definition;</span><br><span class="line">        <span class="comment">// material is stored as element id</span></span><br><span class="line">        <span class="keyword">if</span> (parameter.StorageType == StorageType.ElementId)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (definition.ParameterGroup == BuiltInParameterGroup.PG_MATERIALS &amp;&amp;</span><br><span class="line">                    definition.ParameterType == ParameterType.Material)</span><br><span class="line">            &#123;</span><br><span class="line">                Autodesk.Revit.DB.Material material = <span class="literal">null</span>;</span><br><span class="line">                Autodesk.Revit.DB.ElementId materialId = parameter.AsElementId();</span><br><span class="line">                <span class="keyword">if</span> (<span class="number">-1</span> == materialId.IntegerValue)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//Invalid ElementId, assume the material is &quot;By Category&quot;</span></span><br><span class="line">                    <span class="keyword">if</span> (<span class="literal">null</span> != familyInstance.Category)</span><br><span class="line">                    &#123;</span><br><span class="line">                        material = familyInstance.Category.Material;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    material = document.GetElement(materialId) <span class="keyword">as</span> Material;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>,<span class="string">&quot;Element material: &quot;</span> + material.Name);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>如果在UI中将材质属性设置为“按类别”，则材质的ElementId为ElementId.InvalidElementId，并且不能用于检索Material对象，如示例代码中所示。尝试从类别中检索材质，如下一节所述。 其他化合物参数中包含的某些材质特性无法从API访问。例如，在下图中，对于“系统族：栏杆扶手”，“栏杆结构”参数的“栏杆类型”为“栏杆类型.无”。因此，在这种情况下，您无法获得实质性信息。<img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/ByCategory.jpg"></p>
<p>图107：扶手结构属性</p>
<p> Material和FamilyInstance 梁族、柱族和基础族有另一种使用其StructuralMaterialId属性获取其材质的方法。此属性返回一个ElementId，用于标识定义实例的结构分析属性的材质。</p>
<p>代码区域：从族实例获取图元材质</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Material <span class="title">GetFamilyInstanceMaterial</span>(<span class="params">Document document, FamilyInstance beam</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Material material = document.GetElement(beam.StructuralMaterialId) <span class="keyword">as</span> Material;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> material;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>材质和类别</strong></p>
<p>只有模型图元可以具有材质。</p>
<p>从Revit的“管理”选项卡中，单击“设置” <img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/ac.menuaro.gif" alt="img"> “对象样式”以显示“对象样式”对话框。类别列在“模型对象”（Model Objects)选项卡中的图元具有材质信息。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/ModelObjectsMaterial.jpg" alt="img"></p>
<p>图108：材质分类</p>
<p>只有模型元素可以指定“材质”属性。因此，查询与Model元素（例如，Annotations或Imported）以外的元素相对应的类别的Material将始终导致null。有关元素和类别分类的更多详细信息，请参阅元素要素。</p>
<p>如果一个元素有多个组件，则某些类别.子类别对应于这些组件。</p>
<p>在上一个“对象样式”对话框中，“窗类别”和“框架&#x2F;竖梃”子类别以及“玻璃”子类别将映射到windows元素中的构件。在下图中，似乎窗符号Glass材质参数是获取窗玻璃材质的唯一方法。但是，该值为“按类别”，相应的参数返回ElementId. InvalidElementId。</p>
<p>在这种情况下，窗户的Material不为null，它取决于Category OST_WindowsFrameMullionProjection的Material属性，该属性是窗口类别OST_Windows的子类别。如果它也返回null，则窗格的Material由父类别OST_Windows确定。有关更多详细信息，请参阅元素材质。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-4E345BF1-1837-41C7-BF9C-A89A1A76539F-low.png"></p>
<p>图109：窗户材料</p>
<p><strong>复合结构层材料</strong></p>
<p>可以从HostObjAttributes获取CompoundStructureLayer对象。有关详细信息，请参阅墙、地板、天花板、屋顶和洞口。</p>
<p><strong>电子元件材料</strong></p>
<p>下图显示了检索元素材质的工作流：</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-64D41480-87CE-454E-8B14-1EFEFEC8BF09-low.png"></p>
<p>图110：获取元素材质工作流</p>
<p>此工作流说明了以下过程：</p>
<ul>
<li>该工作流显示了如何获取属于图元的Material对象（而不是Autodesk.Revit.DB.Structure.StructuralMaterialType枚举类型）。</li>
<li>检索材质时有两种要素分类：<ul>
<li>HostObject with CompoundStructure -从CompoundStructureLayer类MaterialId属性获取Material对象。</li>
<li>其他-从参数中获取材质。</li>
</ul>
</li>
<li>当您获得空Material对象或值为ElementId.InvalidElementId的无效ElementId时，请尝试相应类别中的Material。请注意，FamilyInstance及其FamilySymbol通常具有相同的类别。</li>
<li>对Element对象了解得越多，获取材质就越容易。举例来说：<ul>
<li>如果知道元素是梁，则可以获取实例参数Structural Material</li>
<li>如果知道该元素是一个窗口，则可以将其强制转换为FamilyInstance并获取FamilySymbol。</li>
</ul>
</li>
<li>之后，您可以获得参数，如框架外部材料或框架内部材料，以获得材料对象。如果你得到null，尝试从FamilySymbol类别中获取Material对象。</li>
<li>API中并非所有元素材质都可用。</li>
</ul>
<p><strong>演练：获取窗户材质</strong></p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetMaterial</span>(<span class="params">Document document, FamilyInstance window</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    FamilySymbol windowSymbol = window.Symbol;</span><br><span class="line">    Category category = windowSymbol.Category;</span><br><span class="line">    Autodesk.Revit.DB.Material frameExteriorMaterial = <span class="literal">null</span>;</span><br><span class="line">    Autodesk.Revit.DB.Material frameInteriorMaterial = <span class="literal">null</span>;</span><br><span class="line">    Autodesk.Revit.DB.Material sashMaterial = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// Check the parameters first</span></span><br><span class="line">    <span class="keyword">foreach</span> (Parameter parameter <span class="keyword">in</span> windowSymbol.Parameters)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span> (parameter.Definition.Name)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;Frame Exterior Material&quot;</span>:</span><br><span class="line">                frameExteriorMaterial = document.GetElement(parameter.AsElementId()) <span class="keyword">as</span> Material;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;Frame Interior Material&quot;</span>:</span><br><span class="line">                frameInteriorMaterial = document.GetElement(parameter.AsElementId()) <span class="keyword">as</span> Material;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;Sash&quot;</span>:</span><br><span class="line">                sashMaterial = document.GetElement(parameter.AsElementId()) <span class="keyword">as</span> Material;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="literal">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Try category if the material is set by category</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> == frameExteriorMaterial)</span><br><span class="line">        frameExteriorMaterial = category.Material;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> == frameInteriorMaterial)</span><br><span class="line">        frameInteriorMaterial = category.Material;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> == sashMaterial)</span><br><span class="line">        sashMaterial = category.Material;</span><br><span class="line">    <span class="comment">// Show the result because the category may have a null Material,</span></span><br><span class="line">    <span class="comment">// the Material objects need to be checked.</span></span><br><span class="line">    <span class="built_in">string</span> materialsInfo = <span class="string">&quot;Frame Exterior Material: &quot;</span> + (<span class="literal">null</span> != frameExteriorMaterial ? frameExteriorMaterial.Name : <span class="string">&quot;null&quot;</span>) + <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    materialsInfo += <span class="string">&quot;Frame Interior Material: &quot;</span> + (<span class="literal">null</span> != frameInteriorMaterial ? frameInteriorMaterial.Name : <span class="string">&quot;null&quot;</span>) + <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    materialsInfo += <span class="string">&quot;Sash: &quot;</span> + (<span class="literal">null</span> != sashMaterial ? sashMaterial.Name : <span class="string">&quot;null&quot;</span>) + <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>,materialsInfo);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h2 id="材质数量"><a href="#材质数量" class="headerlink" title="材质数量"></a>材质数量</h2><p>有一些方法可以直接获取Revit为材质提取明细表计算的材质体积和面积：</p>
<ul>
<li>Element.GetMaterialIds() –获取元素中的材料列表</li>
<li>Element.GetMaterialVolume() – 获取元素中特定材料的体积</li>
<li>Element.GetMaterialArea() – 获取元素中特定材质的面积</li>
</ul>
<p>这些方法适用于其中Category. HasMaterialList属性为true的元素类别。实际上，这仅限于使用复合结构的图元（如墙、屋顶、楼板、天花板）、其他一些基本三维图元（如楼梯）以及可以将材质指定给族几何图形的三维族（如窗、门、柱、MEP设备和装置以及常规模型族）。请注意，在这些类别中，对于如何提取材料数量有进一步的限制。例如，幕墙和幕墙屋顶本身不会报告任何材质数量;这些构件使用的材质可以从组成幕墙系统的各个嵌板图元中提取。</p>
<p>请注意，在某些情况下，Revit计算的体积和面积可能是近似值。例如，对于墙内的各个层，模型中可见的体积与材质提取明细表中显示的体积之间可能会出现微小的差异。使用墙饰条工具向墙添加饰条或分隔缝时，或在某些连接条件下，往往会出现这些差异。</p>
<p>SDK示例“MaterialTools”结合了材质数量提取工具和剪切元素（洞口、窗和门）的临时抑制，以提取总材质数量和净材质数量。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/material_quantities.png"></p>
<h2 id="绘制元素的表面"><a href="#绘制元素的表面" class="headerlink" title="绘制元素的表面"></a>绘制元素的表面</h2><p>绘制工具功能可通过Revit API使用。可以使用材质绘制墙、楼板和屋顶等图元的面以更改其外观。它不会改变元素的结构。</p>
<p>与绘制元素相关的方法是Document类的一部分。Paint（）将材质应用于元素的指定面。Document.RemovePaint（）将移除应用的材质。此外，IsPainted（）和GetPaintedMaterial（）方法返回有关元素表面的信息。</p>
<p>代码区域：绘制墙面</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Paint any unpainted faces of a given wall</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PaintWallFaces</span>(<span class="params">Wall wall, ElementId matId</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Document doc = wall.Document;</span><br><span class="line">    GeometryElement geometryElement = wall.get_Geometry(<span class="keyword">new</span> Options());</span><br><span class="line">    <span class="keyword">foreach</span> (GeometryObject geometryObject <span class="keyword">in</span> geometryElement)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (geometryObject <span class="keyword">is</span> Solid)</span><br><span class="line">        &#123;</span><br><span class="line">            Solid solid = geometryObject <span class="keyword">as</span> Solid;</span><br><span class="line">            <span class="keyword">foreach</span> (Face face <span class="keyword">in</span> solid.Faces)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (doc.IsPainted(wall.Id, face) == <span class="literal">false</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    doc.Paint(wall.Id, face, matId);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="注：翻译自Revit-API-Developers-Guide"><a href="#注：翻译自Revit-API-Developers-Guide" class="headerlink" title="注：翻译自Revit API Developers Guide"></a><em><strong>注：</strong></em>翻译自<a href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_html">Revit API Developers Guide</a></h2>]]></content>
      <categories>
        <category>Revit二次开发人员指南</category>
      </categories>
      <tags>
        <tag>Revit</tag>
      </tags>
  </entry>
  <entry>
    <title>19草图</title>
    <url>/2024/12/15/Revit%E4%BA%8C%E5%BC%80%E6%8C%87%E5%8D%97/19%E8%8D%89%E5%9B%BE/</url>
    <content><![CDATA[<h1 id="草图"><a href="#草图" class="headerlink" title="草图"></a><a href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_Revit_Geometric_Elements_Sketching_html">草图</a></h1><p>要在Revit中创建图元或编辑其轮廓，必须先创建草图对象。需要绘制草图的图元示例包括：</p>
<ul>
<li>Roofs 屋顶</li>
<li>Floors 地板</li>
<li>Stairs 楼梯</li>
<li>Railings 栏杆</li>
</ul>
<p>还需要草图来定义其他类型的几何图形，例如：</p>
<ul>
<li>Extrusions 拉伸</li>
<li>Openings 开口</li>
<li>Regions 区域</li>
</ul>
<p>在Revit Platform API中，草图函数由二维和三维草图类表示，如下所示：</p>
<ul>
<li>二维Sketch：<ul>
<li>SketchPlane 草图平面</li>
<li>Sketch 草图</li>
<li>ModelCurve 模型线</li>
<li>and more</li>
</ul>
</li>
<li>三维Sketch：<ul>
<li>GenericForm 通用形状</li>
<li>Path3D 3D路径</li>
</ul>
</li>
</ul>
<p>除了草图元素外，本章还介绍了ModelCurve。有关元素分类的详细信息，请参阅元素部分中的元素分类。</p>
<p> 本节中的页面</p>
<ul>
<li>2DSketch类</li>
<li>3DSketch</li>
<li>模型线</li>
</ul>
<h2 id="2D-Sketch类"><a href="#2D-Sketch类" class="headerlink" title="2D Sketch类"></a>2D Sketch类</h2><p>Sketch类表示用于创建3D模型的平面中的封闭曲线。关键功能由SketchPlane和CurveLoop属性表示。</p>
<p>编辑Revit文件时，无法通过迭代Document.Elements枚举来检索Sketch对象，因为所有Sketch对象都是瞬态Elements。访问族的三维建模信息时，草图对象对于形成几何图形非常重要。有关更多详细信息，请参见3D草图。</p>
<p>SketchPlane是所有2D草图类（如ModelCurve和Sketch）的基础。SketchPlane也是DetailCurve等2D注释元素的基础。ModelCurve和DetailCurve都具有SketchPlane属性，并且在相应的创建方法中需要SketchPlane。SketchPlane在Revit UI中始终不可见。</p>
<p>每个ModelCurve必须位于一个SketchPlane中。换句话说，无论您在UI中还是通过使用API绘制ModelCurve，都必须存在SketchPlane。因此，在绘制ModelCurve的二维视图中至少存在一个SketchPlane。</p>
<p>二维视图包含CeilingPlan、FloorPlan和Elevation ViewTypes。默认情况下，会自动为所有这些视图创建“草绘平面”（SketchPlane）。与二维视图相关的SketchPlane Name返回视图名称，例如Level 1或North。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-9B03E831-1E6C-4CE2-9149-3F7B309A5B5D-low.png"></p>
<p>图77：拾取平面以标识新的工作平面</p>
<p>指定新工作平面时，可以选择“拾取平面”，如上图所示。拾取平面后，选择特定图元（如墙）上的平面，如下图所示。在这种情况下，SketchPlane.Name属性返回与该元素相关的字符串。例如，在下图中，SketchPlane.Name属性返回与Wall.Name属性相同的“Generic - 8”。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-67D74CA2-D850-422F-A4FF-E762D683DFC9-low.png"></p>
<p> 图78：在墙上拾取一个平面作为工作平面</p>
<p>注意：“草绘平面”与工作平面不同，因为工作平面是可见的并且可以选择。它在当前API中没有特定的类，但由Element类表示。必须基于特定的SketchPlane定义工作平面。工作平面和SketchPlane Category属性都返回null。尽管“草绘平面”始终不可见，但始终存在与工作平面对应的“草绘平面”。工作平面用于在文本和图片中表达SketchPlane。</p>
<p>以下信息适用于SketchPlane成员：</p>
<ul>
<li>ID、UniqueId、Name和Plane属性返回值;</li>
<li>参数属性为空</li>
<li>Location属性返回Location对象</li>
<li>其他属性返回null。</li>
</ul>
<p>Plane包含SketchPlane几何信息。SketchPlane使用Plane设置平面坐标系，如下图所示：</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-415773EF-49A7-4158-B9DD-42A218063E81-low.png"></p>
<p>图79：SketchPlane和Plane坐标系</p>
<p>以下代码示例说明如何创建新的SketchPlane：</p>
<p>代码区域17-1：创建新的草绘平面</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> SketchPlane <span class="title">CreateSketchPlane</span>(<span class="params">UIApplication application</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//try to create a new sketch plane</span></span><br><span class="line">    XYZ newNormal = <span class="keyword">new</span> XYZ(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>);  <span class="comment">// the normal vector</span></span><br><span class="line">    XYZ newOrigin = <span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);  <span class="comment">// the origin point</span></span><br><span class="line">    <span class="comment">// create geometry plane</span></span><br><span class="line">    Plane geometryPlane = Plane.CreateByNormalAndOrigin(newNormal, newOrigin);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create sketch plane</span></span><br><span class="line">    SketchPlane sketchPlane = SketchPlane.Create(application.ActiveUIDocument.Document,geometryPlane);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sketchPlane;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3D-Sketch"><a href="#3D-Sketch" class="headerlink" title="3D Sketch"></a>3D Sketch</h2><p>三维草图用于编辑族或创建三维对象。在Revit Platform API中，可以使用以下类完成三维草图。</p>
<ul>
<li>Extrusion </li>
<li>Revolution </li>
<li>Blend </li>
<li>Sweep</li>
</ul>
<p>换句话说，有四个操作可以将2D模型转换为3D模型。有关在2D中绘制草图的详细信息，请参见2D草图类。</p>
<p><strong>Extrusion</strong> </p>
<p>Revit使用拉伸定义族的三维几何图形。通过在平面上定义二维草图来创建拉伸;然后Revit在起点和终点之间拉伸草图。</p>
<p>查询“拉伸形状”对象，以查找要在族建模和体量中使用的常规形状。Extrusion类具有以下属性：</p>
<p>表40：拉伸属性</p>
<table>
<thead>
<tr>
<th>**Property **</th>
<th>**Description **</th>
</tr>
</thead>
<tbody><tr>
<td>ExtrusionStart</td>
<td>返回拉伸起点。这是一个双类型。</td>
</tr>
<tr>
<td>ExtrusionEnd</td>
<td>返回拉伸终点。这是一个双类型。</td>
</tr>
<tr>
<td>Sketch</td>
<td>返回拉伸草图。它包含一个草图平面和一些曲线。</td>
</tr>
</tbody></table>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-8F322D1A-5035-4E9E-88F6-2AFAD258E59E-low.png"></p>
<p>图81：拉伸结果</p>
<p><strong>Revolution</strong> </p>
<p>“旋转”命令可创建绕轴旋转的几何图形。可以使用“旋转”命令在家具、圆屋顶或柱上创建门把手或其他把手。</p>
<p>查询“旋转形式”对象，以获得要在族建模和体量中使用的常规形式。Revolution类具有以下属性：</p>
<p>表41：Revolution属性</p>
<table>
<thead>
<tr>
<th>**Property **</th>
<th>**Description **</th>
</tr>
</thead>
<tbody><tr>
<td>Axis</td>
<td>返回轴。它是一个ModelLine对象。</td>
</tr>
<tr>
<td>EndAngle</td>
<td>返回结束角度。这是一个double类型。</td>
</tr>
<tr>
<td>Sketch</td>
<td>返回拉伸草图。它包含一个SketchPlane和一些曲线。</td>
</tr>
</tbody></table>
<p>EndAngle与Revit UI中的相同参数一致。下图说明了Revolution对应参数、草图和结果。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-2CF60823-4258-4838-ADA8-61F52C4B3515-low.png"></p>
<p>图82：对应参数</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-10A03254-96BC-4023-99C5-B22AF43A0702-low.png"></p>
<p>图83：旋转草图</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-803C819E-E85C-462B-BF33-CC49E9FC3C86-low.png"></p>
<p>图84：旋转结果</p>
<p>Note: 注意事项：</p>
<ul>
<li>无法使用Revit Platform API访问“起始角度”。</li>
<li>如果“结束角度”为正，则“旋转”方向为顺时针。如果为负，则旋转方向为逆时针</li>
</ul>
<h2 id="Blend"><a href="#Blend" class="headerlink" title="Blend"></a>Blend</h2><p>“融合”命令将两个轮廓融合在一起。例如，如果绘制了一个大矩形，并在其上绘制了一个小矩形，则Revit会将这两个形状融合在一起。</p>
<p>查询“融合形式”对象以获得要在族建模和体量中使用的常规形式。Blend类具有以下属性：</p>
<p>表42：Blend属性</p>
<table>
<thead>
<tr>
<th>**Property **</th>
<th>**Description **</th>
</tr>
</thead>
<tbody><tr>
<td>BottomSketch</td>
<td>返回底部草图。它是一个Sketch对象。</td>
</tr>
<tr>
<td>TopSketch</td>
<td>返回顶部草图融合。它是一个Sketch对象。</td>
</tr>
<tr>
<td>FirstEnd</td>
<td>返回第一个端点。这是一个double类型。</td>
</tr>
<tr>
<td>SecondEnd</td>
<td>返回第二个终点。这是一个double类型。</td>
</tr>
</tbody></table>
<p>FirstEnd和SecondEnd属性值与Revit UI中的相同参数一致。下图说明了“融合”对应的参数、草图和结果。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-BF73A304-626D-43C2-9A53-8C396270369F-low.png"></p>
<p>图85：UI中的融合参数</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-14B5134B-B412-429C-8CBF-A542C16659C0-low.png"></p>
<p>图86：融合顶部草图和底部草图</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-F637CA72-BA0E-4917-B24D-93947FD69E22-low.png"></p>
<p> 图87：融合结果</p>
<h2 id="Sweep"><a href="#Sweep" class="headerlink" title="Sweep"></a>Sweep</h2><p>“放样”命令可沿创建的二维路径或选定的三维路径沿着放样一个轮廓。路径可以是开环或闭环，但必须穿过轮廓平面。</p>
<p>查询“放样形状”对象，以获得用于族建模和体量的常规形状。Sweep类具有以下属性：</p>
<p>表43：Sweep 属性</p>
<table>
<thead>
<tr>
<th><strong>Property</strong></th>
<th>**Description **</th>
</tr>
</thead>
<tbody><tr>
<td>Path3d</td>
<td>返回三维路径草图。它是一个Path3D对象。</td>
</tr>
<tr>
<td>PathSketch</td>
<td>返回平面路径草图。它是一个Sketch对象。</td>
</tr>
<tr>
<td>ProfileSketch</td>
<td>返回轮廓草图。它是一个Sketch对象。</td>
</tr>
<tr>
<td>EnableTrajSegmentation</td>
<td>返回轨迹分段状态。它是一个布尔值。</td>
</tr>
<tr>
<td>MaxSegmentAngle</td>
<td>返回最大线段角度。这是一个double类型。</td>
</tr>
</tbody></table>
<p>创建2D路径与其他形状类似。通过拾取创建的3D曲线来获取3D路径。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-C9B66D17-E7EF-4CE4-B186-E1862B49461D-low.png"></p>
<p>图88：选择Sweep 3D路径</p>
<p>注意：以下信息适用于放样：</p>
<ul>
<li>仅当使用“拾取路径”获取3D路径时，Path3d特性才可用。</li>
<li>无论路径是三维还是二维，PathSketch都可用。<img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-4E2B269D-16CC-417E-A4BF-EBAD946C73DC-low.png" alt="img"><br>图89：扫描轮廓草图</li>
</ul>
<p>注意：轮廓草图垂直于路径。</p>
<p>分段放样对于创建机械风管弯头非常有用。通过设置两个放样参数并绘制带有圆弧的路径来创建分段放样。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-B63CD7A5-25B1-440A-A31B-AB6FADF08169-low.png"></p>
<p>图90：UI中的相应分段设置</p>
<p>注意：以下信息适用于分段放样：</p>
<ul>
<li>这些参数仅影响路径中的弧。</li>
<li>放样的最小分段数为两个。</li>
<li>通过清除“轨迹分段”（Trajectory Segmentation）复选框，将分段放样更改为非分段放样。EnableTrajSegmentation属性返回false。</li>
<li>如果EnableTrajSegmentation属性为false，则MaxSegmentAngle的值为默认360°。<img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-2AACA3CE-F284-4412-9887-B84FB87CC6BA-low.png" alt="img"></li>
</ul>
<p>图91：放样结果</p>
<h2 id="模型线"><a href="#模型线" class="headerlink" title="模型线"></a>模型线</h2><p>ModelCurve表示项目中的模型线。它存在于三维空间中，在所有视图中可见。</p>
<p>以下图片说明了四个ModelCurve派生类：<br><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-1CE68863-4E07-4852-A896-5ACE5235B7AE-low.png" alt="img"> 图92：ModelLine和ModelArc<br><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-E914167B-553C-4B5B-A87E-1AAB487A12B5-low.png" alt="img"> 图93：ModelEllipse和ModelNurbSpline</p>
<p><strong>创建模型线</strong></p>
<p>创建模型曲线的关键是创建曲线所在的几何、曲线和草图平面。根据您输入的Geometry.Curve类型，返回的相应ModelCurve可以向下转换为正确的类型。</p>
<p>以下示例说明如何创建新的模型曲线（ModelLine和ModelArc）：</p>
<p>代码区域17-2：创建新的模型曲线</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// get handle to application from document</span></span><br><span class="line">Autodesk.Revit.ApplicationServices.Application application = document.Application;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a geometry line in Revit application</span></span><br><span class="line">XYZ startPoint = <span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">XYZ endPoint = <span class="keyword">new</span> XYZ(<span class="number">10</span>, <span class="number">10</span>, <span class="number">0</span>);</span><br><span class="line">Line geomLine = Line.CreateBound(startPoint, endPoint);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a geometry arc in Revit application</span></span><br><span class="line">XYZ end0 = <span class="keyword">new</span> XYZ(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">XYZ end1 = <span class="keyword">new</span> XYZ(<span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line">XYZ pointOnCurve = <span class="keyword">new</span> XYZ(<span class="number">10</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">Arc geomArc = Arc.Create(end0, end1, pointOnCurve);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a geometry plane in Revit application</span></span><br><span class="line">XYZ origin = <span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">XYZ normal = <span class="keyword">new</span> XYZ(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">Plane geomPlane = Plane.CreateByNormalAndOrigin(normal, origin);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a sketch plane in current document</span></span><br><span class="line">SketchPlane sketch = SketchPlane.Create(document, geomPlane);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a ModelLine element using the created geometry line and sketch plane</span></span><br><span class="line">ModelLine line = document.Create.NewModelCurve(geomLine, sketch) <span class="keyword">as</span> ModelLine;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a ModelArc element using the created geometry arc and sketch plane</span></span><br><span class="line">ModelArc arc = document.Create.NewModelCurve(geomArc, sketch) <span class="keyword">as</span> ModelArc;</span><br></pre></td></tr></table></figure>

<p><strong>Members</strong> </p>
<p>GeometryCurve </p>
<p>GeometryCurve属性用于获取或设置模型曲线的几何曲线。除了ModelHermiteSpline，你可以从四个ModelCurves中得到不同的几何曲线;</p>
<ul>
<li>Line </li>
<li>Arc </li>
<li>Ellipse </li>
<li>Nurbspline</li>
</ul>
<p>下面的代码示例说明如何从ModelCurve获取特定Curve。</p>
<p>代码区域17-3：从ModelCurve获取特定曲线</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//get the geometry modelCurve of the model modelCurve</span></span><br><span class="line">Autodesk.Revit.DB.Curve geoCurve = modelCurve.GeometryCurve;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (geoCurve <span class="keyword">is</span> Autodesk.Revit.DB.Line)</span><br><span class="line">&#123;</span><br><span class="line">        Line geoLine = geoCurve <span class="keyword">as</span> Line;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>GeometryCurve属性返回值是一个常规的Geometry.Curve对象，因此，必须使用As运算符来转换对象类型。</p>
<p>注意：以下信息适用于GeometryCurve：</p>
<ul>
<li>在Revit中，无法创建Hermite曲线，但可以从其他软件（如AutoCAD）导入该曲线。Curve是唯一表示Hermite曲线的几何类。</li>
<li>SetPlaneAndCurve（）方法以及Curve和SketchPlane属性设置器用于不同的情况。<ul>
<li>当新曲线位于同一个SketchPlane中，或者新SketchPlane与旧SketchPlane位于同一个平面上时，请使用Curve或SketchPlane属性设置器。</li>
<li>如果新的Curve不在同一个SketchPlane中，或者新的SketchPlane与旧的SketchPlane不在同一个平面上，则必须使用SetPlaneAndCurve（）同时更改Curve值和SketchPlane值，以避免内部数据不一致。</li>
</ul>
</li>
</ul>
<p>线样式</p>
<p>线型由GraphicsStyle类表示。ModelCurve的所有线条样式都可以从GetLineStyleIds（）方法中获得，该方法返回一组GraphicsStyle元素的ElementIds。</p>
<h2 id="注：翻译自Revit-API-Developers-Guide"><a href="#注：翻译自Revit-API-Developers-Guide" class="headerlink" title="注：翻译自Revit API Developers Guide"></a><em><strong>注：</strong></em>翻译自<a href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_html">Revit API Developers Guide</a></h2>]]></content>
      <categories>
        <category>Revit二次开发人员指南</category>
      </categories>
      <tags>
        <tag>Revit</tag>
      </tags>
  </entry>
  <entry>
    <title>22曲面</title>
    <url>/2024/12/23/Revit%E4%BA%8C%E5%BC%80%E6%8C%87%E5%8D%97/22%E6%9B%B2%E9%9D%A2/</url>
    <content><![CDATA[<h1 id="Surfaces"><a href="#Surfaces" class="headerlink" title="Surfaces"></a><a href="https://help.autodesk.com/view/RVT/2018/CHS/?guid=GUID-064E828D-83B8-4671-9F82-C189377DDAE3">Surfaces</a></h1><p>surface类表示表面的数学表示。</p>
<p>surface类不是从GeometryObject类派生的，并且不以边或边循环为边界。Revit中的有界曲面由Face类表示。</p>
<p>Surface是更具体的曲面的基类：</p>
<ul>
<li>Plane   平面</li>
<li>CylindricalSurface   圆柱形表面</li>
<li>ConicalSurface   圆锥面</li>
<li>RuledSurface   规则曲面</li>
<li>RevolvedSurface   旋转曲面</li>
<li>HermiteSurface   Hermite曲面</li>
</ul>
<p>这些子类包含Create（）方法和只读属性，适用于构造导入几何图形。有关在几何体创建中使用曲面的示例，请参见DirectShape主题。</p>
<h2 id="注：翻译自Revit-API-Developers-Guide"><a href="#注：翻译自Revit-API-Developers-Guide" class="headerlink" title="注：翻译自Revit API Developers Guide"></a><em><strong>注：</strong></em>翻译自<a href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_html">Revit API Developers Guide</a></h2>]]></content>
      <categories>
        <category>Revit二次开发人员指南</category>
      </categories>
      <tags>
        <tag>Revit</tag>
      </tags>
  </entry>
  <entry>
    <title>21楼梯和扶手</title>
    <url>/2024/12/23/Revit%E4%BA%8C%E5%BC%80%E6%8C%87%E5%8D%97/21%E6%A5%BC%E6%A2%AF%E5%92%8C%E6%89%B6%E6%89%8B/</url>
    <content><![CDATA[<h1 id="楼梯和扶手"><a href="#楼梯和扶手" class="headerlink" title="楼梯和扶手"></a><a href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_Revit_Geometric_Elements_Stairs_and_Railings_html">楼梯和扶手</a></h1><p>Autodesk.Revit.DB.Architecture命名空间中的Revit API中的类允许访问楼梯和相关构件（如平台和梯段）。可以使用Revit API创建或修改楼梯。Stairs类表示“由构件”创建的楼梯。不能在API中将通过草图创建的楼梯图元作为楼梯对象进行访问。静态方法Stairs.IsByComponent（）可用于确定ElementId是否表示由构件创建的楼梯。</p>
<p> 本节中的页面</p>
<ul>
<li>创建和编辑楼梯</li>
<li>扶手</li>
<li>楼梯注释</li>
<li>楼梯构件</li>
</ul>
<h2 id="创建和编辑楼梯"><a href="#创建和编辑楼梯" class="headerlink" title="创建和编辑楼梯"></a>创建和编辑楼梯</h2><p><strong>StairsEditScope</strong></p>
<p>与Revit文档中其他类型的元素一样，编辑楼梯和楼梯构件需要事务处理。但是，若要创建新构件（如梯段和平台）或创建新楼梯本身，则必须使用Autodesk.Revit.DB.StairsEditScope对象，该对象支持楼梯编辑任务。</p>
<p>StairsEditScope的作用类似于TransactionGroup。启动StairsEditScope后，可以启动事务并编辑楼梯。在StairsEditScope中创建的单个事务不会出现在撤消菜单中。在编辑模式下提交的所有事务将被合并为一个事务，该事务的名称由传递给 StairsEditScope 构造函数的参数指定。</p>
<p>StairsEditScope有两个Start方法。获取现有Stairs对象的ElementId，并为其启动楼梯编辑会话。第二个Start方法采用底部标高和顶部标高的ElementId，并在指定标高中创建具有默认楼梯类型的新空楼梯元素，然后为新楼梯启动楼梯编辑模式。</p>
<p>将梯段和平台添加到楼梯并完成编辑后，请调用 StairsEditScope.Commit() 方法结束楼梯编辑模式。</p>
<p><strong>添加梯段</strong></p>
<ul>
<li>StairsRun类有三个用于为Stairs对象创建新梯段的静态方法：<ul>
<li><strong>CreateSketchedRun</strong> - 通过提供一组边界曲线和踢面曲线来创建草图梯段。</li>
<li><strong>CreateStraightRun</strong> - 创建直线梯段。</li>
<li><strong>CreateSpiralRun</strong> - 通过提供圆心、起始角度和夹角来创建螺旋梯段。</li>
</ul>
</li>
</ul>
<p><strong>添加平台</strong></p>
<p>可以在两个梯段之间添加自动平台或草图平台。静态方法StairsLanding. Canadian AutomaticLanding（）将检查两个楼梯梯段是否满足创建自动平台的限制。静态StairsLanding. random AutomaticLanding（）方法将返回在两个楼梯梯段之间创建的所有平台的Id。</p>
<p>静态StairsLanding. RightSketchedLanding方法通过提供平台的闭合边界曲线，在两个梯段之间创建自定义平台。基本高程的双精度值是CreateSketchedLanding方法的输入参数之一。标高有以下限制：</p>
<ul>
<li>底部高程相对于楼梯的底部高程。</li>
<li>底部高程将自动舍入为踢面高度的倍数。</li>
<li>基础标高应等于或大于踢面高度的一半。</li>
</ul>
<p><strong>例子</strong></p>
<p>下面的示例将创建一个新的Stairs对象、两个梯段（一个为草图梯段，一个为直线梯段）以及它们之间的平台。</p>
<p>代码区域：创建楼梯、楼梯平台和平台</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// FailurePreprocessor class required for StairsEditScope</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">StairsFailurePreprocessor</span> : <span class="title">IFailuresPreprocessor</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> FailureProcessingResult <span class="title">PreprocessFailures</span>(<span class="params">FailuresAccessor failuresAccessor</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Use default failure processing</span></span><br><span class="line">        <span class="keyword">return</span> FailureProcessingResult.Continue; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> ElementId <span class="title">CreateStairs</span>(<span class="params">Document document, Level levelBottom, Level levelTop</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ElementId newStairsId = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> (StairsEditScope newStairsScope = <span class="keyword">new</span> StairsEditScope(document, <span class="string">&quot;New Stairs&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        newStairsId = newStairsScope.Start(levelBottom.Id, levelTop.Id);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">using</span> (Transaction stairsTrans = <span class="keyword">new</span> Transaction(document, <span class="string">&quot;Add Runs and Landings to Stairs&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            stairsTrans.Start();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Create a sketched run for the stairs</span></span><br><span class="line">            IList bdryCurves = <span class="keyword">new</span> List();</span><br><span class="line">            IList riserCurves = <span class="keyword">new</span> List();</span><br><span class="line">            IList pathCurves = <span class="keyword">new</span> List();</span><br><span class="line">            XYZ pnt1 = <span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            XYZ pnt2 = <span class="keyword">new</span> XYZ(<span class="number">15</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            XYZ pnt3 = <span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">10</span>, <span class="number">0</span>);</span><br><span class="line">            XYZ pnt4 = <span class="keyword">new</span> XYZ(<span class="number">15</span>, <span class="number">10</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// boundaries</span></span><br><span class="line">            bdryCurves.Add(Line.CreateBound(pnt1, pnt2));</span><br><span class="line">            bdryCurves.Add(Line.CreateBound(pnt3, pnt4));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// riser curves</span></span><br><span class="line">            <span class="keyword">const</span> <span class="built_in">int</span> riserNum = <span class="number">20</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> ii = <span class="number">0</span>; ii &lt;= riserNum; ii++)</span><br><span class="line">            &#123;</span><br><span class="line">                XYZ end0 = (pnt1 + pnt2)  ii / (<span class="built_in">double</span>)riserNum;</span><br><span class="line">                XYZ end1 = (pnt3 + pnt4)  ii / (<span class="built_in">double</span>)riserNum;</span><br><span class="line">                XYZ end2 = <span class="keyword">new</span> XYZ(end1.X, <span class="number">10</span>, <span class="number">0</span>);</span><br><span class="line">                riserCurves.Add(Line.CreateBound(end0, end2));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//stairs path curves</span></span><br><span class="line">            XYZ pathEnd0 = (pnt1 + pnt3) / <span class="number">2.0</span>;</span><br><span class="line">            XYZ pathEnd1 = (pnt2 + pnt4) / <span class="number">2.0</span>;</span><br><span class="line">            pathCurves.Add(Line.CreateBound(pathEnd0, pathEnd1));</span><br><span class="line"></span><br><span class="line">            StairsRun newRun1 = StairsRun.CreateSketchedRun(document, newStairsId, levelBottom.Elevation, bdryCurves, riserCurves, pathCurves);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Add a straight run</span></span><br><span class="line">            Line locationLine = Line.CreateBound(<span class="keyword">new</span> XYZ(<span class="number">20</span>, <span class="number">-5</span>, newRun1.TopElevation), <span class="keyword">new</span> XYZ(<span class="number">35</span>, <span class="number">-5</span>, newRun1.TopElevation));</span><br><span class="line">            StairsRun newRun2 = StairsRun.CreateStraightRun(document, newStairsId, locationLine, StairsRunJustification.Center);</span><br><span class="line">            newRun2.ActualRunWidth = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Add a landing between the runs</span></span><br><span class="line">            CurveLoop landingLoop = <span class="keyword">new</span> CurveLoop();</span><br><span class="line">            XYZ p1 = <span class="keyword">new</span> XYZ(<span class="number">15</span>, <span class="number">10</span>, <span class="number">0</span>); </span><br><span class="line">            XYZ p2 = <span class="keyword">new</span> XYZ(<span class="number">20</span>, <span class="number">10</span>, <span class="number">0</span>);</span><br><span class="line">            XYZ p3 = <span class="keyword">new</span> XYZ(<span class="number">20</span>, <span class="number">-10</span>, <span class="number">0</span>);</span><br><span class="line">            XYZ p4 = <span class="keyword">new</span> XYZ(<span class="number">15</span>, <span class="number">-10</span>, <span class="number">0</span>);</span><br><span class="line">            Line curve_1 = Line.CreateBound(p1, p2);</span><br><span class="line">            Line curve_2 = Line.CreateBound(p2, p3);</span><br><span class="line">            Line curve_3 = Line.CreateBound(p3, p4);</span><br><span class="line">            Line curve_4 = Line.CreateBound(p4, p1);</span><br><span class="line"></span><br><span class="line">            landingLoop.Append(curve_1);</span><br><span class="line">            landingLoop.Append(curve_2);</span><br><span class="line">            landingLoop.Append(curve_3);</span><br><span class="line">            landingLoop.Append(curve_4);</span><br><span class="line">            StairsLanding newLanding = StairsLanding.CreateSketchedLanding(document, newStairsId, landingLoop, newRun1.TopElevation);</span><br><span class="line"></span><br><span class="line">            stairsTrans.Commit();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// A failure preprocessor is to handle possible failures during the edit mode commitment process.</span></span><br><span class="line">        newStairsScope.Commit(<span class="keyword">new</span> StairsFailurePreprocessor());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> newStairsId;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的例子产生的楼梯：<img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/stairs.jpg" alt="img"></p>
<p><strong>多层楼梯</strong> </p>
<p>MultistoryStairs类允许楼梯跨越多个标高。多层楼梯元素可以包含多个楼梯，这些楼梯的范围由底部标高和顶部标高控制。 此元素将包含一个或多个Stairs元素。楼梯元素是： 复制到由共享相同标高高度的相同楼梯实例组覆盖的每个标高的参考实例， 或未连接到具有相同标高高度的组的单个Stairs实例。 默认情况下，向多层楼梯添加新标高时，新楼梯将添加到组中。对于不同标高的重复楼梯组，实例可以作为Stairs元素的子元素找到。通过修改关联的Stairs实例，可以一起编辑连接组中的楼梯。对于需要特殊设计的特定楼层，可以使用“取消锁定”方法将楼梯从组中分离出来-对取消锁定的楼梯所做的更改不会影响图元中的其他任何实例。稍后可以使用“锁定”方法将楼梯添加回组中，但是对楼梯所做的任何更改都将丢失，因为楼梯的属性将被组规范覆盖。</p>
<p>代码区域：创建多层楼梯</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// create new MultistoryStairs </span></span><br><span class="line">MultistoryStairs multistoryStairs = MultistoryStairs.Create(stairs);</span><br><span class="line"></span><br><span class="line"><span class="comment">// get all levels that can be connected to this multistoryStairs</span></span><br><span class="line">IEnumerable levelIds = <span class="keyword">new</span> FilteredElementCollector(doc).OfClass(<span class="keyword">typeof</span>(Level)).Cast().Where(q =&gt; multistoryStairs.CanConnectLevel(q.Id))</span><br><span class="line">.Select(q =&gt; q.Id);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Connect the levels to the multistoryStairs</span></span><br><span class="line"><span class="comment">// The input to ConnectLevels is a HashSet or SortedSet, so a HashSet is created from the IEnumerable returned by FilteredElementCollector</span></span><br><span class="line">multistoryStairs.ConnectLevels(<span class="keyword">new</span> HashSet(levelIds));</span><br></pre></td></tr></table></figure>

<p>当使用StairsEditScope.Start（ElementId，ElementId）方法创建新楼梯时，它们具有与其关联的默认扶手。但是，Railing.Create（）方法可用于在不带扶手的楼梯的楼梯元素的所有边上创建具有指定扶手类型的新扶手。与需要使用StairsEditScope创建梯段和平台不同，扶手创建不能在打开的楼梯编辑任务中执行。 由于无法为已具有关联扶手的楼梯创建扶手，因此下面的示例在创建新扶手之前删除与楼梯对象关联的现有扶手。</p>
<p>代码区域：创建扶手</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">CreateRailing</span>(<span class="params">Document document, Stairs stairs</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> (Transaction trans = <span class="keyword">new</span> Transaction(document, <span class="string">&quot;Create Railings&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        trans.Start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Delete existing railings</span></span><br><span class="line">        ICollection railingIds = stairs.GetAssociatedRailings();</span><br><span class="line">        <span class="keyword">foreach</span> (ElementId railingId <span class="keyword">in</span> railingIds)</span><br><span class="line">        &#123;</span><br><span class="line">            document.Delete(railingId);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Find RailingType</span></span><br><span class="line">        FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">        ICollection RailingTypeIds = collector.OfClass(<span class="keyword">typeof</span>(RailingType)).ToElementIds();</span><br><span class="line">        Railing.Create(document, stairs.Id, RailingTypeIds.First(), RailingPlacementPosition.Treads);</span><br><span class="line">        trans.Commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="扶手"><a href="#扶手" class="headerlink" title="扶手"></a>扶手</h2><p>Autodesk.Revit.DB.Architecture.Railing类表示Autodesk Revit项目中的扶手元素。尽管扶手与楼梯关联，但它们也可以与其他主体（如楼板）关联，也可以放置在空间中。扶手可以是连续的或不连续的。如果它们是不连续的，则仅提供有限的访问级别。</p>
<p>可以使用GetAssociatedRailings（）方法从Stairs类中检索与楼梯关联的扶手。只有少数属性和方法专用于栏杆扶手，例如返回顶部栏杆的ElementId的TopRail属性和指示栏杆扶手是否翻转的Flipped属性。Railing.Flip（）方法翻转扶手，而RemoveHost（）方法将删除扶手与其主体之间的关联。</p>
<p>下面的示例检索与Stairs对象关联的所有栏杆扶手，并翻转系统生成的默认栏杆扶手。</p>
<p>代码区域：使用扶手</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">FlipDefaultRailings</span>(<span class="params">Stairs stairs</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ICollection&lt;ElementId&gt; railingIds = stairs.GetAssociatedRailings();</span><br><span class="line">    Transaction trans = <span class="keyword">new</span> Transaction(stairs.Document, <span class="string">&quot;Flip Railings&quot;</span>);</span><br><span class="line">    trans.Start();</span><br><span class="line">    <span class="keyword">foreach</span> (ElementId railingId <span class="keyword">in</span> railingIds)</span><br><span class="line">    &#123;</span><br><span class="line">        Railing railing = stairs.Document.GetElement(railingId) <span class="keyword">as</span> Railing;</span><br><span class="line">        <span class="keyword">if</span> (railing.IsDefault == <span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            railing.Flip();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    trans.Commit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Railing类具有Create方法，该方法可自动在楼梯元素的所有侧面上创建具有指定扶手类型的新扶手。扶手的创建将在“创建和编辑楼梯”部分中进行演示。</p>
<p>RailingType类表示生成扶手时使用的扶手类型。它包含许多关于扶手的属性，例如主扶手和次扶手以及顶部扶手的高度、横向偏移和类型。</p>
<p> 代码区域：RailingType</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">GetRailingType</span>(<span class="params">Stairs stairs</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ICollection&lt;ElementId&gt; railingIds = stairs.GetAssociatedRailings();</span><br><span class="line">    <span class="keyword">foreach</span> (ElementId railingId <span class="keyword">in</span> railingIds)</span><br><span class="line">    &#123;</span><br><span class="line">        Railing railing = stairs.Document.GetElement(railingId) <span class="keyword">as</span> Railing;</span><br><span class="line">        RailingType railingType = stairs.Document.GetElement(railing.GetTypeId()) <span class="keyword">as</span> RailingType;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Format railing type info for display</span></span><br><span class="line">        <span class="built_in">string</span> info = <span class="string">&quot;Railing Type:  &quot;</span> + railingType.Name;</span><br><span class="line">        info += <span class="string">&quot;\nPrimary Handrail Height:  &quot;</span> + railingType.PrimaryHandrailHeight;</span><br><span class="line">        info += <span class="string">&quot;\nTop Rail Height:  &quot;</span> + railingType.TopRailHeight;</span><br><span class="line"></span><br><span class="line">        TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>, info);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="楼梯注释"><a href="#楼梯注释" class="headerlink" title="楼梯注释"></a>楼梯注释</h2><p><strong>楼梯注释</strong></p>
<p>StairsPath类可用于注释楼梯的坡度方向和行走线。静态StairsPath.Create（）方法将在楼梯必须可见的特定平面视图中为具有指定楼梯路径类型的指定楼梯创建新楼梯路径。</p>
<p>在Revit UI中编辑楼梯路径时，StairsPath类具有与“属性”窗口中可用的属性相同的属性，例如设置上下方向文字沿着或是否应显示文字的属性。此外，可以指定上下文字的偏移，也可以指定楼梯路径相对于楼梯中心线的偏移。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/CHS/Revit-API/images/GUID-98F7477B-3F67-4E52-BDC3-6B63ECA6B700.jpg" alt="img"></p>
<p>下面的示例在项目中查找StairsPathType和FloorPlan，并使用它们为给定的Stairs创建新的StairsPath。</p>
<p>代码区域：创建楼梯路径</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">CreateStairsPath</span>(<span class="params">Document document, Stairs stairs</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Transaction transNewPath = <span class="keyword">new</span> Transaction(document, <span class="string">&quot;New Stairs Path&quot;</span>);</span><br><span class="line">    transNewPath.Start();</span><br><span class="line">            </span><br><span class="line">    <span class="comment">// Find StairsPathType</span></span><br><span class="line">    FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">    ICollection&lt;ElementId&gt; stairsPathIds = collector.OfClass(<span class="keyword">typeof</span>(StairsPathType)).ToElementIdsElementId();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find a FloorPlan</span></span><br><span class="line">    ElementId planViewId = ElementId.InvalidElementId;</span><br><span class="line">    FilteredElementCollector viewCollector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">    ICollection&lt;ElementId&gt; viewIds = viewCollector.OfClass(<span class="keyword">typeof</span>(View)).ToElementIdsElementId();</span><br><span class="line">    <span class="keyword">foreach</span> (ElementId viewId <span class="keyword">in</span> viewIds)</span><br><span class="line">    &#123;</span><br><span class="line">        View view = document.GetElement(viewId) <span class="keyword">as</span> View;</span><br><span class="line">        <span class="keyword">if</span> (view.ViewType == ViewType.FloorPlan)</span><br><span class="line">        &#123;</span><br><span class="line">            planViewId = view.Id;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">            </span><br><span class="line">    LinkElementId stairsLinkId = <span class="keyword">new</span> LinkElementId(stairs.Id);</span><br><span class="line">    StairsPath.Create(stairs.Document, stairsLinkId, stairsPathIds.First(), planViewId);</span><br><span class="line">    transNewPath.Commit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>StairsPath具有StairsPathType。楼梯路径类型可从两个预定义的系统族中获得：“自动向上&#x2F;向下方向”和“固定向上方向”。可用于这两种类型的属性作为StairsPathType类中的属性提供，例如FullStepArrow和DistanceToCutMark。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/CHS/Revit-API/images/GUID-21CCA05E-3A7C-4CA3-AF96-8BBB88F775E7.jpg" alt="img"></p>
<p>CutMarkType类表示Revit UI中的剪切标记类型，它具有表示在UI中编辑剪切标记类型时可用的相同属性的属性，例如CutLineAngle和CutLineExtension。它与StairsType对象相关联，可以使用BuiltInParameter STAIRSTYPE_CUTMARK_TYPE进行检索，如下所示。</p>
<p>代码区域：获取楼梯的CutMarkType</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> CutMarkType <span class="title">GetCutMark</span>(<span class="params">Stairs stairs</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    CutMarkType cutMarkType = <span class="literal">null</span>;</span><br><span class="line">    StairsType stairsType = stairs.Document.GetElement(stairs.GetTypeId()) <span class="keyword">as</span> StairsType;</span><br><span class="line">    Parameter paramCutMark = stairsType.get_Parameter(BuiltInParameter.STAIRSTYPE_CUTMARK_TYPE);</span><br><span class="line">    <span class="keyword">if</span> (paramCutMark.StorageType == StorageType.ElementId)  <span class="comment">// should be an element id</span></span><br><span class="line">    &#123;</span><br><span class="line">        ElementId cutMarkId = paramCutMark.AsElementId();</span><br><span class="line">        cutMarkType = stairs.Document.GetElement(cutMarkId) <span class="keyword">as</span> CutMarkType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cutMarkType;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="楼梯构件"><a href="#楼梯构件" class="headerlink" title="楼梯构件"></a>楼梯构件</h2><p><strong>楼梯构件</strong></p>
<p>Stairs类表示Revit中的楼梯图元，并包含表示有关踏步、高度、楼层数以及楼梯高度、底部标高和顶部标高的信息的属性。Stairs类的方法可用于获取楼梯平台构件、楼梯梯段构件和楼梯支撑。</p>
<p>下面的示例按构件查找所有楼梯，并将有关每个楼梯的一些信息输出到TaskDialog对话框。请注意，此示例使用带有BuiltInCategory.OST_Stairs的类别过滤器，该过滤器将返回所有楼梯的ElementId，因此在从文档中检索时将每个ElementId转换为Stairs类之前，需要进行测试以查看每个ElementId是否代表Stairs By Component。</p>
<p>代码区域：获取楼梯信息</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Stairs <span class="title">GetStairInfo</span>(<span class="params">Document document</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Stairs stairs = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">    ICollection&lt;ElementId&gt; stairsIds = collector.WhereElementIsNotElementType().OfCategory(BuiltInCategory.OST_Stairs).ToElementIdsElementId();</span><br><span class="line">    <span class="keyword">foreach</span> (ElementId stairId <span class="keyword">in</span> stairsIds)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (Stairs.IsByComponent(document, stairId) == <span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            stairs = document.GetElement(stairId) <span class="keyword">as</span> Stairs;</span><br><span class="line">                   </span><br><span class="line">            <span class="comment">// Format the information</span></span><br><span class="line">            String info = <span class="string">&quot;\nNumber of stories:  &quot;</span> + stairs.NumberOfStories;</span><br><span class="line">            info += <span class="string">&quot;\nHeight of stairs:  &quot;</span> + stairs.Height;</span><br><span class="line">            info += <span class="string">&quot;\nNumber of treads:  &quot;</span> + stairs.ActualTreadsNumber;</span><br><span class="line">            info += <span class="string">&quot;\nTread depth:  &quot;</span> + stairs.ActualTreadDepth;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// Show the information to the user.</span></span><br><span class="line">            TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>, info);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> stairs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>StairsType类表示Stairs元素的类型。它包含有关楼梯的信息，例如楼梯对象中所有梯段和平台的类型、楼梯左侧、右侧和中间支撑的类型和偏移，以及与楼梯生成相关的许多其他特性，例如楼梯图元上每个踢面的最大高度。下面的示例获取Stairs元素的StairsType，并在TaskDialog中显示有关该元素的一些信息。</p>
<p>代码区域：获取楼梯类型信息</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">GetStairsType</span>(<span class="params">Stairs stairs</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    StairsType stairsType = stairs.Document.GetElement(stairs.GetTypeId()) <span class="keyword">as</span> StairsType;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Format stairs type info for display</span></span><br><span class="line">    <span class="built_in">string</span> info = <span class="string">&quot;Stairs Type:  &quot;</span> + stairsType.Name;</span><br><span class="line">    info += <span class="string">&quot;\nLeft Lateral Offset:  &quot;</span> + stairsType.LeftLateralOffset;</span><br><span class="line">    info += <span class="string">&quot;\nRight Lateral Offset:  &quot;</span> + stairsType.RightLateralOffset;</span><br><span class="line">    info += <span class="string">&quot;\nMax Riser Height:  &quot;</span> + stairsType.MaxRiserHeight;</span><br><span class="line">    info += <span class="string">&quot;\nMin Run Width:  &quot;</span> + stairsType.MinRunWidth;</span><br><span class="line"></span><br><span class="line">    TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>, info);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>梯段</strong></p>
<p>楼梯构件由梯段、平台和支撑组成。这些项中的每一项都可以从Stairs类中检索。梯段在Revit API中由StairsRun类表示。下面的示例获取Stairs对象的每个梯段，并确保它以踢面开始和结束。</p>
<p>代码区域：使用StairsRun</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">AddStartandEndRisers</span>(<span class="params">Stairs stairs</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ICollection&lt;ElementId&gt; runIds = stairs.GetStairsRuns();</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">foreach</span> (ElementId runId <span class="keyword">in</span> runIds)</span><br><span class="line">    &#123;</span><br><span class="line">        StairsRun run = stairs.Document.GetElement(runId) <span class="keyword">as</span> StairsRun;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != run)</span><br><span class="line">        &#123;</span><br><span class="line">            run.BeginsWithRiser = <span class="literal">true</span>;</span><br><span class="line">            run.EndsWithRiser = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>StairsRun类提供对梯段属性的访问，例如StairsRunStyle（直线、斜梯等），BaseElevation、TopElevation和有关高程的属性。StairsRun类中还有一些方法可用于访问梯段承载的支撑，可以是全部支撑，也可以仅是梯段边界左侧或右侧的支撑。GetStairsPath（）方法将返回表示梯段上楼梯路径的曲线，这些曲线将投影到楼梯的底部标高上。GetFootprintBoundary（）方法返回梯段的边界曲线，这些曲线也投影到楼梯的底部标高上。</p>
<p>StairsRun类有三个用于创建新梯段的静态方法。这些将在“创建和编辑楼梯”部分中介绍。</p>
<p>StairsRunType类表示StairsRun的类型。它包含有关梯段踏板和宽度的许多特性以及有关梯段的其他信息。下面的示例获取Stairs元素中第一个梯段的StairsRunType，并显示踢面和踏步厚度沿着以及类型名称。</p>
<p>代码区域：获取StairsRunType信息</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">GetRunType</span>(<span class="params">Stairs stairs</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ICollection&lt;ElementId&gt; runIds = stairs.GetStairsRuns();</span><br><span class="line"></span><br><span class="line">    ElementId firstRunId = runIds.First();</span><br><span class="line"></span><br><span class="line">    StairsRun firstRun = stairs.Document.GetElement(firstRunId) <span class="keyword">as</span> StairsRun;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> != firstRun)</span><br><span class="line">    &#123;</span><br><span class="line">        StairsRunType runType = stairs.Document.GetElement(firstRun.GetTypeId()) <span class="keyword">as</span> StairsRunType;</span><br><span class="line">        <span class="comment">// Format landing type info for display</span></span><br><span class="line">        <span class="built_in">string</span> info = <span class="string">&quot;Stairs Run Type:  &quot;</span> + runType.Name;</span><br><span class="line">        info += <span class="string">&quot;\nRiser Thickness:  &quot;</span> + runType.RiserThickness;</span><br><span class="line">        info += <span class="string">&quot;\nTread Thickness:  &quot;</span> + runType.TreadThickness;</span><br><span class="line"></span><br><span class="line">        TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>, info);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>平台</strong></p>
<p>平台由StairsLanding类表示。下面的示例查找Stairs对象的每个平台的厚度。</p>
<p>代码区域：使用楼梯平台</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">GetStairLandings</span>(<span class="params">Stairs stairs</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ICollection&lt;ElementId&gt; landingIds = stairs.GetStairsLandings();</span><br><span class="line">    <span class="built_in">string</span> info = <span class="string">&quot;Number of landings:  &quot;</span> + landingIds.Count;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> landingIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">foreach</span> (ElementId landingId <span class="keyword">in</span> landingIds)</span><br><span class="line">    &#123;</span><br><span class="line">        landingIndex++;</span><br><span class="line">        StairsLanding landing = stairs.Document.GetElement(landingId) <span class="keyword">as</span> StairsLanding;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != landing)</span><br><span class="line">        &#123;</span><br><span class="line">            info += <span class="string">&quot;\nThickness of Landing &quot;</span> + landingIndex + <span class="string">&quot;:  &quot;</span> + landing.Thickness;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>, info);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与StairsRun类似，StairsLanding具有GetStairsPath（）方法和GetFootprintBoundary（）方法，前者返回表示平台上投影到楼梯基层的楼梯路径的曲线，后者返回平台的边界曲线，也投影到楼梯基层。同样类似于StairsRun，有一种方法可以获取平台承载的所有支撑。</p>
<p>StairsLanding类有一个在两个梯段之间创建新平台的方法。它将在“创建和编辑楼梯”部分中介绍。</p>
<p>StairsLandingType类表示Revit API中的平台类型。StairsLandingType类只有两个特定于它的属性，即IsMonolithic（如果楼梯平台是整体的，则为真）和Thickness（表示楼梯平台的厚度）。</p>
<p><strong>楼梯连接</strong><br>Both StairsRun and StairsLanding have a GetConnections() method which provides information about connections among stairs components (run to run, or run to landing). The method returns a collection of StairsComponentConnection objects which have properties about each connection, including the connection type (to a landing, the start of a stairs run, or the end of a stairs run) and the Id of the connected stairs component.<br>StairsRun和StairsLanding都具有GetConnections（）方法，该方法提供有关楼梯构件之间连接的信息（梯段到梯段，或梯段到平台）。该方法返回一个StairsStringentConnection对象的集合，这些对象具有关于每个连接的属性，包括连接类型（连接平台、楼梯梯段起点或楼梯梯段终点）和连接的楼梯构件的ID。</p>
<p><strong>支撑</strong></p>
<p>Revit API不显示楼梯支撑类。获取楼梯、楼梯梯段或楼梯平台的支撑时，支撑将为常规Revit图元。下面的示例获取Stairs对象的所有支撑的名称。</p>
<p>代码区域：获取楼梯支撑</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">GetStairSupports</span>(<span class="params">Stairs stairs</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ICollection&lt;ElementId&gt; supportIds = stairs.GetStairsSupports();</span><br><span class="line">    <span class="built_in">string</span> info = <span class="string">&quot;Number of supports:  &quot;</span> + supportIds.Count;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> supportIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">foreach</span> (ElementId supportId <span class="keyword">in</span> supportIds)</span><br><span class="line">    &#123;</span><br><span class="line">        supportIndex++;</span><br><span class="line">        Element support = stairs.Document.GetElement(supportId);</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != support)</span><br><span class="line">        &#123;</span><br><span class="line">            info += <span class="string">&quot;\nName of support &quot;</span> + supportIndex + <span class="string">&quot;:  &quot;</span> + support.Name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>, info);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="注：翻译自Revit-API-Developers-Guide"><a href="#注：翻译自Revit-API-Developers-Guide" class="headerlink" title="注：翻译自Revit API Developers Guide"></a><em><strong>注：</strong></em>翻译自<a href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_html">Revit API Developers Guide</a></h2>]]></content>
      <categories>
        <category>Revit二次开发人员指南</category>
      </categories>
      <tags>
        <tag>Revit</tag>
      </tags>
  </entry>
  <entry>
    <title>18几何</title>
    <url>/2024/12/14/Revit%E4%BA%8C%E5%BC%80%E6%8C%87%E5%8D%97/18%E5%87%A0%E4%BD%95/</url>
    <content><![CDATA[<h1 id="几何"><a href="#几何" class="headerlink" title="几何"></a><a href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_Revit_Geometric_Elements_Geometry_html">几何</a></h1><p>Autodesk.Revit.DB 命名空间包含许多与几何和图形相关类型相关的类，用于描述 API 中的图形表示。几何相关的类包括：</p>
<ul>
<li>GeometryObject class - 包含从几何对象类派生的类。</li>
<li>Geometry Helper Classes - 包含从 APIObject 类派生出的类和值类型</li>
<li>Geometry Utility Classes - 包含创建非元素几何体和查找实体交点的类</li>
<li>Collection Classes - 包括从 IEnumerable 或 IEnumerator 接口派生的类。</li>
</ul>
<p>在这一节中，您将学习如何使用各种图形相关类型，如何从元素中检索几何数据，如何变换元素，以及更多内容。</p>
<p><strong>本节页面</strong></p>
<ul>
<li>从墙壁中检索几何数据</li>
<li>GeometryObject类</li>
<li>几何辅助类</li>
<li>集合类</li>
<li>从梁中检索几何数据</li>
<li>固体挤压分析</li>
<li>通过光线投影寻找几何图形</li>
<li>几何工具类</li>
<li>房间与空间几何</li>
</ul>
<h2 id="示例：从墙壁中检索几何数据"><a href="#示例：从墙壁中检索几何数据" class="headerlink" title="示例：从墙壁中检索几何数据"></a>示例：从墙壁中检索几何数据</h2><p>本教程演示了如何从墙壁获取几何数据。以下信息被涵盖：</p>
<ul>
<li>获取墙体几何边缘。</li>
<li>获取墙体几何面。</li>
</ul>
<p>注意：在本例中，由于未考虑实例，从元素中检索几何数据受到限制。例如，包含在墙中的放样在示例代码中不可用。本指南的目标是让您对如何检索几何数据有一个基本了解，但并不涵盖所有情况。有关从元素中检索几何数据的更多信息，请参阅示例：从梁中检索几何数据。</p>
<p>代码区域20-1：创建 Geometry.Options</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Autodesk.Revit.DB.Options geomOption = application.Create.NewGeometryOptions();</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">null</span> != geomOption)</span><br><span class="line">&#123;</span><br><span class="line">        geomOption.ComputeReferences = <span class="literal">true</span>;</span><br><span class="line">        geomOption.DetailLevel = Autodesk Autodesk.Revit.DB.DetailLevels.Fine;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Either the DetailLevel or the View can be set, but not both</span></span><br><span class="line">        <span class="comment">//geomOption.View = commandData.Application.ActiveUIDocument.Document.ActiveView;</span></span><br><span class="line"></span><br><span class="line">        TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>, <span class="string">&quot;Geometry Option created successfully.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：有关详细信息，请参阅几何辅助类。</p>
<p>检索面和边</p>
<p> 墙几何图形是由面和边组成的实体。完成以下步骤以获取面和边：</p>
<p>1.使用Wall类的Geometry属性创建一个Geometry.Element实例。此实例包含“对象”属性中的所有几何体对象，如实体、直线等。</p>
<p>2.迭代Object属性以获取几何体实体实例，该实例包含“面”和“边”属性中的所有几何体面和边。</p>
<p>3.迭代“面”属性以获取所有几何体面。</p>
<p>4.迭代Edges属性以获取所有几何体边。 </p>
<p>示例代码如下：</p>
<p>代码区域20-2：检索面和边</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">GetFacesAndEdges</span>(<span class="params">Wall wall</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        String faceInfo = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">        Autodesk.Revit.DB.Options opt = <span class="keyword">new</span> Options();</span><br><span class="line">        Autodesk.Revit.DB.GeometryElement geomElem = wall.get_Geometry(opt);</span><br><span class="line">        <span class="keyword">foreach</span> (GeometryObject geomObj <span class="keyword">in</span> geomElem)</span><br><span class="line">        &#123;</span><br><span class="line">                Solid geomSolid = geomObj <span class="keyword">as</span> Solid;</span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">null</span> != geomSolid)</span><br><span class="line">                &#123;</span><br><span class="line">                        <span class="built_in">int</span> faces = <span class="number">0</span>;</span><br><span class="line">                        <span class="built_in">double</span> totalArea = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">foreach</span> (Face geomFace <span class="keyword">in</span> geomSolid.Faces)</span><br><span class="line">                        &#123;</span><br><span class="line">                                faces++;</span><br><span class="line">                                faceInfo += <span class="string">&quot;Face &quot;</span> + faces + <span class="string">&quot; area: &quot;</span> + geomFace.Area.ToString() + <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">                                totalArea += geomFace.Area;</span><br><span class="line">                        &#125;</span><br><span class="line">                        faceInfo += <span class="string">&quot;Number of faces: &quot;</span> + faces + <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">                        faceInfo += <span class="string">&quot;Total area: &quot;</span> + totalArea.ToString() + <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">                        <span class="keyword">foreach</span> (Edge geomEdge <span class="keyword">in</span> geomSolid.Edges)</span><br><span class="line">                        &#123;</span><br><span class="line">                                <span class="comment">// get wall&#x27;s geometry edges</span></span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>, faceInfo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="GeometryObject类"><a href="#GeometryObject类" class="headerlink" title="GeometryObject类"></a>GeometryObject类</h2><p>索引属性Element.Geometry[]可用于提取任何模型元素（3D元素）的几何图形。这既适用于系统族实例（如墙、楼板和屋顶），也适用于许多类别的族实例（如门、窗、家具或体量）。</p>
<p>提取的几何图形将作为Autodesk. Revit. DB. GeometryElement返回给您。可以使用GetEnumerator（）方法遍历该元素的几何成员。</p>
<p>通常，在提取的几何图形的顶层返回的对象将是以下对象之一：</p>
<ul>
<li>Solids, Faces and Edges-由面和边组成的边界表示</li>
<li>Meshes-三角形的3D阵列</li>
<li>Curves-有界3D曲线</li>
<li>Points – 给定3D位置处的可见基准点</li>
<li>PolyLines – 由3D点定义的一系列线段</li>
<li>GeometryInstances-位于元素内的几何元素的实例</li>
</ul>
<p>该图说明了通过几何体提取找到的对象的层次结构。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/geometry_hierarchy.png"></p>
<p>本节中的页面</p>
<ul>
<li>Curves </li>
<li>GeometryInstances </li>
<li>Meshes </li>
<li>Points </li>
<li>PolyLines </li>
<li>Solids, Faces and Edges</li>
</ul>
<h3 id="Curves"><a href="#Curves" class="headerlink" title="Curves"></a>Curves</h3><p>曲线表示Revit模型中的二维或三维路径。曲线可以表示元素几何形状的整个范围（例如CurveElements），也可以显示为元素几何形状的一部分（例如墙或风管的中心线）。曲线和曲线集合在API的许多元素创建方法中用作输入。</p>
<p>本节中的页面</p>
<ul>
<li>曲线分析</li>
<li>曲线工作</li>
<li>曲线集合</li>
<li>曲线创建</li>
<li>曲线参数化</li>
<li>曲线类型</li>
<li>曲线类型的数学表示</li>
</ul>
<h4 id="曲线分析"><a href="#曲线分析" class="headerlink" title="曲线分析"></a>曲线分析</h4><p>有几种曲线方法是适用于几何分析的工具。</p>
<p>在某些情况下，这些API所做的事情比您通过快速查看其名称所期望的要多。</p>
<p><strong>Intersect()</strong></p>
<p>“相交”方法允许您比较两条曲线，以找出它们的不同之处或相似之处。它可以以您可能期望的方式使用，以获得两条曲线彼此相交的点，但它也可以用于识别：</p>
<ul>
<li>Collinear lines 共线的线</li>
<li>Overlapping lines 重叠线</li>
<li>Identical curves 相同曲线</li>
<li>Totally distinct curves with no intersections 完全不同的曲线，没有交叉点</li>
</ul>
<p>返回值标识这些不同的结果，输出IntersectionSetResult包含有关交点的信息。</p>
<p><strong>Project()</strong> </p>
<p>Project方法将点投影到曲线上，并返回有关曲线上最近点、其参数以及与投影点的距离的信息。</p>
<p><strong>Tessellate()</strong></p>
<p>这会将曲线分割为一系列线性段，精确度在默认公差范围内。对于Curve.Tessellate（），公差略大于1&#x2F;16”。此近似公差是Revit内部使用的公差，足以满足显示目的。</p>
<p>请注意，只有直线可以被分割成只有两个细分点的输出;非线性曲线将总是输出两个以上的点，即使曲线具有极大的半径，在数学上可能等同于直线。</p>
<h4 id="曲线工作"><a href="#曲线工作" class="headerlink" title="曲线工作"></a>曲线工作</h4><p>Curve类提供了使用曲线的有用方法。</p>
<p>除了对分析有用的方法外，Curve类还提供了用于修改曲线或获取有关曲线的基本信息的属性和方法。</p>
<p><strong>改变界限</strong></p>
<p>MakeBound（）方法可用于更改曲线的边界或为先前未绑定的曲线创建边界。MakeUnbound（）将使曲线未绑定。对于这两种方法，如果曲线标记为只读（因为它是直接从Revit图元或集合&#x2F;聚合对象中提取的），则调用此方法会导致对象更改为包含原始曲线的断开连接的副本。修改不会影响原始曲线或提供原始曲线的对象。</p>
<p><strong>图形样式</strong></p>
<p>Curve从GeometryObject继承GraphicsStyleId只读属性，GeometryObject提供指定给Curve的GraphicsStyle的ElementId。方法Curve.SetGraphicsStyleId（）可用于设置Curve的GraphicsStyle Id。Revit API中的许多方法将不使用与此曲线关联的图形样式。例如，用作图元草图一部分的曲线将不会读取此属性。新创建的曲线元素也不会使用此值，因为它们从其关联类别继承图形特性。</p>
<p><strong>曲线长度</strong></p>
<p>曲线有两个与长度相关的属性。Length属性将返回曲线的精确长度。我使用解析或数值积分计算曲线的长度。对于直线和圆弧没有性能影响。对于更快的近似，ApproximateLength属性可以快速估计曲线的长度，但在某些情况下可能会偏离2倍。此计算对于直线和圆弧是精确的。</p>
<h4 id="曲线集合"><a href="#曲线集合" class="headerlink" title="曲线集合"></a>曲线集合</h4><p>Revit API使用不同类型的曲线集合作为输入。</p>
<p>注意：较新的API方法使用Curves的.NET集合代替CurveArray和CurveArrArray。</p>
<p><strong>CurveLoop</strong></p>
<p>curveloop表示端到端连接的特定曲线链。它可以表示一个闭环或一个开环。curveloop的成员可以直接迭代，因为该类实现了IEnumerable。迭代提供了直接包含在循环中的曲线的副本；曲线的修改不会影响loop中包含的曲线。可以使用以下方法创建CurveLoops：</p>
<ul>
<li>CurveLoop.Create（）-从曲线列表创建新的CurveLoop。</li>
<li>CurveLoop.CreateViaCopy() - 创建新的CurveLoop作为现有CurveLoop的副本。</li>
<li>CurveLoop. ViaThumb（Curve，double，XYZ）-通过相对于给定平面加厚输入曲线来创建新的闭合CurveLoop。</li>
<li>CurveLoop. curveViaThrottle（CurveLoop，double，XYZ）-通过相对于给定平面加厚输入开放曲线循环来创建新的闭合曲线循环。</li>
<li>CurveLoop.CreateViaTransform() - 创建一个新的CurveLoop作为输入CurveLoop的转换副本。请注意，重载ViaThursday（）方法的thickness参数必须导致曲线超过Revit的短曲线容差（Application.ShortCurveTolerance），否则将引发异常。</li>
</ul>
<p>CurveLoop.Transform（） 的执行方式与 CreateViaTransform（） 类似，但它会变换 CurveLoop 中包含的曲线，而不是创建变换后的副本。</p>
<p><strong>CurveArray</strong></p>
<p>此集合类表示曲线的任意集合。使用其构造函数创建它。</p>
<p><strong>CurveArrArray</strong></p>
<p>此集合类是 CurveArray 的集合。当使用 this 时，此数组的子元素的组织对 this 传递给的方法有意义;例如，在 NewExtrusion（） 中，多个 CurveArrays 应该表示不同的闭合循环。</p>
<h4 id="曲线创建"><a href="#曲线创建" class="headerlink" title="曲线创建"></a>曲线创建</h4><p>通常需要将曲线作为 Revit API 方法的输入。可以通过多种方式创建它们。</p>
<p>曲线具有许多派生类型，这些类型具有用于创建曲线的静态方法。基类 Curve 还具有从现有曲线创建新曲线的方法。</p>
<p>曲线创建方法会阻止创建短于 Revit 容差的曲线。此容差通过 Application.ShortCurveTolerance 属性公开。</p>
<p><strong>Curve</strong> </p>
<p>Curve 类具有多种从现有曲线创建新曲线的方法。</p>
<ul>
<li>Clone（） - 创建此曲线的副本。</li>
<li>CreateOffset（） - 从该曲线创建一个新的曲线偏移。</li>
<li>CreateReversed（） - 创建一条与现有曲线方向相反的新曲线</li>
<li>Curve.CreateTransformed（） - 创建曲线的新实例作为该曲线的变换。</li>
</ul>
<p><strong>Line</strong></p>
<p>有两种静态方法可用于创建新 Line。</p>
<ul>
<li>CreateBound() - 在两点之间创建新的边界线性曲线。</li>
<li>CreateUnbound() - 在给定原点和方向的情况下创建新的未绑定线性曲线。</li>
</ul>
<p>Code Region：创建unbound 的线性曲线</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// define start point and direction for unbound line</span></span><br><span class="line">XYZ startPoint = <span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">XYZ directionPt = <span class="keyword">new</span> XYZ(<span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// create line</span></span><br><span class="line">Line line = Line.CreateUnbound(startPoint, directionPt);</span><br></pre></td></tr></table></figure>

<p><strong>Arc</strong> </p>
<p>重载的静态 Create（） 方法允许通过以下三种方式之一创建 Arc：</p>
<ul>
<li><p>基于 3 点</p>
</li>
<li><p>代码区域：创建具有 3 个点的圆弧</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Create a new arc using two ends and a point on the curve</span></span><br><span class="line">XYZ end0 = <span class="keyword">new</span> XYZ(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);    <span class="comment">// start point of the arc</span></span><br><span class="line">XYZ end1 = <span class="keyword">new</span> XYZ(<span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>); <span class="comment">// end point of the arc</span></span><br><span class="line">XYZ pointOnCurve = <span class="keyword">new</span> XYZ(<span class="number">10</span>, <span class="number">0</span>, <span class="number">0</span>);   <span class="comment">// point along arc</span></span><br><span class="line"></span><br><span class="line">Arc arc = Arc.Create(end0, end1, pointOnCurve);</span><br></pre></td></tr></table></figure>
</li>
<li><p>基于平面、半径和角度</p>
</li>
<li><p>代码区域：使用平面创建圆弧</p>
</li>
<li><pre><code class="c#">Arc CreateArcByGivingPlane(Autodesk.Revit.ApplicationServices.Application application, Plane plane)
&#123;
    // Create an arc which is placed on the plane and whose center is the plane&#39;s origin
    double radius = 10;
    double startAngle = 0;      // The unit is radian
    double endAngle = 2 * Math.PI;        // this arc will be a circle
    return Arc.Create(plane, radius, startAngle, endAngle);
&#125;
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">- based on center, radius, angles and two axes</span><br><span class="line">  基于圆心、半径、角度和两个轴</span><br><span class="line"></span><br><span class="line">  代码区域：使用轴创建圆弧</span><br><span class="line"></span><br><span class="line">  ```c#</span><br><span class="line">  // Create a new arc defined by its center, radios, angles and 2 axes</span><br><span class="line">  double radius = 10;</span><br><span class="line">  double startAngle = 0;      // In radian</span><br><span class="line">  double endAngle = Math.PI;        // In radian</span><br><span class="line">  XYZ center = new XYZ(5, 0, 0);</span><br><span class="line">  XYZ xAxis = new XYZ(1, 0, 0);   // The x axis to define the arc plane. Must be normalized</span><br><span class="line">  XYZ yAxis = new XYZ(0, 1, 0);   // The y axis to define the arc plane. Must be normalized</span><br><span class="line">  </span><br><span class="line">  Arc arc = Arc.Create(center, radius, startAngle, endAngle, xAxis, yAxis);</span><br></pre></td></tr></table></figure>

注意，对于后两个选项，如果角度范围等于或大于 2 * PI，则曲线将自动转换为无界圆。
</code></pre>
</li>
</ul>
<p><strong>Ellipse</strong> </p>
<p>静态 CreateCurve（） 方法创建一个椭圆，给定中心、椭圆的 x 向量和 y 向量半径、x 轴和 y 轴以定义椭圆的平面以及开始和结束参数。如果 x 半径和 y 半径几乎相等，它将返回一个圆弧，否则将返回一个椭圆。</p>
<p><strong>Cylindrical Helix</strong></p>
<p>CylindricalHelix 的静态 Create（） 方法从轴的基点、半径、x 向量、z 向量、螺距、起始角度（用于指定螺旋线的起点）和结束角度（用于指定螺旋线的终点）创建一个新的 CylindricalHelix。z 向量是轴方向，应垂直于 x 向量。正螺距产生右旋螺旋，而负螺距产生左旋螺旋。</p>
<p><strong>NURBS</strong> </p>
<p>NurbSpline 类表示 NURBS 或非均匀有理 B 样条曲线。重载的静态 CreateCurve（） 方法提供了多种创建 NURBS 曲线的方法。第一种方法是使用 Revit 在用户界面中绘制样条曲线时使用的相同计算。它需要一个控制点和权重的列表来创建新的 NurbSpline。样条的结和阶数是根据给定的控制点和权重计算的。</p>
<p>第二个选项还需要控制点和权重列表，还需要结列表以及 NurbSpline 的阶数。度数必须为 1 或更大。必须至少有 degree+1 个控制点。结的大小必须等于 degree、control points 数组的大小和 1 之和。第一度 + 1 节应该相同，最后一度 + 1 节也应相同。序列中间的结必须是非递减的。</p>
<p>第三个选项只需要控制点和权重。必须至少有 2 个控制点，并且权重的数量必须等于控制点的数量。所有权重的值都必须为正。</p>
<p>在所有情况下，创建的曲线可以是 NURBSpline 或更简单的曲线，例如直线或圆弧。这与 Revit 的期望一致，即在 Revit 图元中应使用尽可能简单的曲线表示。</p>
<p><strong>Hermite Spline</strong></p>
<p>重载的静态 HermiteSpline.Create（） 方法提供了两个用于创建 Hermite 样条的选项。最简单的方法是创建端点处具有默认切线的 Hermite 样条，并且只需要一个控制点列表和一个指示 Hermite 样条是否为周期性的标志。第二个选项将创建在其端点处具有指定切线的 Hermite 样条曲线。它有一个附加的 HermiteSplineTangents 对象参数，用于指定曲线起点和&#x2F;或终点的切线。</p>
<h4 id="曲线参数化"><a href="#曲线参数化" class="headerlink" title="曲线参数化"></a>曲线参数化</h4><p>Revit API 中的曲线可以描述为输入参数“u”的数学函数，其中曲线在 XYZ 空间中任何给定点的位置是“u”的函数。</p>
<p>曲线可以是绑定的，也可以是未绑定的。未绑定曲线没有端点，表示无限抽象（未绑定的直线）或循环曲线（圆或椭圆）。</p>
<p>在 Revit 中，参数“u”可以用两种方式表示：</p>
<ul>
<li>一个 ‘normalized’ 参数。参数的起始值为 0.0，结束值为 1.0。对于某些曲线类型，这使得沿曲线范围的曲线计算非常容易，例如，直线的中点位于参数 0.5 处。（请注意，对于更复杂的曲线方程式（如 Splines），不能总是做出此假设）。</li>
<li>一个 ‘raw’ 参数。参数的 start 和 end 值可以是任何值。对于给定的曲线，最小和最大原始参数的值可以通过 Curve.GetEndParameter（int） 获取。原始参数非常有用，因为它们的单位与 Revit 默认单位（英尺）相同。因此，要从起点沿曲线获得 5 英尺的位置，您可以在起点处获取 raw 参数，并在其上添加 5。原始参数也是计算未绑定曲线的唯一方法。</li>
</ul>
<p>方法 Curve.ComputeNormalizedParameter（） 和 Curve.ComputeRawParameter（） 会自动在两种参数类型之间缩放。方法 Curve.IsInside（） 计算原始参数，以查看它是否位于曲线的边界内。</p>
<p>您可以使用参数来计算曲线在任何给定位置的各种属性：</p>
<ul>
<li>给定曲线的 XYZ 位置。这是从 Curve.Evaluate（） 返回的。可以提供 raw 或 normalized 参数。如果您还调用 ComputeDerivatives（），则这也是 .Origin 属性。</li>
<li>给定曲线的第一个导数&#x2F;切线向量。这是 .Curve.ComputeDerivatives（） 返回的 Transform 的 BasisX 属性。</li>
<li>给定曲线的第二个导数&#x2F;法向量。这是 .BasisY 属性。</li>
<li>给定曲线的<em>次法向量</em>，定义为切线向量和法向量的叉积。这是 .Curve.ComputeDerivatives（） 返回的 Transform 的 BasisZ 属性。</li>
</ul>
<p>返回的所有向量都是非规格化的（但可以使用XYZ.Normalize（）规格化Revit API中的任何向量）。请注意，当曲线是直线时，将不会为法线和副法线向量设置值。可以使用切向量计算给定平面中直线的法向量。</p>
<p>API示例“DirectionCalculation”使用墙位置曲线的切线向量来查找朝南的外墙：</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/directioncalculation_sample.png"></p>
<p>寻找并突出显示朝南的外墙</p>
<h4 id="曲线类型"><a href="#曲线类型" class="headerlink" title="曲线类型"></a>曲线类型</h4><p>Revit使用各种曲线类型来表示文档中的曲线几何图形。</p>
<table>
<thead>
<tr>
<th><strong>Curve type 曲线类型</strong></th>
<th>Revit API类**</th>
<th><strong>Definition 定义</strong></th>
<th><strong>Notes 注意</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Bound line</td>
<td>Line</td>
<td>由端点定义的线段。</td>
<td>从Curve.GetEndpoint（）获取端点</td>
</tr>
<tr>
<td>Unbound line</td>
<td>Line</td>
<td>由位置和方向定义的无限线</td>
<td>使用Curve.IsBound标识这些。在原始参数&#x3D; 0处计算点和切向量，以找到直线方程的输入参数。</td>
</tr>
<tr>
<td>Arc</td>
<td>Arc</td>
<td>一个有界的圆弧</td>
<td>开始和结束在一定的角度。这些角度可以通过弧的每一端的原始参数值获得。</td>
</tr>
<tr>
<td>Circle</td>
<td>Arc</td>
<td>一个没有束缚的圆圈</td>
<td>使用Curve.IsBound标识。使用原始参数进行评价（从0到2π）</td>
</tr>
<tr>
<td>Cylindrical helix</td>
<td>CylindricalHelix</td>
<td>绕在圆柱体上的螺旋线，与圆柱体的轴线成恒定的角度</td>
<td>仅在楼梯和扶手中的特定应用中使用，在访问其他Revit图元和几何图形的曲线时不应使用或遇到。</td>
</tr>
<tr>
<td>Elliptical arc</td>
<td>Ellipse</td>
<td>一个约束椭圆段</td>
<td></td>
</tr>
<tr>
<td>Ellipse</td>
<td>Ellipse</td>
<td>无约束椭圆</td>
<td>使用Curve.IsBound标识。使用原始参数进行评价（从0到2π）</td>
</tr>
<tr>
<td>NURBS</td>
<td>NurbSpline</td>
<td>非均匀有理B样条曲线</td>
<td>用于在各种Revit工具中绘制的样条曲线，以及导入的几何图形</td>
</tr>
<tr>
<td>Hermite</td>
<td>HermiteSpline</td>
<td>一组点之间的样条插值</td>
<td>用于“逐点曲线”和软风管&#x2F;管道等工具，以及导入的几何图形</td>
</tr>
</tbody></table>
<p>所有Revit曲线类型的数学表示可以在曲线类型的数学表示找到。</p>
<h4 id="曲线类型的数学表示"><a href="#曲线类型的数学表示" class="headerlink" title="曲线类型的数学表示"></a>曲线类型的数学表示</h4><p>本节介绍Revit几何图形中遇到的曲线类型、其属性及其数学表示。</p>
<p><strong>Bound lines</strong></p>
<p>Bound lines由其端点定义。在Revit API中，从曲线-标高 GetEndPoint（）方法获取线的端点。</p>
<p>Bound lines上的点根据归一化参数“u”和Bound lines上点的方程为：</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/curve_bound_line.png"></p>
<p><strong>Unbound lines</strong></p>
<p>Unbound lines在Revit API中进行了专门处理。不能使用大多数曲线属性，但是，当提供原始参数时，Evaluate（）和ComputeDerivatives（）可用于获取曲线沿着的位置。</p>
<p>根据原始参数“u”以及线原点和归一化方向向量，未绑定线的点的方程为：</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/curve_unbound_line.png"></p>
<p><strong>Arcs and Circles</strong></p>
<p>圆弧和圆在Revit API中由Arc类表示。它们是根据半径、圆心和垂直于弧平面的矢量定义的，这些参数可以在Revit API中作为属性直接从Arc类访问。</p>
<p>圆的IsBound属性设置为true。这意味着它们只能通过使用原始参数（范围从0到2π）来计算，并且圆上的点的原始参数方程为：</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/curve_arcs.png"></p>
<p>其中假设圆位于XY平面内。</p>
<p>弧的开始和结束都有一定的角度。这些角度可以通过弧的每一端处的原始参数值来获得，并且这些值之间的角度值可以插入到与上述相同的等式中。</p>
<p><strong>圆柱螺旋</strong></p>
<p>圆柱螺旋线在Revit API中由ExtradricalHashion类表示。它们是根据螺旋缠绕的圆柱体的轴的基点、半径、x和y矢量、螺距以及起始角和结束角来定义的。</p>
<p><strong>椭圆和椭圆弧</strong></p>
<p>椭圆和椭圆弧段在Revit API中由Ellipse类表示。与圆弧和圆类似，它们在给定平面中根据其X和Y半径、中心和垂直于椭圆平面的向量来定义。</p>
<p>完整椭圆的IsBound属性设置为true。与圆类似，它们可以通过0和2π之间的原始参数进行评估：</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/curve_ellipse.png"></p>
<p><strong>NurbSpline</strong></p>
<p>NURBS用于用户绘制为曲线或3D对象草图的一部分的样条线段。它们还用于表示某些类型的导入几何数据。</p>
<p>NurbSpline的数据包括：</p>
<ul>
<li>长度为n+1的控制点数组</li>
<li>weights数组，长度也是n+1</li>
<li>曲线阶数，其值等于曲线阶数（k）的小一</li>
<li>长度为n + k +1的节点向量</li>
</ul>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/curve_nurb_spline.png"></p>
<p>Revit的草图绘制工具中使用的NurbSplines可以使用算法单独从控制点和阶数生成。可以在外部复制Revit算法执行的计算，请参见下面的示例：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">NurbSplinespline = curve.GeometryCurve <span class="keyword">as</span> NurbSpline;</span><br><span class="line">DoubleArrayknots = spline.Knots;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Convert to generic collection</span></span><br><span class="line">List knotList = <span class="keyword">new</span> List();</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; knots.Size; i++)</span><br><span class="line">&#123;</span><br><span class="line">    knotList.Add(knots.get_Item(i));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Preparation - get distance between each control point</span></span><br><span class="line">IList controlPoints = spline.CtrlPoints;</span><br><span class="line"><span class="built_in">int</span> numControlPoints = controlPoints.Count;</span><br><span class="line"><span class="built_in">double</span>[] chordLengths = <span class="keyword">new</span> <span class="built_in">double</span>[numControlPoints - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> iControlPoint = <span class="number">1</span>; iControlPoint &lt; numControlPoints; ++iControlPoint)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">double</span> chordLength = </span><br><span class="line">       controlPoints[iControlPoint].DistanceTo(controlPoints[iControlPoint - <span class="number">1</span>]);</span><br><span class="line">    chordLengths[iControlPoint - <span class="number">1</span>] = chordLength;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> degree = spline.Degree;</span><br><span class="line"><span class="built_in">int</span> order = degree + <span class="number">1</span>;</span><br><span class="line"><span class="built_in">int</span> numKnots = numControlPoints + order;</span><br><span class="line"><span class="built_in">double</span>[] computedKnots = <span class="keyword">new</span> <span class="built_in">double</span>[numKnots];</span><br><span class="line"><span class="built_in">int</span> iKnot = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Start knot with multiplicity degree + 1.</span></span><br><span class="line"><span class="built_in">double</span> startKnot = <span class="number">0.0</span>;</span><br><span class="line"><span class="built_in">double</span> knot = startKnot;</span><br><span class="line"><span class="keyword">for</span>(iKnot = <span class="number">0</span>; iKnot &lt; order; ++iKnot)</span><br><span class="line">&#123;</span><br><span class="line">    computedKnots[iKnot] = knot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Interior knots based on chord lengths</span></span><br><span class="line"><span class="built_in">double</span> prevKnot = knot;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="comment">/*blank*/</span>; iKnot &lt;= numControlPoints; ++iKnot) </span><br><span class="line">    <span class="comment">// Last loop computes end knot but does not set interior knot.</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">double</span> knotIncrement = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> jj = iKnot - order; jj &lt; iKnot - <span class="number">1</span>; ++jj)</span><br><span class="line">    &#123;</span><br><span class="line">        knotIncrement += chordLengths[jj];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    knotIncrement /= degree;</span><br><span class="line">    knot = prevKnot + knotIncrement;</span><br><span class="line">    <span class="keyword">if</span> (iKnot &lt; numControlPoints)</span><br><span class="line">        computedKnots[iKnot] = knot;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">break</span>;   <span class="comment">// Leave &quot;knot&quot; set to the end knot; do not increment &quot;ii&quot;.</span></span><br><span class="line"></span><br><span class="line">    prevKnot = knot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// End knot with multiplicity degree + 1.</span></span><br><span class="line"><span class="keyword">for</span>(<span class="comment">/*blank*/</span>; iKnot &lt; numKnots; ++iKnot)</span><br><span class="line">&#123;</span><br><span class="line">    computedKnots[iKnot] = knot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>HermiteSpline</strong></p>
<p>Hermite样条用于在一组控制点之间插值的曲线，如MEP中的逐点曲线和软风管和管道。它们还用于表示某些类型的导入几何数据。在Revit API中，HermiteSpline类提供了通过“控制点”、“切线”和“参数”属性访问点阵列、切线向量和参数的功能。</p>
<p>Hermite样条中两个节点之间的曲线方程为：</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/curve_hermite_1.png"></p>
<p>其中，Pk和Pk+1表示每个节点处的点，Mk和Mk+1表示切向量，并且uk和uk+1表示节点处的参数，并且基函数为：</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/curve_hermite_2.png"></p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/curve_hermite5.png"></p>
<h3 id="GeometryInstances"><a href="#GeometryInstances" class="headerlink" title="GeometryInstances"></a>GeometryInstances</h3><p>GeometryInstance表示Revit以默认配置存储的一组几何图形，然后根据图元的属性将其转换到正确的位置。最常见的遇到几何图形的情况是在族实例中。Revit使用几何图形库，允许它存储给定族的几何图形的单个副本，并在多个实例中重复使用该副本。</p>
<p>请注意，并非所有族实例都将包括几何图形。当Revit需要为给定实例制作族几何图形的唯一副本时（由于局部连接、交点以及与实例放置相关的其他因素的影响），不会遇到GeometryInstance;相反，实体几何图形将位于层次的顶层。</p>
<p>GeometryInstance提供了通过GetSymbolGeometry（）和GetInstanceGeometry（）方法读取其几何体的能力。这些方法返回另一个Autodesk.Revit.DB.GeometryElement，可以像第一级返回一样对其进行分析。</p>
<p>GetSymbolGeometry（）返回在族的坐标系中表示的几何图形。例如，当您需要“通用”表格的图片而不考虑项目中的方向和放置位置时，请使用此选项。这也是唯一一个将实际的Revit几何图形对象返回给您而不是复制的重载。这一点很重要，因为使用此几何图形作为输入来创建其他图元的操作（例如，标注尺寸或放置基于面的族）需要参照原始几何图形。</p>
<p>GetInstanceGeometry（）返回在放置实例的项目的坐标系中表示的几何图形。例如，当需要项目中实例的特定几何图形的图片时（例如，确保桌子与房间的墙壁平行放置），请使用此选项。这始终会返回图元几何图形的副本，因此，虽然它适用于实施导出器或几何分析工具，但不适合用于创建引用此几何图形的其他Revit图元。</p>
<p>GetInstanceGeometry（）和GetSymbolGeometry（）也有重载，它们可以通过任意坐标系变换几何体。这些方法始终返回类似于GetInstanceGeometry（）的副本。</p>
<p>GeometryInstance还存储了从符号坐标空间到实例坐标的变换。此转换可作为Transform属性访问。它也是通过GetInstanceGeometry（）提取几何体副本时使用的变换。有关更多详细信息，请参见几何辅助类。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/instances_transformed.png"></p>
<p>2个使用不同变换放置的族实例-将从两个族实例中获取相同的几何图形</p>
<p>对于某些族，可以嵌套多层。如果您遇到嵌套实例，则可能会以与第一级实例类似的方式对其进行解析。</p>
<p>给出了两个示例来解释如何解析实例的几何形状。</p>
<p>在此示例中，从GeometryInstance方法GetInstanceGeometry（）提取曲线。</p>
<p>代码区域：从实例获取曲线</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetAndTransformCurve</span>(<span class="params">Autodesk.Revit.ApplicationServices.Application app,</span></span></span><br><span class="line"><span class="params"><span class="function">            Autodesk.Revit.DB.Element element, Options geoOptions</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// Get geometry element of the selected element</span></span><br><span class="line">   Autodesk.Revit.DB.GeometryElement geoElement = element.get_Geometry(geoOptions);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Get geometry object</span></span><br><span class="line">   <span class="keyword">foreach</span> (GeometryObject geoObject <span class="keyword">in</span> geoElement)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="comment">// Get the geometry instance which contains the geometry information</span></span><br><span class="line">      Autodesk.Revit.DB.GeometryInstance instance =</span><br><span class="line">             geoObject <span class="keyword">as</span> Autodesk.Revit.DB.GeometryInstance;</span><br><span class="line">      <span class="keyword">if</span> (<span class="literal">null</span> != instance)</span><br><span class="line">      &#123;</span><br><span class="line">         GeometryElement instanceGeometryElement = instance.GetInstanceGeometry();</span><br><span class="line">         <span class="keyword">foreach</span> (GeometryObject o <span class="keyword">in</span> instanceGeometryElement)</span><br><span class="line">         &#123;</span><br><span class="line">            <span class="comment">// Try to find curves</span></span><br><span class="line">            Curve curve = o <span class="keyword">as</span> Curve;</span><br><span class="line">            <span class="keyword">if</span> (curve != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">               <span class="comment">// The curve is already transformed into the project coordinate system</span></span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在此示例中，使用GetSymbolGeometry（）从实例中获取实体。然后使用GeometryInstance.Transform将组成点变换到项目坐标系中。</p>
<p>代码区域：从实例获取可靠信息</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">GetAndTransformSolidInfo</span>(<span class="params">Application application, Element element, Options geoOptions</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">// Get geometry element of the selected element</span></span><br><span class="line">        Autodesk.Revit.DB.GeometryElement geoElement = element.get_Geometry(geoOptions);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Get geometry object</span></span><br><span class="line">        <span class="keyword">foreach</span> (GeometryObject geoObject <span class="keyword">in</span> geoElement)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="comment">// Get the geometry instance which contains the geometry information</span></span><br><span class="line">                Autodesk.Revit.DB.GeometryInstance instance =</span><br><span class="line">      geoObject <span class="keyword">as</span> Autodesk.Revit.DB.GeometryInstance;</span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">null</span> != instance)</span><br><span class="line">                &#123;</span><br><span class="line">                    GeometryElement instanceGeometryElement = instance.GetSymbolGeometry();</span><br><span class="line">                    <span class="keyword">foreach</span> (GeometryObject instObj <span class="keyword">in</span> instanceGeometryElement)</span><br><span class="line">                        &#123;</span><br><span class="line">                                Solid solid = instObj <span class="keyword">as</span> Solid;</span><br><span class="line">                                <span class="keyword">if</span> (<span class="literal">null</span> == solid || <span class="number">0</span> == solid.Faces.Size || <span class="number">0</span> == solid.Edges.Size)</span><br><span class="line">                                &#123;</span><br><span class="line">                                        <span class="keyword">continue</span>;</span><br><span class="line">                                &#125;</span><br><span class="line"></span><br><span class="line">                                Transform instTransform = instance.Transform;</span><br><span class="line">                                <span class="comment">// Get the faces and edges from solid, and transform the formed points</span></span><br><span class="line">                                <span class="keyword">foreach</span> (Face face <span class="keyword">in</span> solid.Faces)</span><br><span class="line">                                &#123;</span><br><span class="line">                                        Mesh mesh = face.Triangulate();</span><br><span class="line">                                        <span class="keyword">foreach</span> (XYZ ii <span class="keyword">in</span> mesh.Vertices)</span><br><span class="line">                                        &#123;</span><br><span class="line">                                                XYZ point = ii;</span><br><span class="line">                                                XYZ transformedPoint = instTransform.OfPoint(point);</span><br><span class="line">                                        &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">foreach</span> (Edge edge <span class="keyword">in</span> solid.Edges)</span><br><span class="line">                                &#123;</span><br><span class="line">                                        <span class="keyword">foreach</span> (XYZ ii <span class="keyword">in</span> edge.Tessellate())</span><br><span class="line">                                        &#123;</span><br><span class="line">                                                XYZ point = ii;</span><br><span class="line">                                                XYZ transformedPoint = instTransform.OfPoint(point);</span><br><span class="line">                                        &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：有关检索到的族实例几何图形的详细信息，请参见示例：从梁中检索几何图形数据。</p>
<h3 id="网格"><a href="#网格" class="headerlink" title="网格"></a>网格</h3><p>网格是三角形边界的集合，它们共同形成3D形状。如果Revit图元是通过某些导入操作创建的，并且还用于某些本机Revit图元（如TopographySurface），则通常会在Revit图元几何图形中遇到网格。还可以通过调用任意给定Revit面的Face.Triangulate（）来获取网格。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/mesh.png"></p>
<p>表示圆环面的网格</p>
<p>以下代码示例说明了如何将Revit面的几何体作为网格获取：</p>
<p>代码区域：提取几何体的网格</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">GetTrianglesFromFace</span>(<span class="params">Face face</span>)</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Get mesh</span></span><br><span class="line"></span><br><span class="line">        Mesh mesh = face.Triangulate();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; mesh.NumTriangles; i++)</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">               MeshTriangle triangle = mesh.get_Triangle(i);</span><br><span class="line"></span><br><span class="line">               XYZ vertex1 = triangle.get_Vertex(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">               XYZ vertex2 = triangle.get_Vertex(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">               XYZ vertex3 = triangle.get_Vertex(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：用于Revit显示目的的近似公差在构造网格时由Triangulate（）方法（上面使用的）的无参数重载使用。Triangulate（）的重载接受一个double，允许将细节级别设置在0（粗糙）和1（精细）之间。</p>
<h3 id="点"><a href="#点" class="headerlink" title="点"></a>点</h3><p>点表示3D空间中的可见坐标。</p>
<p>点通常出现在体量族图元（如ReferencePoint）中。Point类提供对其坐标的读访问，并能够获取对该点的引用，以用作其他函数的输入。</p>
<p><strong>点创建</strong></p>
<p>有两种方法可以创建点：</p>
<ul>
<li>Create(XYZ) - 在给定坐标处创建一个点。</li>
<li>Create(XYZ, ElementId) - 在给定坐标处创建一个Point，并根据GraphicsStyle元素（由ElementId指定）为其指定颜色。</li>
</ul>
<h3 id="PolyLine"><a href="#PolyLine" class="headerlink" title="PolyLine"></a>PolyLine</h3><p>PolyLine是由一组坐标点定义的线段的集合。这些通常在导入的几何体中遇到。PolyLine类提供了读取坐标的能力：</p>
<ul>
<li>PolyLine.NumberOfCoordinates – 在坐标系中的点数</li>
<li>PolyLine.GetCoordinate() – 通过索引获取坐标</li>
<li>PolyLine.GetCoordinates() – 获取对象中所有坐标的集合</li>
<li>PolyLine.Evaluate() – 给定一个规格化参数（从0到1），沿整个PolyLine范围沿着计算XYZ点</li>
</ul>
<h3 id="实体、面和边"><a href="#实体、面和边" class="headerlink" title="实体、面和边"></a>实体、面和边</h3><p>实体是一个Revit API对象，表示面和边的集合。通常，在Revit中，这些集合是完全封闭的体积，但也可能遇到壳或部分有界体积。请注意，有时Revit几何图形将包含未使用的实体，这些实体包含零个边和面。选中“边”和面成员以过滤掉这些实体。</p>
<p>Revit API提供了读取面和边的集合以及计算实体的表面积、体积和质心的功能。</p>
<p>本节中的页面</p>
<ul>
<li>边和面参数化</li>
<li>面</li>
<li>面分析</li>
<li>面分割</li>
<li>面类型</li>
<li>面类型的数学表示</li>
<li>实体分析</li>
<li>实体和面的创建</li>
</ul>
<h5 id="边和面参数化"><a href="#边和面参数化" class="headerlink" title="边和面参数化"></a>边和面参数化</h5><p>边是给定面的边界曲线。</p>
<p>使用EdgeLoops属性迭代面的边。每个循环表示面上的一个闭合边界。边始终参数化为0到1。可以使用Edge.AsCurve（）和Edge.AsCurveFollowingFace（）函数提取边缘的Curve表示。</p>
<p>边通常通过计算两个面的相交来定义。但Revit在绘制图形时不会重新计算此交点。因此，边存储一个点列表-直边的端点和曲边的细分列表。这些点是两个面上的参数坐标。这些点可以通过TessellateOnFace（）方法获得。</p>
<p>剖面产生“切割边缘”。这些是人工边-不表示模型级几何体的一部分，因此不提供参照。</p>
<p><strong>边的方向</strong></p>
<p>方向通常在第一个面上为顺时针方向（第一个面表示Revit已为特定边标识的任意面）。但是，由于两个不同的面在一个特定的边相交，并且无论您关注的是哪个面，该边都具有相同的参数化方向，因此有时需要确定特定面上的边的方向。</p>
<p>下图说明了这是如何工作的。对于面0，所有边都是顺时针参数化的（？？？）。对于面1，与面0共享的边不会重新参数化;因此，相对于面1，该边具有相反的方向，并且某些边在两条边的参数均为0（或1）的地方相交。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/face_edge_direction.png"></p>
<p>边参数化</p>
<p>API示例“PanelEdgeLengthAngle”显示了如何识别给定面的反转边。它使用边端点处的切向量来计算相邻边之间的角度，并检测是否在每个交点处翻转切向量以计算适当的角度。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/paneledgelengthangle_sample.png"></p>
<p>PanelEdgeLengthAngle结果</p>
<h5 id="面"><a href="#面" class="headerlink" title="面"></a>面</h5><p>可以将Revit API中的面描述为两个输入参数“u”和“v”的数学函数，其中面在XYZ空间中任意给定点处的位置是参数的函数。</p>
<p>U和V方向是根据给定面的形状自动确定的。恒定U或V的线可以表示为面上的网格线，如下例所示：</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/face_params.png"></p>
<p>圆柱面上的U和V网格线</p>
<p>可以使用UV参数来评估任意给定位置处的面的各种属性：</p>
<ul>
<li>参数是否在面的边界内，使用Face.IsInside（）</li>
<li>指定UV参数值处给定面的XYZ位置。这是从Face.Evaluate（）返回的。如果您还在调用ComputeDerivatives（），则这也是该方法返回的Transform的.Origin属性。</li>
<li>给定面在U方向上的切向量。这是Face.ComputeDerivatives（）返回的Transform的.BasisX属性</li>
<li>给定面在V方向上的切向量。这是Face.ComputeDerivatives（）返回的Transform的.BasisY属性。</li>
<li>给定面部的法向量。这是Face.ComputeDerivatives（）返回的Transform的.BasisZ属性。</li>
<li>关于U的二阶导数。这是Face.ComputeSecondDerivatives（）返回的FaceSecondDerivatives的. UUD派生属性。</li>
<li>相对于V的二阶导数。这是Face.ComputeSecondDerivatives（）返回的FaceSecondDerivatives的.VVDerivative。</li>
<li>给定面的混合导数。这是Face.ComputeSecondDerivatives（）返回的FaceSecondDerivatives的.MixedDerivative。</li>
</ul>
<p>返回的所有向量都是非单位化的。</p>
<h5 id="面分析"><a href="#面分析" class="headerlink" title="面分析"></a>面分析</h5><p>有几种面方法是适用于几何分析的工具。</p>
<p><strong>Intersect()</strong></p>
<p>“相交”方法计算面与曲线之间的相交。它可用于识别：</p>
<ul>
<li>两个对象之间的交点</li>
<li>如果有一条边靠近该位置，则为距离交点最近的边</li>
<li>与面完全重合的曲线</li>
<li>不相交的曲线和面</li>
</ul>
<p><strong>Project()</strong> </p>
<p>Project方法将点投影到输入面上，并返回有关投影点、到面的距离以及到投影点的最近边的信息。</p>
<p><strong>Triangulate()</strong></p>
<p>Triangulate方法获得一个近似于面的三角形网格。此方法有两个重载。无参数方法与Curve.Tessellate（）类似，因为网格的点在Revit使用的输入公差范围内（略大于1&#x2F;16”）是精确的。第二个Triangulate方法接受一个细节级别作为参数，范围从0（粗略）到1（精细）。</p>
<h5 id="面分割"><a href="#面分割" class="headerlink" title="面分割"></a>面分割</h5><p>可以通过“分割面”命令将面分割为面域。Face.HasRegions属性将报告面是否包含使用Split Face命令创建的区域，而Face.GetRegions（）方法将返回一个面列表，一个面用于承载Split Face的对象的主面（如地板的墙壁），一个面用于每个Split Face区域。</p>
<p>FaceSplitter类表示拆分面的元素。FaceSplitter.SplitElementId属性提供其面被此元素分割的元素的ID。FaceSplitter类可用于按类型过滤和查找这些面，如下所示。</p>
<p>代码区域：查找面分割元素</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Autodesk.Revit.DB.Options opt = app.Create.NewGeometryOptions();</span><br><span class="line">opt.ComputeReferences = <span class="literal">true</span>;</span><br><span class="line">opt.IncludeNonVisibleObjects = <span class="literal">true</span>;</span><br><span class="line">FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(doc);</span><br><span class="line">ICollection splitElements = collector.OfClass(<span class="keyword">typeof</span>(FaceSplitter)).Cast().ToList();</span><br><span class="line"><span class="keyword">foreach</span>(FaceSplitter faceSplitter <span class="keyword">in</span> splitElements)</span><br><span class="line">&#123;</span><br><span class="line">    Element splitElement = doc.GetElement(faceSplitter.SplitElementId);</span><br><span class="line">    Autodesk.Revit.DB.GeometryElement geomElem = faceSplitter.get_Geometry(opt);</span><br><span class="line">    <span class="keyword">foreach</span> (GeometryObject geomObj <span class="keyword">in</span> geomElem)</span><br><span class="line">    &#123;</span><br><span class="line">        Line line = geomObj <span class="keyword">as</span> Line;</span><br><span class="line">        <span class="keyword">if</span> (line != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            XYZ end1 = line.GetEndPoint(<span class="number">0</span>);</span><br><span class="line">            XYZ end2 = line.GetEndPoint(<span class="number">1</span>);</span><br><span class="line">            <span class="built_in">double</span> length = line.ApproximateLength;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="面类型"><a href="#面类型" class="headerlink" title="面类型"></a>面类型</h5><p>Revit使用各种曲线类型来表示文档中的面几何图形。其中包括：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>**Face type **</td>
<td><strong>Revit API Class</strong></td>
<td>**Definition **</td>
<td><strong>Notes 注意</strong></td>
</tr>
<tr>
<td>Plane</td>
<td>PlanarFace</td>
<td>由原点与U和V的单位向量定义的平面。</td>
<td></td>
</tr>
<tr>
<td>Cylinder</td>
<td>CylindricalFace</td>
<td>通过沿着轴拉伸圆定义的面。</td>
<td>Radius提供“半径向量”-圆的单位向量乘以半径值。</td>
</tr>
<tr>
<td>Cone</td>
<td>ConicalFace</td>
<td>一条线绕一个轴旋转而定义的面。</td>
<td>Radius提供“半径向量”-圆的单位向量乘以半径值。</td>
</tr>
<tr>
<td>Revolved face</td>
<td>RevolvedFace</td>
<td>由任意曲线绕轴旋转定义的面。</td>
<td>Radius提供旋转平面的单位矢量，不涉及“半径”。</td>
</tr>
<tr>
<td>Ruled surface</td>
<td>RuledFace</td>
<td>通过放样两条轮廓曲线或一条轮廓曲线和一个点之间的直线而定义的面。</td>
<td>曲线和点都可以作为属性获得。</td>
</tr>
<tr>
<td>Hermite face</td>
<td>HermiteFace</td>
<td>由点之间的Hermite插值定义的面。</td>
<td></td>
</tr>
</tbody></table>
<p>所有Revit面类型的数学表示可以在其中找到：面类型的数学表示。</p>
<h5 id="面类型的数学表示"><a href="#面类型的数学表示" class="headerlink" title="面类型的数学表示"></a>面类型的数学表示</h5><p>本节介绍Revit几何图形中遇到的面类型、其属性及其数学表示。</p>
<p><strong>PlanarFace</strong></p>
<p>由原点与U和V的单位向量定义的平面。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/face_planar.png"></p>
<p><strong>CylindricalFace</strong> </p>
<p>通过沿轴沿着拉伸圆而定义的面。Revit API提供以下属性：</p>
<ul>
<li>面的原点。</li>
<li>拉伸轴。</li>
<li>在X和Y中的“径向矢量”。这些向量是圆的单位向量乘以圆的半径。注意，单位向量可以表示右手或左手控制。</li>
</ul>
<p>此面的参数方程为：</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/face_cylinder.png" alt="img"></p>
<p><strong>ConicalFace</strong> </p>
<p>由一条线绕一个轴旋转而定义的面。Revit API提供以下属性：</p>
<ul>
<li>面的原点。</li>
<li>圆锥体的轴。</li>
<li>在X和Y中的“径向矢量”。这些矢量是单位矢量乘以旋转形成的圆的半径。注意，单位向量可以表示右手或左手控制。</li>
<li>The half angle of the face.<br>面的半个角。</li>
</ul>
<p>此面的参数方程为：</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/face_cone.png" alt="img"></p>
<p><strong>RevolvedFace</strong></p>
<p>由任意曲线绕轴旋转定义的面。Revit API提供以下属性：</p>
<ul>
<li>面的原点</li>
<li>面的轴线</li>
<li>轮廓曲线</li>
<li>旋转曲线的单位向量（姑且地称为“半径”）</li>
</ul>
<p>此面的参数方程为：</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/face_revolved.png" alt="img"></p>
<p><strong>RuledFace</strong> </p>
<p>RuledFace 是通过放样两条轮廓曲线之间或曲线与点之间的直线而创建的。Revit API提供曲线和点作为属性。</p>
<p>该曲面的参数方程为：</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/face_ruled1.png" alt="img"> 如果两条曲线都有效。如果其中一条曲线被替换为一个点，则方程简化为以下之一：</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/face_ruled2.png" alt="img"> <img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/face_ruled3.png" alt="img"> 没有曲线和两个点的RuledFace是不会被返回。</p>
<p><strong>HermiteFace</strong></p>
<p>立方Hermite样条曲线面。Revit API提供：</p>
<ul>
<li>样条插值点的u和v参数数组</li>
<li>每个节点上的3D点的数组（数组按u递增，然后v递增的方式组织）</li>
<li>每个节点的切向量数组</li>
<li>每个节点处的扭曲向量数组</li>
</ul>
<p>在节点（u1，v1）和（u2，v2）之间，该曲面的参数表示为：</p>
<p>其中 <img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/face_hermite2.png" alt="img"> ， <img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/face_hermite3.png" alt="img"> ，<strong>MH</strong>是Hermite矩阵：</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/face_hermite4.png" alt="img"><br>并且B是从插值点处的面属性获得的系数矩阵：</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/face_hermite5.png" alt="img"></p>
<h5 id="实体分析"><a href="#实体分析" class="headerlink" title="实体分析"></a>实体分析</h5><p><strong>实体与曲线的交线</strong></p>
<p>方法Solid.IntersectWithCurve（）计算闭合体积实体和曲线之间的交点。SolidCurveIntersectionOptions类可以指定IntersectWithCurve（）方法的结果是否将包括实体体积内部或外部的曲线段。实体内的曲线段将包括与实体的面重合的曲线段。曲线段和曲线段的参数都可以在结果中使用。</p>
<p>以下示例使用IntersectWithCurve（）方法计算柱内钢筋的长度。</p>
<p>代码区域：查找实体和曲线之间的交点</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">FindColumnRebarIntersections</span>(<span class="params">Document document, FamilyInstance column</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// We will be computing the total length of the rebar inside the column</span></span><br><span class="line">    <span class="built_in">double</span> totalRebarLengthInColumn = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find rebar hosted by this column</span></span><br><span class="line">    RebarHostData rebarHostData = RebarHostData.GetRebarHostData(column);</span><br><span class="line">    <span class="keyword">if</span> (rebarHostData == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    IList rebars = rebarHostData.GetRebarsInHost();</span><br><span class="line">    <span class="keyword">if</span> (rebars.Count == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Retrieve geometry of the column</span></span><br><span class="line">    Options geomOptions = <span class="keyword">new</span> Options();</span><br><span class="line">    geomOptions.ComputeReferences = <span class="literal">true</span>;</span><br><span class="line">    geomOptions.DetailLevel = ViewDetailLevel.Fine;</span><br><span class="line">    GeometryElement elemGeometry = column.get_Geometry(geomOptions);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Examine all geometry primitives of the column</span></span><br><span class="line">    <span class="keyword">foreach</span> (GeometryObject elemPrimitive <span class="keyword">in</span> elemGeometry)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Skip objects that are not geometry instances</span></span><br><span class="line">        GeometryInstance gInstance = elemPrimitive <span class="keyword">as</span> GeometryInstance;</span><br><span class="line">        <span class="keyword">if</span> (gInstance == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Retrieve geometry of each found geometry instance</span></span><br><span class="line">        GeometryElement instGeometry = gInstance.GetInstanceGeometry();</span><br><span class="line">        <span class="keyword">foreach</span> (GeometryObject instPrimitive <span class="keyword">in</span> instGeometry)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Skip non-solid sobject</span></span><br><span class="line">            Solid solid = instPrimitive <span class="keyword">as</span> Solid;</span><br><span class="line">            <span class="keyword">if</span> (solid == <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            SolidCurveIntersectionOptions intersectOptions = <span class="keyword">new</span> SolidCurveIntersectionOptions();</span><br><span class="line">            <span class="keyword">foreach</span> (Rebar rebar <span class="keyword">in</span> rebars)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// Get the centerlines for the rebar to find their intersection with the column</span></span><br><span class="line">                <span class="built_in">bool</span> selfIntersection = <span class="literal">false</span>;</span><br><span class="line">                <span class="built_in">bool</span> suppresHooks = <span class="literal">false</span>;</span><br><span class="line">                <span class="built_in">bool</span> suppresBends = <span class="literal">false</span>;</span><br><span class="line">                IList curves = rebar.GetCenterlineCurves(selfIntersection, suppresHooks, suppresBends, MultiplanarOption.IncludeOnlyPlanarCurves, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Examine every segment of every curve of the centerline</span></span><br><span class="line">                <span class="keyword">foreach</span> (Curve curve <span class="keyword">in</span> curves)</span><br><span class="line">                &#123;</span><br><span class="line">                    SolidCurveIntersection intersection = solid.IntersectWithCurve(curve, intersectOptions);</span><br><span class="line">                    <span class="keyword">for</span> (<span class="built_in">int</span> segment = <span class="number">0</span>; segment &lt;= intersection.SegmentCount - <span class="number">1</span>; segment++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">// Calculate length of the rebar that is inside the column</span></span><br><span class="line">                        Curve curveInside = intersection.GetCurveSegment(segment);</span><br><span class="line">                        <span class="built_in">double</span> rebarLengthInColumn = curveInside.Length;</span><br><span class="line">                        totalRebarLengthInColumn = totalRebarLengthInColumn + rebarLengthInColumn;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="实体和面的创建"><a href="#实体和面的创建" class="headerlink" title="实体和面的创建"></a>实体和面的创建</h5><p>实体和面有时用作其他实用程序的输入。Revit API提供了几个例程，可用于从头开始创建此类几何图形或从其他输入中导出此类几何图形。</p>
<p><strong>Transformed geometry</strong></p>
<p>方法</p>
<ul>
<li>GeometryElement.GetTransformed()</li>
</ul>
<p>返回应用了变换的输入几何图元的副本。由于此几何图形是副本，因此其成员不能用作其他Revit图元的输入参照，但可用于几何分析和提取。</p>
<p><strong>Geometry creation utilities</strong></p>
<p>GeometryCreationUtilities类是一个允许构造基本实体形状的实用程序类：</p>
<ul>
<li>Extrusion 拉伸</li>
<li>Loft</li>
<li>Revolution 旋转</li>
<li>Sweep 放样</li>
<li>Blend 融合</li>
<li>SweptBlend 放样融合</li>
</ul>
<p>生成的几何图形不会作为任何元素的一部分添加到文档中。然而，创建的Solid可用作其他API函数的输入，包括：</p>
<ul>
<li>作为分析可视化框架（SpatialFieldManager.AddSpatialFieldPrimitive（））中方法的输入面-这允许用户相对于文档中的其他元素可视化创建的形状</li>
<li>作为通过相交查找3D元素的输入实体</li>
<li>作为布尔运算的一个或多个输入</li>
<li>作为几何计算的一部分（例如，使用Face.Project（）、Face.Intersect（）或其他面、实体和边几何方法）</li>
</ul>
<p>下面的示例使用GeometryCreationUtilities类基于位置和高度创建圆柱形。例如，这可以用于在墙端点周围创建体积，以便查找与墙端点非常接近的其他墙：</p>
<p>代码区域：创建圆柱体</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Build cylinder centered at wall end point, extending 3&#x27; in diameter</span></span><br><span class="line">CurveLoop cylinderLoop = <span class="keyword">new</span> CurveLoop();</span><br><span class="line">XYZ arcCenter = <span class="keyword">new</span> XYZ(endPoint.X, endPoint.Y, elevation);</span><br><span class="line">Application application = wall.Document.Application;</span><br><span class="line">Arc firstArc = Arc.Create(arcCenter, <span class="number">1.5</span>, <span class="number">0</span>, Math.PI, XYZ.BasisX, XYZ.BasisY);</span><br><span class="line">Arc secondArc = Arc.Create(arcCenter, <span class="number">1.5</span>, Math.PI, <span class="number">2</span> * Math.PI, XYZ.BasisX, XYZ.BasisY);</span><br><span class="line"></span><br><span class="line">cylinderLoop.Append(firstArc);</span><br><span class="line">cylinderLoop.Append(secondArc);</span><br><span class="line"></span><br><span class="line">List singleLoop = <span class="keyword">new</span> List();</span><br><span class="line">singleLoop.Add(cylinderLoop);</span><br><span class="line"></span><br><span class="line">Solid proximityCylinder = GeometryCreationUtilities.CreateExtrusionGeometry(singleLoop, XYZ.BasisZ, height);</span><br></pre></td></tr></table></figure>

<p><strong>Boolean operations</strong> </p>
<p>BooleanOperationsUtils类提供用于组合一对实心几何体对象的方法。</p>
<p>ExecuteBooleanOperation（）方法获取输入实体的副本，并生成新实体作为结果。它的第一个参数可以是任何实体，可以直接从Revit图元获得，也可以通过其他操作（如GeometryCreationUtils）创建。</p>
<p>方法ExecuteBooleanOperationModifyingOriginalSolid（）直接对第一个输入实体执行布尔运算。第一个输入必须是不是直接从Revit图元获得的实体。属性GeometryObject.IsElementGeometry可以标识实体是否适合作为此方法的输入。</p>
<p>这两种方法的选项包括操作类型：并集、差集或交集。下面的示例演示如何获取两个实体的交点，然后查找体积。</p>
<p>代码区域：实体相交的体积</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ComputeIntersectionVolume</span>(<span class="params">Solid solidA, Solid solidB</span>)</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    Solid intersection = BooleanOperationsUtils.ExecuteBooleanOperation(solidA, solidB, BooleanOperationsType.Intersect);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">double</span> volumeOfIntersection = intersection.Volume;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法CutWithHalfSpace（）和CutWithHalfSpaceModifyingOriginalSolid（）生成一个实体，该实体是输入Solid与给定Plane正侧的半空间的交点。平面的正侧是平面。法线指向的一侧。第一种方法使用结果创建新实体，而第二种方法修改现有实体（必须是由应用程序创建的实体，而不是从Revit图元获得的实体）。</p>
<h2 id="Geometry-Helper-类"><a href="#Geometry-Helper-类" class="headerlink" title="Geometry Helper 类"></a>Geometry Helper 类</h2><p>API中有几个Geometry Helper类。Helper类用于描述某些元素的几何信息，例如使用BoundingBoxXYZ类为视图定义CropBox。</p>
<ul>
<li>BoundingBoxXYZ - 用于定义三维视图截面区域等情况的三维矩形框。</li>
<li>Transform - 变换仿射3D空间。</li>
<li>Reference -Revit模型中几何对象的稳定参照，在创建尺寸标注等图元时使用。</li>
<li>Plane - 几何中的平面。</li>
<li>Options - 用于分析几何图形的用户首选项。</li>
<li>XYZ - 表示3D空间中坐标的对象。</li>
<li>UV - 表示2D空间中坐标的对象。</li>
<li>BoundingBoxUV - 平行于坐标轴的2D矩形。</li>
</ul>
<h3 id="Transform"><a href="#Transform" class="headerlink" title="Transform"></a>Transform</h3><p>在Revit应用程序中，变换仅限于3x4变换（矩阵），即相对于模型空间的其余部分和其他对象变换对象在模型空间中的位置。变换是根据模型空间中的位置和方向构建的。三个方向矢量（BasisX、BasisY和BasisZ属性）和原点提供所有变换信息。由四个值形成的矩阵如下：</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-362AC8B3-CB53-4DB6-8606-5D90F2C8BFC4-low.png"></p>
<p>将变换应用于点如下：</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-5ABFA7C5-22F5-4A86-9878-CB0812834EB8-low.png"></p>
<p>Transform Of Point方法实现了前面的函数。</p>
<p>下面几节将介绍Geometry.Transform类的属性和方法。</p>
<h4 id="Identity"><a href="#Identity" class="headerlink" title="Identity"></a>Identity</h4><p>转换Identity </p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-4AD4178C-E897-44E0-93CD-AA8C1FD39AC4-low.png">CreateReflection()</p>
<p>反射指定的平面。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-DCA42587-9FD4-4AE3-95A8-1D45ED472D14-low.png">图112：墙反射关系</p>
<p>如上图所示，参照平面镜像了一面墙。CreateReflection（）方法需要参考平面的几何平面信息。</p>
<p>代码区域20-8：使用反射属性</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Transform <span class="title">Reflect</span>(<span class="params">ReferencePlane refPlane</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Transform mirTrans = Transform.CreateReflection(refPlane.GetPlane());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mirTrans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="CreateRotation-and-CreateRotationAtPoint"><a href="#CreateRotation-and-CreateRotationAtPoint" class="headerlink" title="CreateRotation() and CreateRotationAtPoint()"></a>CreateRotation() and CreateRotationAtPoint()</h4><p>围绕位于（0，0，0）或指定点的指定轴旋转指定角度。</p>
<h4 id="CreateTranslation"><a href="#CreateTranslation" class="headerlink" title="CreateTranslation()"></a>CreateTranslation()</h4><p>按指定的向量平移。给定一个矢量XYZ数据，如下创建一个变换：<img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-4E661E3C-0609-44C0-A7D5-52E993FEA94C-low.png"></p>
<h4 id="Determinant"><a href="#Determinant" class="headerlink" title="Determinant"></a>Determinant</h4><p>变换行列式</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-4570D0C0-0834-4A9E-AB7C-751F771AAE5B-low.png"></p>
<h4 id="HasReflection"><a href="#HasReflection" class="headerlink" title="HasReflection"></a>HasReflection</h4><p>这是一个布尔值，指示变换是否产生反射。</p>
<h4 id="Scale"><a href="#Scale" class="headerlink" title="Scale"></a>Scale</h4><p>表示变换比例的值。</p>
<h4 id="Inverse"><a href="#Inverse" class="headerlink" title="Inverse"></a>Inverse</h4><p>逆变换。如果存在变换矩阵B使得A<em>B &#x3D; B</em> A &#x3D; I（单位元），则变换矩阵A是可逆的。</p>
<h4 id="IsIdentity"><a href="#IsIdentity" class="headerlink" title="IsIdentity"></a>IsIdentity</h4><p>指示此转换是否为标识的布尔值。</p>
<h4 id="IsTranslation"><a href="#IsTranslation" class="headerlink" title="IsTranslation"></a>IsTranslation</h4><p>布尔值，指示此转变是否是转换。</p>
<h4 id="Multiply"><a href="#Multiply" class="headerlink" title="Multiply"></a>Multiply</h4><p>将转换乘以指定的变换并返回结果。</p>
<p>Operator*-将两个指定的转换相乘。</p>
<h4 id="ScaleBasis"><a href="#ScaleBasis" class="headerlink" title="ScaleBasis"></a>ScaleBasis</h4><p>缩放基向量并返回结果。</p>
<h4 id="ScaleBasisAndOrigin"><a href="#ScaleBasisAndOrigin" class="headerlink" title="ScaleBasisAndOrigin"></a>ScaleBasisAndOrigin</h4><p>缩放基向量，变换原点返回结果。</p>
<h4 id="OfPoint"><a href="#OfPoint" class="headerlink" title="OfPoint"></a>OfPoint</h4><p>将transformation到指定点。使用Origin属性。</p>
<h4 id="OfVector"><a href="#OfVector" class="headerlink" title="OfVector"></a>OfVector</h4><p>将transform转换为向量。不使用Origin属性。</p>
<h4 id="AlmostEqual"><a href="#AlmostEqual" class="headerlink" title="AlmostEqual"></a>AlmostEqual</h4><p>比较两个转换。AlmostEqual与Revit核心代码中的计算机制和精度一致。此外，在Transform类中没有实现Equal和&#x3D;&#x3D;运算符。</p>
<p>API提供了几种完成几何变换的快捷方式。几个几何体类中的Transformed属性用于执行此工作，如下表所示。</p>
<p>表48：Transformed 方法</p>
<table>
<thead>
<tr>
<th><strong>Class Name 类名</strong></th>
<th><strong>Function Description 功能描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Curve.get_Transformed(Transform transform)</td>
<td>将指定的变换转换为曲线</td>
</tr>
<tr>
<td>GeometryElement.GetTransformed(Transform transform)</td>
<td>转换原始元素中几何图形的副本。</td>
</tr>
<tr>
<td>Profile.get_Transformed(Transform transform)</td>
<td>转换轮廓并返回结果。</td>
</tr>
<tr>
<td>Mesh.get_Transformed(Transform transform) M</td>
<td>转换网格并返回结果。</td>
</tr>
</tbody></table>
<p>注意：transformed方法克隆自身，然后返回转换后的克隆结果。 除了这些方法之外，Instance类（它是族实例、链接实例和导入的CAD内容等图元的父类）还有两个方法，可以为给定的Instance提供变换。GetTransform（）方法根据实例的放置方式获得实例的基本变换，而GetTotalTransform（）方法提供使用真北变换修改的变换，例如导入实例。</p>
<p><strong>Reference</strong> </p>
<p>Reference 在元素创建中非常有用。 创建尺寸需要参照。 参考以灵活的方式标识几何表示树内的路径。 树用于查看特定的几何表达创建。API基于不同的Pick指针类型公开四种类型的引用。它们以不同的方式从API中检索：</p>
<ul>
<li>对于点-Curve.GetEndPointReference方法</li>
<li>对于曲线（直线、圆弧等）- Curve.Reference属性</li>
<li>对于面-face.Reference属性</li>
<li>对于剪切边-Edge.Reference property</li>
</ul>
<p>不能任意使用不同的参考类型。举例来说： NewLineBoundaryConditions（）方法需要Line的引用。 NewAreaBoundaryConditions（）方法需要面的引用。 NewPointBoundaryConditions（）方法需要Point的引用。 Reference. ConvertToStableRepresentation（）方法可用于将对几何体对象（例如面、边或曲线）的引用另存为字符串，然后在同一Revit任务中（甚至在存在同一文档的不同任务中）使用ParseFromStableRepresentation（）方法以字符串作为输入来获取相同的引用。</p>
<p> Options Geometry 通常从索引属性Element.Geometry中提取。梁、柱或支撑的原始几何图形在实例通过连接、剪切、复制、拉伸或其他后处理进行修改之前，可以使用FamilyInstance. GetOriginalGeometry（）方法提取。Element. Geometry和FamilyInstance. GetOriginalGeometry（）都接受必须提供的options 类。</p>
<p>options 类根据其属性自定义接收的输出类型： </p>
<ul>
<li>ComputeReferences -指示检索几何信息时是否计算几何参照。默认值为false，因此如果此属性未设置为true，则引用将不可访问。 </li>
<li>IncludeNonVisibleObjects -指示还返回在默认视图中不可见的几何对象。 </li>
<li><em>View</em> -从特定视图获取几何信息。请注意，如果指定了视图，则将使用此视图的详细程度来代替“DetailLevel”。 </li>
<li>DetailLevel -指示首选详细程度。默认值为“中”。</li>
</ul>
<p> ComputeReferences  如果将此属性设置为false，则API不计算几何参照。从几何体树检索的所有引用属性都不返回任何内容。有关引用的更多详细信息，请参阅“引用”部分。与FamilyInstance.GetOriginalGeometry（）一起使用时，此选项不能设置为true。 </p>
<p>IncludeNonVisibleObjects 大多数不可见几何图形是用户在编辑元素时看到的构造和条件几何图形（即，窗族实例的中心平面）。此属性的默认值为false。但是，某些条件可见几何图形表示真实对象（例如Revit中风管周围的隔热层），因此应将其提取。 </p>
<p>View 如果用户将“视图”特性设置为其他视图，则检索到的几何图形信息可能会有所不同。有关详细信息，请查看以下示例： 1. 在Revit中，在三维视图中绘制楼梯，然后在三维视图中选择“裁剪区域”、“裁剪区域可见”和“剖面框”属性。在“裁剪区域”中，修改三维视图中的剖面框以显示楼梯的一部分。如果使用API获取楼梯的几何图形信息，并将三维视图设置为Options.View属性，则只能检索楼梯几何图形的一部分。下图显示了Revit应用程序中的楼梯（左图）和使用API绘制的楼梯（右图）。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-F6123E3E-4B46-4502-915A-5FC399B34045-low.png"></p>
<p>图113：不同的剖面框显示不同的几何图形 </p>
<p>在Revit中绘制楼梯，然后绘制剖面，如左图所示。如果使用API获取此楼梯的信息，并将此剖面视图设置为Options.View属性，则只能检索楼梯几何图形的一部分。使用API绘制的楼梯如右图所示。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-1095389D-A7C6-4AB8-A6C6-FC8CC3C05EAB-low.png"></p>
<p>图114：检索几何剖面图 </p>
<p>DetailLevel API在Geometry.Options.DetailLevels中定义了三个枚举。这三个枚举对应于Revit应用程序中的三个详细程度，如下所示。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-81B8A84A-2F7B-4019-8CC8-4DA11B7A176A-low.png"></p>
<p>图115：三个细节层次</p>
<p>据DetailLevel特性中的不同设置检索不同的几何体信息。例如，在Revit应用程序中绘制梁，然后使用API从梁中获取几何图形进行绘制。以下图片显示了绘制结果：</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-B1C82974-A3D1-4893-9DF9-E9396C7D6352-low.png"></p>
<p>图116：梁的几何详图</p>
<p>BoundingBoxXYZ BoundingBoxXYZ定义了一个3D矩形框，它需要与任何坐标轴平行。与Instance类类似，BoundingBoxXYZ将数据存储在局部坐标空间中。它具有一个Transform属性，可将数据从框局部坐标空间转换到模型空间。换句话说，要获取模型空间中的长方体边界（与Revit中的长方体边界相同），请使用Transform属性变换每个数据成员。以下各节说明如何使用BoundingBoxXYZ。 #定义视图边界 BoundingBoxXYZ可用于通过View.CropBox属性定义视图边界。下图使用剖面视图显示了如何在Revit应用程序中使用BoundingBoxXYZ。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-C517106E-BC7F-4E89-90C4-7FFF1D6B3FD2-low.png"></p>
<p>图117：截面视图中的BoundingBoxXYZ </p>
<p>前面图片中的虚线显示了作为CropBox特性（BoundingBoxXYZ实例）显示的横断面图边界。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-22E284B3-C514-4EB4-B322-91454006173E-low.png"></p>
<p>图118：创建的截面视图 </p>
<p>上一张图片显示了相应的横断面图。视图边界外的墙将不显示。 </p>
<p>定义截面框 BoundingBoxXYZ还用于为从View3D.GetSectionBox（）方法检索的三维视图定义剖面框。在“特性”对话框中选择“剖面框”特性。剖面框如下图所示：</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-1EA1F70A-FFC5-4C58-9446-48E73E9C5606-low.png"></p>
<p>图119：三维视图剖面框#其他用途在元素的几何图形周围定义一个框。（Element.BoundingBox属性）。</p>
<p>以这种方式检索的BoundingBoxXYZ实例平行于坐标轴。在ViewSection. ViewDetail（）方法中使用。下表标识了此类的主要用途。表49：BoundingBoxXYZ属性</p>
<table>
<thead>
<tr>
<th>**Property Name **</th>
<th><strong>Usage 使用</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Max&#x2F;Min</td>
<td>最大&#x2F;最小坐标。这两个属性定义了一个平行于任何坐标轴的三维长方体。Transform属性提供了一个可以将长方体变换到适当位置的变换矩阵。</td>
</tr>
<tr>
<td>Transform</td>
<td>从长方体坐标空间转换到模型空间。</td>
</tr>
<tr>
<td>Enabled</td>
<td>指示是否打开边界框。</td>
</tr>
<tr>
<td>MaxEnabled&#x2F; MinEnabled</td>
<td>如果裁剪视图处于打开状态，<em><strong>MaxEnabled</strong></em>属性和<em><strong>MinEnabled</strong></em>属性都返回true。<img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-7050609C-8AAF-40C4-A9A8-F8920B6AD022-low.png" alt="img">如果裁剪视图处于关闭状态，<em><strong>MaxEnabled</strong></em>属性和<em><strong>MinEnabled</strong></em>属性都返回false。* 定义给定维度的最大&#x2F;最小界限是否处于活动状态。如果Enable属性为false，这两个属性也应该返回false。  此属性指示视图的裁剪框面是否可用于裁剪元素的视图。 <em>如果从View3D.GetSectionBox（)方法检索BoundingBoxXYZ，则返回值取决于是否在“三维视图属性”对话框中选择了“剖面框”属性。如果是，则所有Enabled属性都返回true。</em> 如果从Element.BoundingBox属性检索BoundingBoxXYZ，则所有Enabled属性都为true。</td>
</tr>
<tr>
<td>Bounds</td>
<td>Max&#x2F;Min属性的界限。</td>
</tr>
<tr>
<td>BoundEnabled</td>
<td>MaxEnabled&#x2F;MinEnabled属性的界限。</td>
</tr>
</tbody></table>
<p>下面的代码示例阐释如何旋转BoundingBoxXYZ以修改三维视图剖面框。</p>
<p>代码区域20-9：旋转BoundingBoxXYZ</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">RotateBoundingBox</span>(<span class="params">View3D view3d</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!view3d.IsSectionBoxActive)</span><br><span class="line">    &#123;</span><br><span class="line">        TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>,<span class="string">&quot;The section box for View3D isn&#x27;t active.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    BoundingBoxXYZ box = view3d.GetSectionBox();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create a rotation transform to apply to the section box </span></span><br><span class="line">    XYZ origin = <span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    XYZ axis = <span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Rotate 30 degrees</span></span><br><span class="line">    Transform rotate = Transform.CreateRotationAtPoint(axis, Math.PI/<span class="number">6.0</span>, origin);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Transform the View3D&#x27;s section box with the rotation transform</span></span><br><span class="line">    box.Transform = box.Transform.Multiply(rotate);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set the section box back to the view (requires an open transaction)</span></span><br><span class="line">    view3d.SetSectionBox(box);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="BoundingBoxUV"><a href="#BoundingBoxUV" class="headerlink" title="BoundingBoxUV"></a>BoundingBoxUV</h3><p>BoundingBoxUV是一个值类，它定义了一个平行于坐标轴的2D矩形。它支持最小和最大数据成员。它们一起定义BoundingBoxUV的边界。BoundingBoxUV从View.Outline属性中检索，该属性是图纸空间视图中的边界视图。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-3CDBA6D9-E139-482E-816C-640D56DE5E63-low.png"></p>
<p>图120：视图轮廓</p>
<p>两个点定义BoundingBoxUV。</p>
<ul>
<li><p>Min point - 左下角端点。</p>
</li>
<li><p>Max point - 右上端点。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-71827A01-D568-4770-9457-A279F252DBFD-low.png"></p>
</li>
</ul>
<p>图121：BoundingBoxUV最大值和最小值</p>
<p>注意：BoundingBoxUV不能像下图那样呈现倾斜矩形</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-1A52815E-11F5-4305-B68E-B0A63A06718D-low.png"></p>
<p>图122：倾斜矩形</p>
<h2 id="集合类"><a href="#集合类" class="headerlink" title="集合类"></a>集合类</h2><p>Revit API中的专用几何图形集合类。</p>
<p>API根据集合类包含的项提供以下集合类：</p>
<p>表50：几何集合类</p>
<table>
<thead>
<tr>
<th>**Class&#x2F;Type **</th>
<th>对应的集合类**</th>
<th>对应的迭代器**</th>
</tr>
</thead>
<tbody><tr>
<td>Edge</td>
<td>EdgeArray, EdgeArrayArray</td>
<td>EdgeArrayIterator, EdgeArrayArrayIterator</td>
</tr>
<tr>
<td>Face</td>
<td>FaceArray</td>
<td>FaceArrayIterator</td>
</tr>
<tr>
<td>Reference</td>
<td>ReferenceArray</td>
<td>ReferenceArrayIterator</td>
</tr>
<tr>
<td>Double value</td>
<td>DoubleArray</td>
<td>DoubleArrayIterator</td>
</tr>
</tbody></table>
<p>所有这些类都使用非常相似的方法和属性来完成类似的工作。有关更多详细信息，请参阅集合。</p>
<h2 id="示例：从梁中检索几何图形数据"><a href="#示例：从梁中检索几何图形数据" class="headerlink" title="示例：从梁中检索几何图形数据"></a>示例：从梁中检索几何图形数据</h2><p>本节说明如何从梁获取实体和曲线。可以以类似的方式检索柱和支撑几何数据。GeometryElement可以包含所需的几何体作为Solid或GeometryInstance，具体取决于梁是连接的还是独立的，本代码涵盖了这两种情况。</p>
<p>注意：如果要获取梁和支撑驱动曲线，请调用LocationCurve可用的FamilyInstance Location属性。</p>
<p>示例代码如下所示：</p>
<p>代码区域20-10：从梁获取实体和曲线</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetCurvesFromABeam</span>(<span class="params">Autodesk.Revit.DB.FamilyInstance beam,</span></span></span><br><span class="line"><span class="params"><span class="function">                                Autodesk.Revit.DB.Options options</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Autodesk.Revit.DB.GeometryElement geomElem = beam.get_Geometry(options);</span><br><span class="line"></span><br><span class="line">    Autodesk.Revit.DB.CurveArray curves = <span class="keyword">new</span> CurveArray();</span><br><span class="line">    System.Collections.Generic.List&lt;Autodesk.Revit.DB.Solid&gt; solids = <span class="keyword">new</span> System.Collections.Generic.List&lt;Autodesk.Revit.DB.Solid&gt;(); </span><br><span class="line"></span><br><span class="line">    <span class="comment">//Find all solids and insert them into solid array</span></span><br><span class="line">    AddCurvesAndSolids(geomElem, <span class="keyword">ref</span> curves, <span class="keyword">ref</span> solids);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">AddCurvesAndSolids</span>(<span class="params">Autodesk.Revit.DB.GeometryElement geomElem,</span></span></span><br><span class="line"><span class="params"><span class="function">                                <span class="keyword">ref</span> Autodesk.Revit.DB.CurveArray curves,</span></span></span><br><span class="line"><span class="params"><span class="function">                                <span class="keyword">ref</span> System.Collections.Generic.List&lt;Autodesk.Revit.DB.Solid&gt; solids</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">foreach</span> (Autodesk.Revit.DB.GeometryObject geomObj <span class="keyword">in</span> geomElem)</span><br><span class="line">    &#123;</span><br><span class="line">        Autodesk.Revit.DB.Curve curve = geomObj <span class="keyword">as</span> Autodesk.Revit.DB.Curve;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != curve)</span><br><span class="line">        &#123;</span><br><span class="line">            curves.Append(curve);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Autodesk.Revit.DB.Solid solid = geomObj <span class="keyword">as</span> Autodesk.Revit.DB.Solid;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != solid)</span><br><span class="line">        &#123;</span><br><span class="line">            solids.Add(solid);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//If this GeometryObject is Instance, call AddCurvesAndSolids</span></span><br><span class="line">        Autodesk.Revit.DB.GeometryInstance geomInst = geomObj <span class="keyword">as</span> Autodesk.Revit.DB.GeometryInstance;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != geomInst)</span><br><span class="line">        &#123;</span><br><span class="line">            Autodesk.Revit.DB.GeometryElement transformedGeomElem</span><br><span class="line">                = geomInst.GetInstanceGeometry(geomInst.Transform);</span><br><span class="line">            AddCurvesAndSolids(transformedGeomElem, <span class="keyword">ref</span> curves, <span class="keyword">ref</span> solids);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的示例使用FamilyInstance.Geometry属性访问梁的真实几何图形。若要在通过连接、剪切、复制、拉伸或其他后期处理修改族实例之前获取其原始几何图形，请使用FamilyInstance.GetOriginalGeometry（）方法。</p>
<p>注意：有关如何检索Geometry.Options类型对象的详细信息，请参阅Geometry Helper Classes。</p>
<h2 id="实体的拉伸分析"><a href="#实体的拉伸分析" class="headerlink" title="实体的拉伸分析"></a>实体的拉伸分析</h2><p>实用程序类ExtrusionAnalyzer允许您尝试将给定的几何图形“拟合”到拉伸轮廓的形状中。这个类的实例是一次性使用类，应该提供一个立体几何、一个平面和一个方向。初始化ExtrusionAnalyzer后，可以通过以下成员访问结果：</p>
<ul>
<li>GetExtrusionBase（）方法返回与输入平面对齐的拉伸实体的计算基础轮廓。</li>
<li>CalculateFaceAlignment（）方法可用于标识原始几何体中与计算拉伸的面对齐或不对齐的所有面。例如，这对于确定墙的顶部是否有倾斜连接（如果与屋顶有连接，则会出现这种情况）非常有用。如果某个面未对齐，则会将某些内容连接到影响该面的几何体。</li>
<li>若要确定生成非对齐面的元素，请将面传递给Element.GetGeneratingElementIds（）。有关此实用程序的更多详细信息，请参阅以下部分。</li>
</ul>
<p>ExtrusionAnalyzer实用程序最适用于至少有点“类似于拉伸”的几何体，例如，可能会或可能不会受到端点连接、楼板连接、屋顶连接、由门窗切割的洞口或其他修改影响的墙几何体。对于特定的形状和方向组合，分析器可能很少无法确定作为挤出基础的连贯面-在这些情况下将引发InvalidOperationException。</p>
<p>在此示例中，拉伸分析器用于计算并绘制由输入实体和太阳方向形成的阴影的轮廓。</p>
<p>代码区域：使用拉伸分析器计算并绘制阴影轮廓。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> </span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> Draw the shadow of the indicated solid with the sun direction specified.</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> </span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> The shadow will be outlined with model curves added to the document.</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> A transaction must be open in the document.</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> The document.</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> The target solid.</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> The target level where to measure and draw the shadow.</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> The direction from the sun (or light source).</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> The curves created for the shadow.</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> Thrown by ExtrusionAnalyzer when the geometry and </span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> direction combined do not permit a successful analysis.</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ICollection <span class="title">DrawShadow</span>(<span class="params">Document document, Solid solid, Level targetLevel, XYZ sunDirection</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Create target plane from level.    Plane plane = Plane.CreateByNormalAndOrigin(XYZ.BasisZ, new XYZ(0, 0, targetLevel.ProjectElevation));</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create extrusion analyzer.</span></span><br><span class="line">    ExtrusionAnalyzer analyzer = ExtrusionAnalyzer.Create(solid, plane, sunDirection);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get the resulting face at the base of the calculated extrusion.</span></span><br><span class="line">    Face result = analyzer.GetExtrusionBase();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Convert edges of the face to curves.</span></span><br><span class="line">    CurveArray curves = document.Application.Create.NewCurveArray();</span><br><span class="line">    <span class="keyword">foreach</span> (EdgeArray edgeLoop <span class="keyword">in</span> result.EdgeLoops)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">foreach</span> (Edge edge <span class="keyword">in</span> edgeLoop)</span><br><span class="line">        &#123;</span><br><span class="line">            curves.Append(edge.AsCurve());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get the model curve factory object.</span></span><br><span class="line">    Autodesk.Revit.Creation.ItemFactoryBase itemFactory;</span><br><span class="line">    <span class="keyword">if</span> (document.IsFamilyDocument)</span><br><span class="line">        itemFactory = document.FamilyCreate;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        itemFactory = document.Create;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add a sketch plane for the curves.    CurveLoop loop = new CurveLoop();</span></span><br><span class="line">    <span class="keyword">foreach</span> (Curve currentCurve <span class="keyword">in</span> curves)</span><br><span class="line">    &#123;</span><br><span class="line">        loop.Append(currentCurve);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SketchPlane sketchPlane = SketchPlane.Create(document, loop.GetPlane());</span><br><span class="line">    document.Regenerate();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add the shadow curves</span></span><br><span class="line">    ModelCurveArray curveElements = itemFactory.NewModelCurveArray(curves, sketchPlane);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Return the ids of the curves created</span></span><br><span class="line">    List curveElementIds = <span class="keyword">new</span> List();</span><br><span class="line">    <span class="keyword">foreach</span> (ModelCurve curveElement <span class="keyword">in</span> curveElements)</span><br><span class="line">    &#123;</span><br><span class="line">        curveElementIds.Add(curveElement.Id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> curveElementIds;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的实用程序可用于计算给定质量相对于视图当前日光和阴影设置的阴影：</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/shadowcalculator.png"></p>
<h2 id="通过光线投影查找几何图形"><a href="#通过光线投影查找几何图形" class="headerlink" title="通过光线投影查找几何图形"></a>通过光线投影查找几何图形</h2><p>ReferenceIntersector类可用于查找与给定射线相交的元素。</p>
<p><strong>ReferenceIntersector</strong> </p>
<p>此类允许应用程序使用Revit的拾取工具来查找图元和几何图形。这个类使用从指定方向的点发出的射线来查找射线击中的几何体。</p>
<p>该类仅与3D几何体相交，并且在创建时需要3D视图。可以使用已被剖面框剪切的三维视图，或设置了视图专有几何图元和图形选项的三维视图。输入视图上的可见性设置将确定是否返回特定图元（例如，此工具永远不会返回隐藏图元，几何图形位于视图剖面框之外的图元也不会返回）。</p>
<p>ReferenceIntersector类支持基于元素或引用类型过滤输出。输出可以根据使用的构造函数进行自定义，或者在调用方法执行光线投影之前使用类的方法和属性进行自定义。</p>
<p>有4个构造函数。</p>
<table>
<thead>
<tr>
<th><strong>Name 名称</strong></th>
<th><strong>Description 描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>ReferenceIntersector(View3D)</td>
<td>构造一个ReferenceIntersector，它被设置为返回所有元素的交集，并表示所有引用目标类型。</td>
</tr>
<tr>
<td>ReferenceIntersector(ElementFilter, FindReferenceTarget, View3D)</td>
<td>构造一个ReferenceIntersector，将其设置为返回通过过滤器的任何元素的交集。</td>
</tr>
<tr>
<td>ReferenceIntersector(ElementId, FindReferenceTarget, View3D)</td>
<td>构造一个ReferenceIntersector，它被设置为仅返回来自单个目标元素的交集。</td>
</tr>
<tr>
<td>ReferenceIntersector(ICollection, FindReferenceTarget, View3D)</td>
<td>构造一个ReferenceIntersector，它被设置为返回一组目标元素中任何一个的交集。</td>
</tr>
</tbody></table>
<p>FindReferenceTarget枚举包括以下选项：元素、网格、边、曲线、面或全部。 </p>
<p>查找元素 </p>
<p>有两种方法可以投影光线，这两种方法都将光线的原点及其方向作为输入。仅返回光线前面的元素的引用。Find（）方法返回与ReferenceIntersector的条件匹配的ReferenceWithContext对象的集合。该对象包含光线参照，它可以是与光线相交的元素和几何参照。返回的某些图元参照将具有一个相应的几何对象，该对象也是矩形的（例如，穿过墙中洞口的光线将与墙和洞口图元相交）。如果只对真正的物理交点感兴趣，则应用程序应丢弃其Reference类型为Element的所有引用。 FindNearest（）方法的行为与Find（）方法类似，但仅返回距离光线原点最近的对象引用。 返回的ReferenceWithContext包含一个接近度参数。这是光线原点与交点之间的距离。应用程序可以使用此距离来排除距离原点太远的项目，以进行特定的几何分析。应用程序还可以使用此距离来处理一些有趣的问题，包括分析模型的几何图形。</p>
<p>注意：这些方法不会返回与不在激活设计选项中的图元的交点。</p>
<p>链接文件中的元素</p>
<p> FindReferencesInRevitLinks属性提供了一个选项，用于返回在Revit链接中遇到的图元结果。如果设置为false，ReferenceIntersector将找不到对Revit链接中任何图元的参照，并且返回的所有参照将仅指向主体文档中的图元。如果设置为true，则结果可能包括对主体中元素的引用和对链接实例中元素的引用。 如果在ReferenceIntersector中设置了目标ElementId的列表，则仅当ElementId与ReferenceRevitLinkInstance的ID匹配时，才会返回引用。如果有匹配，链接中的任何相交元素都将被返回（它们的id将不会与目标id列表进行比较）。 如果应用了ElementFilter，则将根据存储的ElementFilter计算链接中的元素。请注意，如果应用的过滤器是几何过滤器（如BoundingBox过滤器或ElementIntersects过滤器），则结果可能与预期不同。这是因为将针对链接模型坐标中的链接图元计算过滤器，而链接模型坐标可能与图元在主体模型中显示的坐标不匹配。此外，在实例化期间接受Document和&#x2F;或ElementId作为输入的ElementFilters将无法正确传递链接中出现的元素，因为过滤器将无法将链接元素与过滤器的标准相匹配。 ###查找元素附近的元素 此工具的一个主要用途是查找与其他元素非常接近的元素。这允许应用程序将该工具用作其“眼睛”，并确定尚未具有内置关系的元素之间的关系。 例如，光线跟踪功能可用于查找嵌入墙中的柱。由于柱和墙不直接保持关系，因此此类允许我们通过跟踪墙范围外的光线并查找与柱的交点来查找潜在的候选对象。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/find_refs_1.png"></p>
<p>示例：查找嵌入墙中的柱</p>
<p><strong>测量距离</strong> </p>
<p>这个类也可以用来测量从天窗到最近楼层的垂直距离。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/DistanceToFloor.jpg"></p>
<p>示例：使用ReferenceIntersector.FindNearest（）进行测量</p>
<p>代码区域：使用光线投影测量距离</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">RayProjection</span> : <span class="title">IExternalCommand</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">Execute</span>(<span class="params">ExternalCommandData revit, <span class="keyword">ref</span> <span class="built_in">string</span> message, ElementSet elements</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Document doc = revit.Application.ActiveUIDocument.Document;</span><br><span class="line"></span><br><span class="line">        ICollection selectedIds = revit.Application.ActiveUIDocument.Selection.GetElementIds();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If skylight is selected, process it.</span></span><br><span class="line">        FamilyInstance skylight = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (selectedIds.Count == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">foreach</span> (ElementId id <span class="keyword">in</span> selectedIds)</span><br><span class="line">            &#123;</span><br><span class="line">                Element e = doc.GetElement(id);</span><br><span class="line">                <span class="keyword">if</span> (e <span class="keyword">is</span> FamilyInstance)</span><br><span class="line">                &#123;</span><br><span class="line">                    FamilyInstance instance = e <span class="keyword">as</span> FamilyInstance;</span><br><span class="line">                    <span class="built_in">bool</span> isWindow = (instance.Category.Id.IntegerValue == (<span class="built_in">int</span>)BuiltInCategory.OST_Windows);</span><br><span class="line">                    <span class="built_in">bool</span> isHostedByRoof = (instance.Host.Category.Id.IntegerValue == (<span class="built_in">int</span>)BuiltInCategory.OST_Roofs);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (isWindow &amp;&amp; isHostedByRoof)</span><br><span class="line">                    &#123;</span><br><span class="line">                        skylight = instance;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (skylight == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            message = <span class="string">&quot;Please select one skylight.&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span> Result.Cancelled;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Calculate the height</span></span><br><span class="line">        Line line = CalculateLineAboveFloor(doc, skylight);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create a model curve to show the distance</span></span><br><span class="line">        Plane plane = Plane.CreateByNormalAndOrigin(<span class="keyword">new</span> XYZ(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>), line.GetEndPoint(<span class="number">0</span>));</span><br><span class="line">        SketchPlane sketchPlane = SketchPlane.Create(doc, plane);</span><br><span class="line"></span><br><span class="line">        ModelCurve curve = doc.Create.NewModelCurve(line, sketchPlane);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Show a message with the length value</span></span><br><span class="line">        TaskDialog.Show(<span class="string">&quot;Distance&quot;</span>, <span class="string">&quot;Distance to floor: &quot;</span> + String.Format(<span class="string">&quot;&#123;0:f2&#125;&quot;</span>, line.Length));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Result.Succeeded;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> </span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> Determines the line segment that connects the skylight to the nearest floor.</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> </span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> The line segment.</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Line <span class="title">CalculateLineAboveFloor</span>(<span class="params">Document doc, FamilyInstance skylight</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Find a 3D view to use for the ReferenceIntersector constructor</span></span><br><span class="line">        FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(doc);</span><br><span class="line">        Func&lt;View3D, <span class="built_in">bool</span>&gt; isNotTemplate = v3 =&gt; !(v3.IsTemplate);</span><br><span class="line">        View3D view3D = collector.OfClass(<span class="keyword">typeof</span>(View3D)).Cast().First(isNotTemplate);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Use the center of the skylight bounding box as the start point.</span></span><br><span class="line">        BoundingBoxXYZ box = skylight.get_BoundingBox(view3D);</span><br><span class="line">        XYZ center = box.Min.Add(box.Max).Multiply(<span class="number">0.5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Project in the negative Z direction down to the floor.</span></span><br><span class="line">        XYZ rayDirection = <span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">        ElementClassFilter filter = <span class="keyword">new</span> ElementClassFilter(<span class="keyword">typeof</span>(Floor));</span><br><span class="line"></span><br><span class="line">        ReferenceIntersector refIntersector = <span class="keyword">new</span> ReferenceIntersector(filter, FindReferenceTarget.Face, view3D);</span><br><span class="line">        ReferenceWithContext referenceWithContext = refIntersector.FindNearest(center, rayDirection);</span><br><span class="line"></span><br><span class="line">        Reference reference = referenceWithContext.GetReference();</span><br><span class="line">        XYZ intersection = reference.GlobalPoint;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create line segment from the start point and intersection point.</span></span><br><span class="line">        Line result = Line.CreateBound(center, intersection);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>射线反弹&#x2F;分析</strong></p>
<p>ReferenceIntersector.Find（）返回的参照包括几何上的交点。知道了面上的交点、面的材质和光线方向，应用程序就可以分析建筑物内的反射和折射。下图演示了如何使用交点来反射由模型图元遮挡的光线;添加了模型曲线来表示每条光线的路径。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/find_refs_3.png"></p>
<p>示例：从曲面反弹的射线</p>
<p><strong>查找交点&#x2F;碰撞</strong></p>
<p>ReferenceIntersector类的另一个用途是检测与给定梁或管道的中心线相交&#x2F;干涉的交点（如梁或管道）。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/find_refs_4.png"></p>
<p>示例：在干涉周围重新布线元素</p>
<h2 id="几何工具类"><a href="#几何工具类" class="headerlink" title="几何工具类"></a>几何工具类</h2><p>有许多工具类可用于处理几何体对象。</p>
<p><strong>HostObjectUtils</strong></p>
<p>HostObjectUtils类提供方法作为定位复合HostObjects的某些面的快捷方式。这些实用程序检索用作对象的CompoundStructure的边界的面：</p>
<ul>
<li>HostObjectUtils.GetSideFaces() – 适用于墙壁和FaceWalls;您可以获得外部或内部饰面。</li>
<li>HostObjectUtils.GetTopFaces() and HostObjectUtils.GetBottomFaces() – 适用于屋顶、楼板和天花板。</li>
</ul>
<p><strong>SolidUtils</strong></p>
<p>SolidUtils类包含对实体执行操作的方法。</p>
<ul>
<li>SolidUtils.Clone() - 创建一个新的Solid，它是输入Solid的副本</li>
<li>SolidUtils.SplitVolumes() - 使用一个包含不相交的封闭体积的实体，并返回新创建的代表每个体积的实体对象。如果不需要分割，则返回输入实体。</li>
<li>SolidUtils.TessellateSolidOrShell() - 对给定的输入实体（可以是一个或多个完全闭合的体积，也可以是一个开放的壳）进行三角测量。返回一个TriangulatedSolidOrShell对象，该对象允许访问存储的实体的三角化边界组件或壳的三角化连接组件。</li>
<li>SolidUtils.CreateTransformed() - 创建一个新的实体，它是输入实体的变换。</li>
</ul>
<p><strong>JoinGeometryUtils</strong></p>
<p>JoinGeometryUtils类包含用于连接和取消连接元素以及管理元素连接顺序的方法。这些实用程序不适用于族文档。</p>
<ul>
<li>JoinGeometryUtils.AreElementsJoined() - 确定是否连接两个元素</li>
<li>JoinGeometryUtils.GetJoinedElements() - 返回连接到给定元素的所有元素</li>
<li>JoinGeometryUtils.JoinGeometry() - 在共享公共面的两个元素之间创建连接。将删除连接图元之间的可见边。然后，连接的元素共享相同的线宽和填充图案。</li>
<li>JoinGeometryUtils.UnjoinGeometry() - 删除两个连接元素之间的连接</li>
<li>JoinGeometryUtils.SwitchJoinOrder() - 反转两个元素连接的顺序。切割元件变成被切割元件，反之亦然。</li>
<li>JoinGeometryUtils . IsCuttingElementInJoin() - 确定两个连接的元素中的第一个元素是否剪切第二个元素，反之亦然。</li>
</ul>
<p><strong>FacetingUtils</strong></p>
<p>此类用于将三角形结构转换为其中某些三角形已合并为四边形的结构。</p>
<ul>
<li>FacetingUtils.ConvertTrianglesToQuads() - 此方法以TriangulationInterface（从TriangulatedSolidOrShell构造）作为输入，并返回表示原始三角化对象的三角形和四边形的集合。</li>
</ul>
<h2 id="房间和空间几何"><a href="#房间和空间几何" class="headerlink" title="房间和空间几何"></a>房间和空间几何</h2><p>通过Revit API可以访问空间图元（房间和空间）的三维几何图形。</p>
<p>SpatialElementGeometryCalculator类可用于计算空间元素的几何形状并获取几何形状与元素边界元素之间的关系。可以为此实用程序提供2个选项：</p>
<ul>
<li>SpatialElementBoundaryLocation – 是否使用详细面或边界元素中心线进行计算</li>
<li>StoredFreeBoundaryFaces – 是否在结果中包括不直接映射到边界元素的面。</li>
</ul>
<p>计算几何体的结果包含在SpatialElementGeometryResults类中。从SpatialElementGeometryResults类中，可以获得：</p>
<ul>
<li>表示几何的实体体积（GetGeometry（）方法）</li>
<li>边界面信息（一个集合SpatialElementBoundarySubfaces）</li>
</ul>
<p>每个子面提供：</p>
<ul>
<li>空间元素的表面</li>
<li>边界元素的匹配面</li>
<li>子面（由该特定边界元素限定的空间元素面部分）</li>
<li>底面类型（底部、顶部或侧面）</li>
</ul>
<p>关于使用此实用程序的一些注意事项：</p>
<ul>
<li>计算器为已处理的几何体维护一个内部缓存。如果要计算同一项目中多个图元的几何图形，则应使用此类的单个实例。请注意，当对文档进行任何更改时，将清除该高速缓存。</li>
<li>楼板几乎从不作为边界元素包含在内。Revit使用房间的二维轮廓来形成底面，而不将其与楼板几何图形相匹配。</li>
<li>由墙剪切特征（例如门和窗）创建的洞口不包括在返回的面中。</li>
<li>几何图形计算与Revit提供的功能相匹配。在某些情况下，如果Revit假设如何计算房间和空间边界的体积，则这些假设将显示在实用程序的输出中。</li>
</ul>
<p>以下示例计算房间的几何图形并查找其边界面</p>
<p>代码区域：使用SpatialElementGeometryCalculator的面部区域</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SpatialElementGeometryCalculator calculator = new SpatialElementGeometryCalculator(doc);</span><br><span class="line"></span><br><span class="line"><span class="comment">// compute the room geometry</span></span><br><span class="line">SpatialElementGeometryResults results = calculator.CalculateSpatialElementGeometry(room);</span><br><span class="line"></span><br><span class="line"><span class="comment">// get the solid representing the room&#x27;s geometry</span></span><br><span class="line">Solid roomSolid = results.GetGeometry(); </span><br><span class="line"></span><br><span class="line">foreach (Face face in roomSolid.Faces)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">double</span> faceArea = face.Area;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get the sub-faces for the face of the room</span></span><br><span class="line">    IList subfaceList = results.GetBoundaryFaceInfo(face);</span><br><span class="line">    foreach (SpatialElementBoundarySubface subface in subfaceList)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (subfaceList.Count &gt; <span class="number">1</span>) <span class="comment">// there are multiple sub-faces that define the face</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// get the area of each sub-face</span></span><br><span class="line">            <span class="type">double</span> subfaceArea = subface.GetSubface().Area;</span><br><span class="line">            <span class="comment">// sub-faces exist in situations such as when a room-bounding wall has been</span></span><br><span class="line">            <span class="comment">// horizontally split and the faces of each split wall combine to create the </span></span><br><span class="line">            <span class="comment">// entire face of the room</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面的示例计算房间的几何图形，并查找属于定义房间的图元的面的材质。</p>
<p>代码区域：使用SpatialElementGeometryCalculator的面材质</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">MaterialFromFace</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="built_in">string</span> s = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    Document doc = <span class="keyword">this</span>.Document;</span><br><span class="line">        UIDocument uidoc = <span class="keyword">new</span> UIDocument(doc);</span><br><span class="line">        Room room = doc.GetElement(uidoc.Selection.PickObject(ObjectType.Element).ElementId) <span class="keyword">as</span> Room;</span><br><span class="line"></span><br><span class="line">        SpatialElementBoundaryOptions  spatialElementBoundaryOptions = <span class="keyword">new</span> SpatialElementBoundaryOptions();</span><br><span class="line">        spatialElementBoundaryOptions.SpatialElementBoundaryLocation = SpatialElementBoundaryLocation.Finish;</span><br><span class="line">        SpatialElementGeometryCalculator calculator = <span class="keyword">new</span> SpatialElementGeometryCalculator(doc, spatialElementBoundaryOptions);</span><br><span class="line">        SpatialElementGeometryResults results = calculator.CalculateSpatialElementGeometry(room);</span><br><span class="line">        Solid roomSolid = results.GetGeometry(); </span><br><span class="line"></span><br><span class="line">        <span class="keyword">foreach</span> (Face roomSolidFace <span class="keyword">in</span> roomSolid.Faces)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">foreach</span> (SpatialElementBoundarySubface subface <span class="keyword">in</span> results.GetBoundaryFaceInfo(roomSolidFace))</span><br><span class="line">            &#123;</span><br><span class="line">                Face boundingElementface = subface.GetBoundingElementFace();</span><br><span class="line">                ElementId id = boundingElementface.MaterialElementId;</span><br><span class="line">                s +=  doc.GetElement(id).Name + <span class="string">&quot;, id = &quot;</span> + id.IntegerValue.ToString() + <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    TaskDialog.Show(<span class="string">&quot;revit&quot;</span>,s);&#125;</span><br></pre></td></tr></table></figure>

<h2 id="注：翻译自Revit-API-Developers-Guide"><a href="#注：翻译自Revit-API-Developers-Guide" class="headerlink" title="注：翻译自Revit API Developers Guide"></a><em><strong>注：</strong></em>翻译自<a href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_html">Revit API Developers Guide</a></h2>]]></content>
      <categories>
        <category>Revit二次开发人员指南</category>
      </categories>
      <tags>
        <tag>Revit</tag>
      </tags>
  </entry>
  <entry>
    <title>23DirectShape</title>
    <url>/2024/12/24/Revit%E4%BA%8C%E5%BC%80%E6%8C%87%E5%8D%97/23DirectShape/</url>
    <content><![CDATA[<h1 id="DirectShape"><a href="#DirectShape" class="headerlink" title="DirectShape"></a>DirectShape</h1><p>此图元类型可以在项目或族文档中存储通过导入操作或计算获得的任意几何图形。</p>
<p>DirectShape元素和相关类支持在Revit文档中存储外部创建的几何形状的功能。几何体可以包括闭合实体或网格。DirectShape主要用于从其他数据格式（如IFC或STEP）导入形状，在这些格式中，没有足够的信息来创建“真实的”Revit图元。</p>
<p>可以为DirectShape对象指定顶级模型类别，例如墙类别。子类别不能指定给DirectShape元素。IsValidCategoryId（）方法可以测试类别ID，以确保它是批准与DirectShape和Category一起使用的顶级内置类别。如果类别类型为Model，则会指示CategoryType枚举值。类别将影响该对象在Revit中的显示方式，并将为该对象授予可用参数的集合和某些有限的行为。</p>
<p><strong>DirectShape创建</strong></p>
<p>静态DirectElement（）方法将创建一个新的实例级DirectShape。它需要将DirectShape添加到其中的文档以及适当的内置类别的ID。DirectShape提供ApplicationId和ApplicationDataId字符串参数，这些参数为创建的形状的源提供上下文。</p>
<p>创建DirectShape后，可以使用重载的SetShape（）方法之一来设置该形状。该形状可以直接从ShapeBuilder对象或从GeometryObject列表中设置。如果您无论如何都要使用ShapeBuilder对象为DirectShape构造几何图形，则使用ShapeBuilder输入可能会有轻微的性能优势，因为Revit将绕过对输入几何图形的重复验证。还可以使用不同版本的DirectShape（）方法将其他几何体对象附加到DirectShape。请注意，BulldShape（）不会将传入的几何体与任何已经存在的几何体合并或连接，几何体将独立存储。</p>
<p>DirectMap接受以下几何体类型作为输入：</p>
<ul>
<li>实体（可以是封闭或开放的外壳）</li>
<li>网格</li>
<li>曲线</li>
<li>点</li>
</ul>
<p>此外，还可以指定要在DirectShape的视图特定表示中使用的几何体。该几何图形与DirectShapeTargetViewType的输入一起沿着输入。设置视图专有的形状表达时，它将仅用于该类型的视图中。目前，唯一受支持的视图专有表达用于平面视图。</p>
<p>面的示例演示如何从使用GeometryCreationUtilities类创建的球体创建简单的DirectShape。请注意在创建几何体时使用了参考框架。在使用Frame对象创建几何图形之前，最好先调用静态方法Frame.CanDefineRevitGeometry（），该方法测试提供的Frame对象是否可用于定义Revit曲线或曲面。为了满足要求，框架必须正交，并且其原点应位于Revit设计限制范围内。(When创建几何体时，使用静态XYZ也很有用。IsWithinLengthLimits（），以确保该点在Revit设计限制范围内。）</p>
<p>代码区域：创建DirectShape</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Create a DirectShape Sphere</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">CreateSphereDirectShape</span>(<span class="params">Document doc</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    List&lt;Curve&gt; profile = <span class="keyword">new</span> List&lt;Curve&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// first create sphere with 2&#x27; radius</span></span><br><span class="line">    XYZ center = XYZ.Zero;</span><br><span class="line">    <span class="built_in">double</span> radius = <span class="number">2.0</span>;    </span><br><span class="line">    XYZ profile00 = center;</span><br><span class="line">    XYZ profilePlus = center + <span class="keyword">new</span> XYZ(<span class="number">0</span>, radius, <span class="number">0</span>);</span><br><span class="line">    XYZ profileMinus = center - <span class="keyword">new</span> XYZ(<span class="number">0</span>, radius, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    profile.Add(Line.CreateBound(profilePlus, profileMinus));</span><br><span class="line">    profile.Add(Arc.Create(profileMinus, profilePlus, center + <span class="keyword">new</span> XYZ(radius, <span class="number">0</span>, <span class="number">0</span>)));</span><br><span class="line"></span><br><span class="line">    CurveLoop curveLoop = CurveLoop.Create(profile);</span><br><span class="line">    SolidOptions options = <span class="keyword">new</span> SolidOptions(ElementId.InvalidElementId, ElementId.InvalidElementId);</span><br><span class="line"></span><br><span class="line">    Frame frame = <span class="keyword">new</span> Frame(center, XYZ.BasisX, -XYZ.BasisZ, XYZ.BasisY);</span><br><span class="line">    <span class="keyword">if</span> (Frame.CanDefineRevitGeometry(frame) == <span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Solid sphere = GeometryCreationUtilities.CreateRevolvedGeometry(frame, <span class="keyword">new</span> CurveLoop[] &#123; curveLoop &#125;, <span class="number">0</span>, <span class="number">2</span> * Math.PI, options);</span><br><span class="line">        <span class="keyword">using</span> (Transaction t = <span class="keyword">new</span> Transaction(doc, <span class="string">&quot;Create sphere direct shape&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            t.Start();</span><br><span class="line">            <span class="comment">// create direct shape and assign the sphere shape</span></span><br><span class="line">            DirectShape ds = DirectShape.CreateElement(doc, <span class="keyword">new</span> ElementId(BuiltInCategory.OST_GenericModel));</span><br><span class="line"></span><br><span class="line">            ds.ApplicationId = <span class="string">&quot;Application id&quot;</span>;</span><br><span class="line">            ds.ApplicationDataId = <span class="string">&quot;Geometry object id&quot;</span>;</span><br><span class="line">            ds.SetShape(<span class="keyword">new</span> GeometryObject[] &#123; sphere &#125;);</span><br><span class="line">            t.Commit();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DirectShape的几何体也可以使用ShapeBuilder类的子类或从TessellatedShapeBuilder创建。</p>
<p><strong>ShapeBuilder</strong></p>
<p>ViewShapeBuilder和WireframeBuilder可用于创建几何体以存储在DirectShape类中。ViewShapeBuilder类生成并验证视图特定的形状表示。它仅限于平面视图的基于曲线的表达。WireframeBuilder构造由点和曲线组成的3D形状表示。这两种类型的ShapeBuilder都可以通过使用带ShapeBuilder参数的DirectShape.SetShape（）或DirectShape.SetShadShape（）重载应用于DirectShape元素。</p>
<p><strong>TessellatedShapeBuilder</strong></p>
<p>TessellatedShapeBuilder可用于创建实体、壳或多边形网格，这些网格由一组连接的平面小平面包围，通过逐个添加TessellatedFace对象创建。只有在面集处于“open”状态时，才能将面添加到构建中。使用OpenConnectedFaceSet（）方法打开面集。添加所有TessellatedFaces后，调用CloseConnectedFaceSet（）关闭面集。构建器允许多个面集的可能性-在这种情况下，第一个面集应该代表物体的外部“表面”，所有后续面集代表内部空隙。尽管输入数据中存在不一致或遗漏，构建器仍会尝试创建在Revit中有效的几何图形。</p>
<p>定义所有面并关闭面集后，调用Build（）方法从存储的面集构建指定的几何对象。可以在调用Build（）之前设置TessellatedShapeBuilder的Target、Fallback和GraphicsStyleId属性，否则将使用默认选项。Build（）的结果存储在TessellatedShapeBuilder中，可以通过调用GetBuildResult（）进行检索。TessellatedShapeBuilderResult.GetGeometricalObjects（）方法将返回一个GeometryObjects列表，该列表可与相应的DirectShape.SetShape（）或DirectShape. SethdShape（）重载一起使用，如下面的示例所示。</p>
<p>代码区域：使用TessellatedShapeBuilder创建DirectShape</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Create a pyramid-shaped DirectShape using given material for the faces</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">CreateTessellatedShape</span>(<span class="params">Document doc, ElementId materialId</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    List&lt;XYZ&gt; loopVertices = <span class="keyword">new</span> List&lt;XYZ&gt;(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    TessellatedShapeBuilder builder = <span class="keyword">new</span> TessellatedShapeBuilder();</span><br><span class="line"></span><br><span class="line">    builder.OpenConnectedFaceSet(<span class="literal">true</span>);</span><br><span class="line">    <span class="comment">// create a pyramid with a square base 4&#x27; x 4&#x27; and 5&#x27; high</span></span><br><span class="line">    <span class="built_in">double</span> length = <span class="number">4.0</span>;</span><br><span class="line">    <span class="built_in">double</span> height = <span class="number">5.0</span>;</span><br><span class="line"></span><br><span class="line">    XYZ basePt1 = XYZ.Zero;</span><br><span class="line">    XYZ basePt2 = <span class="keyword">new</span> XYZ(length, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    XYZ basePt3 = <span class="keyword">new</span> XYZ(length, length, <span class="number">0</span>);</span><br><span class="line">    XYZ basePt4 = <span class="keyword">new</span> XYZ(<span class="number">0</span>, length, <span class="number">0</span>);</span><br><span class="line">    XYZ apex = <span class="keyword">new</span> XYZ(length / <span class="number">2</span>, length / <span class="number">2</span>, height);</span><br><span class="line"></span><br><span class="line">    loopVertices.Add(basePt1);</span><br><span class="line">    loopVertices.Add(basePt2);</span><br><span class="line">    loopVertices.Add(basePt3);</span><br><span class="line">    loopVertices.Add(basePt4);</span><br><span class="line">    builder.AddFace(<span class="keyword">new</span> TessellatedFace(loopVertices, materialId));</span><br><span class="line"></span><br><span class="line">    loopVertices.Clear();</span><br><span class="line">    loopVertices.Add(basePt1);</span><br><span class="line">    loopVertices.Add(apex);</span><br><span class="line">    loopVertices.Add(basePt2);</span><br><span class="line">    builder.AddFace(<span class="keyword">new</span> TessellatedFace(loopVertices, materialId));</span><br><span class="line"></span><br><span class="line">    loopVertices.Clear();</span><br><span class="line">    loopVertices.Add(basePt2);</span><br><span class="line">    loopVertices.Add(apex);</span><br><span class="line">    loopVertices.Add(basePt3);</span><br><span class="line">    builder.AddFace(<span class="keyword">new</span> TessellatedFace(loopVertices, materialId));</span><br><span class="line"></span><br><span class="line">    loopVertices.Clear();</span><br><span class="line">    loopVertices.Add(basePt3);</span><br><span class="line">    loopVertices.Add(apex);</span><br><span class="line">    loopVertices.Add(basePt4);</span><br><span class="line">    builder.AddFace(<span class="keyword">new</span> TessellatedFace(loopVertices, materialId));</span><br><span class="line"></span><br><span class="line">    loopVertices.Clear();</span><br><span class="line">    loopVertices.Add(basePt4);</span><br><span class="line">    loopVertices.Add(apex);</span><br><span class="line">    loopVertices.Add(basePt1);</span><br><span class="line">    builder.AddFace(<span class="keyword">new</span> TessellatedFace(loopVertices, materialId));</span><br><span class="line"></span><br><span class="line">    builder.CloseConnectedFaceSet();</span><br><span class="line">    builder.Target = TessellatedShapeBuilderTarget.Solid;</span><br><span class="line">    builder.Fallback = TessellatedShapeBuilderFallback.Abort;</span><br><span class="line">    builder.Build();</span><br><span class="line"></span><br><span class="line">    TessellatedShapeBuilderResult result = builder.GetBuildResult();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> (Transaction t = <span class="keyword">new</span> Transaction(doc, <span class="string">&quot;Create tessellated direct shape&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        t.Start();</span><br><span class="line">                </span><br><span class="line">        DirectShape ds = DirectShape.CreateElement(doc, <span class="keyword">new</span> ElementId(BuiltInCategory.OST_GenericModel));</span><br><span class="line">        ds.ApplicationId = <span class="string">&quot;Application id&quot;</span>;</span><br><span class="line">        ds.ApplicationDataId = <span class="string">&quot;Geometry object id&quot;</span>;</span><br><span class="line"></span><br><span class="line">        ds.SetShape(result.GetGeometricalObjects());</span><br><span class="line">        t.Commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面的图片是运行上面的示例并指定混凝土材质ID的结果。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/CHS/Revit-API/images/GUID-94C65476-5A32-4C89-8561-4AD97C41774D.png" alt="img"></p>
<p><strong>BRepBuilder</strong></p>
<p>BRepBuilder类提供了构造Revit边界表达几何图形（实体、开放壳等）的功能。作为表面、边和边的边界环的输入的结果。如果边界表示的构建成功，则可以在接受几何图形的任何其他Revit工具中直接使用生成的几何图形对象，或者可以直接传递BRepBuilder，以通过DirectShape类的SetShape（）和RoundShape（）方法填充DirectShape。下面是一个使用SetShape（）方法将圆柱体形状分配给新DirectShape对象的示例。</p>
<p>代码区域：使用BRepBuilder创建DirectShape</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">CreateDirectShapeFromCylinder</span>(<span class="params">Document doc</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Naming convention for faces and edges: we assume that x is to the left and pointing down, y is horizontal and pointing to the right, z is up</span></span><br><span class="line">    BRepBuilder brepBuilder = <span class="keyword">new</span> BRepBuilder(BRepType.Solid);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The surfaces of the four faces.</span></span><br><span class="line">    Frame basis = <span class="keyword">new</span> Frame(<span class="keyword">new</span> XYZ(<span class="number">50</span>, <span class="number">-100</span>, <span class="number">0</span>), <span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>), <span class="keyword">new</span> XYZ(<span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">    CylindricalSurface cylSurf = CylindricalSurface.Create(basis, <span class="number">50</span>);</span><br><span class="line">    Plane top = Plane.CreateByNormalAndOrigin(<span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>), <span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>));  <span class="comment">// normal points outside the cylinder</span></span><br><span class="line">    Plane bottom = Plane.CreateByNormalAndOrigin(<span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>), <span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)); <span class="comment">// normal points inside the cylinder</span></span><br><span class="line">                                                                                              </span><br><span class="line">    <span class="comment">// Add the four faces</span></span><br><span class="line">    BRepBuilderGeometryId frontCylFaceId = brepBuilder.AddFace(BRepBuilderSurfaceGeometry.Create(cylSurf, <span class="literal">null</span>), <span class="literal">false</span>);</span><br><span class="line">    BRepBuilderGeometryId backCylFaceId = brepBuilder.AddFace(BRepBuilderSurfaceGeometry.Create(cylSurf, <span class="literal">null</span>), <span class="literal">false</span>);</span><br><span class="line">    BRepBuilderGeometryId topFaceId = brepBuilder.AddFace(BRepBuilderSurfaceGeometry.Create(top, <span class="literal">null</span>), <span class="literal">false</span>);</span><br><span class="line">    BRepBuilderGeometryId bottomFaceId = brepBuilder.AddFace(BRepBuilderSurfaceGeometry.Create(bottom, <span class="literal">null</span>), <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Geometry for the four semi-circular edges and two vertical linear edges</span></span><br><span class="line">    BRepBuilderEdgeGeometry frontEdgeBottom = BRepBuilderEdgeGeometry.Create(Arc.Create(<span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">-100</span>, <span class="number">0</span>), <span class="keyword">new</span> XYZ(<span class="number">100</span>, <span class="number">-100</span>, <span class="number">0</span>), <span class="keyword">new</span> XYZ(<span class="number">50</span>, <span class="number">-50</span>, <span class="number">0</span>)));</span><br><span class="line">    BRepBuilderEdgeGeometry backEdgeBottom = BRepBuilderEdgeGeometry.Create(Arc.Create(<span class="keyword">new</span> XYZ(<span class="number">100</span>, <span class="number">-100</span>, <span class="number">0</span>), <span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">-100</span>, <span class="number">0</span>), <span class="keyword">new</span> XYZ(<span class="number">50</span>, <span class="number">-150</span>, <span class="number">0</span>)));</span><br><span class="line"></span><br><span class="line">    BRepBuilderEdgeGeometry frontEdgeTop = BRepBuilderEdgeGeometry.Create(Arc.Create(<span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">-100</span>, <span class="number">100</span>), <span class="keyword">new</span> XYZ(<span class="number">100</span>, <span class="number">-100</span>, <span class="number">100</span>), <span class="keyword">new</span> XYZ(<span class="number">50</span>, <span class="number">-50</span>, <span class="number">100</span>)));</span><br><span class="line">    BRepBuilderEdgeGeometry backEdgeTop = BRepBuilderEdgeGeometry.Create(Arc.Create(<span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">-100</span>, <span class="number">100</span>), <span class="keyword">new</span> XYZ(<span class="number">100</span>, <span class="number">-100</span>, <span class="number">100</span>), <span class="keyword">new</span> XYZ(<span class="number">50</span>, <span class="number">-150</span>, <span class="number">100</span>)));</span><br><span class="line"></span><br><span class="line">    BRepBuilderEdgeGeometry linearEdgeFront = BRepBuilderEdgeGeometry.Create(<span class="keyword">new</span> XYZ(<span class="number">100</span>, <span class="number">-100</span>, <span class="number">0</span>), <span class="keyword">new</span> XYZ(<span class="number">100</span>, <span class="number">-100</span>, <span class="number">100</span>));</span><br><span class="line">    BRepBuilderEdgeGeometry linearEdgeBack = BRepBuilderEdgeGeometry.Create(<span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">-100</span>, <span class="number">0</span>), <span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">-100</span>, <span class="number">100</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add the six edges</span></span><br><span class="line">    BRepBuilderGeometryId frontEdgeBottomId = brepBuilder.AddEdge(frontEdgeBottom);</span><br><span class="line">    BRepBuilderGeometryId frontEdgeTopId = brepBuilder.AddEdge(frontEdgeTop);</span><br><span class="line">    BRepBuilderGeometryId linearEdgeFrontId = brepBuilder.AddEdge(linearEdgeFront);</span><br><span class="line">    BRepBuilderGeometryId linearEdgeBackId = brepBuilder.AddEdge(linearEdgeBack);</span><br><span class="line">    BRepBuilderGeometryId backEdgeBottomId = brepBuilder.AddEdge(backEdgeBottom);</span><br><span class="line">    BRepBuilderGeometryId backEdgeTopId = brepBuilder.AddEdge(backEdgeTop);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Loops of the four faces</span></span><br><span class="line">    BRepBuilderGeometryId loopId_Top = brepBuilder.AddLoop(topFaceId);</span><br><span class="line">    BRepBuilderGeometryId loopId_Bottom = brepBuilder.AddLoop(bottomFaceId);</span><br><span class="line">    BRepBuilderGeometryId loopId_Front = brepBuilder.AddLoop(frontCylFaceId);</span><br><span class="line">    BRepBuilderGeometryId loopId_Back = brepBuilder.AddLoop(backCylFaceId);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add coedges for the loop of the front face</span></span><br><span class="line">    brepBuilder.AddCoEdge(loopId_Front, linearEdgeBackId, <span class="literal">false</span>);</span><br><span class="line">    brepBuilder.AddCoEdge(loopId_Front, frontEdgeTopId, <span class="literal">false</span>);</span><br><span class="line">    brepBuilder.AddCoEdge(loopId_Front, linearEdgeFrontId, <span class="literal">true</span>);</span><br><span class="line">    brepBuilder.AddCoEdge(loopId_Front, frontEdgeBottomId, <span class="literal">true</span>);</span><br><span class="line">    brepBuilder.FinishLoop(loopId_Front);</span><br><span class="line">    brepBuilder.FinishFace(frontCylFaceId);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add coedges for the loop of the back face</span></span><br><span class="line">    brepBuilder.AddCoEdge(loopId_Back, linearEdgeBackId, <span class="literal">true</span>);</span><br><span class="line">    brepBuilder.AddCoEdge(loopId_Back, backEdgeBottomId, <span class="literal">true</span>);</span><br><span class="line">    brepBuilder.AddCoEdge(loopId_Back, linearEdgeFrontId, <span class="literal">false</span>);</span><br><span class="line">    brepBuilder.AddCoEdge(loopId_Back, backEdgeTopId, <span class="literal">true</span>);</span><br><span class="line">    brepBuilder.FinishLoop(loopId_Back);</span><br><span class="line">    brepBuilder.FinishFace(backCylFaceId);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add coedges for the loop of the top face</span></span><br><span class="line">    brepBuilder.AddCoEdge(loopId_Top, backEdgeTopId, <span class="literal">false</span>);</span><br><span class="line">    brepBuilder.AddCoEdge(loopId_Top, frontEdgeTopId, <span class="literal">true</span>);</span><br><span class="line">    brepBuilder.FinishLoop(loopId_Top);</span><br><span class="line">    brepBuilder.FinishFace(topFaceId);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add coedges for the loop of the bottom face</span></span><br><span class="line">    brepBuilder.AddCoEdge(loopId_Bottom, frontEdgeBottomId, <span class="literal">false</span>);</span><br><span class="line">    brepBuilder.AddCoEdge(loopId_Bottom, backEdgeBottomId, <span class="literal">false</span>);</span><br><span class="line">    brepBuilder.FinishLoop(loopId_Bottom);</span><br><span class="line">    brepBuilder.FinishFace(bottomFaceId);</span><br><span class="line"></span><br><span class="line">    brepBuilder.Finish();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> (Transaction tr = <span class="keyword">new</span> Transaction(doc, <span class="string">&quot;Create a DirectShape&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        tr.Start();</span><br><span class="line">        DirectShape ds = DirectShape.CreateElement(doc, <span class="keyword">new</span> ElementId(BuiltInCategory.OST_GenericModel));</span><br><span class="line">        ds.SetShape(brepBuilder);</span><br><span class="line">        tr.Commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>ShapeImporter</strong> </p>
<p>ShapeImporter工具类支持将以外部格式（如SAT和Rhino）存储的几何体转换为可用于设置DirectShape形状的GeometryObjects集合。使用ShapeImporter.Convert（）生成几何体对象（如果可能，还生成关联文档中的相应材料和图形样式）。</p>
<p>代码区域：从SAT文件创建DirectShape</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ReadSATFile</span>(<span class="params">Document revitDoc</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Allow the user to select a SAT file.</span></span><br><span class="line">    OpenFileDialog ofd = <span class="keyword">new</span> OpenFileDialog();</span><br><span class="line">    ofd.Filter = <span class="string">&quot;SAT Files (*.sat)|*.sat&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (DialogResult.OK == ofd.ShowDialog())</span><br><span class="line">    &#123;</span><br><span class="line">        ShapeImporter shapeImporter = <span class="keyword">new</span> ShapeImporter();</span><br><span class="line">        shapeImporter.InputFormat = ShapeImporterSourceFormat.SAT; </span><br><span class="line">        IList&lt;GeometryObject&gt; shapes = shapeImporter.Convert(revitDoc, ofd.FileName);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (shapes.Count != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">using</span> (Transaction tr = <span class="keyword">new</span> Transaction(revitDoc, <span class="string">&quot;Create a DirectShape&quot;</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                tr.Start();</span><br><span class="line"></span><br><span class="line">                DirectShape dsImportedSat = DirectShape.CreateElement(revitDoc, <span class="keyword">new</span> ElementId(BuiltInCategory.OST_Walls));</span><br><span class="line">                dsImportedSat.SetShape(shapes);</span><br><span class="line"></span><br><span class="line">                tr.Commit();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Options</strong> </p>
<p>DirectShapeOptions类用于控制DirectShape对象的行为。使用DirectShape.SetOptions（）设置DirectShape对象使用的选项。GetOptions（）方法将返回DirectShape对象当前使用的DirectShapeOptions。</p>
<p>默认情况下，DirectShape元素支持元素参照，包括尺寸标注、路线和面主体以及捕捉。可以使用DirectShapeOptions.ReferencingOption属性更改此默认行为。如果将其设置为NotReferenceable，则几何图形不能用于标注、捕捉、对齐或面主体。用户仍然可以选择该元素进行不引用单个几何对象的操作。</p>
<p>如果DirectShape元素属于房间边界计算的适当类别，并且关联的“房间边界”参数设置为true，则DirectShape元素还支持参与房间边界计算的功能。属性DirectShapeOptions.RoomBoundingOption标识DirectShape是否支持“房间边界”参数的选项以允许参与房间边界计算。默认值为NotApplied，但对于适用的DirectController，此值将自动更改为SetByParameter。</p>
<h2 id="注：翻译自Revit-API-Developers-Guide"><a href="#注：翻译自Revit-API-Developers-Guide" class="headerlink" title="注：翻译自Revit API Developers Guide"></a><em><strong>注：</strong></em>翻译自<a href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_html">Revit API Developers Guide</a></h2>]]></content>
      <categories>
        <category>Revit二次开发人员指南</category>
      </categories>
      <tags>
        <tag>Revit</tag>
      </tags>
  </entry>
  <entry>
    <title>24子元素</title>
    <url>/2024/12/23/Revit%E4%BA%8C%E5%BC%80%E6%8C%87%E5%8D%97/24%E5%AD%90%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<h1 id="子元素"><a href="#子元素" class="headerlink" title="子元素"></a><a href="https://help.autodesk.com/view/RVT/2018/CHS/?guid=GUID-DD027284-D899-43FB-B33A-5917C06D0C20">子元素</a></h1><p>多个Revit图元现在可以包含称为子图元的细分。子元素提供了一种方法，使元素的各个部分的行为就像它们是真实的元素一样，而不会产生向模型中添加更多完整元素的开销。</p>
<p>许多Revit功能（例如，参数、明细表和标记）都设计用于对图元进行操作。因此，Revit代码需要将对象表示为元素，以便它们参与这些功能。这可能会导致可伸缩性问题，因为每个元素都会增加开销，并且添加许多元素可能会降低模型的性能。</p>
<p>另一种方法是使用子元素。图元可以显示其包含的一组“子图元”，指定其类别和参数等特征，并且某些Revit功能会将这些子图元视为普通图元。例如，子元素可以为主元素提供几何图形，并且可以独立于其父元素进行选择。它可能会有自己的（可设置的）类型以及分配的类别，该类别可以与其父元素不同。</p>
<p>在API中，新的Subelement类用于引用一个Element或给定Element的特定子元素。它通常与对元素或特定子元素的引用直接相关。</p>
<h2 id="注：翻译自Revit-API-Developers-Guide"><a href="#注：翻译自Revit-API-Developers-Guide" class="headerlink" title="注：翻译自Revit API Developers Guide"></a><em><strong>注：</strong></em>翻译自<a href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_html">Revit API Developers Guide</a></h2>]]></content>
      <categories>
        <category>Revit二次开发人员指南</category>
      </categories>
      <tags>
        <tag>Revit</tag>
      </tags>
  </entry>
  <entry>
    <title>27机电工程</title>
    <url>/2024/12/30/Revit%E4%BA%8C%E5%BC%80%E6%8C%87%E5%8D%97/27%E6%9C%BA%E7%94%B5%E5%B7%A5%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="机电工程"><a href="#机电工程" class="headerlink" title="机电工程"></a>机电工程</h1><p>为了支持Revit软件的MEP工程功能，API提供了对Revit模型中HVAC和管道数据的读写访问，包括：</p>
<ul>
<li>在系统中穿过风管、管道、管件和接头</li>
<li>添加、删除和更改风管、管道和其他设备</li>
<li>获取和设置系统属性</li>
<li>确定系统是否连接良好</li>
<li>访问机械设置</li>
<li>管理布管配置</li>
</ul>
<p>本节中的页面</p>
<ul>
<li>MEP元素创建</li>
<li>MEP系统</li>
<li>连接器</li>
<li>MEP预制件详述</li>
<li>族创建</li>
<li>机械设置</li>
<li>电气设置</li>
<li>布管系统配置</li>
</ul>
<h2 id="MEP元素创建"><a href="#MEP元素创建" class="headerlink" title="MEP元素创建"></a>MEP元素创建</h2><p>可以使用Revit API创建MEP图元。</p>
<p>可以使用Autodesk.Revit.Creation.Document类中提供的以下方法创建与风管、管道和电气系统相关的许多图元：</p>
<ul>
<li>NewFlexDuct</li>
<li>NewFlexPipe</li>
<li>NewMechanicalSystem </li>
<li>NewPipingSystem</li>
<li>NewCrossFitting</li>
<li>NewElbowFitting </li>
<li>NewTakeoffFitting </li>
<li>NewTeeFitting </li>
<li>NewTransitionFitting </li>
<li>NewUnionFitting</li>
</ul>
<p>其他MEP元素（如管道）只能使用其对应类的静态Create（）方法创建。某些MEP图元（如风管）可以通过相应类（即Duct）的静态方法或Autodesk.Revit.Creation.Document类的方法创建。对于这些元素，静态Create（）方法是首选。</p>
<p>Duct  管道</p>
<ul>
<li>FlexDuct</li>
<li>Pipe </li>
<li>FlexPipe  </li>
<li>PipingSystem </li>
<li>Wire</li>
</ul>
<p>Pages in this section  本节中的页面</p>
<ul>
<li>创建管道和风管</li>
<li>创建导线</li>
<li>占位符</li>
<li>创建系统</li>
</ul>
<h3 id="创建管道和风管"><a href="#创建管道和风管" class="headerlink" title="创建管道和风管"></a>创建管道和风管</h3><p>有三种方法可以创建新风管：软风管、管道和软管。它们可以在两点之间、两个连接件之间或点与连接件之间创建。</p>
<p>下面的代码使用Pipe.Create（）方法在两点之间创建一个新管道。新的软管、风管和软风管都可以类似地创建。</p>
<p>代码区域：使用静态Create（）方法创建新管道</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Pipe <span class="title">CreateNewPipe</span>(<span class="params">Document document, ElementId systemTypeId, ElementId levelId</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// find a pipe type</span></span><br><span class="line"></span><br><span class="line">    FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">    collector.OfClass(<span class="keyword">typeof</span>(PipeType));</span><br><span class="line">    PipeType pipeType = collector.FirstElement() <span class="keyword">as</span> PipeType;</span><br><span class="line"></span><br><span class="line">    Pipe pipe = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> != pipeType)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// create pipe between 2 points</span></span><br><span class="line">        XYZ p1 = <span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        XYZ p2 = <span class="keyword">new</span> XYZ(<span class="number">10</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        pipe = Pipe.Create(document, systemTypeId, pipeType.Id, levelId, p1, p2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pipe;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面的代码区域演示了如何使用静态FlexPipe.Create（）方法创建FlexPipe。管道、风管和软风管都可以类似地在两点之间创建。</p>
<p>代码区域：使用静态Create（）方法创建新的FlexPipe</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> FlexPipe <span class="title">CreateFlexPipe</span>(<span class="params">Document document, Level level</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// find a pipe type</span></span><br><span class="line">    FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">    collector.OfClass(<span class="keyword">typeof</span>(FlexPipeType));</span><br><span class="line">    ElementId pipeTypeId = collector.FirstElementId();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// find a pipe system type</span></span><br><span class="line">    FilteredElementCollector sysCollector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">    sysCollector.OfClass(<span class="keyword">typeof</span>(PipingSystemType));</span><br><span class="line">    ElementId pipeSysTypeId = sysCollector.FirstElementId();</span><br><span class="line"></span><br><span class="line">    FlexPipe pipe = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (pipeTypeId != ElementId.InvalidElementId &amp;&amp; pipeSysTypeId != ElementId.InvalidElementId)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// create flex pipe with 3 points</span></span><br><span class="line">        List points = <span class="keyword">new</span> List();</span><br><span class="line">        points.Add(<span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">        points.Add(<span class="keyword">new</span> XYZ(<span class="number">10</span>, <span class="number">10</span>, <span class="number">0</span>));</span><br><span class="line">        points.Add(<span class="keyword">new</span> XYZ(<span class="number">10</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">        pipe = FlexPipe.Create(document, pipeSysTypeId, pipeTypeId, level.Id, points);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pipe;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建管道后，可能需要修改直径。“管道”的“直径”属性为只读。要更改直径，请获取RBS_PIPE_DIAMETER_PARAM内置参数。</p>
<p>代码区域：更改管道直径</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ChangePipeSize</span>(<span class="params">Pipe pipe</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        Parameter parameter = pipe.get_Parameter(BuiltInParameter.RBS_PIPE_DIAMETER_PARAM);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">string</span> message = <span class="string">&quot;Pipe diameter: &quot;</span> + parameter.AsValueString();</span><br><span class="line"></span><br><span class="line">        parameter.Set(<span class="number">0.5</span>); <span class="comment">// set to 6&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Regenerate the docucment before trying to read a parameter that has been edited</span></span><br><span class="line">        pipe.Document.Regenerate();</span><br><span class="line"></span><br><span class="line">        message += <span class="string">&quot;\nPipe diameter after set: &quot;</span> + parameter.AsValueString();</span><br><span class="line"></span><br><span class="line">        MessageBox.Show(message, <span class="string">&quot;Revit&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建新风管或管道的另一种常用方法是在两个现有连接件之间创建，如下例所示。在本示例中，假设已在Revit中选择了2个带有接头的图元代码区域：在两个连接件之间添加风管其中一个是机械设备，另一个是风管管件，其接头与设备上的SupplyAir接头对齐。</p>
<p>代码区域：在两个连接件之间添加风管</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Duct <span class="title">CreateDuctBetweenConnectors</span>(<span class="params">UIDocument uiDocument</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// prior to running this example</span></span><br><span class="line">    <span class="comment">// select some mechanical equipment with a supply air connector</span></span><br><span class="line">    <span class="comment">// and an elbow duct fitting with a connector in line with that connector</span></span><br><span class="line">    ElementId levelId = ElementId.InvalidElementId;</span><br><span class="line">    Connector connector1 = <span class="literal">null</span>, connector2 = <span class="literal">null</span>;</span><br><span class="line">    ConnectorSetIterator csi = <span class="literal">null</span>;</span><br><span class="line">    ICollection selectedIds = uiDocument.Selection.GetElementIds();</span><br><span class="line">    Document document = uiDocument.Document;</span><br><span class="line">    <span class="comment">// First find the selected equipment and get the correct connector</span></span><br><span class="line">    <span class="keyword">foreach</span> (ElementId id <span class="keyword">in</span> selectedIds)</span><br><span class="line">    &#123;</span><br><span class="line">        Element e = document.GetElement(id);</span><br><span class="line">        <span class="keyword">if</span> (e <span class="keyword">is</span> FamilyInstance)</span><br><span class="line">        &#123;</span><br><span class="line">            FamilyInstance fi = e <span class="keyword">as</span> FamilyInstance;</span><br><span class="line">            Family family = fi.Symbol.Family;</span><br><span class="line">            <span class="keyword">if</span> (family.FamilyCategory.Name == <span class="string">&quot;Mechanical Equipment&quot;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                csi = fi.MEPModel.ConnectorManager.Connectors.ForwardIterator();</span><br><span class="line">                <span class="keyword">while</span> (csi.MoveNext())</span><br><span class="line">                &#123;</span><br><span class="line">                    Connector conn = csi.Current <span class="keyword">as</span> Connector;</span><br><span class="line">                    <span class="keyword">if</span> (conn.Direction == FlowDirectionType.Out &amp;&amp; </span><br><span class="line">                        conn.DuctSystemType == DuctSystemType.SupplyAir)</span><br><span class="line">                    &#123;</span><br><span class="line">                        connector1 = conn;</span><br><span class="line">                        levelId = family.LevelId;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// next find the second selected item to connect to</span></span><br><span class="line">    <span class="keyword">foreach</span> (ElementId id <span class="keyword">in</span> selectedIds)</span><br><span class="line">    &#123;</span><br><span class="line">        Element e = document.GetElement(id);</span><br><span class="line">        <span class="keyword">if</span> (e <span class="keyword">is</span> FamilyInstance)</span><br><span class="line">        &#123;</span><br><span class="line">            FamilyInstance fi = e <span class="keyword">as</span> FamilyInstance;</span><br><span class="line">            Family family = fi.Symbol.Family;</span><br><span class="line">            <span class="keyword">if</span> (family.FamilyCategory.Name != <span class="string">&quot;Mechanical Equipment&quot;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                csi = fi.MEPModel.ConnectorManager.Connectors.ForwardIterator();</span><br><span class="line">                <span class="keyword">while</span> (csi.MoveNext())</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="literal">null</span> == connector2)</span><br><span class="line">                    &#123;</span><br><span class="line">                        Connector conn = csi.Current <span class="keyword">as</span> Connector;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// make sure to choose the connector in line with the first connector</span></span><br><span class="line">                        <span class="keyword">if</span> (Math.Abs(conn.Origin.Y - connector1.Origin.Y) &lt; <span class="number">0.001</span>)</span><br><span class="line">                        &#123;</span><br><span class="line">                            connector2 = conn;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Duct duct = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> != connector1 &amp;&amp; <span class="literal">null</span> != connector2 &amp;&amp; levelId != ElementId.InvalidElementId)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// find a duct type</span></span><br><span class="line">        FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(uiDocument.Document);</span><br><span class="line">        collector.OfClass(<span class="keyword">typeof</span>(DuctType));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Use Linq query to make sure it is one of the rectangular duct types</span></span><br><span class="line">        <span class="keyword">var</span> query = <span class="keyword">from</span> element <span class="keyword">in</span> collector</span><br><span class="line">                    <span class="keyword">where</span> element.Name.Contains(<span class="string">&quot;Mitered Elbows&quot;</span>) == <span class="literal">true</span></span><br><span class="line">                    <span class="keyword">select</span> element;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// use extension methods to get first duct type</span></span><br><span class="line">        DuctType ductType = collector.Cast().First();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != ductType)</span><br><span class="line">        &#123;</span><br><span class="line">            duct = Duct.Create(document, ductType.Id, levelId, connector1, connector2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> duct;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="衬里和绝缘"><a href="#衬里和绝缘" class="headerlink" title="衬里和绝缘"></a>衬里和绝缘</h4><p>可以将管道和风管保温层和内衬作为与风管和管道关联的单独对象添加。可以使用静态方法InsulationLiningBase.GetInsulationIds（）检索与风管或管道关联的隔热层图元的ID，而可以使用静态方法InsulationLiningBase.GetLiningIds（）检索衬里图元的ID。</p>
<p>若要创建与给定风管、管道、管件、附件或内容关联的新隔热层，请使用相应的静态方法：DuctInsulation.Create（）或PipeInsulation.Create（）。DuctLining.Create（）可用于创建应用于给定风管、管件或附件内部的衬里的新实例。</p>
<h3 id="创建导线"><a href="#创建导线" class="headerlink" title="创建导线"></a>创建导线</h3><p>可以使用Revit API创建新的导线。</p>
<p>静态Wire.Create（）允许在文档中创建新的连接。Create（）方法需要新创建的关联在其中可见的视图的id。它必须是楼层平面或天花板投影平面视图的ID。导线的WiringType可以是Arc（隐藏在墙、天花板或楼板内的布线）或Chamfer（暴露的布线）。</p>
<p>导线的位置由定义导线顶点的XYZ点列表以及可选的起始和&#x2F;或结束连接器指定。端点连接器可以为空，但是，如果指定了起始连接器，则连接器的原点将作为起点添加到导线的顶点。同样，如果指定了端点连接器，则连接器的原点将作为端点添加到导线的顶点。静态方法Wire.AreVertexPointsValid（）将检查XYZ点以及起始和结束连接器的列表，以确保它们适合于导线。</p>
<p>导线的形状由导线的布线类型以及通过顶点和端点连接器提供的点的总数确定。如果布线类型为WiringType.Arc：</p>
<ul>
<li>如果总共提供了2个点，则导线为直线导线。</li>
<li>如果总共提供3个点，则导线为圆弧导线。</li>
<li>如果有4个或更多点，则导线为样条线导线。</li>
</ul>
<p>如果布线类型为WiringType.Chamfer，则将创建一条连接所有点的连接线。</p>
<p>下面的示例在活动视图中创建一条新的直线导线，但未指定任何连接器。</p>
<p>代码区域：创建新导线</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Wire <span class="title">CreateWire</span>(<span class="params">Document document</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Wire wire = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">    IList wireTypes = collector.OfCategory(BuiltInCategory.OST_Wire).WhereElementIsElementType().ToElements();</span><br><span class="line">    WireType wireType = wireTypes.First() <span class="keyword">as</span> WireType;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (wireType != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        IList wireVertices = <span class="keyword">new</span> List();</span><br><span class="line">        wireVertices.Add(<span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">        wireVertices.Add(<span class="keyword">new</span> XYZ(<span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">        wire = Wire.Create(document, wireType.Id, document.ActiveView.Id, WiringType.Arc, wireVertices, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> wire;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>连接器</strong></p>
<p>若要在创建后将关联连接到元素，请调用Wire.ConnectTo（），并传入开始和结束连接器。如果使用此方法时导线已经连接，则旧连接将断开，导线将连接到新目标。</p>
<p> <strong>顶点</strong></p>
<p>创建线框后，可以使用Wire.GetVertex（）方法检索顶点。这个方法接受一个请求顶点的索引，这个索引应该在0和Wire.NumberOfVertices（包括线的起点和终点）之间。</p>
<p>使用Wire. InsertVertex（）将顶点添加到列表的末尾，或使用Wire.InsertVertex（）将顶点添加到列表中的特定点。IsVertexPointValid（）方法检查给定的顶点是否可以添加到该线。如果因为视图平面上的此位置已存在顶点（在公差范围内）而无法添加点，IsVertexPointValid（）将返回false。请注意，如果开始顶点已经连接到元素，则不能在开始顶点之前插入顶点。类似地，如果端点已经连接到元素，则不能将顶点附加到列表的末尾。</p>
<p>Wire.RemoveVertex（）将从列表中删除顶点。如果导线顶点已连接到元素，则此方法将无法删除该顶点。为了移除此顶点，应先断开连接，然后移除，然后重新连接（如果需要）。</p>
<h3 id="占位符"><a href="#占位符" class="headerlink" title="占位符"></a>占位符</h3><p>占位符风管和管道</p>
<p>Revit API提供了在尚不清楚布局的确切设计时将占位符元素放入系统的功能。使用占位符风管和管道可以在设计仍然未知的情况下实现良好的连接系统，然后可以在后期的最终设计中进行详细说明。</p>
<p>两个静态方法Duct.Placeholder（）和Pipe.Placeholder（）创建占位符元素。风管和管道的IsPlaceholder属性指示它们是否为占位符元素。</p>
<p>准备从占位符创建实际风管和管道时，请使用Mechanical Utils.ConvertDuctPlaceholders（）和PlumbingUtils.ConvertPipePlaceholders（）方法将一组占位符元素转换为风管和管道。一旦转换成功，占位符元素将被删除。将创建新风管、管道和管件图元，并建立连接。</p>
<h3 id="创建系统"><a href="#创建系统" class="headerlink" title="创建系统"></a>创建系统</h3><p>创建电气、机械和管道系统。</p>
<p>Mechanical System和PipingSystem具有静态重载Create（）方法，可用于创建新的机械系统或管道系统。这是创建新MEP系统的首选方法。这两个类的最简单Create（）重载在给定文档中创建一个具有给定类型ID（对于Mechanical System，该ID应为DuctSystemType的ID，对于PipingSystem，该ID应为PipeSystemType的ID）的新系统。这两个类都有第二个Create（）重载，它也接受系统的名称。创建元素后，可以使用MEPSystem.Add（）方法将其添加到系统中。</p>
<p>还可以使用NewMechanicalSystem（）和NewPipingSystem（）从Creation.Document类创建MechanicalSystem和PipingSystem。NewPipingSystem（）和NewMechanicalSystem（）都采用作为基本设备连接器的连接器，例如管道系统的热水器或机械系统的风扇。它们还采用将添加到系统中的连接件（如管道系统中水槽上的连接件）的ConnectorSet。创建新系统所需的最后一项信息是NewPipingSystem（）的PipeSystemType或NewMechanical System（）的DuctSystemType。</p>
<p>可以使用ElectricalSystem.Create方法创建电气系统，该方法有两个重载。从一个未使用的Connector创建一个新的ElectricalSystem元素。另一个从一组电气元件创建一个新的ElectricalSystem元素。这两个重载都需要ElectricalSystemType。</p>
<p>在以下示例中，将从选定的机械设备（如风扇）和所有选定的风道末端创建新的SupplyAir风管系统。</p>
<p>代码区域：创建新的机械系统</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// create a connector set for new mechanical system</span></span><br><span class="line">ConnectorSet connectorSet = <span class="keyword">new</span> ConnectorSet();</span><br><span class="line"><span class="comment">// Base equipment connector</span></span><br><span class="line">Connector baseConnector = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Select a Parallel Fan Powered VAV and some Supply Diffusers</span></span><br><span class="line"><span class="comment">// prior to running this example</span></span><br><span class="line">ConnectorSetIterator csi = <span class="literal">null</span>;</span><br><span class="line">ICollection selectedIds = uiDocument.Selection.GetElementIds();</span><br><span class="line">Document document = uiDocument.Document;</span><br><span class="line"><span class="keyword">foreach</span> (ElementId id <span class="keyword">in</span> selectedIds)</span><br><span class="line">&#123;</span><br><span class="line">    Element e = document.GetElement(id);</span><br><span class="line">    <span class="keyword">if</span> (e <span class="keyword">is</span> FamilyInstance)</span><br><span class="line">    &#123;</span><br><span class="line">        FamilyInstance fi = e <span class="keyword">as</span> FamilyInstance;</span><br><span class="line">        Family family = fi.Symbol.Family;</span><br><span class="line">        <span class="comment">// Assume the selected Mechanical Equipment is the base equipment for new system</span></span><br><span class="line">        <span class="keyword">if</span> (family.FamilyCategory.Name == <span class="string">&quot;Mechanical Equipment&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//Find the &quot;Out&quot; and &quot;SupplyAir&quot; connector on the base equipment</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="literal">null</span> != fi.MEPModel)</span><br><span class="line">            &#123;</span><br><span class="line">                csi = fi.MEPModel.ConnectorManager.Connectors.ForwardIterator();</span><br><span class="line">                <span class="keyword">while</span> (csi.MoveNext())</span><br><span class="line">                &#123;</span><br><span class="line">                    Connector conn = csi.Current <span class="keyword">as</span> Connector;</span><br><span class="line">                    <span class="keyword">if</span> (conn.Direction == FlowDirectionType.Out &amp;&amp; conn.DuctSystemType == DuctSystemType.SupplyAir)</span><br><span class="line">                    &#123;</span><br><span class="line">                        baseConnector = conn;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (family.FamilyCategory.Name == <span class="string">&quot;Air Terminals&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// add selected Air Terminals to connector set for new mechanical system</span></span><br><span class="line">            csi = fi.MEPModel.ConnectorManager.Connectors.ForwardIterator();</span><br><span class="line">            csi.MoveNext();</span><br><span class="line">            connectorSet.Insert(csi.Current <span class="keyword">as</span> Connector);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MechanicalSystem mechanicalSys = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">null</span> != baseConnector &amp;&amp; connectorSet.Size &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// create a new SupplyAir mechanical system</span></span><br><span class="line">    mechanicalSys = uiDocument.Document.Create.NewMechanicalSystem(baseConnector, connectorSet, DuctSystemType.SupplyAir);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="MEP系统"><a href="#MEP系统" class="headerlink" title="MEP系统"></a>MEP系统</h2><p>MEPSystem是Revit MEP中电气、机械和管道系统的基类。</p>
<p>ElectricalSystem、MechanicalSystem和PipingSystem都派生自MEP System类。基类具有一些跨系统类型的通用功能，例如向系统添加元素或查找系统的基础面板或设备。基类中的一些方法仅适用于HVAC和管道系统，例如DivideSystem（）方法，它划分系统中的物理网络并为每个网络创建一个新系统。</p>
<p>派生类具有特定于系统类型的其他方法和属性。</p>
<p><strong>MEP截面</strong></p>
<p>MEPSystem类有一个SectionsCount属性，该属性返回系统截面的节数。可以使用GetSectionByIndex（）方法或GetSectionByNumber（）方法获取MEPSection对象。虽然这些方法在MEP System基类中，但MEP Section类表示风管和管道部分，主要用于压力损失计算。它是一系列连接的图元（管段-风管或管道、管件、端子和附件），可以从GetElementIds（）方法获得。所有截面构件应具有相同的流动分析特性：流量、尺寸、速度、摩擦力和粗糙度。</p>
<p>截面中每个元件的段长度、压降和损失系数可能不同，因此在MEP截面中提供了方法，以获得给定截面中某个元件的特定元件ID的这些值。管道的系数是损失系数。对于管道，这与摩擦系数相同。</p>
<p><strong>计算</strong></p>
<p>MEP系统的某些属性是由Revit计算的。Mechanical System和PipingSystem都具有IsWellConnected属性，该属性指示系统是否连接良好。如果系统连接不好，需要计算的参数无效。</p>
<p>对于机械和管道系统，某些值是根据系统截面的特性计算的。MEPSystem.GetCriticalPathSectionNumbers（）方法按流动方向的顺序返回关键路径部分编号的列表，PressureLossOfCriticalPath（）获取关键路径中部分的总压力损失。</p>
<p>Mechanical System和PipingSystem中的GetFlow（）和GetStaticPressure（）方法可获取系统的流量和静压。</p>
<p>PipingSystem具有其他计算属性：GetFixtureUnits（）和GetVolume（）</p>
<p>注意：由于Revit内部处理这些计算属性的方式，它们不支持动态模型更新。但是，其他未计算的系统属性支持动态模型更新。</p>
<h2 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h2><p>连接件与域（风管、管道或电气）关联，该域可从连接件的“域”特性中获取。连接器存在于机械设备以及导管和管道上。</p>
<p>要遍历系统，可以检查系统基本设备上的连接器，并通过检查IsConnected属性和AllRefs属性来确定连接器附着的内容。在查找物理连接时，检查连接器的ConnectionType非常重要。Revit中既有物理连接器，也有逻辑连接器，但在应用程序中仅物理连接器可见。下面的图像显示了两种类型的物理连接器-端点连接和曲线连接器。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-BBDF045B-E39B-4A5A-9D87-8AFCA7E1F5F3-low.png" alt="img"></p>
<p>图167：物理连接器</p>
<p>下面的示例说明如何确定连接器的所有者，以及连接器与连接类型沿着的内容（如果有）。</p>
<p>代码区域30-5：确定连接器连接的内容</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetElementAtConnector</span>(<span class="params">Autodesk.Revit.DB.Connector connector</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    MEPSystem mepSystem = connector.MEPSystem;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> != mepSystem)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> message = <span class="string">&quot;Connector is owned by: &quot;</span> + connector.Owner.Name;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (connector.IsConnected == <span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ConnectorSet connectorSet = connector.AllRefs;</span><br><span class="line">            ConnectorSetIterator csi = connectorSet.ForwardIterator();</span><br><span class="line">            <span class="keyword">while</span> (csi.MoveNext())</span><br><span class="line">            &#123;</span><br><span class="line">                Connector connected = csi.Current <span class="keyword">as</span> Connector;</span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">null</span> != connected)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// look for physical connections</span></span><br><span class="line">                    <span class="keyword">if</span> (connected.ConnectorType == ConnectorType.End ||</span><br><span class="line">                        connected.ConnectorType == ConnectorType.Curve ||</span><br><span class="line">                        connected.ConnectorType == ConnectorType.Physical)</span><br><span class="line">                    &#123;</span><br><span class="line">                        message += <span class="string">&quot;\nConnector is connected to: &quot;</span> + connected.Owner.Name;</span><br><span class="line">                        message += <span class="string">&quot;\nConnection type is: &quot;</span> + connected.ConnectorType;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            message += <span class="string">&quot;\nConnector is not connected to anything.&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>, message);    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面的对话框是在管道设备的连接器上运行此代码示例的结果。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-938B934C-71EB-42CE-8B02-FE2392B5CC3F-low.png" alt="img"></p>
<p>图168：连接器信息</p>
<h2 id="MEP预制件详述"><a href="#MEP预制件详述" class="headerlink" title="MEP预制件详述"></a>MEP预制件详述</h2><p>多个Revit API类共同提供将预制构件添加到Revit文档的功能。</p>
<p><strong>预制详细类</strong></p>
<p>在MEP模型中放置预制零件之前，必须指定预制件配置并将预制件服务加载到模型中。Revit API中有许多类可用于简化此过程，其中包括：</p>
<ul>
<li><strong>FabricationConfiguration</strong> - 包含有关项目使用的预制件配置设置的信息。</li>
<li><strong>FabricationConfigurationInfo</strong> - 包含有关FabricationConfiguration属性的信息。</li>
<li><strong>ConfigurationReloadInfo</strong> - 包含重新加载FabricationConfiguration的结果。</li>
<li><strong>ConnectionValidationInfo</strong> -包含通过重新加载FabricationConfiguration生成的与连接相关的警告。</li>
<li><strong>FabricationService</strong> - 预制件配置的一部分，并定义可以使用哪些FabricationService。</li>
<li><strong>FabricationServiceButton</strong> - 定义在不同条件下使用哪些项。</li>
<li><strong>FabricationPart</strong> - 表示Revit中的预制构件。</li>
<li><strong>FabricationPartType</strong> - 定义FabricationPart的类型。</li>
<li><strong>FabricationRodInfo</strong> - 提供FabricationPart的杆信息。</li>
<li><strong>FabricationHostedInfo</strong> - 包含FabricationPart的主机信息，并提供从主机断开连接的功能。</li>
<li><strong>FabricationConnectorInfo</strong> - 包含有关FabricationPart的连接器的信息。</li>
<li><strong>FabricationUtils</strong> - Autodesk Revit产品中用于预制件的常规实用程序方法。</li>
<li><strong>FabricationDimensionDefinition</strong> - 包含有关预制件尺寸的信息。</li>
</ul>
<p>MEP预制件中涉及的主要类别将在下文中详细介绍。可以在Revit SDK的FabricationPartLayout示例中找到示例代码。</p>
<p><strong>预制件配置</strong></p>
<p>使用FabricationConfiguration类，用户可以获取和设置文档的装配配置设置。他们还可以加载和卸载服务、重新加载预制件配置、获取加载的服务、获取预制件规范、从配置中获取材料和绝缘信息以及获取连接器信息。</p>
<p>文档只有一个装配配置，您可以使用静态FabricationConfiguration.GetFabricationConfiguration（）方法获取它。要更改配置，请调用重载的SetConfiguration（）方法，传入包含有关FabricationConfiguration的信息的FabricationConfiguration Info对象。SetConfiguration（）方法的一个重载将使用全局概要文件设置配置，另一个重载接受概要文件名称并使用该特定概要文件设置配置。(The FabricationConfiguration.GetProfile（）方法和FabricationConfigurationInfo.GetProfiles（）方法分别返回与加载的配置或所有配置关联的配置文件。）</p>
<p>方法的作用是：从源加工配置中重新加载加工配置。这必须在加载预制件服务之前完成。</p>
<p>使用GetAllLoadedServices（）方法获取所有加载的服务，或使用GetAllUsedServices（）方法仅获取使用的预制件服务。如果服务中的任何预制件部件是由用户创建的，则服务正在使用中。这两个方法都返回FabricationService对象的列表。</p>
<p>LoadServices（）和UnloadServices（）可分别用于加载和卸载预制件服务列表。</p>
<p>FabricationConfiguration类还具有获取配置数据缩写的方法。GetMaterialAbbreviation（）返回材质或隔热层或双层壁材质的缩写。GetSpecificationAbbreviation（）返回给定规范的规范缩写，GetInsulationSpecificationAbbreviation（）将返回给定绝缘规范的缩写。</p>
<p><strong>预制件服务</strong></p>
<p>预制零件服务是预制零件配置的一部分，定义可以使用哪些预制零件服务按钮。GroupCount属性返回服务中的组数。使用组的索引，可以调用GetGroupName（）来获取组的名称。方法GetButtonCount（）将返回指定组中的按钮数量，实际按钮可以通过调用GetButton（）与指定的组索引和按钮索引来检索。</p>
<p><strong>预制件服务按钮</strong></p>
<p>FabricationServiceButton类包含有关预制件按钮的信息。预制件服务按钮定义可用于定义FabricationPart的项目，可能受特定条件列表的约束。预制零件服务按钮是预制件服务的一部分。</p>
<p><strong>预制零件</strong></p>
<p>使用FabricationPart类，用户可以在Revit模型中创建、放置、移动和对齐预制零件。用户还可以获取或设置预制零件的尺寸，并获取预制托管信息和杆信息。</p>
<p>重载的静态FabricationPart.Create（）方法基于预制服务按钮创建一个新的预制零件。重载的静态Hanger（）方法在另一个预制零件上创建一个悬挂件。静态AlignPartByConnectors（）方法将移动预制零件，并通过其中一个连接器将其与另一个连接器对齐。</p>
<p>也可以使用DesignToFabricationConverter类从设计元素创建FabricationParts。Convert（）方法将一组MEP设计元素转换为预制零件。可以使用GetConvertedFabricationParts（）方法获取成功创建的FabricationParts。如果Convert（）方法指示部分失败，则GetPartialConvertFailureResults（）方法将返回可能失败的列表。对于部分故障类型（例如InvalidConnections），DesignToFabricationConverter类有一个对应的方法来检索具有该错误类型的FabricationParts的ElementId列表（例如GetConvertedFabricationPartsWithInvalidConnections（））。</p>
<p>还存在获得和设置预制尺寸的值、获得主元件信息和获得预制杆信息的方法。</p>
<p>连接和位置</p>
<p>FabricationPart有许多方法可以附加到连接器或更改FabricationPart的位置。静态StretchAndFit（）方法支持从指定的连接器拉伸加工零件并装配到目标布线端的操作。路由端表示为FabricationPartRouteEnd对象，该对象可以从静态FabricationPartRouteEnd. fromConnector（）或FabricationPartRouteEnd. fromCenterline（）方法中获取。如果StretchAndFit（）方法失败，它将返回一个FabricationPartFitResult枚举，该枚举提供有关失败的更多详细信息。</p>
<p>修改FabricationPart的其他方法包括Reposition（）、RotateConnectedPartByConnector（）和PlaceAsTap（）。</p>
<p>产品清单</p>
<p>某些FabricationPart图元（如购买的风管和管件）具有“产品列表”。产品列表条目表示选定零件的可用尺寸的目录。ProductListEntry属性指定FabricationPart的产品列表项。如果IsProductList（）方法返回false，ProductListEntry将为-1。</p>
<p>要获取FabricationPart的产品条目列表，请使用GetProductListEntryCount（）和GetProductListEntryName（）方法。在更改FabricationPart的ProductListEntry之前，请调用IsProductListEntryEntrySize（）以检查是否可以将此Part更改为指定的产品列表条目而不更改任何连接的尺寸。</p>
<h2 id="族创建"><a href="#族创建" class="headerlink" title="族创建"></a>族创建</h2><p>在Revit族文档中创建机械设备时，需要添加接头以允许设备连接到系统。风管、电气和管道连接件都可以类似的方式添加，方法是使用将放置连接件的参照平面和连接件的系统类型。</p>
<p>ConnectorElement类提供的重载静态方法有：</p>
<ul>
<li>CreateCableTrayConnector </li>
<li>CreateConduitConnector </li>
<li>CreateDuctConnector </li>
<li>CreateElectricalConnector </li>
<li>CreatePipeConnector</li>
</ul>
<p>上面的每个方法都有第二个重载，该重载接受一个附加的Edge参数，该参数允许创建以给定面的内部循环为中心的连接器元素。下面的代码演示如何将两个管道连接件添加到拉伸上的面，并设置它们的一些属性。</p>
<p>代码区域30 - 6：添加管道连接件</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">CreatePipeConnectors</span>(<span class="params">UIDocument uiDocument, Extrusion extrusion</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">// get the faces of the extrusion</span></span><br><span class="line">        Options geoOptions = uiDocument.Document.Application.Create.NewGeometryOptions();</span><br><span class="line">        geoOptions.View = uiDocument.Document.ActiveView;</span><br><span class="line">        geoOptions.ComputeReferences = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        List planarFaces = <span class="keyword">new</span> List();</span><br><span class="line">        Autodesk.Revit.DB.GeometryElement geoElement = extrusion.get_Geometry(geoOptions);</span><br><span class="line">        <span class="keyword">foreach</span> (GeometryObject geoObject <span class="keyword">in</span> geoElement)</span><br><span class="line">        &#123;</span><br><span class="line">                Solid geoSolid = geoObject <span class="keyword">as</span> Solid;</span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">null</span> != geoSolid)</span><br><span class="line">                &#123;</span><br><span class="line">                        <span class="keyword">foreach</span> (Face geoFace <span class="keyword">in</span> geoSolid.Faces)</span><br><span class="line">                        &#123;</span><br><span class="line">                                <span class="keyword">if</span> (geoFace <span class="keyword">is</span> PlanarFace)</span><br><span class="line">                                &#123;</span><br><span class="line">                                        planarFaces.Add(geoFace <span class="keyword">as</span> PlanarFace);</span><br><span class="line">                                &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (planarFaces.Count &gt; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="comment">// Create the Supply Hydronic pipe connector</span></span><br><span class="line">                ConnectorElement connSupply = ConnectorElement.CreatePipeConnector(uiDocument.Document,</span><br><span class="line">                                                                                   PipeSystemType.SupplyHydronic,</span><br><span class="line">                                                                                   planarFaces[<span class="number">0</span>].Reference);</span><br><span class="line">                Parameter param = connSupply.get_Parameter(BuiltInParameter.CONNECTOR_RADIUS);</span><br><span class="line">                param.Set(<span class="number">1.0</span>); <span class="comment">// 1&#x27; radius</span></span><br><span class="line">                param = connSupply.get_Parameter(BuiltInParameter.RBS_PIPE_FLOW_DIRECTION_PARAM);</span><br><span class="line">                param.Set(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Create the Return Hydronic pipe connector</span></span><br><span class="line">                ConnectorElement connReturn =  ConnectorElement.CreatePipeConnector(uiDocument.Document,</span><br><span class="line">                                                                                    PipeSystemType.ReturnHydronic,</span><br><span class="line">                                                                                    planarFaces[<span class="number">1</span>].Reference);</span><br><span class="line">                param = connReturn.get_Parameter(BuiltInParameter.CONNECTOR_RADIUS);</span><br><span class="line">                param.Set(<span class="number">0.5</span>); <span class="comment">// 6&quot; radius</span></span><br><span class="line">                param = connReturn.get_Parameter(BuiltInParameter.RBS_PIPE_FLOW_DIRECTION_PARAM);</span><br><span class="line">                param.Set(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下图说明了在使用“机械设备”样板创建的新族文档中运行此示例并传入拉伸2’×2’× 1 ‘的结果。请注意，连接件放置在平面的质心处。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-9971E21F-AE7B-4FF3-9251-A91C6DEAA663-low.png"></p>
<p>图169：在拉伸上创建的两个连接器</p>
<h2 id="机械设置"><a href="#机械设置" class="headerlink" title="机械设置"></a>机械设置</h2><p>“MEP设置-机械设置”下的“管理”选项卡上提供的许多设置也可通过Revit API使用。</p>
<p><strong>管道设置</strong></p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/MechPipeSettings.png"></p>
<p>管道设置</p>
<p>PipeSettings类提供对上面显示的设置的访问，例如“管道尺寸后缀”和“管道接头公差”。每个文档都有一个PipeSettings对象，可以通过静态方法PipeSettings.GetPipeSettings（）访问该对象。</p>
<p>拟合角度</p>
<p>管道的管件角度使用设置可从PipeSettings类的以下属性和方法中获得：</p>
<ul>
<li>PipeSettings.FittingAngleUsage</li>
<li>PipeSettings.GetSpecificFittingAngles()</li>
<li>PipeSettings.GetSpecificFittingAngleStatus()</li>
<li>PipeSettings.SetSpecificFittingAngleStatus()</li>
</ul>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/MechPipeAngleSettings.png" alt="img"></p>
<p><strong>管件角度</strong></p>
<p>分段和尺寸</p>
<p>UI中的“管道设置-分段和尺寸”下的设置也可用。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/MechPipeSizesSettings.png" alt="img"></p>
<p>分段和尺寸</p>
<p>此信息可通过Segment和MEPSize类获得。段表示包含材质和一组可用尺寸的MEPCurve的长度。管道尺寸由MEPSize类表示。可用的段可以使用过滤器找到。下面的例子演示了如何在上面的对话框中获取一些信息。</p>
<p>代码区域：管道设置中的导线测量管道尺寸</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">FilteredElementCollector collectorPipeType = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">collectorPipeType.OfClass(<span class="keyword">typeof</span>(Segment));</span><br><span class="line"></span><br><span class="line">IEnumerable segments = collectorPipeType.ToElements().Cast();</span><br><span class="line"><span class="keyword">foreach</span> (Segment segment <span class="keyword">in</span> segments)</span><br><span class="line">&#123;</span><br><span class="line">    StringBuilder strPipeInfo = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    strPipeInfo.AppendLine(<span class="string">&quot;Segment: &quot;</span> + segment.Name);</span><br><span class="line"></span><br><span class="line">    strPipeInfo.AppendLine(<span class="string">&quot;Roughness: &quot;</span> + segment.Roughness);</span><br><span class="line"></span><br><span class="line">    strPipeInfo.AppendLine(<span class="string">&quot;Pipe Sizes:&quot;</span>);</span><br><span class="line">    <span class="built_in">double</span> dLengthFac = <span class="number">304.8</span>;  <span class="comment">// used to convert stored units from ft to mm for display</span></span><br><span class="line">    <span class="keyword">foreach</span> (MEPSize size <span class="keyword">in</span> segment.GetSizes())</span><br><span class="line">    &#123;</span><br><span class="line">        strPipeInfo.AppendLine(<span class="built_in">string</span>.Format(<span class="string">&quot;Nominal: &#123;0:F3&#125;, ID: &#123;1:F3&#125;, OD: &#123;2:F3&#125;&quot;</span>,</span><br><span class="line">                                    size.NominalDiameter  dLengthFac, size.InnerDiameter  dLengthFac, size.OuterDiameter * dLengthFac));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TaskDialog.Show(<span class="string">&quot;PipeSetting Data&quot;</span>, strPipeInfo.ToString());</span><br><span class="line">    <span class="keyword">break</span>;&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/PipeSettingsExample.jpg"></p>
<p>上一个示例的输出</p>
<p>若要向列表中添加新大小，请使用Segment.AddSize（）方法。使用Segment.RemoveSize（）按公称直径删除尺寸。</p>
<p>坡度</p>
<p>PipeSettings类还提供对UI中“管道设置-坡度”下可用坡度值的访问。使用GetPipeSlopes（）检索坡度值列表。PipeSettings.SetPipeSlopes（）提供一次设置所有坡度值的功能，而PipeSettings.AddPipeSlope（）添加单个管道坡度。Revit将坡度值存储为百分比（0-100）。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/MechPipeSlopeSettings.png" alt="img"></p>
<p>管道坡度值</p>
<p><strong>风管设置</strong></p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/MechDuctSettings.png"></p>
<p>风管设置</p>
<p>通过DuctSettings类可以访问上面显示的设置，例如“风管管件注释尺寸”和“空气密度”。每个文档都有一个DuctSettings对象，可以通过静态方法DuctSettings.GetDuctSettings（）访问该对象。</p>
<p>风管管件角度</p>
<p>风管的管件角度使用设置可从DuctSettings类的以下特性和方法中获得：</p>
<ul>
<li>DuctSettings.FittingAngleUsage</li>
<li>DuctSettings.GetSpecificFittingAngles()</li>
<li>DuctSettings.GetSpecificFittingAngleStatus()</li>
<li>DuctSettings.SetSpecificFittingAngleStatus()</li>
</ul>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/MechDuctAngleSettings.png" alt="img"></p>
<p>风管管件角度</p>
<h2 id="电气设置"><a href="#电气设置" class="headerlink" title="电气设置"></a>电气设置</h2><p>在“MEP设置-电气设置”下的“管理”选项卡上提供的某些设置也可通过Revit API使用。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/ElectricalSettings.png"></p>
<p>电气设置</p>
<p>ElectricalSettings类提供对不同电气设置的访问，例如管件角度、导线类型和电压类型。每个文档都有一个ElectricalSettings对象，可以通过静态方法ElectricalSetting.GetElectricalSettings（）访问该对象。</p>
<p> 常规设置</p>
<p>以下常规设置可用作ElectricalSetting类的属性：</p>
<ul>
<li>CircuitSequence - 访问回路序列编号模式</li>
<li>CircuitNamePhaseA - 按相位访问回路命名（相位A标签）。</li>
<li>CircuitNamePhaseB -按相位访问回路命名（相位B标签）。</li>
<li>CircuitNamePhaseC - 按相位访问回路命名（相位C标签）。</li>
</ul>
<p>拟合角度</p>
<p>电缆桥架和套管的装配角度设置可通过以下ElectricalSettings类的方法获得：</p>
<ul>
<li>GetSpecificFittingAngles()</li>
<li>GetSpecificFittingAngleStatus()</li>
<li>SetSpecificFittingAngleStatus()</li>
</ul>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/ElectricalAnglesSettings.png" alt="img"></p>
<p>拟合角度</p>
<p>其他电气设置</p>
<p>ElectricalSetting类的属性提供对以下内容的访问：</p>
<ul>
<li>Distribution System Types 配电系统类型</li>
<li>Voltage Types 电压类型</li>
<li>Wire Conduit Types 导线管类型</li>
<li>Wire Material Types 线材类型</li>
<li>Wire Types 导线类型</li>
</ul>
<p>还可以使用方法在项目中添加或删除配电系统类型、电压类型、导线材质类型和导线类型。</p>
<h2 id="布管系统配置"><a href="#布管系统配置" class="headerlink" title="布管系统配置"></a>布管系统配置</h2><p>布管系统配置可以通过RollingPreferenceManager类访问。此类的实例可从MEPCurveType类的属性中获得。目前，只有PipeType和DuctType支持布管系统配置。</p>
<p>ChalleningPreferenceManager管理用于选择段类型和尺寸以及基于用户选择标准的管接头类型的所有规则。ExcluingPreferenceRule类管理一个管段或管接头首选项，该类的实例可以添加到ExcluingPreferenceManager中。每个工艺路线首选项规则根据管理的工艺路线物料类型进行分组。该类型由PreferenceRuleGroupType表示，并包括以下选项：</p>
<table>
<thead>
<tr>
<th>**Member name **</th>
<th>**Description **</th>
</tr>
</thead>
<tbody><tr>
<td>Undefined</td>
<td>未定义的组类型（默认初始值）</td>
</tr>
<tr>
<td>Segments</td>
<td>分段类型（例如：管材）</td>
</tr>
<tr>
<td>Elbows</td>
<td>弯头类型</td>
</tr>
<tr>
<td>Junctions</td>
<td>接头类型（例如接头、T形接头、Y形接头、分接头）</td>
</tr>
<tr>
<td>Crosses</td>
<td>交叉类型</td>
</tr>
<tr>
<td>Transitions</td>
<td>过渡类型（请注意，多形状过渡可能有自己的组）</td>
</tr>
<tr>
<td>Unions</td>
<td>将两个段连接在一起的联合类型</td>
</tr>
<tr>
<td>MechanicalJoints</td>
<td>将管接头连接到管接头、管段连接到管接头或管段连接到管段的机械联接类型</td>
</tr>
<tr>
<td>TransitionsRectangularToRound</td>
<td>从矩形型材到圆形型材的多形状过渡</td>
</tr>
<tr>
<td>TransitionsRectangularToOval</td>
<td>从矩形型材到椭圆形型材的多种形状过渡</td>
</tr>
<tr>
<td>TransitionsOvalToRound</td>
<td>从椭圆形轮廓到圆形轮廓的多种形状过渡</td>
</tr>
</tbody></table>
<p>每个布管系统配置规则都可以具有一个或多个选择条件（由PrimaryCriterionBase类和派生类型PrimarySizeCriterion表示）。PrimarySizeCriterion基于最小和最大尺寸约束选择管件和管段。 BullingConditions类保存BullingCondition实例的集合。BullingCondition类表示在确定是否满足布线条件（如最小或最大直径）时用作输入的布线信息。GetMEPPartId（）方法基于一个PreferenceRuleGroupType和PreferenceConditions获取一个管接头或管段ID。 以下示例获取文档中的所有管道类型，获取每种管道类型的布管系统配置管理器，然后根据布管系统配置管理器中的规则获取每个管段的尺寸。</p>
<p>代码区域：使用布管系统配置</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> List <span class="title">GetAvailablePipeSegmentSizesFromDocument</span>(<span class="params">Document document</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    System.Collections.Generic.HashSet sizes = <span class="keyword">new</span> HashSet();</span><br><span class="line"></span><br><span class="line">    FilteredElementCollector collectorPipeType = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">    collectorPipeType.OfClass(<span class="keyword">typeof</span>(PipeType));</span><br><span class="line"></span><br><span class="line">    IEnumerable pipeTypes = collectorPipeType.ToElements().Cast();</span><br><span class="line">    <span class="keyword">foreach</span> (PipeType pipeType <span class="keyword">in</span> pipeTypes)</span><br><span class="line">    &#123;</span><br><span class="line">        RoutingPreferenceManager rpm = pipeType.RoutingPreferenceManager;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">int</span> segmentCount = rpm.GetNumberOfRules(RoutingPreferenceRuleGroupType.Segments);</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> index = <span class="number">0</span>; index != segmentCount; ++index)</span><br><span class="line">        &#123;</span><br><span class="line">            RoutingPreferenceRule segmentRule = rpm.GetRule(RoutingPreferenceRuleGroupType.Segments, index);</span><br><span class="line">            Segment segment = document.GetElement(segmentRule.MEPPartId) <span class="keyword">as</span> Segment;</span><br><span class="line">            <span class="keyword">foreach</span> (MEPSize size <span class="keyword">in</span> segment.GetSizes())</span><br><span class="line">            &#123;</span><br><span class="line">                sizes.Add(size.NominalDiameter);  <span class="comment">//Use a hash-set to remove duplicate sizes among Segments and PipeTypes.</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    List sizesSorted = sizes.ToList();</span><br><span class="line">    sizesSorted.Sort();</span><br><span class="line">    <span class="keyword">return</span> sizesSorted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="注：翻译自Revit-API-Developers-Guide"><a href="#注：翻译自Revit-API-Developers-Guide" class="headerlink" title="注：翻译自Revit API Developers Guide"></a><em><strong>注：</strong></em>翻译自<a href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_html">Revit API Developers Guide</a></h2>]]></content>
      <categories>
        <category>Revit二次开发人员指南</category>
      </categories>
      <tags>
        <tag>Revit</tag>
      </tags>
  </entry>
  <entry>
    <title>25建筑</title>
    <url>/2024/12/24/Revit%E4%BA%8C%E5%BC%80%E6%8C%87%E5%8D%97/25%E5%BB%BA%E7%AD%91/</url>
    <content><![CDATA[<h1 id="建筑"><a href="#建筑" class="headerlink" title="建筑"></a>建筑</h1><p>本章介绍特定于Revit建筑功能的API功能：</p>
<ul>
<li>与房间相关的功能（Element.Room、RoomTag等）</li>
</ul>
<p> 本节中的主题</p>
<ul>
<li>Rooms</li>
</ul>
<h2 id="房间"><a href="#房间" class="headerlink" title="房间"></a>房间</h2><p><strong>Rooms</strong> </p>
<p>以下各节介绍了有关房间类、其参数以及如何在API中使用房间类的信息。</p>
<p>Room类用于表示房间和图元，例如房间明细表和面积平面。下表列出了API中不同房间、面积及其对应标签的属性和创建函数：</p>
<p><strong>表55：房间、面积和标签关系</strong></p>
<table>
<thead>
<tr>
<th>**Element **</th>
<th>**Class **</th>
<th>**Category **</th>
<th>**Boundary **</th>
<th>**Location **</th>
<th>**Can Create **</th>
</tr>
</thead>
<tbody><tr>
<td>Room in Plan View</td>
<td>Room</td>
<td>OST_Rooms</td>
<td>在封闭区域中有</td>
<td>LocationPoint</td>
<td>NewRoom（），NewRoom（Phase）除外</td>
</tr>
<tr>
<td>Room in Schedule View</td>
<td>Room</td>
<td>OST_Rooms</td>
<td>Null</td>
<td>Null</td>
<td>NewRoom(Phase)</td>
</tr>
<tr>
<td>Area</td>
<td>Room</td>
<td>OST_Areas</td>
<td>总是有</td>
<td>LocationPoint</td>
<td>No</td>
</tr>
<tr>
<td>Room Tag</td>
<td>RoomTag</td>
<td>OST_RoomTags</td>
<td></td>
<td>LocationPoint</td>
<td>Creation.Document.NewRoomTag()</td>
</tr>
<tr>
<td>Area Tag</td>
<td>FamilySymbol</td>
<td>OST_AreaTags</td>
<td></td>
<td>LocationPoint</td>
<td>No</td>
</tr>
</tbody></table>
<p>注：房间名称是房间名称和房间号的组合。例如，对于编号为2且名称为“Master Bedroom”的房间，Room.Name将返回“Master Bedroom 2”。使用ROOM_NAME内置参数获取房间名称。</p>
<p>注意：作为注释元素，特定视图可使用RoomTag. View。不要尝试设置RoomTag.Name属性，因为该名称是自动分配的;否则将引发异常。</p>
<p><strong>创建房间</strong></p>
<p>下面的代码演示了在特定楼层的某个点创建房间的最简单方法：</p>
<p>代码区域28-1：创建房间</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function">Room <span class="title">CreateRoom</span>(<span class="params">Autodesk.Revit.DB.Document document, Level level</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">// Create a UV structure which determines the room location</span></span><br><span class="line">        UV roomLocation = <span class="keyword">new</span> UV(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create a new room</span></span><br><span class="line">        Room room = document.Create.NewRoom(level, roomLocation);</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == room)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Create a new room failed.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> room;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以在房间明细表中创建房间，然后将其插入到平面回路中。</p>
<ul>
<li>Document.NewRoom（Phase）方法用于创建不与任何特定位置关联的新文件室，并将其插入到现有明细表中。在拨打电话之前，确保房间时间表存在或在指定阶段创建房间时间表。</li>
<li>Document.NewRoom（Roomroom，PlanCircuit线路）方法用于从明细表中的房间和PlanCircuit创建房间。<ul>
<li>输入房间必须仅存在于房间明细表中，这意味着它不会显示在任何平面视图中。</li>
<li>调用该方法后，将在PlanCircuit所在的视图中创建具有相同名称和编号的模型房间。</li>
</ul>
</li>
</ul>
<p>有关平面电路的详细信息，请参见平面拓扑。</p>
<p>以下代码说明了整个过程：</p>
<p>代码区域28-2：创建房间并将其插入到平面回路中</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function">Room <span class="title">InsertNewRoomInPlanCircuit</span>(<span class="params">Autodesk.Revit.DB.Document document, Level level, Phase newConstructionPhase</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// create room using Phase</span></span><br><span class="line">    Room newScheduleRoom = document.Create.NewRoom(newConstructionPhase);</span><br><span class="line">            </span><br><span class="line">    <span class="comment">// set the Room Number and Name</span></span><br><span class="line">    <span class="built_in">string</span> newRoomNumber = <span class="string">&quot;101&quot;</span>;</span><br><span class="line">    <span class="built_in">string</span> newRoomName = <span class="string">&quot;Class Room 1&quot;</span>;</span><br><span class="line">    newScheduleRoom.Name = newRoomName;</span><br><span class="line">    newScheduleRoom.Number = newRoomNumber;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get a PlanCircuit</span></span><br><span class="line">    PlanCircuit planCircuit = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// first get the plan topology for given level</span></span><br><span class="line">    PlanTopology planTopology = document.get_PlanTopology(level);</span><br><span class="line">            </span><br><span class="line">    <span class="comment">// Iterate circuits in this plan topology</span></span><br><span class="line">    <span class="keyword">foreach</span> (PlanCircuit circuit <span class="keyword">in</span> planTopology.Circuits)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// get the first circuit we find</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != circuit)</span><br><span class="line">        &#123;</span><br><span class="line">            planCircuit = circuit;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">           </span><br><span class="line">    Room newRoom2 = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> != planCircuit)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">using</span> (Transaction transaction = <span class="keyword">new</span> Transaction(document, <span class="string">&quot;Create Room&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (transaction.Start() == TransactionStatus.Started)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// The input room must exist only in the room schedule, </span></span><br><span class="line">                <span class="comment">// meaning that it does not display in any plan view.</span></span><br><span class="line">                newRoom2 = document.Create.NewRoom(newScheduleRoom, planCircuit);</span><br><span class="line">                <span class="comment">// a model room with the same name and number is created in the </span></span><br><span class="line">                <span class="comment">// view where the PlanCircuit is located</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">null</span> != newRoom2)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// Give the user some information</span></span><br><span class="line">                    TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>, <span class="string">&quot;Room placed in Plan Circuit successfully.&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                transaction.Commit();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> newRoom2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建房间并将其添加到位置后，可以使用Room.Unplace（）方法将其从该位置删除（但在项目中仍然可用）。然后可以将其放置在新的位置。</p>
<h3 id="房间边界"><a href="#房间边界" class="headerlink" title="房间边界"></a>房间边界</h3><p>房间的边界可在房间所在的位置创建封闭区域。</p>
<ul>
<li>边界包括以下要素：<ul>
<li>Walls  </li>
<li>Model lines  </li>
<li>Columns  </li>
<li>Roofs</li>
</ul>
</li>
</ul>
<h4 id="检索房间边界"><a href="#检索房间边界" class="headerlink" title="检索房间边界"></a>检索房间边界</h4><p>房间周围的边界是从基类方法SpatialElement.GetBoundarySegments（）获得的。当房间不在封闭区域中或仅存在于明细表中时，该方法返回null。每个房间可能有几个区域，每个区域都有几个段，因此数据以BoundarySegment列表的形式返回。</p>
<p>下图显示了在Revit UI中选择的房间边界：</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/CHS/Revit-API/images/GUID-4FEC99FB-5F16-4343-8475-ECFF367CB072.png" alt="img"></p>
<p>图138：房间边界</p>
<p>线段列表的大小取决于封闭区域拓扑。每个BoundarySegment列表都创建一个回路或一条连续的线，其中一个线段连接到下一个线段。下面的图片提供了几个例子。在下面的图片中，所有墙都是“房间边界”，模型线类别为OST_AreaSeparationLines。如果某个图元不是“房间边界”，则将其从图元中排除以形成边界。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/CHS/Revit-API/images/GUID-792A1532-E1EE-4186-894F-F593C930B2A6.png" alt="img"></p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/CHS/Revit-API/images/GUID-C259DDE9-9A9E-457F-87C3-3D686A8A9359.png"></p>
<p>下表提供了之前房间的Room.GetBoundarySegments（）.Size结果：</p>
<p><strong>表56：Room.GetBoundarySegments（）.Size</strong></p>
<table>
<thead>
<tr>
<th><strong>Room 房间</strong></th>
<th>**Room.GetBoundarySegments().Size **</th>
</tr>
</thead>
<tbody><tr>
<td>Room 1、2、3</td>
<td>1</td>
</tr>
<tr>
<td>Room 4</td>
<td>2</td>
</tr>
<tr>
<td>Room 5、6</td>
<td>3</td>
</tr>
</tbody></table>
<p>注意：由模型线连接的墙被视为连续的线段。单个模型线将被忽略。</p>
<p>获取IList&lt;IList<BoundarySegment>后，通过迭代列表获取BoundarySegment。</p>
<p><strong>BoundarySegment</strong> </p>
<p>构成区域的线段由BoundarySegment类表示;其ElementId属性返回对应元素的id，条件如下：</p>
<ul>
<li>对于ModelCurve元素，类别必须是BuiltInCategory.OST_AreaSeparationLines，这意味着它表示房间分隔符。</li>
<li>对于墙、柱和屋顶等其他图元，如果图元是房间边界，则“房间边界”参数（BuiltInParameter.WALL_ATTR_ROOM_BOUNDING）必须为真，如下图所示。</li>
</ul>
<p><img src="https://help.autodesk.com/cloudhelp/2018/CHS/Revit-API/images/GUID-FBC69AE1-EF76-4773-AC4A-7CBCC77EE924.png" alt="img"></p>
<p>图141：房间边界属性</p>
<p>WALL_ATTR_ROOM_BOUNDING内置参数通过API设置：</p>
<p>代码区域28-3：设置房间边界</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetRoomBounding</span>(<span class="params">Wall wall</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        Parameter parameter = wall.get_Parameter(BuiltInParameter.WALL_ATTR_ROOM_BOUNDING);</span><br><span class="line">        parameter.Set(<span class="number">1</span>);   <span class="comment">//set &quot;Room Bounding&quot; to true</span></span><br><span class="line">        parameter.Set(<span class="number">0</span>);   <span class="comment">//set &quot;Room Bounding&quot; to false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请注意，在下面的图片中，屋顶如何形成房间的BoundarySegment。第一张图片显示立面视图中的Level 3。将在Level 3楼层视图中创建房间。后两张图片显示了房间和房子的3D视图的边界。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/CHS/Revit-API/images/GUID-067191A0-12EA-430F-B145-6B8D5D6E596E.png" alt="img"></p>
<p>图142：在标高3视图中创建的房间</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/CHS/Revit-API/images/GUID-862FFB79-21A7-4F5A-B949-B442529EF50E.png"></p>
<p><strong>图143：</strong>屋顶形成的房间边界</p>
<p>面积边界只能是类别为面积边界（BuiltInCategory.OST_AreaSchemeLines）的ModelCurve，而显示房间的边界可以是墙和其他图元。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/CHS/Revit-API/images/GUID-8B918B3C-ED10-486C-912A-9D4A1F8CC4EA.png"></p>
<p>图144：墙端边缘</p>
<p>如果BoundarySegment对应于房间分隔和墙之间的曲线，如上图所示：</p>
<ul>
<li>Element属性返回null</li>
<li>曲线不为空。</li>
</ul>
<p><strong>边界与事务</strong></p>
<p>在使用API创建了一个元素（如墙）之后，如果调用Room.GetBoundarySegments（），墙可以更改房间边界。您必须确保数据已更新。</p>
<p>下图显示了使用Revit Platform API创建墙后房间的变化。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/CHS/Revit-API/images/GUID-5410C3CF-324E-4C38-9152-BA29AB5D6CA1.png" alt="img"></p>
<p>图145：添加的墙更改房间边界</p>
<p>要更新房间边界数据，请使用以下代码中的事务机制：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">UpdateRoomBoundary</span>(<span class="params">UIApplication application, Room room, Level level</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Document document = application.ActiveUIDocument.Document;</span><br><span class="line">            </span><br><span class="line">    <span class="comment">//Get the size before creating a wall</span></span><br><span class="line">    <span class="built_in">int</span> size = room.GetBoundarySegments(<span class="keyword">new</span> SpatialElementBoundaryOptions()).First().Count;</span><br><span class="line">    <span class="built_in">string</span> message = <span class="string">&quot;Room boundary size before wall: &quot;</span> + size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Prepare a line</span></span><br><span class="line">    XYZ startPos = <span class="keyword">new</span> XYZ(<span class="number">-10</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    XYZ endPos = <span class="keyword">new</span> XYZ(<span class="number">10</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    Line line = Line.CreateBound(startPos, endPos);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Create a new wall and enclose the creating into a single transaction</span></span><br><span class="line">    <span class="keyword">using</span> (Transaction transaction = <span class="keyword">new</span> Transaction(document, <span class="string">&quot;Create Wall&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (transaction.Start() == TransactionStatus.Started)</span><br><span class="line">        &#123;</span><br><span class="line">            Wall wall = Wall.Create(document, line, level.Id, <span class="literal">false</span>);</span><br><span class="line">            <span class="keyword">if</span> (<span class="literal">null</span> != wall)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (TransactionStatus.Committed == transaction.Commit())</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//Get the new size</span></span><br><span class="line">                    size = room.GetBoundarySegments(<span class="keyword">new</span> SpatialElementBoundaryOptions()).First().Count;</span><br><span class="line">                    message += <span class="string">&quot;\nRoom boundary size after wall: &quot;</span> + size;</span><br><span class="line">                    TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>, message);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                transaction.RollBack();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有关详细信息，请参阅事务。</p>
<p><strong>平面拓扑</strong></p>
<p>房间所在的标高平面具有由墙和房间分隔线等图元构成的拓扑。PlanTopology和PlanCircuit类用于表示标高拓扑。</p>
<ul>
<li>使用Level从Document对象获取PlanTopology对象。在每个平面视图中，每个阶段对应一个PlanTopology。</li>
<li>相同的条件适用于BoundarySegment，但房间分隔符和房间边界参数为true的元素可以是PlanCircuit中的边（边界）。</li>
</ul>
<p><img src="https://help.autodesk.com/cloudhelp/2018/CHS/Revit-API/images/GUID-E0715B88-5A70-4424-8268-E1CAD3D5EEFF.png" alt="img"></p>
<p>图146：房间和平面拓扑图</p>
<p>PlanCircuit.Sideship属性返回线路边编号，而SpatialElement.GetBoundarySegments（）返回IList&lt;IList&lt;Autodesk.Revit.DB.BoundarySegment&gt;，其Count与线路边编号不同。</p>
<ul>
<li>如果墙上有分支，则SpatialElement.GetBoundarySegments（）将底墙识别为两面墙。</li>
<li>PlanCircuit.无论分支的数量如何，Sideball总是将图片中的底墙视为一个。</li>
</ul>
<p><img src="https://help.autodesk.com/cloudhelp/2018/CHS/Revit-API/images/GUID-25504A29-2C29-409B-AFF6-916CD359E8C2.png" alt="img"></p>
<p>图147：比较房间边界与PlanCircuit</p>
<p>表57：房间边界与平面回路的比较</p>
<table>
<thead>
<tr>
<th>**Circuit **</th>
<th><strong>Circuit.SideNum</strong></th>
<th>**IList&lt;IList&lt;Autodesk.Revit.DB.BoundarySegment&gt; .Count for Room **</th>
</tr>
</thead>
<tbody><tr>
<td>Circuit 1</td>
<td>3</td>
<td>3 (Room1)</td>
</tr>
<tr>
<td>Circuit 2</td>
<td>4 +2 &#x3D; 6</td>
<td>4 +3 &#x3D; 7 (Room2)</td>
</tr>
<tr>
<td>Circuit 3</td>
<td>3 +2 &#x3D; 5</td>
<td>3 +3 &#x3D; 6 (Room3)</td>
</tr>
<tr>
<td>Circuit 4</td>
<td>3</td>
<td>3 (Room4)</td>
</tr>
<tr>
<td>Circuit 5</td>
<td>3</td>
<td>3 (Room5)</td>
</tr>
</tbody></table>
<p><strong>房间和族实例</strong></p>
<p>“门”和“窗”是与“房间”相关的特殊族实例。这里只讨论门，因为唯一的区别是窗户没有翻转把手。</p>
<p>以下特性适用于门：</p>
<ul>
<li>门元素可以在没有房间的情况下存在。</li>
<li>在API中（仅在API中），Door元素具有两个附加属性，它们引用门的两个相对侧上的区域：ToRoom和FromRoom</li>
<li>如果区域是房间，则属性的值将是房间元素。</li>
<li>如果区域不是房间，则属性将返回null。两个属性可以同时为null。</li>
<li>门打开的一侧的区域将是ToRoom。另一边的房间将是FromRoom。</li>
<li>每当相应的区域发生变化时，这两个属性都会动态更新。</li>
</ul>
<p>在下面的图片中，五扇门插入到墙中，而不翻转饰面。该表列出了每个门的FromRoom、ToRoom和Room属性。房间属性属于所有族实例。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/CHS/Revit-API/images/GUID-B05F86CE-DD91-401E-BD6C-67704F9BE55C.png" alt="img"></p>
<p>Figure 148: Door 1 </p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/CHS/Revit-API/images/GUID-4D623C2A-40AC-44D0-86E5-14D00C649014.png" alt="img"></p>
<p>Figure 149: Door 2 </p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/CHS/Revit-API/images/GUID-97032EDC-973A-4DD0-A314-3796F3E52F1E.png" alt="img"></p>
<p>Figure 150: Door 3 </p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/CHS/Revit-API/images/GUID-25B7F1B6-3F62-4607-A2DC-AA38B4CBE0D1.png" alt="img"></p>
<p>Figure 151: Door 4</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/CHS/Revit-API/images/GUID-BEB8BE84-3D6F-4E7E-A87D-0FE6C7CB6D3F.png" alt="img"></p>
<p>Figure 152: Door 5 </p>
<p><strong>表58：门属性</strong></p>
<table>
<thead>
<tr>
<th>**Door **</th>
<th><strong>FromRoom</strong></th>
<th><strong>ToRoom</strong></th>
<th><strong>Room 房间</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Door 1</td>
<td>null</td>
<td>null</td>
<td>null</td>
</tr>
<tr>
<td>Door 2</td>
<td>Room 1</td>
<td>null</td>
<td>null</td>
</tr>
<tr>
<td>Door 3</td>
<td>Room 3</td>
<td>Room 2</td>
<td>Room 2</td>
</tr>
<tr>
<td>Door 4</td>
<td>Room 4</td>
<td>null</td>
<td>null</td>
</tr>
<tr>
<td>Door 5</td>
<td>null</td>
<td>Room 6</td>
<td>Room 6</td>
</tr>
</tbody></table>
<p>所有族实例都具有“房间”属性，该属性是实例在上一个项目阶段中所在的房间。窗户和门都面对着一个房间。通过翻转门或窗的朝向或调用FamilyInstance.FlipFromToRoom（）来更改房间。对于其他类型的实例（如梁和柱），“房间”是与实例具有相同边界的房间。</p>
<p>下面的代码演示了如何从族实例中获取Room。需要检查结果是否为null。</p>
<p>代码区域28-5：从族实例获取房间</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetRoomInfo</span>(<span class="params">FamilyInstance familyInstance</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        Room room = familyInstance.Room;</span><br><span class="line">        room = familyInstance.FromRoom;  <span class="comment">//for door and window family only</span></span><br><span class="line">        room = familyInstance.ToRoom;    <span class="comment">//for door and window family only</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != room)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="comment">//use the room...</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>其他房间属性</strong></p>
<p>Room类还有其他几个属性，可用于获取有关对象的信息。房间具有以下只读尺寸属性：</p>
<ul>
<li>Area  </li>
<li>Perimeter </li>
<li>UnboundedHeight</li>
<li>Volume  </li>
<li>ClosedShell</li>
</ul>
<p>此示例显示选定房间的尺寸标注信息。请注意，必须启用体积计算设置，否则房间体积将返回为0。</p>
<p>代码区域28-6：获取房间的尺寸</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetRoomDimensions</span>(<span class="params">Document doc, Room room</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    String roominfo = <span class="string">&quot;Room dimensions:\n&quot;</span>;</span><br><span class="line">    <span class="comment">// turn on volume calculations:</span></span><br><span class="line">    <span class="keyword">using</span> (Transaction t = <span class="keyword">new</span> Transaction(doc, <span class="string">&quot;Turn on volume calculation&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        t.Start();</span><br><span class="line">        AreaVolumeSettings settings = AreaVolumeSettings.GetAreaVolumeSettings(doc);</span><br><span class="line">        settings.ComputeVolumes = <span class="literal">true</span>;</span><br><span class="line">        t.Commit();</span><br><span class="line">    &#125;</span><br><span class="line">            </span><br><span class="line">    roominfo += <span class="string">&quot;Vol: &quot;</span> + room.Volume + <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    roominfo += <span class="string">&quot;Area: &quot;</span> + room.Area + <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    roominfo += <span class="string">&quot;Perimeter: &quot;</span> + room.Perimeter + <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    roominfo += <span class="string">&quot;Unbounded height: &quot;</span> + room.UnboundedHeight + <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>,roominfo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>房间（或空间）的ClosedShell属性是由房间开放空间的边界（墙、楼板、天花板、屋顶和边界线）形成的几何图形。如果需要检查模型中的其他物理图元与房间的交点，例如，查看图元的一部分或全部是否位于房间中，则此属性非常有用。有关示例，请参见随Revit SDK提供的RoofsRooms示例应用程序，其中ClosedShell用于检查房间是否垂直无边界。</p>
<p>此外，还可以获取或设置具有以下属性的房间的基准偏移和限制偏移：</p>
<ul>
<li>BaseOffset</li>
<li>LimitOffset</li>
</ul>
<p>可以使用UpperLimit属性获取或设置定义房间上限的标高。</p>
<h2 id="注：翻译自Revit-API-Developers-Guide"><a href="#注：翻译自Revit-API-Developers-Guide" class="headerlink" title="注：翻译自Revit API Developers Guide"></a><em><strong>注：</strong></em>翻译自<a href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_html">Revit API Developers Guide</a></h2>]]></content>
      <categories>
        <category>Revit二次开发人员指南</category>
      </categories>
      <tags>
        <tag>Revit</tag>
      </tags>
  </entry>
  <entry>
    <title>26结构工程</title>
    <url>/2024/12/24/Revit%E4%BA%8C%E5%BC%80%E6%8C%87%E5%8D%97/26%E7%BB%93%E6%9E%84%E5%B7%A5%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="结构工程"><a href="#结构工程" class="headerlink" title="结构工程"></a><a href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_Discipline_Specific_Functionality_Structural_Engineering_html">结构工程</a></h1><p>以下各节介绍了仅与Revit的结构工程功能相关的API功能：</p>
<ul>
<li><p>结构模型元素-讨论仅与Revit的结构工程功能相关的特定元素及其属性。</p>
</li>
<li><p>AnalyticalModel -讨论与分析模型相关的类，如AnalyticalModel、RigidLink和AnalyticalModelSupport。</p>
</li>
<li><p>AnalyticalLink -讨论在分析梁和柱之间创建新的分析链接。</p>
</li>
<li><p>荷载-讨论荷载设置和三种荷载。</p>
</li>
</ul>
<p>您的分析链接-为希望将Revit链接到某些Structural Analysis应用程序的API用户提供建议。</p>
<p>本章包含一些高级主题。如果您不熟悉Revit Platform API，请先阅读基本部分，如“入门”、“元素要素”、“参数”等。</p>
<ul>
<li>本节中的主题<ul>
<li>结构模型元素</li>
<li>分析模型<br>在结构工程中，分析模型是结构物理模型的工程描述。</li>
<li>荷载<br>以下部分确定荷载设置并讨论荷载限制指南。</li>
<li>Analysis Link分析链接</li>
<li>Analytical Links</li>
</ul>
</li>
</ul>
<h2 id="结构模型元素"><a href="#结构模型元素" class="headerlink" title="结构模型元素"></a>结构模型元素</h2><p>结构模型元素实际上是支撑结构的元素，如柱、钢筋、桁架等。以下部分介绍如何操作这些元素。</p>
<p>本节中包含的模型元素特定于Revit的结构工程功能。有关其他结构元素类的详细信息，请参见“墙、楼板、屋顶和洞口”和“族”中的相应部分。</p>
<p>本节中的主题</p>
<ul>
<li>结构柱、梁和支撑</li>
<li>桁架</li>
<li>加强<br>Revit API提供了用于管理有效主体（如混凝土柱、梁、墙、基础和结构楼板）中的钢筋（如钢筋、钢筋或钢筋网）的类。</li>
<li>边界条件</li>
<li>板</li>
</ul>
<h3 id="结构柱、梁和支撑"><a href="#结构柱、梁和支撑" class="headerlink" title="结构柱、梁和支撑"></a>结构柱、梁和支撑</h3><p><strong>结构柱、梁和支撑</strong></p>
<p>结构柱、梁和支撑元素都由FamilyInstance类表示。它们由StructuralType属性区分。</p>
<p>代码区域29-1：柱、梁和支撑的区别</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetStructuralType</span>(<span class="params">FamilyInstance familyInstance</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> message = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">switch</span> (familyInstance.StructuralType)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> StructuralType.Beam:</span><br><span class="line">            message = <span class="string">&quot;FamilyInstance is a beam.&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> StructuralType.Brace:</span><br><span class="line">            message = <span class="string">&quot;FamilyInstance is a brace.&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> StructuralType.Column:</span><br><span class="line">            message = <span class="string">&quot;FamilyInstance is a column.&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> StructuralType.Footing:</span><br><span class="line">            message = <span class="string">&quot;FamilyInstance is a footing.&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="literal">default</span>:</span><br><span class="line">            message = <span class="string">&quot;FamilyInstance is non-structural or unknown framing.&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>,message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以使用类别过滤出与结构柱、梁和支撑对应的FamilySymbol对象。结构梁和支撑的类别为BuiltInCategory.OST_StructuralFraming。结构柱的类别为BuiltInCategory.OST_StructuralColumns。</p>
<p>代码区域29-2：使用BuiltInCategory.OST_StructuralFraming</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetBeamAndColumnSymbols</span>(<span class="params">Document document</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    List&lt;FamilySymbol&gt; columnTypes = <span class="keyword">new</span> List&lt;FamilySymbol&gt;();</span><br><span class="line">    List&lt;FamilySymbol&gt; framingTypes = <span class="keyword">new</span> List&lt;FamilySymbol&gt;();</span><br><span class="line">    FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">    ICollection&lt;Element&gt; elements = collector.OfClass(<span class="keyword">typeof</span>(Family)).ToElements();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">foreach</span>(Element element <span class="keyword">in</span> elements)</span><br><span class="line">    &#123;</span><br><span class="line">        Family family = element <span class="keyword">as</span> Family;</span><br><span class="line">        Category category = family.FamilyCategory;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != category)</span><br><span class="line">        &#123;</span><br><span class="line">            ISet&lt;ElementId&gt; familySymbolIds = family.GetFamilySymbolIds();</span><br><span class="line">            <span class="keyword">if</span> ((<span class="built_in">int</span>)BuiltInCategory.OST_StructuralColumns == category.Id.IntegerValue)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">foreach</span> (ElementId id <span class="keyword">in</span> familySymbolIds)</span><br><span class="line">                &#123;</span><br><span class="line">                    FamilySymbol symbol = family.Document.GetElement(id) <span class="keyword">as</span> FamilySymbol;</span><br><span class="line">                    columnTypes.Add(symbol);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((<span class="built_in">int</span>)BuiltInCategory.OST_StructuralFraming == category.Id.IntegerValue)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">foreach</span> (ElementId id <span class="keyword">in</span> familySymbolIds)</span><br><span class="line">                &#123;</span><br><span class="line">                    FamilySymbol symbol = family.Document.GetElement(id) <span class="keyword">as</span> FamilySymbol;</span><br><span class="line">                    framingTypes.Add(symbol);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> message = <span class="string">&quot;Column Types: &quot;</span>;</span><br><span class="line">    <span class="keyword">foreach</span> (FamilySymbol familySymbol <span class="keyword">in</span> columnTypes)</span><br><span class="line">    &#123;</span><br><span class="line">        message += <span class="string">&quot;\n&quot;</span> + familySymbol.Name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>,message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以使用FamilyInstance.ExtensionUtility属性获取和设置梁缩进属性。如果此属性返回null，则无法修改梁缩进。</p>
<p><strong>BeamSystem</strong></p>
<p>BeamSystem提供对梁系统的完全访问和编辑能力。可以获取和设置其所有属性，例如BeamSystemType、BeamType、Direction和Level。方向不限于一条边。它可以设置为与BeamSystem在同一平面上的任何XYZ坐标。</p>
<p>注意：在UI中或通过API更改了Elevation属性后，不能更改StructuralBeam AnalyticalModel。在下图中，梁系统高程更改为10英尺后，分析模型线仍保留在原始位置。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/CHS/Revit-API/images/GUID-1A4BF557-4296-4FE8-BCA3-CD3E1520BA7A.png"></p>
<p>图156：改变梁系统标高</p>
<h3 id="桁架"><a href="#桁架" class="headerlink" title="桁架"></a>桁架</h3><p><strong>桁架</strong></p>
<p>桁架类表示Revit中的所有桁架类型。TrussType属性指示桁架的类型。</p>
<p>代码区域29-7：在两个柱上创建桁架</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function">Truss <span class="title">CreateTruss</span>(<span class="params">Autodesk.Revit.DB.Document document, FamilyInstance column1, FamilyInstance column2</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Truss truss = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">using</span> (Transaction transaction = <span class="keyword">new</span> Transaction(document, <span class="string">&quot;Add Truss&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (transaction.Start() == TransactionStatus.Started)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//sketchPlane</span></span><br><span class="line">            XYZ origin = <span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            XYZ xDirection = <span class="keyword">new</span> XYZ(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            XYZ yDirection = <span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">            XYZ zDirection = <span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">            Plane plane = Plane.Create(<span class="keyword">new</span> Frame(origin, xDirection, yDirection, zDirection));</span><br><span class="line">            SketchPlane sketchPlane = SketchPlane.Create (document, plane);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//new base Line - use line that spans two selected columns</span></span><br><span class="line">            AnalyticalModel frame1 = column1.GetAnalyticalModel() <span class="keyword">as</span> AnalyticalModel;</span><br><span class="line">            XYZ centerPoint1 = (frame1.GetCurve() <span class="keyword">as</span> Line).GetEndPoint(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            AnalyticalModel frame2 = column2.GetAnalyticalModel() <span class="keyword">as</span> AnalyticalModel;</span><br><span class="line">            XYZ centerPoint2 = (frame2.GetCurve() <span class="keyword">as</span> Line).GetEndPoint(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            XYZ startPoint = <span class="keyword">new</span> XYZ(centerPoint1.X, centerPoint1.Y, <span class="number">0</span>);</span><br><span class="line">            XYZ endPoint = <span class="keyword">new</span> XYZ(centerPoint2.X, centerPoint2.Y, <span class="number">0</span>);</span><br><span class="line">            Autodesk.Revit.DB.Line baseLine = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                baseLine = Line.CreateBound(startPoint, endPoint);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (System.ArgumentException)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Selected columns are too close to create truss.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// use the active view for where the truss&#x27;s tag will be placed; View used in</span></span><br><span class="line">            <span class="comment">// NewTruss should be plan or elevation view parallel to the truss&#x27;s base line </span></span><br><span class="line">            Autodesk.Revit.DB.View view = document.ActiveView;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Get a truss type for the truss</span></span><br><span class="line">            FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">            collector.OfClass(<span class="keyword">typeof</span>(FamilySymbol));</span><br><span class="line">            collector.OfCategory(BuiltInCategory.OST_Truss);</span><br><span class="line"></span><br><span class="line">            TrussType trussType = collector.FirstElement() <span class="keyword">as</span> TrussType;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="literal">null</span> != trussType)</span><br><span class="line">            &#123;</span><br><span class="line">                truss = Truss.Create(document, trussType.Id, sketchPlane.Id, baseLine);</span><br><span class="line">                transaction.Commit();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                transaction.RollBack();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;No truss types found in document.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">return</span> truss;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="加强"><a href="#加强" class="headerlink" title="加强"></a>加强</h3><p>Revit API提供了用于管理有效主体（如混凝土柱、梁、墙、基础和结构楼板）中的钢筋（如钢筋、钢筋或钢筋网）的类。</p>
<p>本节中的主题</p>
<ul>
<li>Rebar 钢筋<br>Rebar类表示用于加强适当元素（如混凝土梁、柱、板或基础）的钢筋。</li>
<li>钢筋连接器<br>钢筋连接器用于连接相邻钢筋。</li>
<li>区域和路径钢筋<br>Revit API提供了表示Revit结构要素中的面积钢筋和路径钢筋的类。</li>
<li>织物增强<br>钢筋网是一层由焊接钢丝网制成的钢筋网，并置于混凝土板或墙内。</li>
<li>钢筋容器<br>钢筋容器是表示一个主体中钢筋聚合的元素。此元素只能通过API创建。</li>
<li>钢筋设置<br>有关模型中钢筋的几个设置在文档级别进行控制，并通过文档的ReinfocementSettings类进行访问。</li>
<li>钢筋舍入<br>钢筋修圆是编制施工图的重要内容。钢筋长度公差小于行业或当地标准通常被视为不适用于指定钢筋。</li>
</ul>
<h4 id="钢筋"><a href="#钢筋" class="headerlink" title="钢筋"></a>钢筋</h4><p>Rebar 类表示用于加固合适元素（如混凝土梁、柱、板或基础）的钢筋。</p>
<p> <strong>创建钢筋</strong></p>
<p>您可以使用以下三种静态 Rebar 方法之一创建钢筋对象。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Rebar Rebar.CreateFromCurves(</span><br><span class="line">        Document doc,</span><br><span class="line">        RebarStyle style,</span><br><span class="line">        RebarBarType rebarType,</span><br><span class="line">        RebarHookType startHook,</span><br><span class="line">        RebarHookType endHook,</span><br><span class="line">        Element host,</span><br><span class="line">        XYZ norm,</span><br><span class="line">        IList&lt;Curve&gt; curves,</span><br><span class="line">        RebarHookOrientation startHookOrient,</span><br><span class="line">        RebarHookOrientation endHookOrient,</span><br><span class="line">        <span class="built_in">bool</span> useExistingShapeIfPossible,</span><br><span class="line">        <span class="built_in">bool</span> createNewShape</span><br><span class="line">);<span class="comment">//在项目中创建 Rebar 元素的新实例。所有曲线都必须属于由法线和原点定义的平面。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Rebar Rebar.CreateFromRebarShape(</span><br><span class="line">        Document doc,</span><br><span class="line">        RebarShape rebarShape,</span><br><span class="line">        RebarBarType rebarType,</span><br><span class="line">        Element host,</span><br><span class="line">        XYZ origin,</span><br><span class="line">        XYZ xVec,</span><br><span class="line">        XYZ yVec</span><br><span class="line">);<span class="comment">//创建一个新的 Rebar 作为 RebarShape 的实例。该实例将具有 RebarShape 中的默认形状参数，其位置基于形状定义中形状的边界框。在计算形状的边界框之前，将从形状中删除钩子。如果在文档中可以找到合适的钩子，它们将被任意分配。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Rebar Rebar.CreateFromCurvesAndShape(</span><br><span class="line">        Document doc,</span><br><span class="line">        RebarShape rebarShape,</span><br><span class="line">        RebarBarType rebarType,</span><br><span class="line">        RebarHookType startHook,</span><br><span class="line">        RebarHookType endHook,  </span><br><span class="line">        Element host,</span><br><span class="line">        XYZ norm,</span><br><span class="line">        IList&lt;Curve&gt; curves,</span><br><span class="line">        RebarHookOrientation startHookOrient,</span><br><span class="line">        RebarHookOrientation endHookOrient</span><br><span class="line">);<span class="comment">//在项目中创建 Rebar 元素的新实例。该实例将具有 RebarShape 中的默认形状参数。所有曲线都必须属于由法线和原点定义的平面。</span></span><br></pre></td></tr></table></figure>

<p>第一个版本从描述钢筋的曲线数组创建钢筋，而第二个版本根据 RebarShape 和位置创建 Rebar 对象。第三个版本从曲线数组中基于 RebarShape 创建钢筋。</p>
<p>使用 CreateFromCurves（） 或 CreateFromCurvesAndShape（） 方法时，参数 RebarBarType 和 RebarHookType 在文档的 RebarBarTypes 和 RebarHookTypes 属性中可用。</p>
<p>以下代码说明了如何创建具有特定布局的 Rebar。</p>
<p>代码区域 29-8：创建具有特定布局的钢筋</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function">Rebar <span class="title">CreateRebar</span>(<span class="params">Autodesk.Revit.DB.Document document, FamilyInstance column, RebarBarType barType, RebarHookType hookType</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Define the rebar geometry information - Line rebar</span></span><br><span class="line">    LocationPoint location = column.Location <span class="keyword">as</span> LocationPoint;</span><br><span class="line">    XYZ origin = location.Point;</span><br><span class="line">    XYZ normal = <span class="keyword">new</span> XYZ(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// create rebar 9&#x27; long</span></span><br><span class="line">    XYZ rebarLineEnd = <span class="keyword">new</span> XYZ(origin.X, origin.Y, origin.Z + <span class="number">9</span>);</span><br><span class="line">    Line rebarLine = Line.CreateBound(origin, rebarLineEnd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create the line rebar</span></span><br><span class="line">    IList&lt;Curve&gt; curves = <span class="keyword">new</span> List&lt;Curve&gt;();</span><br><span class="line">    curves.Add(rebarLine);</span><br><span class="line"></span><br><span class="line">    Rebar rebar = Rebar.CreateFromCurves(document, Autodesk.Revit.DB.Structure.RebarStyle.Standard, barType, hookType, hookType,</span><br><span class="line">                        column, origin, curves, RebarHookOrientation.Right, RebarHookOrientation.Left, <span class="literal">true</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> != rebar)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// set specific layout for new rebar as fixed number, with 10 bars, distribution path length of 1.5&#x27;</span></span><br><span class="line">        <span class="comment">// with bars of the bar set on the same side of the rebar plane as indicated by normal</span></span><br><span class="line">        <span class="comment">// and both first and last bar in the set are shown</span></span><br><span class="line">        rebar.GetShapeDrivenAccessor().SetLayoutAsFixedNumber(<span class="number">10</span>, <span class="number">1.5</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rebar;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>有关创建钢筋元素的更多示例，请参见 Revit SDK 附带的钢筋和 NewRebar 示例应用程序。</p>
<p>下表列出了 Parameter REBAR_ELEM_LAYOUT_RULE的整数值：</p>
<p>表 59：钢筋布局规则</p>
<table>
<thead>
<tr>
<th><strong>Value 值</strong></th>
<th><strong>0</strong></th>
<th><strong>1</strong></th>
<th><strong>2</strong></th>
<th><strong>3</strong></th>
<th><strong>4</strong></th>
</tr>
</thead>
<tbody><tr>
<td>描述</td>
<td>None</td>
<td>固定数量</td>
<td>最大间距</td>
<td>带间距的数字</td>
<td>最小净间距</td>
</tr>
</tbody></table>
<p>The Rebar.GetShapeDrivenAccessor().ScaleToBox（） 方法提供了一种同时设置所有形状参数的方法。该行为类似于放置 Rebar 的 UI。</p>
<p><strong>RebarHostData 和 RebarCoverType</strong></p>
<p>明确保护层与有效钢筋主体的各个面关联。可以通过Autodesk.Revit.Elements.RebarHostData对象访问主体的保护层设置。通过参数提供了一种更简单、功能更弱的访问相同设置的机制。</p>
<p>Cover 由命名为偏移的距离定义，建模为 Autodesk.Revit.DB.Structure.RebarCoverType 的元素。</p>
<p><strong>编号</strong></p>
<p>钢筋是可以通过Revit API控制其编号的元素类别之一。NumberingSchema和NumberingSchemaType类可用于定义钢筋元素的组织方式，以便对其进行编号&#x2F;标记。每个NumberingSchema控制一种特定类型的元素的编号。NumberingSchema的元素也是元素，并且每个Revit文档中的每种类型始终只有一个。所有内置编号架构的可用类型都在NumberingSchemaTypes类中枚举。</p>
<p>属于特定模式（例如NumberingSchemaTypes.StructuralNumberingSchemas.Rebar）的元素（例如Rebar）按顺序组织和编号。序列是共享相同编号分区的元素的集合，编号分区由它们各自的分区参数（NUMBER_PARTITION_PARAM）值定义。编号序列必须至少包含一个元素。换句话说，一旦存在至少一个元素，其分区参数具有不同于其他元素（在相同的编号模式中）的值，则建立序列。如果最后一个元素被删除（删除或移动到不同的序列），那么空序列将不再存在。</p>
<p>元素在创建时（基于当时的编号分区值）被分配给序列，方法是显式修改元素的Partition参数或使用AssignElementsToSequence（）方法。AssignElementsToSequence（）方法优于显式更改Partition参数，因为该方法会立即将更改应用于序列和元素编号，而更改的参数仅在当前事务关闭后生效。</p>
<p>除了直接或间接更改元素的Partition参数外，还可以使用NumberingSchema类的方法重新组织编号序列。MoveSequence（）方法将现有序列的所有元素移动到架构中尚不存在的新序列，从而有效地重命名所有受影响元素上的Partition参数。方法的作用是：在应用匹配策略的同时，从一个序列中删除所有元素，并将它们追加到另一个现有序列的元素中。方法MergeSequences（）接受所有指定序列的元素，并将它们全部移动到新创建的序列中。所有合并的元素将重新编号，并根据需要根据匹配算法进行匹配。</p>
<p>下面的示例使用MoveSequence（）方法在两个编号序列中交换Rebar的编号。</p>
<p>代码区域：交换号码</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> This method uses multiple moving operations to swap numbers</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> for Rebars in two numbering sequences. The sequences are</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> identified by the names of two numbering partitions.</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;document&quot;&gt;</span>Document to modify<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;part1&quot;&gt;</span>Name of the partition of one numbering sequence<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;part2&quot;&gt;</span>Name of the partition of another numbering sequence<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">SwapNumberingSequences</span>(<span class="params">Document document, <span class="built_in">string</span> part1, <span class="built_in">string</span> part2</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Obtain a schema object for a particular kind of elements </span></span><br><span class="line">    NumberingSchema schema = NumberingSchema.GetNumberingSchema(document,NumberingSchemaTypes.StructuralNumberingSchemas.Rebar);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> (Transaction transaction = <span class="keyword">new</span> Transaction(document))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Changes to numbering sequences must be made inside a transaction</span></span><br><span class="line">        transaction.Start(<span class="string">&quot;Swap Numbering Sequences&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We will use a temporary partition for the swap operation,</span></span><br><span class="line">        <span class="comment">// for the move operation only works if the target partition </span></span><br><span class="line">        <span class="comment">// does not exist yet in the same numbering schema.</span></span><br><span class="line">        <span class="comment">// (We assume this TEMPORARY partition does not exist.)</span></span><br><span class="line">        <span class="built_in">string</span> tempPartition = <span class="string">&quot;TEMPORARY&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Step 1</span></span><br><span class="line">        <span class="comment">// First we move all elements from one sequence into </span></span><br><span class="line">        <span class="comment">// a partition we know does not exist. This action will</span></span><br><span class="line">        <span class="comment">// create the temporary partition and remove the original</span></span><br><span class="line">        <span class="comment">// one (part1).</span></span><br><span class="line">        schema.MoveSequence(part1, tempPartition);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Step 2</span></span><br><span class="line">        <span class="comment">// With the sequence in partition &#x27;part1&#x27; removed</span></span><br><span class="line">        <span class="comment">// we can now move elements from the second sequence to it.</span></span><br><span class="line">        <span class="comment">// This action will re-create a sequence in partition &#x27;part1&#x27;</span></span><br><span class="line">        <span class="comment">// and remove the sequence in partition &#x27;part2&#x27;</span></span><br><span class="line">        schema.MoveSequence(part2, part1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Step 3</span></span><br><span class="line">        <span class="comment">// Finally, we can move elements &#x27;parked&#x27; in the temporary</span></span><br><span class="line">        <span class="comment">// sequence to partition &#x27;part2&#x27;, for that partition was</span></span><br><span class="line">        <span class="comment">// removed in the previous step and thus can now be created</span></span><br><span class="line">        <span class="comment">// again. The temporary partition will be automatically </span></span><br><span class="line">        <span class="comment">// removed upon completing this step.</span></span><br><span class="line">        schema.MoveSequence(tempPartition, part2);</span><br><span class="line"></span><br><span class="line">        transaction.Commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不同序列中的元素独立地编号，这意味着即使元素不同，在两个序列中也可能存在具有相同编号的元素。同样，在两个或更多个序列中可能存在完全相同的元素，其具有不同的数字。然而，在每个编号序列内，任何两个相同的元素将总是具有相同的编号，而不同的元件在编号序列内将永远不具有相同的编号。</p>
<p>创建后，Escape元素始终自动编号。每个新元素将获得一个递增的更大的数字。但是，与同一序列中的现有元素匹配的新元素将被分配相同的编号。元素将尽可能长时间地保留其分配的编号。这意味着，例如，如果删除了以前创建的某些钢筋图元，则所有剩余图元（在相同编号序列中）将保留其编号，这可能会导致相应编号序列中出现间隙。对于不需要空位的序列，可以通过调用RemoveGaps（）来移除空位。</p>
<p>下面的示例通过删除编号序列中的任何剩余间隙并设置每个序列的起始编号以使序列中的编号不重叠来合并钢筋元素上的编号。</p>
<p>代码区域：Consolidate Rebar Numbers</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ConsolidateRebarNumbers</span>(<span class="params">Document document</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Obtain a schema object for a particular kind of elements </span></span><br><span class="line">    NumberingSchema schema = NumberingSchema.GetNumberingSchema(document,NumberingSchemaTypes.StructuralNumberingSchemas.Rebar);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Collect the names of partitions of all the numbering sequences currently contained in the schema</span></span><br><span class="line">    IList&lt;<span class="built_in">string</span>&gt; sequences = schema.GetNumberingSequences();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> (Transaction transaction = <span class="keyword">new</span> Transaction(document))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Changes to numbers must be made inside a transaction</span></span><br><span class="line">        transaction.Start(<span class="string">&quot;Consolidate Rebar Numbers&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// First we make sure numbers in all sequences are consecutive</span></span><br><span class="line">        <span class="comment">// by removing possible gaps in numbers. Note: RemoveGaps does</span></span><br><span class="line">        <span class="comment">// nothing for a sequence where there are no gaps present.</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// We also want to find what the maximum range of numbers is</span></span><br><span class="line">        <span class="comment">// of all the sequences (the one the widest span of used numbers)</span></span><br><span class="line">        <span class="built_in">int</span> maxRange = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">foreach</span> (<span class="built_in">string</span> name <span class="keyword">in</span> sequences)</span><br><span class="line">        &#123;</span><br><span class="line">            schema.RemoveGaps(name);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Here we use First() from the Linq extension.</span></span><br><span class="line">            <span class="comment">// There is always at least one range in every sequence,</span></span><br><span class="line">            <span class="comment">// and after gaps are closed there is exactly one range.</span></span><br><span class="line">            IntegerRange range = schema.GetNumbers(name).First();  </span><br><span class="line">            <span class="built_in">int</span> rangeSpan = <span class="number">1</span> + (range.High - range.Low);</span><br><span class="line">            <span class="keyword">if</span> (rangeSpan &gt; maxRange)</span><br><span class="line">            &#123;</span><br><span class="line">                maxRange = rangeSpan;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Next we give sequences different start numbers</span></span><br><span class="line">        <span class="comment">// starting with 100 and then stepping by at least</span></span><br><span class="line">        <span class="comment">// the maximum range we found in the previous step</span></span><br><span class="line">        <span class="built_in">int</span> startNumber = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We round the range up to the closest 100</span></span><br><span class="line">        <span class="built_in">int</span> step = <span class="number">100</span> * (<span class="built_in">int</span>)((maxRange + <span class="number">99</span>) / <span class="number">100.0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">foreach</span> (<span class="built_in">string</span> name <span class="keyword">in</span> sequences)</span><br><span class="line">        &#123;</span><br><span class="line">            schema.ShiftNumbers(name, startNumber);</span><br><span class="line">            startNumber += step;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        transaction.Commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>数字被存储为每个编号元素上的编号参数的值。通过查询NumberingSchema.NumberingParameterId属性获取参数的ID。可以通过查询相应编号元素的参数来获得编号的值。该值是只读的，因此无法设置;它始终根据编号分区中元素的关系以及每个元素编号顺序中的匹配策略计算。</p>
<p>尽管编号总是自动分配给模式的所有元素，但ChangeNumber（）方法为程序员提供了一种方法，只要新编号在编号序列中是唯一的，就可以显式地覆盖特定编号。调用者指定一个要更改的数字和一个要应用的新值，前提是该值在同一编号序列中还不存在。</p>
<p><strong>分布类型</strong></p>
<p>Rebar.DistributionType属性可用于修改钢筋集的类型。钢筋集可以是“均匀”或“可变长度”，对于均匀分布类型：所有钢筋参数与集中的第一个钢筋相同。对于可变长度分布类型：考虑到集合中第一个钢筋的约束，钢筋参数可以变化（主要是长度）。</p>
<p>Rebar.GetParameterValueAtIndex() 方法的作用是：获取位于指定索引处的条形图的参数值。仅接受0和NumberOfBarPositions-1之间的值。如果DistributionType为Uniform，则无论索引如何，返回的ParameterValue都相同。如果DistributionType为VaryingLength，则返回的ParameterValue在给定索引处计算。</p>
<h3 id="边界条件"><a href="#边界条件" class="headerlink" title="边界条件"></a>边界条件</h3><p><strong>边界条件</strong></p>
<p>有三种类型的边界条件：</p>
<ul>
<li>Point 点</li>
<li>Curve 曲线</li>
<li>Area 区域</li>
</ul>
<p>使用以下代码检索类型和相关的几何信息：</p>
<p>代码区域29-9：获取边界条件类型和几何形状</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetInfo_BoundaryConditions</span>(<span class="params">BoundaryConditions boundaryConditions</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> message = <span class="string">&quot;BoundaryConditions : &quot;</span>;</span><br><span class="line"></span><br><span class="line">    boundaryConditions.GetBoundaryConditionsType();</span><br><span class="line">    <span class="keyword">switch</span> (boundaryConditions.GetBoundaryConditionsType())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> BoundaryConditionsType.Point:</span><br><span class="line">            XYZ point = boundaryConditions.Point;</span><br><span class="line">            message += <span class="string">&quot;\nThis BoundaryConditions is a Point Boundary Conditions.&quot;</span>;</span><br><span class="line">            message += <span class="string">&quot;\nLocation point: (&quot;</span> + point.X + <span class="string">&quot;, &quot;</span></span><br><span class="line">                        + point.Y + <span class="string">&quot;, &quot;</span> + point.Z + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> BoundaryConditionsType.Line:</span><br><span class="line">            message += <span class="string">&quot;\nThis BoundaryConditions is a Line Boundary Conditions.&quot;</span>;</span><br><span class="line">            Curve curve = boundaryConditions.GetCurve();</span><br><span class="line">            <span class="comment">// Get curve start point</span></span><br><span class="line">            message += <span class="string">&quot;\nLocation Line: start point: (&quot;</span> + curve.GetEndPoint(<span class="number">0</span>).X + <span class="string">&quot;, &quot;</span></span><br><span class="line">                    + curve.GetEndPoint(<span class="number">0</span>).Y + <span class="string">&quot;, &quot;</span> + curve.GetEndPoint(<span class="number">0</span>).Z + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">            <span class="comment">// Get curve end point</span></span><br><span class="line">            message += <span class="string">&quot;;  end point:(&quot;</span> + curve.GetEndPoint(<span class="number">1</span>).X + <span class="string">&quot;, &quot;</span></span><br><span class="line">                    + curve.GetEndPoint(<span class="number">1</span>).Y + <span class="string">&quot;, &quot;</span> + curve.GetEndPoint(<span class="number">1</span>).Z + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> BoundaryConditionsType.Area:</span><br><span class="line">            message += <span class="string">&quot;\nThis BoundaryConditions is an Area Boundary Conditions.&quot;</span>;</span><br><span class="line">            IList loops = boundaryConditions.GetLoops();</span><br><span class="line">            <span class="keyword">foreach</span> (CurveLoop curveLoop <span class="keyword">in</span> loops)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">foreach</span> (Curve areaCurve <span class="keyword">in</span> curveLoop)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// Get curve start point</span></span><br><span class="line">                    message += <span class="string">&quot;\nCurve start point:(&quot;</span> + areaCurve.GetEndPoint(<span class="number">0</span>).X + <span class="string">&quot;, &quot;</span></span><br><span class="line">                            + areaCurve.GetEndPoint(<span class="number">0</span>).Y + <span class="string">&quot;, &quot;</span> + areaCurve.GetEndPoint(<span class="number">0</span>).Z + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">                    <span class="comment">// Get curve end point</span></span><br><span class="line">                    message += <span class="string">&quot;; Curve end point:(&quot;</span> + areaCurve.GetEndPoint(<span class="number">1</span>).X + <span class="string">&quot;, &quot;</span></span><br><span class="line">                            + areaCurve.GetEndPoint(<span class="number">1</span>).Y + <span class="string">&quot;, &quot;</span> + areaCurve.GetEndPoint(<span class="number">1</span>).Z + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="literal">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>,message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="板"><a href="#板" class="headerlink" title="板"></a>板</h3><p><strong>板</strong></p>
<p>Slab（结构楼板）和Slab Foundation都由Floor类表示，并由IsFoundationSlab属性区分。</p>
<p>板跨方向由API中的IndependentTag类表示，可用方式如下：</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-23AFA5D3-DFA8-48EE-BDC3-EFB37BADCB7D-low.png"></p>
<p>图157：板跨方向</p>
<p>使用NewSlab（）创建板时，不会自动创建跨方向。也没有办法直接创建它们。</p>
<p>“楼板”复合结构图层“结构桥面”属性由以下属性公开：</p>
<ul>
<li>CompoundStructuralLayer.DeckUsage</li>
<li>DeckProfile</li>
</ul>
<p>属性在以下对话框中列出：</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-F892CB9B-E142-4112-8925-32C543D8A9AA-low.png" alt="img"></p>
<p>图158：楼板复合结构层属性</p>
<h2 id="分析模型"><a href="#分析模型" class="headerlink" title="分析模型"></a>分析模型</h2><p>在结构工程中，分析模型是结构物理模型的工程描述。</p>
<p>以下结构图元具有结构杆件分析模型：</p>
<ul>
<li>Structural Columns 结构柱</li>
<li>Structural Framing elements (such as beams and braces)<br>结构框架图元（如梁和支撑）</li>
<li>Structural Floors 结构楼板</li>
<li>Structural Footings 结构基础</li>
<li>Structural Walls 结构墙</li>
</ul>
<p>可以使用GetAnalyticalModel（）方法获得元素的AnalyticalModel。请注意，新创建的结构图元的AnalyticalModel在再生发生之前不可用。根据图元的族，AnalyticalModel可能不存在。如果AnalyticalModel值不适用于图元的族，则GetAnalyticalModel（）方法返回null。在使用这个类之前检查这个值。AnalyticalModel由以下信息组成：</p>
<ul>
<li>元素相对于分析的位置</li>
<li>参数信息，包括投影、硬点、近似和刚性连接</li>
<li>支持信息</li>
<li>手动和自动调整信息</li>
<li>分析偏移</li>
</ul>
<p>在专业中提供特定选项：</p>
<ul>
<li>AnalyticalModelStick -表示结构框架梁、结构框架支撑和结构柱的分析模型。</li>
<li>AnalyticalModelColumn - AnalyticalModelStick的子类，表示结构柱的分析模型。</li>
<li>AnalyticalModelSurface - 表示结构楼板、结构基础底板和结构墙的分析模型。</li>
</ul>
<h3 id="分析位置"><a href="#分析位置" class="headerlink" title="分析位置"></a>分析位置</h3><p>根据与AnalyticalModel相对应的元素类型，可以通过以下三种方法之一来获得元素相对于分析的位置：GetPoint（）、GetCurve（）或GetCurves（）。</p>
<p>请注意，从这些方法检索的曲线没有设置其“引用”（Reference）特性。因此，它们不能用于Curve.GetEndPointReference（）等方法。相反，您可以通过构造包含必要信息的AnalyticalModelModel对象来获取对曲线及其端点的引用，如下例所示。</p>
<p>代码区域29-10：获取分析曲线的参考</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">GetReferenceData</span>(<span class="params">FamilyInstance familyInst</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        AnalyticalModel analyticalModelFrame = familyInst.GetAnalyticalModel();</span><br><span class="line">        Curve analyticalCurve = analyticalModelFrame.GetCurve();</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != analyticalCurve)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="comment">// test the stable reference to the curve.</span></span><br><span class="line">                AnalyticalModelSelector amSelector = <span class="keyword">new</span> AnalyticalModelSelector(analyticalCurve);</span><br><span class="line">                amSelector.CurveSelector = AnalyticalCurveSelector.WholeCurve;</span><br><span class="line">                Reference curveReference = analyticalModelFrame.GetReference(amSelector);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// test the stable reference to the start point of the curve</span></span><br><span class="line">                amSelector.CurveSelector = AnalyticalCurveSelector.StartPoint;</span><br><span class="line">                Reference startPointReference = analyticalModelFrame.GetReference(amSelector);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// test the stable reference to the start point of the curve</span></span><br><span class="line">                amSelector.CurveSelector = AnalyticalCurveSelector.EndPoint;</span><br><span class="line">                Reference endPointReference = analyticalModelFrame.GetReference(amSelector);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>GetPoint()</strong>  </p>
<p>如果AnalyticalModel可以由单个点（即Structural Footing）表示，则此方法将返回该点。否则，它将引发Autodesk.Revit.Exceptions.InapplicableDataException。IsSinglePoint（）方法可用于确定AnalyticalModel是否可由单个点表示。</p>
<p>下面的示例演示如何获取结构基础的分析位置。</p>
<p>代码区域29-11：获取结构基脚的位置</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// retrieve and iterate current selected element</span></span><br><span class="line">UIDocument uidoc = commandData.Application.ActiveUIDocument;</span><br><span class="line">ElementSet selection = uidoc.Selection.Elements;</span><br><span class="line"><span class="keyword">foreach</span> (Element e <span class="keyword">in</span> selection)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">// if the element is structural footing</span></span><br><span class="line">        FamilyInstance familyInst = e <span class="keyword">as</span> FamilyInstance;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != familyInst &amp;&amp; familyInst.StructuralType == StructuralType.Footing)</span><br><span class="line">        &#123;</span><br><span class="line">                AnalyticalModel model = familyInst.GetAnalyticalModel();</span><br><span class="line">                <span class="comment">// structural footing should be expressable as a single point</span></span><br><span class="line">                <span class="keyword">if</span> (model.IsSinglePoint() == <span class="literal">true</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                        XYZ analyticalLocationPoint = model.GetPoint();</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>GetCurve()</strong>  </p>
<p>如果AnalyticalModel可以由单个曲线（即Structural Column或Structural Framing）表示，则此方法将返回该Curve。否则，它将引发Autodesk. Revit. Exceptions. InapplicableDataException。IsSingleCurve（）方法可用于确定AnalyticalModel是否可由单条曲线表示。</p>
<p>代码区域29-12：获取结构柱的曲线</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetColumnCurve</span>(<span class="params">FamilyInstance familyInst</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">// get AnalyticalModel from structural column</span></span><br><span class="line">        <span class="keyword">if</span> (familyInst.StructuralType == StructuralType.Column)</span><br><span class="line">        &#123;</span><br><span class="line">                AnalyticalModel modelColumn = familyInst.GetAnalyticalModel();</span><br><span class="line">                <span class="comment">// column should be represented by a single curve</span></span><br><span class="line">                <span class="keyword">if</span> (modelColumn.IsSingleCurve() == <span class="literal">true</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                        Curve columnCurve = modelColumn.GetCurve();</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>GetCurves()</strong></p>
<p>此方法需要获取由多条曲线定义的AnalyticalModel的曲线，但可用于所有情况。如果AnalyticalModel可以由单个曲线表示，则该方法将返回仅包含一条曲线的List。如果AnalyticalModel可以由单个点表示，则此方法将返回包含该点的长度几乎为0的Curve。此方法将AnalyticalCurveType枚举作为参数。可能的值为：</p>
<ul>
<li><em>RawCurves</em> - 生成的基础分析模型曲线</li>
<li><em>ActiveCurves</em> - 屏幕上显示的曲线（不包括刚性链接）</li>
<li><em>ApproximatedCurves</em> - 使用直线段近似的曲线</li>
</ul>
<p>The following values related to Rigid Links are also available. See the Rigid Links section later in this chapter for more information.<br>也可以使用与刚性链接相关的以下值。有关详细信息，请参见本章后面的“刚性连杆”部分。</p>
<ul>
<li><em>RigidLinkHead</em> -梁的端点0（头部）处的刚性连杆</li>
<li><em>RigidLinkTail</em> - 梁末端1（尾部）的刚性连杆</li>
<li><em>AllRigidLinks</em> - 所有刚性连杆曲线。端点0（头部）处的刚性连杆将位于第一个条目中。末端1（尾部）的刚性连杆将位于最后一个条目中。</li>
</ul>
<p><strong>GetLoops()</strong></p>
<p>对于结构墙、楼板和楼板，建议使用AnalyticalModelSurface类。使用GetLoops（）方法可以基于AnalyticalLoopType参数检索曲面的一组CurveLoop对象。可能的值为：</p>
<ul>
<li><em>All</em> - 所有分析回路</li>
<li><em>External</em> - 在所有其他循环之外循环。</li>
<li><em>Internal</em> - 位于另一个循环内部的循环。在多个嵌套循环的情况下，这将返回除了最外部循环之外的所有循环。</li>
<li><em>Filled</em> - 内部已填充的循环。在多个嵌套循环的情况下，这将返回最外部的循环，并从外部循环到内部循环。在视图中，返回的回路显示为实体的外部轮廓。</li>
<li><em>Void</em> - 内部为空的循环。在多个嵌套循环的情况下，这将返回一系列循环，从第二个最外部开始，每隔一个标题进入最内部。在视图中，返回的回路显示为开口的外部轮廓。下面的示例演示了如何将AnalyticalModelSurface用于结构墙，以获取所有选定墙的外边缘并显示其坐标。</li>
</ul>
<p>代码区域29-13：获取结构墙的曲线</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// retrieve and iterate current selected element</span></span><br><span class="line">UIDocument uidoc = commandData.Application.ActiveUIDocument;</span><br><span class="line">ICollection selectedIds = uidoc.Selection.GetElementIds();</span><br><span class="line">Document document = uidoc.Document;</span><br><span class="line"><span class="keyword">foreach</span> (ElementId id <span class="keyword">in</span> selectedIds)</span><br><span class="line">&#123;</span><br><span class="line">    Element e = document.GetElement(id);</span><br><span class="line">    Wall aWall = e <span class="keyword">as</span> Wall;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> != aWall)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// get AnalyticalModelSurface from Structural Wall</span></span><br><span class="line">        AnalyticalModelSurface modelWall = aWall.GetAnalyticalModel() <span class="keyword">as</span> AnalyticalModelSurface;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == modelWall)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Architecture wall doesn&#x27;t have analytical model</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// get wall curves</span></span><br><span class="line">        StringBuilder wallString = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        wallString.AppendLine(<span class="string">&quot;Wall curves:&quot;</span>);</span><br><span class="line">        IList wallCurveLoops = modelWall.GetLoops(AnalyticalLoopType.External);</span><br><span class="line">        <span class="keyword">foreach</span> (CurveLoop curveloop <span class="keyword">in</span> wallCurveLoops)</span><br><span class="line">        &#123;</span><br><span class="line">            CurveLoopIterator itr = curveloop.GetCurveLoopIterator();</span><br><span class="line">            itr.Reset();</span><br><span class="line">            <span class="keyword">while</span> (itr.MoveNext())</span><br><span class="line">            &#123;</span><br><span class="line">                Curve wallCurve = itr.Current;</span><br><span class="line">                wallString.AppendLine(String.Format(<span class="string">&quot;&#123;0&#125;, &#123;1&#125;&quot;</span>, wallCurve.GetEndPoint(<span class="number">0</span>).ToString(), wallCurve.GetEndPoint(<span class="number">1</span>).ToString()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TaskDialog.Show(<span class="string">&quot;Wall Analytical Model&quot;</span>, wallString.ToString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <strong>局部坐标系</strong></p>
<p>AnalyticalModelStick和AnalyticalModelSurface元素的局部坐标系的方向可以通过调用重载的GetLocalCoordinateSystem（）方法作为变换获得。对于AnalyticalModelSurface，此方法的重载（不带参数）将返回整个模型的局部坐标系方向的变换，而带XYZ点的重载将返回描述曲面上指定点处的局部坐标系的变换。指定的点必须位于分析模型的表面上，否则Revit将引发异常。</p>
<p>当在AnalyticalModelStick类上调用GetLocalCoordinateSystem（）时，您可以可选地调用GetLocalCoordinateSystem（double），传递沿着曲线的距离，该距离由可以在0和1之间变化的参数表示（例如，0.5表示沿着参数化曲线的中点）。也可以调用GetLocalCoordinateSystem（XYZ point），其约束条件与在AnalyticalModelSurface上调用时相同，即指定的点必须位于沿着分析模型。Face.Evaluate或Curve.Evaluate可用于获取位于曲面上或沿曲线沿着的XYZ点。</p>
<h3 id="参数信息"><a href="#参数信息" class="headerlink" title="参数信息"></a>参数信息</h3><p>AnalyticalModel提供对刚性链接、投影和近似等参数信息的访问。</p>
<p><strong>刚性连杆</strong></p>
<p>刚性连杆将梁的分析模型连接到柱的分析模型。使用CanHaveRigidLinks（）方法和AnalyticalModel.RigidLinksOption属性确定刚性链接是否适用于AnalyticalModel。此外，还可以使用HasRigidLinksWith（）确定AnalyticalModel是否具有与特定图元的刚性链接。</p>
<p>通过使用AnalyticalModel.GetCurves（）方法指定AnalyticalCurveType选项RigidLinkHead和RigidLinkTail，可以检索末端链接。或者，将AnalyticalModel.GetRigidLink（）与AnalyticalModel对象一起使用。</p>
<p>结构梁的AnalyticalModel方法GetCurve（）和GetCurves（）之间的一个区别是，GetCurves（）包括单个Curve以及结构梁RigidLink Curve（如果存在）。将AnalyticalCurveType.RigidLinkHead或AnalyticalCurveType.RigidLinkTail枚举值传递给GetCurves（）方法，以获取梁头部或尾部的RigidLink。</p>
<p>虽然不能直接创建刚性连接（因为它不是独立对象），但可以使用梁和&#x2F;或柱的分析模型上的RigidLinksOption属性来创建刚性连接。梁的刚性连接选项将替代柱的选项。</p>
<p>对于结构梁，RigidLinksOption属性可以具有以下值：</p>
<ul>
<li>AnalyticalRigidLinksOption.Enabled - 将形成刚性链接</li>
<li>AnalyticalRigidLinksOption.Disabled -将不形成刚性链接</li>
<li>AnalyticalRigidLinksOption.FromColumn - 可以形成刚性连接，具体取决于相应结构柱的值。</li>
</ul>
<p>对于结构柱，RigidLinksOption属性可以具有以下值：</p>
<ul>
<li>AnalyticalRigidLinksOption.Enabled - 将形成刚性连接，除非相应的结构梁的设置替代。</li>
<li>AnalyticalRigidLinksOption.Disabled - 除非相应结构梁的设置替代，否则不会形成刚性连接。</li>
</ul>
<p>注意：除了设置正确的值外，要创建刚性连杆，图元还必须重叠。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-80B7AF6C-FF62-4431-AA18-69BD624D7C69-low.png"></p>
<p><strong>对齐、投影和延伸</strong></p>
<p>子类AnalyticalModelSurface、AnalyticalModelStick和AnalyticalModelColumn具有支持检查和操作结构元素的对齐、投影和延伸的专用成员。以下代码示例显示如何更改AnalyticalModelSurface或AnalyticalModelStick的投影。</p>
<p>代码区域：更改AnalyticalModelStick投影</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ChangeBeamProjection</span>(<span class="params">FamilyInstance familyInstance</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    AnalyticalModelStick ams = familyInstance.GetAnalyticalModel() <span class="keyword">as</span> AnalyticalModelStick;</span><br><span class="line">    <span class="keyword">if</span> (ams != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Change the Z projection for the end of the beam</span></span><br><span class="line">        StickElementProjectionZ orgEndProj = ams.GetProjectionZ(AnalyticalElementSelector.EndOrTop);</span><br><span class="line">        StickElementProjectionZ newEndProj = StickElementProjectionZ.Bottom;</span><br><span class="line">        <span class="keyword">using</span> (Transaction tran = <span class="keyword">new</span> Transaction(familyInstance.Document, <span class="string">&quot;ChangeProjection&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            tran.Start();</span><br><span class="line">            ams.SetProjection(AnalyticalElementSelector.EndOrTop, ElementId.InvalidElementId, newEndProj);</span><br><span class="line">            tran.Commit();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TaskDialog.Show(<span class="string">&quot;AnalyticalModelStick&quot;</span>, <span class="string">&quot;AnalyticalModelStick ID: &quot;</span> + ams.Id + <span class="string">&quot;; \nOriginal ProjectionZ value was: &quot;</span> + orgEndProj + <span class="string">&quot;; \nNew ProjectionZ value: &quot;</span> + newEndProj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码区域：更改AnalyticalModel曲面投影</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> </span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> Change the Z projection for all surface elements to BottomOrExterior</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ChangeSurfaceProjections</span>(<span class="params">Document document</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">    IList elements = collector.WherePasses(<span class="keyword">new</span> ElementClassFilter(<span class="keyword">typeof</span>(AnalyticalModelSurface))).WhereElementIsNotElementType().ToElements();</span><br><span class="line">    <span class="keyword">if</span> (elements.Count &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">using</span> (Transaction tran = <span class="keyword">new</span> Transaction(document, <span class="string">&quot;Change Surface Projections&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            tran.Start();</span><br><span class="line">            <span class="keyword">foreach</span> (AnalyticalModelSurface ams <span class="keyword">in</span> elements)</span><br><span class="line">            &#123;</span><br><span class="line">                SurfaceElementProjectionZ orgEndProj = ams.ProjectionZ;</span><br><span class="line">                SurfaceElementProjectionZ newEndProj = SurfaceElementProjectionZ.BottomOrExterior;</span><br><span class="line">                ams.ProjectionZ = newEndProj;</span><br><span class="line">            &#125;</span><br><span class="line">            tran.Commit();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下一个示例演示如何设置柱的顶部拉伸。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> </span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> Change the top extension for the column to Reference Level</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ChangeColumnTopExtension</span>(<span class="params">FamilyInstance column</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    AnalyticalModelColumn amc = column.GetAnalyticalModel() <span class="keyword">as</span> AnalyticalModelColumn;</span><br><span class="line">    <span class="keyword">if</span> (amc != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">using</span> (Transaction tran = <span class="keyword">new</span> Transaction(column.Document, <span class="string">&quot;Change Top Extension&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            tran.Start();</span><br><span class="line"></span><br><span class="line">            StickElementExtension orgTopExt = amc.TopExtension;</span><br><span class="line">            StickElementExtension newTopExt = StickElementExtension.ReferenceLevel;</span><br><span class="line">            amc.TopExtension = newTopExt;</span><br><span class="line"></span><br><span class="line">            TaskDialog.Show(<span class="string">&quot;AnalyticalModelColumn&quot;</span>, <span class="string">&quot;AnalyticalModelColumn ID: &quot;</span> + amc.Id + <span class="string">&quot;; \nOriginal TopExtension value was: &quot;</span> + orgTopExt + <span class="string">&quot;; \nNew TopExtension value: &quot;</span> + newTopExt);</span><br><span class="line"></span><br><span class="line">            tran.Commit();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>近似</strong></p>
<p>当AnalyticalModel由曲线而不是直线定义时（即对于弯曲梁），近似值（由直线组成）可能更可取。AnalyticalModel有几种与曲线近似相关的方法。如果CanApproximate（）返回true，请使用Approximate（）方法在非近似（曲线）分析模型和近似（仅由直线组成）分析模型之间切换。切换到近似后，使用GetCurves（）获取近似曲线的直线。</p>
<p>近似将基于近似偏差值（GetApproximationDeviation（））和使用硬点参数（UsesHardPoints（））。这些值也有相应的Set方法。近似偏差限制平滑曲线与由近似生成的线段之间的距离。硬点是弯曲梁上其他结构元素接触的位置。将此参数设置为true时，将强制分段分析模型在附着到曲梁的杆件端点处具有节点</p>
<p><strong>AnalyzeAs</strong></p>
<p>可以通过AnalyticalModel检索和设置Analyze As参数。此参数向分析程序指示应如何分析元素，或元素是否为NotForAnalysis。由于GetAnalyzeAs（）和SetAnalyzeAs（）使用的AnalyzeAs枚举包含用于不同类型元素的枚举值，因此并非所有值都适用于所有分析模型。使用IsAnalyzeAsValid（）方法确定特定值是否适用于分析模型。</p>
<h3 id="手动调节"><a href="#手动调节" class="headerlink" title="手动调节"></a>手动调节</h3><p>结构杆件分析模型的几何图形也可以相对于它所连接的图元进行调整（假设SupportsManualAdjustment（）方法返回true）。使用AnalyticalModel.ManuallyAdjust（）方法相对于另一个图元调整分析模型。</p>
<p>代码区域29-14：相对于另一个图元调整分析模型</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Pick the source analytical line to adjust to</span></span><br><span class="line">Selection sel = app.ActiveUIDocument.Selection;</span><br><span class="line">Reference refAnalytical = sel.PickObject(ObjectType.Element, <span class="string">&quot;Please Pick the source analytical line to adjust to&quot;</span>);</span><br><span class="line">AnalyticalModel aModel = doc.GetElement(refAnalytical) <span class="keyword">as</span> AnalyticalModel;</span><br><span class="line">Curve aCurve = aModel.GetCurve();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get the reference of the start point</span></span><br><span class="line">AnalyticalModelSelector aSelector = <span class="keyword">new</span> AnalyticalModelSelector(aCurve);</span><br><span class="line">aSelector.CurveSelector = AnalyticalCurveSelector.StartPoint;</span><br><span class="line">Reference refSource = aModel.GetReference(aSelector);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Pick the source analytical line to be adjusted</span></span><br><span class="line">Reference refAnalytical2 = sel.PickObject(ObjectType.Element, <span class="string">&quot;Please pick the source analytical line to be adjusted&quot;</span>);</span><br><span class="line">AnalyticalModel aModel2 = doc.GetElement(refAnalytical2) <span class="keyword">as</span> AnalyticalModel;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get the reference of the start point</span></span><br><span class="line">Curve aCurve2 = aModel2.GetCurve();</span><br><span class="line">AnalyticalModelSelector aSelector2 = <span class="keyword">new</span> AnalyticalModelSelector(aCurve2);</span><br><span class="line">aSelector2.CurveSelector = AnalyticalCurveSelector.StartPoint;</span><br><span class="line"><span class="comment">// Can be adjusted to the middle of the line if WholeCurve is used</span></span><br><span class="line">Reference refTarget = aModel2.GetReference(aSelector2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Adjust the analytical line</span></span><br><span class="line">aModel.ManuallyAdjust(refSource, refTarget, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<p>AnalyticalModel还提供了一些方法，用于确定分析模型是否已被手动调整，以及将其重置回相对于其相应物理模型的原始位置。此外，GetManualAdjustmentMatchedElements（）方法检索元素Id的集合，分析模型已根据这些元素Id进行了调整。</p>
<h3 id="分析偏移"><a href="#分析偏移" class="headerlink" title="分析偏移"></a>分析偏移</h3><p>调整分析模型的另一种方法是使用偏移。设置分析偏移与手动调整分析模型不同。分析偏移是应用于整个分析模型的基本偏移，独立于任何其他图元。AnalyticalModel具有获取和设置分析偏移以及确定是否可以更改分析偏移的方法（CanSetAnalyticalOffset（））。</p>
<h3 id="分析模型支撑"><a href="#分析模型支撑" class="headerlink" title="分析模型支撑"></a>分析模型支撑</h3><p>括每个支撑的优先级（如果多个图元提供支撑）以及提供支撑的点、曲线或面。以下示例说明如何在不同条件下使用AnalyticalModelSupport对象。</p>
<p><strong>楼板和结构梁支撑信息</strong></p>
<p>在草图模式下绘制板时，请选择设计栏上的“拾取支座”。如下图所示，板有三个支撑梁。通过迭代板的AnalyticalModelSupports集合，可以获得三个梁以及CurveSupport AnalyticalSupportType。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-93B7CB30-48F8-4580-88F4-973E91BE718B-low.png" alt="img">图160：楼板和结构梁支撑信息</p>
<p><strong>地板和墙壁支撑信息</strong></p>
<p>通过拾取墙作为支撑来绘制板后，无法从楼板的AnalyticalModelSupport集合中获取墙。相反，Floor在Wall的AnalyticalModelSupports集合中可用。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-9EB168A7-3040-465D-B3B8-D9E39529E4B4-low.png" alt="img">图161：地板和墙壁支撑信息</p>
<p><strong>结构柱、梁和支撑支撑信息</strong></p>
<p>在下图中，水平梁有三个点支撑–两个结构柱和一个结构支撑。支撑有三个点支撑–两个结构柱和一个结构梁。两个柱都没有支撑元件。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-F386B22F-C4FD-4DC3-A751-BE9076FDF4C5-low.png" alt="img"><br>图162：StructuralElements支撑信息</p>
<p><strong>梁系统和墙支撑信息</strong></p>
<p>虽然在绘制BeamSystem时可以拾取墙作为支撑，但由于BeamSystem没有AnalyticalModel属性，因此无法直接获得其支撑信息。解决方案是调用GetBeamIds（）方法，以检索Beams的AnalyticalModelSupport集合。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-8B85D42D-52D3-42DA-B416-B5D63B0884D3-low.png" alt="img"></p>
<p>图163：梁系统和墙支撑信息</p>
<p><strong>墙基础和墙支撑信息</strong></p>
<p>对于具有条形基础的墙，该墙具有可用于条形基础的CurveSupport。可以使用AnalyticalModel.GetCurves（）方法获得支撑曲线。在下面的示例中，曲线中有两个圆弧。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-29E58471-AA23-45AE-9DDB-FAAF03462296-low.png" alt="img"><br>图164：墙基础和墙支撑信息</p>
<p><strong>独立基础和结构柱支撑信息</strong></p>
<p>结构柱可以将独立基脚作为点支撑。在这种情况下，基脚可以随支撑的结构柱移动。具有OST_StructuralFoundation类别的FamilyInstance的ElementId可从AnalyticalModelSupport.GetSupportingElement（）方法获得。通常，支撑点是从AnalyticalModel.GetCurve（）方法检索的曲线的底部点。在从GetPoint（）方法获得独立基脚FamilyInstance和AnalyticalModel Point后，也可以使用该选项。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-70211C95-7FE5-4A12-A4E0-52EA53FC2DEB-low.png" alt="img"><br>图165：独立基础（FamilyInstance)和结构柱支撑信息</p>
<h3 id="分析杆件力"><a href="#分析杆件力" class="headerlink" title="分析杆件力"></a>分析杆件力</h3><p>AnalyticalModelStick类可以在杆元素的每一端存储六个内力。在每个端部处，可以存储3个平移力和3个旋转（力矩）力。这些杆件力可以表示模型上的一组特定载荷的结果，也可以表示用于连接设计的设计力。与荷载工况或组合无关。杆件力对应于分析杆模型（位于梁、支撑和柱上）的UI的“杆件力”属性。</p>
<p>这些力由PermanerForces类表示，该类提供获取和设置所有6个力分量（3个力，3个力矩）的访问权限，并通过Start属性指示对象是表示杆件起点处的力还是表示杆件终点处的力：对于起点和终点力，设置为true;对于终点力，设置为false。</p>
<p>开始和结束力和力矩都存储为由力或力矩的分量值组成的XYZ向量。例如，在一个示例中，力。X表示沿X方向作用的力的值。</p>
<h3 id="阅读杆力"><a href="#阅读杆力" class="headerlink" title="阅读杆力"></a>阅读杆力</h3><p>可以通过调用方法AnalyticalModelStick. GetForces（）来访问与分析模型一起存储的杆件力，该方法返回最小计数为零、最大计数为2（每端一个）的GetForces对象列表。如果没有为成员存储成员力，则列表将为空，如果只有一端指定了力，则列表将仅包含一个MemberForces对象。请注意，在UI中设置为“Released”或通过AnalyticalModleStick.SetReleases（）设置为true（已释放）的任何力或力矩方向在通过AnalyticalModleStick. GetReleaserForces（）查询时将报告为0.0。（释放的力或力矩不能抵抗释放方向上的力或力矩。）</p>
<h3 id="设置构件力"><a href="#设置构件力" class="headerlink" title="设置构件力"></a>设置构件力</h3><p>可以通过调用重载的SetForceForces（）方法之一来在AnalyticalModelStick上设置成员力。SetBumerForces（）将用新提供的杆件力覆盖任何现有杆件力。</p>
<p>对于当前释放的任何力或力矩方向，UI和AnalyticalModelStick. GetReleases（）都将返回这些值为零，但如果您通过AnalyticalModelStick. SetReleases（）方法设置它们，它们将被保留，以便如果用户稍后清除释放，或者您通过AnalyticalModelStick.SetReleases（）清除释放，则将报告先前设置的值。</p>
<h3 id="移除杆件力"><a href="#移除杆件力" class="headerlink" title="移除杆件力"></a>移除杆件力</h3><p>Member forces for AnalyticalModelSticks may be removed for both ends at once or only for an individual end. To remove all AnalyticalModelSticks的杆件力可以同时从两端删除，也可以仅从单个端删除。若要移除元素的所有成员力，请调用AnalyticalModelStick. RemoveAllModelerForces（）。若要仅移除起点或终点的杆件力，请调用AnalyticalModelStick. RemoveModelerForces（）并指示要移除的终点。</p>
<h2 id="荷载"><a href="#荷载" class="headerlink" title="荷载"></a>荷载</h2><p>以下部分确定荷载设置并讨论荷载限制指南。</p>
<p><strong>加载设置</strong></p>
<p>API可以访问“设置”对话框”荷载工况“和”荷载组合“选项卡上的所有功能。</p>
<p>以下属性可从相应的LoadCase BuiltInParameter中获得：</p>
<p><strong>表60荷载工况特性和参数</strong></p>
<table>
<thead>
<tr>
<th>**Property **</th>
<th>**BuiltInParameter **</th>
</tr>
</thead>
<tbody><tr>
<td>Case Number</td>
<td>LOAD_CASE _NUMBER</td>
</tr>
<tr>
<td>Nature</td>
<td>LOAD_CASE_NATURE</td>
</tr>
<tr>
<td>Category</td>
<td>LOAD_CASE_CATEGORY</td>
</tr>
</tbody></table>
<p>LOAD_CASE_CATEGORY参数返回ElementId。下表标识了类别和元素ID值之间的映射。</p>
<p>表61：载荷工况类别</p>
<table>
<thead>
<tr>
<th><strong>Load Case Category 荷载工况类别</strong></th>
<th><strong>BuiltInCategory</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Dead Loads  恒载</td>
<td>OST_LoadCasesDead</td>
</tr>
<tr>
<td>Live Loads  活荷载</td>
<td>OST_LoadCasesLive</td>
</tr>
<tr>
<td>Wind Loads  风荷载</td>
<td>OST_LoadCasesWind</td>
</tr>
<tr>
<td>Snow Loads  雪荷载</td>
<td>OST_LoadCasesSnow</td>
</tr>
<tr>
<td>Roof Live Loads  屋顶活荷载</td>
<td>OST_LoadCasesRoofLive</td>
</tr>
<tr>
<td>Accidental Loads  偶然荷载</td>
<td>OST_LoadCasesAccidental</td>
</tr>
<tr>
<td>Temperature Loads  温度荷载</td>
<td>OST_LoadCasesTemperature</td>
</tr>
<tr>
<td>Seismic Loads  地震荷载</td>
<td>OST_LoadCasesSeismic</td>
</tr>
</tbody></table>
<h3 id="创建荷载和荷载组合"><a href="#创建荷载和荷载组合" class="headerlink" title="创建荷载和荷载组合"></a>创建荷载和荷载组合</h3><p>下面的类有一个或多个静态Create（）方法来创建相应的类：</p>
<ul>
<li>LoadUsage </li>
<li>LoadNature</li>
<li>LoadCase </li>
<li>LoadCombination</li>
<li>PointLoad </li>
<li>LineLoad</li>
<li>AreaLoad</li>
</ul>
<p>因为它们都是Element子类，所以可以使用Document.Delete（）删除它们。</p>
<p>荷载组合是通过静态方法LoadCombination.Create（）创建的，该方法有两个重载。第一种方法只接受对要在其中创建加载组合的文档的引用和新组合名称的字符串。第二个函数接受这些参数加上LoadCombinationType和LoadCombinationState。LoadCombinationType可以是Combination（直接荷载组合）或Envelope（多个荷载工况或组合的效应包络）。</p>
<p>LoadCombinationState可以是Serviceability或Ultimate。如果荷载组合代表结构上的服务荷载水平，则使用“可服务性”。这通常用于设计或检查构件挠度或其他可用性标准，如许用应力设计方法。如果荷载组合表示荷载抗力系数设计方法中通常使用的结构上的极限荷载状态或系数荷载状态，请使用极限荷载。</p>
<p>创建LoadCombination后，需要使用LoadComponents填充它，LoadComponents包含荷载组合及其系数。LoadComponents通过调用LoadCombination.SetComponents（）添加到LoadCombination中，并带有组件列表，如下面的代码片段所示。<br>注意：请确保组件列表不涉及其本身。下面的示例演示如何创建荷载组合，以及如何查找或创建用于设置荷载组合构件的荷载工况和荷载性质。</p>
<p>代码区域：创建新的LoadCombination</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function">LoadCombination <span class="title">CreateLoadCombinationLoadCaseLoadUsageLoadNatureAndLoadComponent</span>(<span class="params">Document document</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Create a new load combination</span></span><br><span class="line">    LoadCombination loadCombination = LoadCombination.Create(document, <span class="string">&quot;DL1 + RAIN1&quot;</span>, LoadCombinationType.Combination, LoadCombinationState.Ultimate);</span><br><span class="line">    <span class="keyword">if</span> (loadCombination == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Create new load combination failed.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get all existing LoadCase</span></span><br><span class="line">    FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">    ICollection collection = collector.OfClass(<span class="keyword">typeof</span>(LoadCase)).ToElements();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find LoadCase &quot;DL1&quot;</span></span><br><span class="line">    LoadCase case1 = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">foreach</span> (Element e <span class="keyword">in</span> collection)</span><br><span class="line">    &#123;</span><br><span class="line">        LoadCase loadCase = e <span class="keyword">as</span> LoadCase;</span><br><span class="line">        <span class="keyword">if</span> (loadCase.Name == <span class="string">&quot;DL1&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            case1 = loadCase;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get all existing LoadNature</span></span><br><span class="line">    collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">    collection = collector.OfClass(<span class="keyword">typeof</span>(LoadNature)).ToElements();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find LoadNature &quot;Dead&quot;</span></span><br><span class="line">    LoadNature nature1 = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">foreach</span> (Element e <span class="keyword">in</span> collection)</span><br><span class="line">    &#123;</span><br><span class="line">        LoadNature loadNature = e <span class="keyword">as</span> LoadNature;</span><br><span class="line">        <span class="keyword">if</span> (loadNature.Name == <span class="string">&quot;Dead&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            nature1 = loadNature;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create LoadNature &quot;Dead&quot; if not exist</span></span><br><span class="line">    <span class="keyword">if</span> (nature1 == <span class="literal">null</span>)</span><br><span class="line">        nature1 = LoadNature.Create(document, <span class="string">&quot;Dead&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create LoadCase &quot;DL1&quot; if not exist</span></span><br><span class="line">    <span class="keyword">if</span> (case1 == <span class="literal">null</span>)</span><br><span class="line">        case1 = LoadCase.Create(document, <span class="string">&quot;DL1&quot;</span>, nature1.Id, LoadCaseCategory.Dead);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create LoadNature &quot;Rain&quot;</span></span><br><span class="line">    LoadNature nature2 = LoadNature.Create(document, <span class="string">&quot;Rain&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (nature2 == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Create new load nature failed.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create LoadCase &quot;RAIN1&quot;</span></span><br><span class="line">    LoadCase case2 = LoadCase.Create(document, <span class="string">&quot;RAIN1&quot;</span>, nature2.Id, LoadCaseCategory.Snow);</span><br><span class="line">    <span class="keyword">if</span> (case1 == <span class="literal">null</span> || case2 == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Create new load case failed.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create LoadComponents - they consist of LoadCases or nested LoadCombination and Factors</span></span><br><span class="line">    List components = <span class="keyword">new</span> List();</span><br><span class="line">    components.Add(<span class="keyword">new</span> LoadComponent(case1.Id, <span class="number">2.0</span>));</span><br><span class="line">    components.Add(<span class="keyword">new</span> LoadComponent(case2.Id, <span class="number">1.5</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add components to combination</span></span><br><span class="line">    loadCombination.SetComponents(components);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create LoadUsages</span></span><br><span class="line">    LoadUsage usage1 = LoadUsage.Create(document, <span class="string">&quot;Frequent&quot;</span>);</span><br><span class="line">    LoadUsage usage2 = LoadUsage.Create(document, <span class="string">&quot;Rare&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (usage1 == <span class="literal">null</span> || usage2 == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Create new load usage failed.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add load usages to combination</span></span><br><span class="line">    loadCombination.SetUsageIds(<span class="keyword">new</span> List() &#123;usage1.Id, usage2.Id&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Give the user some information</span></span><br><span class="line">    TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>, <span class="built_in">string</span>.Format(<span class="string">&quot;Load Combination ID=&#x27;&#123;0&#125;&#x27; created successfully.&quot;</span>, loadCombination.Id.IntegerValue));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> loadCombination;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>您还可以通过使用LoadCombination.GetComponents（）修改案例、组件、性质等，进行修改，然后再次调用LoadCombination.SetComponents（）。可以通过调用LoadCombination. GetUsageIds（）来修改LoadCombination的LoadUsages，以获取LoadUsage Ids的列表，修改该列表，然后再次调用SetUsageIds（）。下面的代码示例演示如何修改现有的LoadCombination。</p>
<p>代码区域：修改荷载组合</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ModifyLoadCombinationLoadCaseLoadUsageLoadNatureAndLoadComponent</span>(<span class="params">Document document, LoadCombination loadCombination</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Change name of LoadCombination</span></span><br><span class="line">    loadCombination.Name = <span class="string">&quot;DL2 + RAIN1&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get any LoadCase from combination</span></span><br><span class="line">    <span class="comment">// Combination can have assigned LoadCase or other (nested) LoadCombination so we need to filter out any LoadCombination</span></span><br><span class="line">    LoadCase case1 = <span class="literal">null</span>;</span><br><span class="line">    IList caseAndCombinationIds = loadCombination.GetCaseAndCombinationIds();</span><br><span class="line">    <span class="keyword">foreach</span> (ElementId id <span class="keyword">in</span> caseAndCombinationIds)</span><br><span class="line">    &#123;</span><br><span class="line">        Element element = document.GetElement(id);</span><br><span class="line">        <span class="keyword">if</span> (element <span class="keyword">is</span> LoadCase)</span><br><span class="line">        &#123;</span><br><span class="line">            case1 = (LoadCase)element;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (element <span class="keyword">is</span> LoadCombination)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (case1 == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Can&#x27;t get LoadCase.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Change case name and number</span></span><br><span class="line">    case1.Name = <span class="string">&quot;DL2&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (LoadCase.IsNumberUnique(document, <span class="number">3</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        case1.Number = <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create load nature</span></span><br><span class="line">    LoadNature liveNature = LoadNature.Create(document, <span class="string">&quot;Dead nature&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (liveNature == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Create new load nature failed.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Change nature category and ID for case</span></span><br><span class="line">    case1.SubcategoryId = <span class="keyword">new</span> ElementId(BuiltInCategory.OST_LoadCasesDead);</span><br><span class="line">    case1.NatureId = liveNature.Id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Change factor for case1</span></span><br><span class="line">    IList components = loadCombination.GetComponents();</span><br><span class="line">    <span class="keyword">foreach</span> (LoadComponent loadComponent <span class="keyword">in</span> components)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (loadComponent.LoadCaseOrCombinationId == case1.Id)</span><br><span class="line">        &#123;</span><br><span class="line">            loadComponent.Factor = <span class="number">3.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    loadCombination.SetComponents(components);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Remove one usage from combination</span></span><br><span class="line">    IList usages = loadCombination.GetUsageIds();</span><br><span class="line">    usages.RemoveAt(<span class="number">0</span>);</span><br><span class="line">    loadCombination.SetUsageIds(usages);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Give the user some information</span></span><br><span class="line">    TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>, <span class="built_in">string</span>.Format(<span class="string">&quot;Load Combination ID=&#x27;&#123;0&#125;&#x27; modified successfully.&quot;</span>, loadCombination.Id.IntegerValue));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>LoadCase和LoadNature类中没有Duplicate（）方法。若要实现此功能，必须首先创建一个新的LoadCase（或LoadNature）对象，然后从现有的LoadCase（或LoadNature）复制相应的属性和参数。 以下是演示在VB.NET中创建点荷载的最小示例代码：</p>
<p>代码区域：新PointLoad</p>
<figure class="highlight vb"><table><tr><td class="code"><pre><span class="line"><span class="comment">&#x27;Define the location at which the PointLoad is applied. </span></span><br><span class="line"><span class="keyword">Dim</span> point <span class="keyword">As</span> <span class="built_in">New</span> XYZ(<span class="number">0</span>, <span class="number">0</span>, <span class="number">4</span>)</span><br><span class="line"><span class="comment">&#x27;Define the 3d force. </span></span><br><span class="line"><span class="keyword">Dim</span> force <span class="keyword">As</span> <span class="built_in">New</span> XYZ(<span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>)</span><br><span class="line"><span class="comment">&#x27;Define the 3d moment. </span></span><br><span class="line"><span class="keyword">Dim</span> moment <span class="keyword">As</span> <span class="built_in">New</span> XYZ(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">Dim</span> pointLoad <span class="keyword">As</span> PointLoad = pointLoad.Create(document, point, force, moment, <span class="literal">Nothing</span>, <span class="literal">Nothing</span>)</span><br></pre></td></tr></table></figure>

<h2 id="分析链接"><a href="#分析链接" class="headerlink" title="分析链接"></a>分析链接</h2><p>使用Revit，在创建物理模型时会自动生成结构分析模型。分析模型将链接到结构分析应用程序，物理模型将通过Revit API根据结果自动更新。一些第三方软件开发商已经为其结构分析应用程序提供了双向链接。其中包括：</p>
<ul>
<li>ADAPT Corporation（<a href="http://www.adaptsoft.com/revitstructure/">www.adaptsoft.com/revitstructure/</a>）的ADAPT-Builder Suite</li>
<li>Fastrak和S-Frame来自CSC（<a href="http://www.cscworld.com/">www.cscworld.com</a>）</li>
<li>来自CSI的ETABS（<a href="http://www.csiberkeley.com/">www.csiberkeley.com/</a>）</li>
<li>RFEM来自Dlubal（<a href="https://www.dlubal.com/en/download/rfem_revit_en.pdf">www.dlubal.com/en/download/rfem_revit_en.pdf</a>）</li>
<li>GRAITEC（<a href="http://www.graitec.com/En/revit.asp">www.graitec.com/En/revit.asp</a>）的高级设计、视觉设计、Arche、Effel和SuperSTRESS</li>
<li>来自Nemetschek的Scia工程师（<a href="https://www.scia.net/en/software/product-selection/scia-engineer%EF%BC%89">https://www.scia.net/en/software/product-selection/scia-engineer）</a></li>
<li>来自Oasys Software（Arup）的GSA（<a href="http://www.oasys-software.com/products">www.oasys-software.com/products</a>）</li>
<li>Prokon Software Consultants的ProDESK（<a href="http://www.prokon.com/">www.prokon.com/</a>）</li>
<li>Bentley的RAM Structural System（<a href="http://www.bentley.com/en-US/Products/RAM+Structural+System/">www.bentley.com/en-US/Products/RAM+Structural+System/</a>）</li>
<li>RISA-3D和RISAFloor，来自RISA Technologies（<a href="http://www.risatech.com/partner/revit_structure.asp">www.risatech.com/partner/revit_structure.asp</a>）</li>
<li>SOFiSTiK Structural Desktop Suite来自SOFiSTiK（<a href="http://www.sofistik.com/">http://www.sofistik.com</a>）</li>
<li>来自SPACE GASS（<a href="http://www.example.com)的space/">www.example.com）的SPACE</a> GASS<a href="http://www.spacegass.com/index.asp?resend=/revit.asp">www.spacegass.com/index.asp? resend=/revit.asp</a>）</li>
<li>来自Structural Integrators的Revit Structure STAAD.Pro界面（<a href="http://www.structuralintegrators.com/products/si_xchange.php">structuralintegrators.com&#x2F;products&#x2F;si_xchange.php</a>）</li>
<li>Autodesk的Robot Structural Analysis Professional（<a href="http://www.autodesk.com/products/robot-structural-analysis%EF%BC%89">http://www.autodesk.com/products/robot-structural-analysis）</a></li>
</ul>
<p>The key to linking Revit to other analysis applications is to set up the mapping relationship between the objects in different object models. That means the difficulty and level of the integration depends on the similarity between the two object models.<br>将Revit链接到其他分析应用程序的关键是设置不同对象模型中的对象之间的映射关系。这意味着集成的难度和水平取决于两个对象模型之间的相似性。</p>
<p>For example, during the product design process, design a table with at least the first two columns in the object mapping in the following table: one for the Revit API and the other for the structural analysis application, shown as follows:<br>例如，在产品设计过程中，设计一个表，其中至少包含下表中对象映射的前两列：一列用于Revit API，另一列用于结构分析应用程序，如下所示：</p>
<p><strong>表62：Revit和Analysis应用程序对象映射</strong></p>
<table>
<thead>
<tr>
<th><strong>Revit API</strong></th>
<th><strong>Analysis Application 分析应用</strong></th>
<th><strong>Import to Revit 导入到Revit</strong></th>
</tr>
</thead>
<tbody><tr>
<td>StructuralColumn  结构柱</td>
<td>Column  柱</td>
<td>NewStructuralColumn  新建结构柱</td>
</tr>
<tr>
<td>Property:  属性：</td>
<td></td>
<td></td>
</tr>
<tr>
<td>…</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Location  位置</td>
<td></td>
<td>Read-only;  只读;</td>
</tr>
<tr>
<td>Parameter:  参数名称：</td>
<td></td>
<td></td>
</tr>
<tr>
<td>…</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Analyze as  分析为</td>
<td></td>
<td>Editable;  可编辑;</td>
</tr>
<tr>
<td>AnalyticalModel:  分析模型：</td>
<td></td>
<td></td>
</tr>
<tr>
<td>…</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Profile  轮廓</td>
<td></td>
<td>Read-only;  只读;</td>
</tr>
<tr>
<td>RigidLink</td>
<td></td>
<td>Read-only;  只读;</td>
</tr>
<tr>
<td>…</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Material:  材质：</td>
<td></td>
<td></td>
</tr>
<tr>
<td>…</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="Analytical-Links"><a href="#Analytical-Links" class="headerlink" title="Analytical Links"></a>Analytical Links</h2><p>分析链接是连接2个独立分析节点的图元，具有固定状态等属性。在建模过程中，Revit可以根据某些规则自动创建从分析梁到分析柱的分析链接。也可以在Revit UI中或使用Revit API手动创建。</p>
<p>在Revit API中，分析链接由AnalyticalLink类表示。固定度值可从其关联的AnalyticalLinkType获得。</p>
<p>下面的示例演示了如何读取文档中的所有AnalyticalLinks，并显示一个汇总自动生成和手动创建的AnalyticalLinks数量的TaskDialog。</p>
<p>代码区域：阅读分析链接</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ReadAnalyticalLinks</span>(<span class="params">Document document</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    FilteredElementCollector collectorAnalyticalLinks = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">    collectorAnalyticalLinks.OfClass(<span class="keyword">typeof</span>(AnalyticalLink));</span><br><span class="line"></span><br><span class="line">    IEnumerable alinks = collectorAnalyticalLinks.ToElements().Cast();</span><br><span class="line">    <span class="built_in">int</span> nAutoGeneratedLinks = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">int</span> nManualLinks = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">foreach</span> (AnalyticalLink alink <span class="keyword">in</span> alinks)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (alink.IsAutoGenerated() == <span class="literal">true</span>)</span><br><span class="line">            nAutoGeneratedLinks++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            nManualLinks++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">string</span> msg = <span class="string">&quot;Auto-generated AnalyticalLinks: &quot;</span> + nAutoGeneratedLinks;</span><br><span class="line">    msg += <span class="string">&quot;\nManually created AnalyticalLinks: &quot;</span> + nManualLinks;</span><br><span class="line">    TaskDialog.Show(<span class="string">&quot;AnalyticalLinks&quot;</span>, msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>静态方法AnalyticalLink.Create（）创建一个新的分析链接。不是直接连接两个元素，而是在两个集线器之间创建连接。Hub类表示两个或多个Autodesk Revit元素之间的连接。 以下示例在两个选定的FamilyInstance对象之间创建新的分析链接。它使用一个过滤器来查找模型中的所有中心点，然后GetHub（）方法搜索中心点以查找引用每个FamilyInstance的AnalyticalModel的ID的中心点。</p>
<p>代码区域：创建新的AnalyticalLink</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">CreateLink</span>(<span class="params">Document doc, FamilyInstance fi1, FamilyInstance fi2</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    FilteredElementCollector hubCollector = <span class="keyword">new</span> FilteredElementCollector(doc);</span><br><span class="line">    hubCollector.OfClass(<span class="keyword">typeof</span>(Hub));  <span class="comment">//Get all hubs</span></span><br><span class="line">    ICollection allHubs = hubCollector.ToElements();</span><br><span class="line">    FilteredElementCollector linktypeCollector = <span class="keyword">new</span> FilteredElementCollector(doc);</span><br><span class="line">    linktypeCollector.OfClass(<span class="keyword">typeof</span>(AnalyticalLinkType));</span><br><span class="line">    ElementId firstLinkType = linktypeCollector.ToElementIds().First();  <span class="comment">//Get the first analytical link type.</span></span><br><span class="line">    <span class="comment">// Get hub Ids from two selected family instance items</span></span><br><span class="line">    ElementId startHubId = GetHub(fi1.GetAnalyticalModel().Id, allHubs);</span><br><span class="line">    ElementId endHubId = GetHub(fi2.GetAnalyticalModel().Id, allHubs);</span><br><span class="line">    Transaction tran = <span class="keyword">new</span> Transaction(doc, <span class="string">&quot;Create Link&quot;</span>);</span><br><span class="line">    tran.Start();</span><br><span class="line">    <span class="comment">//Create a link between these two hubs.</span></span><br><span class="line">    AnalyticalLink createdLink = AnalyticalLink.Create(doc, firstLinkType, startHubId, endHubId);    tran.Commit();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Get the first Hub on a given AnalyticalModel element</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> ElementId <span class="title">GetHub</span>(<span class="params">ElementId hostId, ICollection allHubs</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">foreach</span> (Element ehub <span class="keyword">in</span> allHubs)</span><br><span class="line">    &#123;</span><br><span class="line">        Hub hub = ehub <span class="keyword">as</span> Hub;</span><br><span class="line">        ConnectorManager manager = hub.GetHubConnectorManager();</span><br><span class="line">        ConnectorSet connectors = manager.Connectors;</span><br><span class="line">        <span class="keyword">foreach</span> (Connector connector <span class="keyword">in</span> connectors)</span><br><span class="line">        &#123;</span><br><span class="line">            ConnectorSet refConnectors = connector.AllRefs;</span><br><span class="line">            <span class="keyword">foreach</span> (Connector refConnector <span class="keyword">in</span> refConnectors)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (refConnector.Owner.Id == hostId)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> hub.Id;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ElementId.InvalidElementId;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="注：翻译自Revit-API-Developers-Guide"><a href="#注：翻译自Revit-API-Developers-Guide" class="headerlink" title="注：翻译自Revit API Developers Guide"></a><em><strong>注：</strong></em>翻译自<a href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_html">Revit API Developers Guide</a></h2>]]></content>
      <categories>
        <category>Revit二次开发人员指南</category>
      </categories>
      <tags>
        <tag>Revit</tag>
      </tags>
  </entry>
  <entry>
    <title>28可扩展储存</title>
    <url>/2024/11/29/Revit%E4%BA%8C%E5%BC%80%E6%8C%87%E5%8D%97/28%E5%8F%AF%E6%89%A9%E5%B1%95%E5%82%A8%E5%AD%98/</url>
    <content><![CDATA[<h1 id="在Revit模型中存储数据"><a href="#在Revit模型中存储数据" class="headerlink" title="在Revit模型中存储数据"></a><a href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_Advanced_Topics_Storing_Data_in_the_Revit_model_html">在Revit模型中存储数据</a></h1><p>使用共享参数或可扩展存储在Revit模型中存储数据。</p>
<p>Revit API提供了两种在Revit模型中存储数据的方法。第一种是使用共享参数。通过Revit API，可以通过编程方式访问通过Revit UI提供的相同共享参数功能。如果共享参数被定义为可见，则用户可以在元素的属性窗口中查看这些参数。可以将共享参数指定给许多（但不是所有）类别的图元。有关详细信息，请参阅共享参数。</p>
<p>另一个选项是可扩展存储，它允许您创建自定义数据结构，然后将该数据的实例分配给模型中的元素。用户在Revit UI中永远看不到这些数据，但其他第三方应用程序可以通过Revit API访问这些数据，具体取决于定义模式时分配给该模式的读&#x2F;写访问权限。与共享参数不同，可扩展存储不限于某些类别的元素。可扩展存储数据可以指定给从Revit模型中的基类Element派生的任何对象。</p>
<p>本节中的页面</p>
<ul>
<li>可扩展存储</li>
</ul>
<h2 id="可扩展存储"><a href="#可扩展存储" class="headerlink" title="可扩展存储"></a>可扩展存储</h2><p>创建您自己的类模式数据结构，并将其实例附加到Revit模型中的任何元素。</p>
<p>基于schema的数据与Revit模型一起保存，并允许更高级别的、元数据增强的、面向对象的数据结构。schema数据可以配置为对所有用户可读和&#x2F;或可写，仅对特定应用程序供应商可读和&#x2F;或可写，或仅对来自供应商的特定应用程序可读和&#x2F;或可写。</p>
<p>在Revit中使用Elements存储数据时，必须执行以下步骤：</p>
<ol>
<li>创建并命名新schema</li>
<li>设置schema的读&#x2F;写访问权限</li>
<li>为schema定义一个或多个数据字段</li>
<li>基于schema创建实体</li>
<li>为实体的字段分配值</li>
<li>将图元与Revit图元关联</li>
</ol>
<h3 id="Schema和SchemaBuilder"><a href="#Schema和SchemaBuilder" class="headerlink" title="Schema和SchemaBuilder"></a>Schema和SchemaBuilder</h3><p>创建可扩展存储的第一步是定义schema。schema类似于面向对象编程语言中的class。使用SchemaBuilder类构造函数创建新schema。SchemaBuilder是一个用于创建schema的帮助类。一旦使用SchemaBuilder完成schema，就可以使用Schema类访问schema的属性。在该阶段，schema不再是可编辑的。</p>
<p>尽管SchemaBuilder构造函数接受一个用于标识schema的字符串，但schema名称也是必需的。创建schema之后，调用SchemaBuilder.SetSchemaName（）为schema分配一个用户友好的标识符。schema名称对于标识错误消息中的schema很有用。</p>
<p>可以独立地设置与schema相关联的实体的读和写访问级别。选项包括Public、Vendor或Application。如果将读或写访问级别设置为Vendor，则必须指定可能访问schema实体的第三方供应商的VendorId。如果将其中一个访问级别设置为应用程序，则必须提供可能访问schema实体的应用程序或外接程序的URL。</p>
<p><em><strong>注意：</strong></em>schema与文档一起存储，任何Revit API附加模块都可以读取文档中的可用schema以及schema的某些数据。然而，对schema的字段的访问是基于在schema中定义的读访问来限制的，并且与特定元素一起存储的实体中的实际数据是基于在定义schema时在schema中设置的读和写访问级别来限制的。</p>
<h3 id="Fields-and-FieldBuilder"><a href="#Fields-and-FieldBuilder" class="headerlink" title="Fields and FieldBuilder"></a>Fields and FieldBuilder</h3><p>一旦创建了schema，就可以定义字段。字段类似于类的属性。它包含名称、文档、值类型和单位类型。字段可以是简单类型、数组或映射。允许以下简单数据类型：</p>
<table>
<thead>
<tr>
<th><strong>Type 类型</strong></th>
<th><strong>Default Value 默认值</strong></th>
</tr>
</thead>
<tbody><tr>
<td>int</td>
<td>0</td>
</tr>
<tr>
<td>short</td>
<td>0</td>
</tr>
<tr>
<td>byte</td>
<td>0</td>
</tr>
<tr>
<td>double</td>
<td>0.0</td>
</tr>
<tr>
<td>float</td>
<td>0.0</td>
</tr>
<tr>
<td>bool</td>
<td>false</td>
</tr>
<tr>
<td>string</td>
<td>Empty string (“”)</td>
</tr>
<tr>
<td>GUID</td>
<td>Guid.Empty {00000000-0000-0000-0000-000000000000} GUID。</td>
</tr>
<tr>
<td>ElementId</td>
<td>ElementId.InvalidElementId</td>
</tr>
<tr>
<td>Autodesk.Revit.DB.XYZ</td>
<td>(0.0,0.0,0.0)</td>
</tr>
<tr>
<td>Autodesk.Revit.DB.UV</td>
<td>(0.0,0.0)</td>
</tr>
</tbody></table>
<p>此外，字段的类型可以是Autodesk. Revit. DB. ExtensibleData. Autonomy。换句话说，它是另一个Schema的实例，也称为SubSchema 或 SubEntity。此类型字段的默认值为Entity，模式为null，guid为Guid.Empty。 使用字符串字段时，请注意Revit对字符串对象的大小限制为16 MB。</p>
<p> 可以使用SchemaBuilder.AddSimpleField（）方法为字段指定名称和类型来创建简单字段。AddSimpleField（）返回一个FieldBuilder，它是一个用于定义Field的帮助类。如果字段的类型被指定为Entity，则使用FieldBuilder.SetSubSchemaString（）指定要存储在此字段中的实体的Schema的类型。 </p>
<p>使用SchemaBuilder.AddArrayField（）方法创建一个字段，该字段包含Schema中的值数组，并具有给定的名称和所包含值的类型。数组字段可以具有与简单字段相同的类型。 </p>
<p>使用SchemaBuilder.AddMapField（）方法创建一个字段，该字段包含Schema中的有序键值映射，并具有给定的名称、键类型和所包含值的类型。支持的值类型与简单字段相同。支持的键类型仅限于int、short、byte、string、bool、ElementId和String。 一旦使用SchemaBuilder完成Schema，就不能再使用FieldBuilder编辑字段。在该阶段，Schema类提供了按名称获取Field的方法，或者获取Schema中定义的所有Field的列表。</p>
<h3 id="Entity"><a href="#Entity" class="headerlink" title="Entity"></a>Entity</h3><p>在为Schema定义了所有字段之后，SchemaBuilder.Finish（）将返回完成的Schema。可以使用该Schema创建新Entity。</p>
<p>对于Schema中的每个字段，可以使用Entity.Set（）存储值，Entity.Set（）接受一个字段和一个值（其类型取决于字段类型）。</p>
<p>一旦为Entity设置了所有适用的字段，就可以使用Element.SetEntity（）方法将其分配给元素。</p>
<p> 要在以后检索数据，请调用Element.GetEntity（），传入相应的Schema。如果没有基于该Schema的Entity与元素一起保存，则将返回无效Entity。若要检查是否返回了有效的Entity，请调用Entity.IsValid（）方法。</p>
<p>可以使用Entity.Get（）方法从实体中获取字段值。 </p>
<p>若要从Element中删除可扩展存储实体，请调用Element.DeleteEntity（），传入用于创建它的Schema。 </p>
<p>要确定与元素一起存储的实体，请使用Element.GetEntitySchemaGuids（）方法，该方法返回元素的任何Entity的Schema的GUID。Schemaguid可以与静态方法Schema.schema（）一起使用，以检索相应的Schemas。 </p>
<p>下面是一个定义可扩展存储模式、创建实体、设置其值、将其分配给元素以及检索数据的示例。</p>
<p>代码区域22-9：可扩展存储</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Create a data structure, attach it to a wall, populate it with data, and retrieve the data back from the wall</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StoreDataInWall</span>(<span class="params">Wall wall, XYZ dataToStore</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        Transaction createSchemaAndStoreData = <span class="keyword">new</span> Transaction(wall.Document, <span class="string">&quot;tCreateAndStore&quot;</span>);</span><br><span class="line">        createSchemaAndStoreData.Start();</span><br><span class="line">        SchemaBuilder schemaBuilder = </span><br><span class="line">                <span class="keyword">new</span> SchemaBuilder(<span class="keyword">new</span> Guid(<span class="string">&quot;720080CB-DA99-40DC-9415-E53F280AA1F0&quot;</span>));</span><br><span class="line">        schemaBuilder.SetReadAccessLevel(AccessLevel.Public); <span class="comment">// allow anyone to read the object</span></span><br><span class="line">        schemaBuilder.SetWriteAccessLevel(AccessLevel.Vendor); <span class="comment">// restrict writing to this vendor only</span></span><br><span class="line">        schemaBuilder.SetVendorId(<span class="string">&quot;ADSK&quot;</span>); <span class="comment">// required because of restricted write-access</span></span><br><span class="line">        schemaBuilder.SetSchemaName(<span class="string">&quot;WireSpliceLocation&quot;</span>);</span><br><span class="line">        <span class="comment">// create a field to store an XYZ</span></span><br><span class="line">        FieldBuilder fieldBuilder = </span><br><span class="line">                schemaBuilder.AddSimpleField(<span class="string">&quot;WireSpliceLocation&quot;</span>, <span class="keyword">typeof</span>(XYZ)); </span><br><span class="line">        fieldBuilder.SetUnitType(UnitType.UT_Length);</span><br><span class="line">        fieldBuilder.SetDocumentation(<span class="string">&quot;A stored location value representing a wiring splice in a wall.&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Schema schema = schemaBuilder.Finish(); <span class="comment">// register the Schema object</span></span><br><span class="line">        Entity entity = <span class="keyword">new</span> Entity(schema); <span class="comment">// create an entity (object) for this schema (class)</span></span><br><span class="line">        <span class="comment">// get the field from the schema</span></span><br><span class="line">        Field fieldSpliceLocation = schema.GetField(<span class="string">&quot;WireSpliceLocation&quot;</span>); </span><br><span class="line">        <span class="comment">// set the value for this entity</span></span><br><span class="line">        entity.Set(fieldSpliceLocation, dataToStore, DisplayUnitType.DUT_METERS); </span><br><span class="line">        wall.SetEntity(entity); <span class="comment">// store the entity in the element</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// get the data back from the wall</span></span><br><span class="line">        Entity retrievedEntity = wall.GetEntity(schema);</span><br><span class="line">        XYZ retrievedData = </span><br><span class="line">                retrievedEntity.Get(schema.GetField(<span class="string">&quot;WireSpliceLocation&quot;</span>),</span><br><span class="line">                DisplayUnitType.DUT_METERS);</span><br><span class="line">        createSchemaAndStoreData.Commit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><h4 id="自我记录和自定义"><a href="#自我记录和自定义" class="headerlink" title="自我记录和自定义"></a>自我记录和自定义</h4><p>通过添加字段、单元、子实体和描述字符串来创建Schema不仅是存储数据的一种方法。对于其他用户来说，它也是一种隐式文档，并且其他人可以通过简单的采用路径在以后创建相同模式的实体。</p>
<h4 id="利用局部性"><a href="#利用局部性" class="headerlink" title="利用局部性"></a>利用局部性</h4><p>因为Schema的Entity是以每个元素为基础存储的，所以当应用程序可能只需要当前选定梁的数据时，不需要读取文档中的所有可扩展存储数据（例如，来自所有梁族实例的所有数据）。这允许更具体地针对数据访问代码和更好的数据访问性能的潜力。</p>
<h2 id="注：翻译自Revit-API-Developers-Guide"><a href="#注：翻译自Revit-API-Developers-Guide" class="headerlink" title="注：翻译自Revit API Developers Guide"></a><em><strong>注：</strong></em>翻译自<a href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_html">Revit API Developers Guide</a></h2>]]></content>
      <categories>
        <category>Revit二次开发人员指南</category>
      </categories>
      <tags>
        <tag>Revit</tag>
      </tags>
  </entry>
  <entry>
    <title>30外部事件</title>
    <url>/2024/11/29/Revit%E4%BA%8C%E5%BC%80%E6%8C%87%E5%8D%97/30%E5%A4%96%E9%83%A8%E4%BA%8B%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="外部事件"><a href="#外部事件" class="headerlink" title="外部事件"></a><a href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_Advanced_Topics_External_Events_html">外部事件</a></h1><p>Revit API提供了一个外部事件框架，以适应非模态对话框的使用。它是为异步处理量身定制的，其操作类似于具有默认频率的Idling事件。</p>
<p>要使用外部事件框架实现无模式对话框，请执行以下步骤：</p>
<ol>
<li>通过从IExternalEventException接口派生来实现外部事件处理程序</li>
<li>使用静态ExternalEvent.Create（）方法创建ExternalEvent</li>
<li>当需要执行Revit操作的无模式对话框中发生事件时，调用ExternalEvent.Raise（）</li>
<li>当存在可用的空闲时间周期时，Revit将调用IExternalEvents.Execute（）方法的实现。</li>
</ol>
<h3 id="IExternalEventHandler"><a href="#IExternalEventHandler" class="headerlink" title="IExternalEventHandler"></a>IExternalEventHandler</h3><p>这是要为外部事件实现的接口。实现此接口的类的实例注册到Revit中，每次引发相应的外部事件时，都会调用此接口的Execute方法。</p>
<p>IExternalEventHandler 只有两个方法要实现，Execute（）方法和GetName（），后者应该返回事件的名称。下面是一个基本的实现，它将在引发事件时显示TaskDialog。</p>
<p>**代码区域：实现IExternalEventHandler **</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ExternalEventExample</span> : <span class="title">IExternalEventHandler</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Execute</span>(<span class="params">UIApplication app</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        TaskDialog.Show(<span class="string">&quot;External Event&quot;</span>, <span class="string">&quot;Click Close to close.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">GetName</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;External Event Example&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="外部事件-1"><a href="#外部事件-1" class="headerlink" title="外部事件"></a>外部事件</h3><p>ExternalEvent类用于创建ExternalEvent。此类的实例将在事件创建时返回给外部事件的所有者。事件的所有者将使用此实例来通知Revit应调用该事件。Revit将定期检查是否有任何事件已发出信号（引发），并将执行通过调用事件各自处理程序上的Execute方法引发的所有事件。</p>
<p>下面的示例演示IExternalApplication的实现，该IExternalApplication具有从ExternalCommand（显示在代码区域的末尾）调用的ShowForm（）方法。ShowForm（）方法从上面的例子中创建了一个外部事件处理程序的新实例，创建了一个新的ExternalEvent，然后显示无模式对话框，该对话框稍后将使用传入的ExternalEvent对象来引发事件。</p>
<p><strong>代码区域：创建外部事件</strong></p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ExternalEventExampleApp</span> : <span class="title">IExternalApplication</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// class instance</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ExternalEventExampleApp thisApp = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// ModelessForm instance</span></span><br><span class="line">    <span class="keyword">private</span> ExternalEventExampleDialog m_MyForm;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">OnShutdown</span>(<span class="params">UIControlledApplication application</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (m_MyForm != <span class="literal">null</span> &amp;&amp; m_MyForm.Visible)</span><br><span class="line">        &#123;</span><br><span class="line">            m_MyForm.Close();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Result.Succeeded;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">OnStartup</span>(<span class="params">UIControlledApplication application</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_MyForm = <span class="literal">null</span>;   <span class="comment">// no dialog needed yet; the command will bring it</span></span><br><span class="line">        thisApp = <span class="keyword">this</span>;  <span class="comment">// static access to this application instance</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Result.Succeeded;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//   The external command invokes this on the end-user&#x27;s request</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ShowForm</span>(<span class="params">UIApplication uiapp</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// If we do not have a dialog yet, create and show it</span></span><br><span class="line">        <span class="keyword">if</span> (m_MyForm == <span class="literal">null</span> || m_MyForm.IsDisposed)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// A new handler to handle request posting by the dialog</span></span><br><span class="line">            ExternalEventExample handler = <span class="keyword">new</span> ExternalEventExample();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// External Event for the dialog to use (to post requests)</span></span><br><span class="line">            ExternalEvent exEvent = ExternalEvent.Create(handler);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// We give the objects to the new dialog;</span></span><br><span class="line">            <span class="comment">// The dialog becomes the owner responsible for disposing them, eventually.</span></span><br><span class="line">            m_MyForm = <span class="keyword">new</span> ExternalEventExampleDialog(exEvent, handler);</span><br><span class="line">            m_MyForm.Show();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="meta">Autodesk.Revit.Attributes.Transaction(Autodesk.Revit.Attributes.TransactionMode.Manual)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Command</span> : <span class="title">IExternalCommand</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> Result <span class="title">Execute</span>(<span class="params">ExternalCommandData commandData, <span class="keyword">ref</span> <span class="built_in">string</span> message, ElementSet elements</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            ExternalEventExampleApp.thisApp.ShowForm(commandData.Application);</span><br><span class="line">            <span class="keyword">return</span> Result.Succeeded;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception ex)</span><br><span class="line">        &#123;</span><br><span class="line">            message = ex.Message;</span><br><span class="line">            <span class="keyword">return</span> Result.Failed;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一旦显示非模态对话框，用户就可以与之交互。对话框中的操作可能需要触发Revit中的某些操作。发生这种情况时，将调用ExternalEvent.Raise（）方法。下面的示例是一个简单的无模式对话框的代码，该对话框有两个按钮：一个用于引发事件，另一个用于关闭对话框。</p>
<p>代码区域：引发事件</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">ExternalEventExampleDialog</span> : <span class="title">Form</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> ExternalEvent m_ExEvent;</span><br><span class="line">    <span class="keyword">private</span> ExternalEventExample m_Handler;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ExternalEventExampleDialog</span>(<span class="params">ExternalEvent exEvent, ExternalEventExample handler</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        InitializeComponent();</span><br><span class="line">        m_ExEvent = exEvent;</span><br><span class="line">        m_Handler = handler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnFormClosed</span>(<span class="params">FormClosedEventArgs e</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// we own both the event and the handler</span></span><br><span class="line">        <span class="comment">// we should dispose it before we are closed</span></span><br><span class="line">        m_ExEvent.Dispose();</span><br><span class="line">        m_ExEvent = <span class="literal">null</span>;</span><br><span class="line">        m_Handler = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// do not forget to call the base class</span></span><br><span class="line">        <span class="keyword">base</span>.OnFormClosed(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">closeButton_Click</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">showMessageButton_Click</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_ExEvent.Raise();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用ExternalEvent.Raise（）方法时，Revit将等待可用的Idling计时器，然后调用IExternalEventEvent.Execute（）方法。在这个简单的例子中，它将显示一个TaskDialog，文本为“Click Close to close.”“，如上面第一个代码区域所示。</p>
<p>有关使用外部事件框架的更复杂示例，请参见SDK中ModelessDialog\ModelessForm_ExternalEvent文件夹下的示例代码。它使用一个带有许多按钮的非模态对话框，IExternalEventEvent实现有一个公共属性来跟踪按下了哪个按钮，因此它可以在Execute（）方法中打开该值。</p>
<h2 id="注：翻译自Revit-API-Developers-Guide"><a href="#注：翻译自Revit-API-Developers-Guide" class="headerlink" title="注：翻译自Revit API Developers Guide"></a><em><strong>注：</strong></em>翻译自<a href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_html">Revit API Developers Guide</a></h2>]]></content>
      <categories>
        <category>Revit二次开发人员指南</category>
      </categories>
      <tags>
        <tag>Revit</tag>
      </tags>
  </entry>
  <entry>
    <title>29事件</title>
    <url>/2024/11/29/Revit%E4%BA%8C%E5%BC%80%E6%8C%87%E5%8D%97/29%E4%BA%8B%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="事件"><a href="#事件" class="headerlink" title="事件"></a><a href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_Advanced_Topics_Events_html">事件</a></h1><p>事件是在Revit用户界面或API工作流中执行特定操作时触发的通知。通过订阅事件，可以在操作即将发生或刚刚发生时通知外接程序应用程序，并采取与该事件相关的某些操作。有些事件是成对发生的，一个发生在动作发生之前（“pre”事件），另一个发生在动作发生之后（“post”事件）。在这些前&#x2F;后对中不发生的事件称为“单个”事件。</p>
<p>Revit提供对应用程序级别（如ApplicationClosing或DocumentOpened）和文档级别（如DocumentClosing和DocumentPrinting）的事件的访问。Application类中提供的相同应用程序级别事件也可从ControlledApplication类中获得，ControlledApplication类表示未访问文档的Revit应用程序。ControlledApplication可用于OnStartup（）和OnStartup（）方法中的外接程序。就订阅和取消订阅事件而言，这些类是可互换的;从ControlledApplication类订阅事件与从Application类订阅事件相同。</p>
<p>事件还可以分类为数据库（DB）事件或用户界面（UI）事件。DB事件可从Application和Document类获得，而UI事件可从UIApplication类获得。（目前所有UI事件都仅在应用程序级别）。</p>
<p>有些事件被认为是只读的，这意味着在它们的执行过程中，模型可能不会被修改。事件为只读的事实在API帮助文件中有说明。重要的是要知道，即使在常规事件（即非只读事件）期间，模型也可能处于无法修改的状态。程序员应该检查属性Document.IsModifiable和Document.IsReadOnly以确定模型是否可以修改。</p>
<p> 本节中的页面</p>
<ul>
<li>数据库事件</li>
<li>用户界面事件</li>
<li>注册事件</li>
<li>取消事件</li>
</ul>
<h2 id="数据库事件"><a href="#数据库事件" class="headerlink" title="数据库事件"></a>数据库事件</h2><p>下表列出了数据库事件、它们的类型以及它们是否在应用程序和&#x2F;或文档级别可用：</p>
<p><strong>表53：数据库事件类型</strong></p>
<table>
<thead>
<tr>
<th><strong>Event 事件</strong></th>
<th><strong>Type 类型</strong></th>
<th><strong>Application 应用</strong></th>
<th><strong>Document 文档</strong></th>
</tr>
</thead>
<tbody><tr>
<td>DocumentChanged event</td>
<td>single</td>
<td>X</td>
<td></td>
</tr>
<tr>
<td>DocumentClosing</td>
<td>pre</td>
<td>X</td>
<td>X</td>
</tr>
<tr>
<td>DocumentClosed</td>
<td>post</td>
<td>X</td>
<td></td>
</tr>
<tr>
<td>DocumentCreating</td>
<td>pre</td>
<td>X</td>
<td></td>
</tr>
<tr>
<td>DocumentCreated</td>
<td>post</td>
<td>X</td>
<td></td>
</tr>
<tr>
<td>DocumentOpening</td>
<td>pre</td>
<td>X</td>
<td></td>
</tr>
<tr>
<td>DocumentOpened</td>
<td>post</td>
<td>X</td>
<td></td>
</tr>
<tr>
<td>DocumentPrinting</td>
<td>pre</td>
<td>X</td>
<td>X</td>
</tr>
<tr>
<td>DocumentPrinted</td>
<td>post</td>
<td>X</td>
<td>X</td>
</tr>
<tr>
<td>DocumentSaving</td>
<td>pre</td>
<td>X</td>
<td>X</td>
</tr>
<tr>
<td>DocumentSaved</td>
<td>post</td>
<td>X</td>
<td>X</td>
</tr>
<tr>
<td>DocumentSavingAs</td>
<td>pre</td>
<td>X</td>
<td>X</td>
</tr>
<tr>
<td>DocumentSavedAs</td>
<td>post</td>
<td>X</td>
<td>X</td>
</tr>
<tr>
<td>DocumentSynchronizingWithCentral</td>
<td>pre</td>
<td>X</td>
<td></td>
</tr>
<tr>
<td>DocumentSynchronizedWithCentral</td>
<td>post</td>
<td>X</td>
<td></td>
</tr>
<tr>
<td>FailuresProcessing</td>
<td>single</td>
<td>X</td>
<td></td>
</tr>
<tr>
<td>FileExporting</td>
<td>pre</td>
<td>X</td>
<td></td>
</tr>
<tr>
<td>FileExported</td>
<td>post</td>
<td>X</td>
<td></td>
</tr>
<tr>
<td>FileImporting</td>
<td>pre</td>
<td>X</td>
<td></td>
</tr>
<tr>
<td>FileImported</td>
<td>post</td>
<td>X</td>
<td></td>
</tr>
<tr>
<td>ProgressChanged</td>
<td>single</td>
<td>X</td>
<td></td>
</tr>
<tr>
<td>ViewPrinting</td>
<td>pre</td>
<td>X</td>
<td>X</td>
</tr>
<tr>
<td>ViewPrinted</td>
<td>post</td>
<td>X</td>
<td>X</td>
</tr>
</tbody></table>
<ul>
<li>DocumentChanged -提交、撤消或重做事务时的通知</li>
<li>DocumentClosing -Revit即将关闭文档时的通知</li>
<li>DocumentClosed -Revit关闭文档后立即发出的通知</li>
<li>DocumentCreating -Revit将要创建新文档时的通知</li>
<li>DocumentCreated -Revit完成创建新文档时的通知</li>
<li>DocumentOpening -Revit即将打开文档时的通知</li>
<li>DocumentOpened -Revit打开文档后的通知</li>
<li>DocumentPrinting -Revit将要打印文档的视图或视图集时的通知</li>
<li>DocumentPrinted -在Revit打印完文档的视图或视图集后发出的通知</li>
<li>DocumentSaving -Revit即将保存文档时的通知</li>
<li>DocumentSaved -Revit保存文档后立即发出的通知</li>
<li>DocumentSavingAs -Revit将以新名称保存文档时的通知</li>
<li>DocumentSavedAs -当Revit刚用新名称保存文档时发出的通知</li>
<li>DocumentSynchronizingWithCentral -当Revit要将文档与中心文件同步时发出的通知</li>
<li>DocumentSynchronizedWithCentral -在Revit将文档与中心文件同步后发出的通知</li>
<li>FailuresProcessing -事务结束时Revit处理失败时的通知</li>
<li>FileExporting -Revit即将导出为API支持的文件格式时的通知</li>
<li>FileExported -Revit导出为API支持的文件格式后的通知</li>
<li>FileImporting -Revit将要导入API支持的文件格式时的通知</li>
<li>FileImported -Revit导入API支持的文件格式后的通知</li>
<li>ProgressChanged -当Revit中的操作具有进度条数据时发出的通知</li>
<li>ViewPrinting -Revit即将打印文档视图时的通知</li>
<li>ViewPrinted -在Revit打印完文档视图后立即发出通知</li>
</ul>
<p>本节中的页面</p>
<ul>
<li>DocumentChanged事件</li>
</ul>
<h3 id="DocumentChanged事件"><a href="#DocumentChanged事件" class="headerlink" title="DocumentChanged事件"></a>DocumentChanged事件</h3><p>更改Revit文档时会触发DocumentChanged事件。只要提交、撤消或重做Revit事务，就会引发此事件。这是一个只读事件，旨在允许外部数据与Revit数据库的状态保持同步。若要更新Revit数据库以响应图元中的更改，请使用IUpdater框架。</p>
<p>DocumentChangedEventArgs类由DocumentChanged事件使用。这个类有几个方法来获取任何新添加的元素（GetAddElementIds（））、已删除的元素（GetDeletedElementIds（））或已修改的元素（GetModifiedElementIds（））的元素ID。GetAddElementIds（）和GetModifiedElementIds（）方法具有采用ElementFilter的重载，这使得仅检测感兴趣的更改变得容易。</p>
<h2 id="用户界面事件"><a href="#用户界面事件" class="headerlink" title="用户界面事件"></a>用户界面事件</h2><p>下表列出了用户界面事件、它们的类型以及它们是否在应用程序和&#x2F;或文档级别可用：</p>
<p><strong>表54：UI事件类型</strong></p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>**Event **</td>
<td>**Type **</td>
<td><strong>UIApplication</strong></td>
<td>**ControlledApplication **</td>
<td>**UIDocument **</td>
</tr>
<tr>
<td>ApplicationClosing</td>
<td>pre</td>
<td>X</td>
<td></td>
<td></td>
</tr>
<tr>
<td>ApplicationInitialized</td>
<td>single</td>
<td></td>
<td>X</td>
<td></td>
</tr>
<tr>
<td>DialogBoxShowing</td>
<td>single</td>
<td>X</td>
<td></td>
<td></td>
</tr>
<tr>
<td>DisplayingOptionsDialog</td>
<td>single</td>
<td>X</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Idling</td>
<td>single</td>
<td>X</td>
<td></td>
<td></td>
</tr>
<tr>
<td>ViewActivating</td>
<td>pre</td>
<td>X</td>
<td></td>
<td></td>
</tr>
<tr>
<td>ViewActivated</td>
<td>post</td>
<td>X</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<ul>
<li>ApplicationClosing - 即将关闭Revit应用程序时的通知</li>
<li>ApplicationInitialized-在Revit应用程序初始化后、所有外部应用程序已启动且应用程序已准备好处理文档后发出的通知</li>
<li>DialogBoxShowing-Revit显示对话框或消息框时的通知</li>
<li>DisplayingOptionsDialog -显示Revit选项对话框时的通知</li>
<li>Idling - Revit不在活动工具或事务中时的通知</li>
<li>ViewActivating -Revit即将激活文档视图时的通知</li>
<li>ViewActivated -在Revit激活文档视图后立即发出通知</li>
</ul>
<h2 id="注册事件"><a href="#注册事件" class="headerlink" title="注册事件"></a>注册事件</h2><p>在哪里以及如何注册事件。</p>
<p>使用事件是一个两步的过程。首先，必须有一个处理事件通知的函数。这个函数必须接受两个参数，第一个是Object，表示事件通知的“发送者”，第二个是事件特定的对象，包含特定于该事件的事件参数。例如，若要注册DocumentSavingAs事件，事件处理程序必须采用第二个参数，该参数是DocumentSavingAsEventArgs对象。</p>
<p>使用事件的第二部分是向Revit注册事件。这可以在OnStartup（）函数中通过ControlledApplication参数完成，也可以在Revit启动后的任何时间完成。虽然可以为外部命令和外部应用程序注册事件，但不建议这样做，除非外部命令在同一外部命令中注册和取消注册事件。还要注意，注册到事件和从事件取消注册必须在主线程上执行时发生。如果外部应用程序试图从有效的API上下文外部注册事件（或取消注册），则将引发异常。</p>
<p>下面的示例注册DocumentOpened事件，当触发该事件时，此应用程序将设置项目的地址。</p>
<p><strong>代码区域24-1：注册ControlledApplication.DocumentOpened</strong></p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Application_DocumentOpened</span> : <span class="title">IExternalApplication</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> </span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> </span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> Implement this method to subscribe to event.</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">OnStartup</span>(<span class="params">UIControlledApplication application</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Register event. </span></span><br><span class="line">            application.ControlledApplication.DocumentOpened += <span class="keyword">new</span> EventHandler</span><br><span class="line">                &lt;Autodesk.Revit.DB.Events.DocumentOpenedEventArgs&gt;(application_DocumentOpened);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.Failed;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Result.Succeeded;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">OnShutdown</span>(<span class="params">UIControlledApplication application</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// remove the event.</span></span><br><span class="line">        application.ControlledApplication.DocumentOpened -= application_DocumentOpened;</span><br><span class="line">        <span class="keyword">return</span> Result.Succeeded;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">application_DocumentOpened</span>(<span class="params"><span class="built_in">object</span> sender, DocumentOpenedEventArgs <span class="keyword">args</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// get document from event args.</span></span><br><span class="line">        Document doc = <span class="keyword">args</span>.Document;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Following code snippet demonstrates support of DocumentOpened event to modify the model.</span></span><br><span class="line">        <span class="comment">// Because DocumentOpened supports model changes, it allows user to update document data.</span></span><br><span class="line">        <span class="comment">// Here, this sample assigns a specified value to ProjectInformation.Address property. </span></span><br><span class="line">        <span class="comment">// User can change other properties of document or create(delete) something as he likes.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// Please note that ProjectInformation property is empty for family document.</span></span><br><span class="line">        <span class="comment">// So please don&#x27;t run this sample on family document.</span></span><br><span class="line">        <span class="keyword">using</span> (Transaction transaction = <span class="keyword">new</span> Transaction(doc, <span class="string">&quot;Edit Address&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (transaction.Start() == TransactionStatus.Started)</span><br><span class="line">            &#123;</span><br><span class="line">                doc.ProjectInformation.Address =</span><br><span class="line">                    <span class="string">&quot;United States - Massachusetts - Waltham - 1560 Trapelo Road&quot;</span>;</span><br><span class="line">                transaction.Commit();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="取消事件"><a href="#取消事件" class="headerlink" title="取消事件"></a>取消事件</h2><p>在操作发生之前触发的事件（即DocumentSaving）通常是可取消的。(用可取消属性，以确定事件是否可以取消。）例如，您可能希望在保存模型之前检查模型是否满足某些条件。例如，通过注册DocumentSaving或DocumentSavingAs事件，您可以检查文档中的某些条件并取消Save或Save As操作。事件一旦取消，就无法取消。</p>
<p><em><strong>注意：</strong></em>如果取消了pre事件，则不会通知已订阅该事件的其他事件处理程序。但是，将通知已订阅与前事件相关的后事件的处理程序。下面的DocumentSavingAs事件的事件处理程序检查ProjectInformation Status参数是否为空，如果为空，则取消SaveAs事件。请注意，如果应用程序取消了一个事件，它应该向用户提供一个解释。</p>
<p><strong>代码区域24-2：取消事件</strong></p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">CheckProjectStatusInitial</span>(<span class="params">Object sender, DocumentSavingAsEventArgs <span class="keyword">args</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        Document doc = <span class="keyword">args</span>.Document;</span><br><span class="line">        ProjectInfo proInfo = doc.ProjectInformation;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Project information is only available for project document.</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != proInfo)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">string</span>.IsNullOrEmpty(proInfo.Status))</span><br><span class="line">                &#123;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// cancel the save as process.</span></span><br><span class="line">                        <span class="keyword">args</span>.Cancel = <span class="literal">true</span>;</span><br><span class="line">                        MessageBox.Show(<span class="string">&quot;Status project parameter is not set.  Save is aborted.&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em><strong>注意：</strong></em>虽然大多数事件参数都有Cancel和Cancellable属性，但DocumentChanged和FailuresProcessing事件有相应的Cancel（）和IsCancellable（）方法。</p>
<h2 id="注：翻译自Revit-API-Developers-Guide"><a href="#注：翻译自Revit-API-Developers-Guide" class="headerlink" title="注：翻译自Revit API Developers Guide"></a><em><strong>注：</strong></em>翻译自<a href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_html">Revit API Developers Guide</a></h2>]]></content>
      <categories>
        <category>Revit二次开发人员指南</category>
      </categories>
      <tags>
        <tag>Revit</tag>
      </tags>
  </entry>
  <entry>
    <title>31可停靠对话框窗格</title>
    <url>/2024/11/29/Revit%E4%BA%8C%E5%BC%80%E6%8C%87%E5%8D%97/31%E5%8F%AF%E5%81%9C%E9%9D%A0%E5%AF%B9%E8%AF%9D%E6%A1%86%E7%AA%97%E6%A0%BC/</url>
    <content><![CDATA[<h1 id="可停靠对话框窗格"><a href="#可停靠对话框窗格" class="headerlink" title="可停靠对话框窗格"></a><a href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_Advanced_Topics_Dockable_Dialog_Panes_html">可停靠对话框窗格</a></h1><p>自Revit 2013以来，应用程序可以通过利用Revit API中的Idling事件（用户界面事件和外部事件）类来使用无模式对话框。需要非模态对话框的加载项也可以选择使用可停靠的非模态对话框。与标准的无模式对话框类似，可停靠对话框是注册的Windows Presentation Foundation（WPF）对话框窗格，参与Revit的窗口对接系统。注册的可停靠窗格可以停靠在主Revit窗口的顶部、左侧、右侧和底部，也可以作为选项卡添加到现有系统窗格（例如项目浏览器）。此外，可停靠窗格可以浮动，表现得很像标准的非模态对话框。</p>
<h2 id="IDockablePaneProvider"><a href="#IDockablePaneProvider" class="headerlink" title="IDockablePaneProvider"></a>IDockablePaneProvider</h2><p>注册可停靠窗格需要IDockablePaneProvider接口的实例。在Revit用户界面初始化期间调用此界面的SetupDockableWindow（）方法，以收集有关附加模块可固定窗格窗口的信息。SetupDockableData（）有一个DockablePaneProviderData类型的参数，它是关于新可停靠窗格的信息的容器。</p>
<p>IDockablePaneProvider接口的实现应设置DockablePaneProviderData的FrameworkElement和InitialState属性。FrameworkElement属性是包含窗格用户界面的Windows Presentation Framework对象。</p>
<p><strong>注意：</strong>建议外接程序中的可停靠对话框是实现IDockablePaneProvider的类，并从System.Windows.Controls.Page子类化它。</p>
<p>InitialState属性是对接窗格的初始位置和设置，由DockablePaneState类指示。窗格的停靠位置可以是上、下、左、右、浮动或选项卡式。如果位置为Tabbed，则DockablePaneState.TabBehind属性可用于指定新窗格将显示在哪个窗格后面。如果位置为Floating，则DockablePaneState.FloatingRectangle属性包含确定窗格大小和位置的矩形。</p>
<h2 id="DockablePane-Dockable"><a href="#DockablePane-Dockable" class="headerlink" title="DockablePane Dockable"></a>DockablePane Dockable</h2><p>要在运行时访问可停靠窗格，需要通过调用UIApplication. RegisterDockableList（）方法来注册它。此方法需要新窗格的唯一标识符（DockablePaneId）、指定窗格标题的字符串以及IDockablePaneProvider接口的实现。</p>
<p>可停靠窗格可以通过调用UIApplication. GetDockablePanId（）并传入唯一的DockablePaneId来访问。此方法返回一个DockablePanId。DockablePane.Show（）将在Revit用户界面中的最后停靠位置（如果当前不可见）显示窗格。Dockable.Hide（）将隐藏可见的可停靠窗格。但是，它对内置的Revit可固定窗格没有影响。</p>
<h2 id="注：翻译自Revit-API-Developers-Guide"><a href="#注：翻译自Revit-API-Developers-Guide" class="headerlink" title="注：翻译自Revit API Developers Guide"></a><em><strong>注：</strong></em>翻译自<a href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_html">Revit API Developers Guide</a></h2>]]></content>
      <categories>
        <category>Revit二次开发人员指南</category>
      </categories>
      <tags>
        <tag>Revit</tag>
      </tags>
  </entry>
  <entry>
    <title>32动态模型更新</title>
    <url>/2024/11/29/Revit%E4%BA%8C%E5%BC%80%E6%8C%87%E5%8D%97/32%E5%8A%A8%E6%80%81%E6%A8%A1%E5%9E%8B%E6%9B%B4%E6%96%B0/</url>
    <content><![CDATA[<h1 id="动态模型更新"><a href="#动态模型更新" class="headerlink" title="动态模型更新"></a><a href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_Advanced_Topics_Dynamic_Model_Update_html">动态模型更新</a></h1><p>动态模型更新为Revit API应用程序提供了修改Revit模型的能力，作为对模型中发生的更改（当这些更改即将在事务结束时提交时）的反应。Revit API应用程序可以通过实现IUpdater接口并将其注册到UpdaterRegistry类来创建更新程序。注册包括指定模型中的哪些更改应该触发更新程序。</p>
<p>Pages in this section 本节中的页面</p>
<ul>
<li>实现IUpdater</li>
<li>Execute方法</li>
<li>注册更新程序</li>
<li>Exposure to End-User</li>
</ul>
<h2 id="实现IUpdater"><a href="#实现IUpdater" class="headerlink" title="实现IUpdater"></a>实现IUpdater</h2><p>IUpdater接口要求实现以下5个方法：</p>
<ul>
<li>GetUpdaterId()-此方法应为更新程序返回一个全局唯一的ID，包括应用程序ID和此更新程序的ID。此方法在更新程序注册期间调用一次。</li>
<li>GetUpdateName()-如果在运行时更新程序有问题，则返回一个名称，通过该名称可以向用户标识更新程序。</li>
<li>GetAdditionalInformation()-此方法应返回辅助文本，Revit将使用该文本在未加载更新程序时通知最终用户。</li>
<li>GetChangePriority()-此方法标识更新程序将执行的更改的性质。它用于标识更新程序的执行顺序。此方法在更新程序注册期间调用一次。</li>
<li>Execute()-这是Revit将调用以执行更新的方法。有关Execute()方法的更多信息，请参见下一节。</li>
</ul>
<p>如果一个文档被一个Updater修改了，那么这个文档将存储Updater的唯一ID。如果用户稍后打开文档，但Updater不存在，则Revit将警告用户，以前编辑文档的第三方Updater不可用，除非将Updater标记为可选。默认情况下，Updater是非可选的，只有在必要时才应使用可选Updater。</p>
<p>下面的代码是实现IUpdater接口（为新添加的墙更改WallType）并在OnStartup()方法中注册更新程序的简单示例。它演示了创建和使用Updater的所有关键方面。</p>
<p>代码区域25-1：实现IUpdater的示例</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">WallUpdaterApplication</span> : <span class="title">Autodesk.Revit.UI.IExternalApplication</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Result <span class="title">OnStartup</span>(<span class="params">Autodesk.Revit.UI.UIControlledApplication application</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">                <span class="comment">// Register wall updater with Revit</span></span><br><span class="line">                WallUpdater updater = <span class="keyword">new</span> WallUpdater(application.ActiveAddInId);</span><br><span class="line">                UpdaterRegistry.RegisterUpdater(updater);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Change Scope = any Wall element</span></span><br><span class="line">                ElementClassFilter wallFilter = <span class="keyword">new</span> ElementClassFilter(<span class="keyword">typeof</span>(Wall));</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Change type = element addition</span></span><br><span class="line">                UpdaterRegistry.AddTrigger(updater.GetUpdaterId(), wallFilter, Element.GetChangeTypeElementAddition());</span><br><span class="line">                <span class="keyword">return</span> Result.Succeeded;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Result <span class="title">OnShutdown</span>(<span class="params">Autodesk.Revit.UI.UIControlledApplication application</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">                WallUpdater updater = <span class="keyword">new</span> WallUpdater(application.ActiveAddInId);</span><br><span class="line">                UpdaterRegistry.UnregisterUpdater(updater.GetUpdaterId());</span><br><span class="line">                <span class="keyword">return</span> Result.Succeeded;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">WallUpdater</span> : <span class="title">IUpdater</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">static</span> AddInId m_appId;</span><br><span class="line">        <span class="keyword">static</span> UpdaterId m_updaterId;</span><br><span class="line">        WallType m_wallType = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// constructor takes the AddInId for the add-in associated with this updater</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">WallUpdater</span>(<span class="params">AddInId id</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">                m_appId = id;</span><br><span class="line">                m_updaterId = <span class="keyword">new</span> UpdaterId(m_appId, <span class="keyword">new</span> Guid(<span class="string">&quot;FBFBF6B2-4C06-42d4-97C1-D1B4EB593EFF&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Execute</span>(<span class="params">UpdaterData data</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">                Document doc = data.GetDocument();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Cache the wall type</span></span><br><span class="line">                <span class="keyword">if</span> (m_wallType == <span class="literal">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                        FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(doc);</span><br><span class="line">                        collector.OfClass(<span class="keyword">typeof</span>(WallType));</span><br><span class="line">                        <span class="keyword">var</span> wallTypes = <span class="keyword">from</span> element <span class="keyword">in</span> collector</span><br><span class="line">                                                        <span class="keyword">where</span></span><br><span class="line">                                                                element.Name == <span class="string">&quot;Exterior - Brick on CMU&quot;</span></span><br><span class="line">                                                        <span class="keyword">select</span> element;</span><br><span class="line">                        <span class="keyword">if</span> (wallTypes.Count() &gt; <span class="number">0</span>)</span><br><span class="line">                        &#123;</span><br><span class="line">                                m_wallType = wallTypes.Cast().ElementAt(<span class="number">0</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (m_wallType != <span class="literal">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                        <span class="comment">// Change the wall to the cached wall type.</span></span><br><span class="line">                        <span class="keyword">foreach</span> (ElementId addedElemId <span class="keyword">in</span> data.GetAddedElementIds())</span><br><span class="line">                        &#123;</span><br><span class="line">                                Wall wall = doc.GetElement(addedElemId) <span class="keyword">as</span> Wall;</span><br><span class="line">                                <span class="keyword">if</span> (wall != <span class="literal">null</span>)</span><br><span class="line">                                &#123;</span><br><span class="line">                                        wall.WallType = m_wallType;</span><br><span class="line">                                &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">GetAdditionalInformation</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;Wall type updater example: updates all newly created walls to a special wall&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> ChangePriority <span class="title">GetChangePriority</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">return</span> ChangePriority.FloorsRoofsStructuralWalls;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> UpdaterId <span class="title">GetUpdaterId</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">return</span> m_updaterId;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">GetUpdaterName</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;Wall Type Updater&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Execute方法"><a href="#Execute方法" class="headerlink" title="Execute方法"></a>Execute方法</h2><p>Execute()方法的目的是允许你的Updater对文档的更改做出反应，并做出适当的关联。此方法由Revit在文档事务结束时调用，其中添加、更改或删除了与此Updater的UpdateTrigger匹配的元素。由于其他Updater所做的更改，该方法可能会为同一事务调用多次。更新程序在DocumentChanged事件之前调用，因此此事件将包含所有Updater所做的更改。</p>
<p>在调用此方法期间对文档所做的所有更改都将成为调用事务的一部分，并为撤消和重做操作进行维护。在实现此方法时，您可能不会打开任何新事务（将抛出异常），但可以根据需要使用子事务。</p>
<p>虽然它也可以用于更新文档外部的数据，但这些更改不会成为原始事务的一部分，并且在原始事务撤消或重做时不会受到撤消或重做的影响。如果确实使用此方法修改文档外部的数据，则还应订阅DocumentChanged事件，以便在撤消或重做原始事务时更新数据。</p>
<h3 id="变更范围"><a href="#变更范围" class="headerlink" title="变更范围"></a>变更范围</h3><p>Execute()方法有一个UpdaterData参数，它提供执行更新所需的所有必要数据，包括文档和有关触发更新的更改的信息。三个基本方法（GetAddedElementIds()、GetDeletedElementIds()和GetModifiedElementIds()）标识触发更新的元素。Updater还可以使用IsChangeTriggered()方法来检查特定的更改是否触发了更新。</p>
<h3 id="禁止和警告性变更"><a href="#禁止和警告性变更" class="headerlink" title="禁止和警告性变更"></a>禁止和警告性变更</h3><p>执行Updater时不能调用以下方法，因为它们会在元素之间引入交叉引用。(当这些更改与工作集操作结合使用时，可能导致文档损坏）。当更新程序尝试调用以下任何方法时，将引发ForbiddenForDynamicUpdateException：</p>
<ul>
<li>Autodesk.Revit.DB.ViewSheet.AddView()</li>
<li>Autodesk.Revit.DB.Document.LoadFamily（Autodesk.Revit.DB.Document、Autodesk.Revit.DB.IFamilyLoadOptions）</li>
<li>AreaReinforcement.Create()</li>
<li>PathReinforcement.Create()</li>
</ul>
<p>除了上面列出的禁用方法外，其他要求文档处于无事务状态的API方法也不能被调用。这些方法包括但不限于Save（）、SaveAs（）、Close（）、LoadFamily（）等。有关详细信息，请参阅相应方法的文档。</p>
<p>还禁止从更新程序的Execute（）方法内调用UpdaterRegistry类，例如RegistryUpdater（）或AddTrigger（）。调用任何UpdaterRegistry方法都将引发异常。此规则的一个例外是UpdaterRegistry.UnregisterUpdater（）方法，只要要注销的更新程序不是当前正在执行的更新程序，就可以在执行更新程序期间调用该方法。</p>
<p>尽管在执行Updater期间允许使用以下方法，但当调用的结果是建立元素之间的交叉引用时，它们也可以抛出ForbiddenForDynamicUpdateException。其中一个例子是创建一个与现有面墙相交的面墙，因此这两个面墙必定连接在一起。从Updater调用这些方法时要小心：</p>
<ul>
<li>Autodesk.Revit.Creation.ItemFactoryBase.NewFamilyInstances2()</li>
<li>Autodesk.Revit.Creation.ItemFactoryBase.NewFamilyInstance(Autodesk.Revit.DB.XYZ, Autodesk.Revit.DB.FamilySymbol, Autodesk.Revit.DB.Element,Autodesk.Revit.DB.Structure.StructuralType)</li>
<li>Autodesk.Revit.Creation.Document.NewFamilyInstance(Autodesk.Revit.DB.XYZ, Autodesk.Revit.DB.FamilySymbol, Autodesk.Revit.DB.Element, Autodesk.Revit.DB.Level, Autodesk.Revit.DB.Structure.StructuralType)</li>
<li>Autodesk.Revit.DB.FaceWall.Create()</li>
</ul>
<p>因此，应该注意的是，如果修改它们将是有效的，那么删除和重新创造现有元素应该是有效的。如果删除元素可能是一个简单的解决方案，它不仅会影响Revit的性能，但它将销毁任何引用以“重新创建”其他元素的对象。用户可能会失去工作，因为他们已经完成了限制并宣布了问题中的元素。</p>
<h3 id="管理变更"><a href="#管理变更" class="headerlink" title="管理变更"></a>管理变更</h3><p>更新程序需要能够处理使用它们时可能出现的复杂问题，可能需要协调对元素的后续更改。由更新器修改的元素可能在更新器下一次被调用时改变，并且那些改变可能影响由更新器修改的信息。例如，元素可以由用户显式编辑，或者由于再生触发的传播更改而隐式编辑。</p>
<p>同一个元素也可能被另一个更新器修改，甚至可能在同一个事务中。虽然对完全相同的数据进行显式更改会被跟踪和禁止，但间接或传播的更改仍然是可能的。也许最复杂的情况是，用户和&#x2F;或同一更新程序可以在文件的不同版本中更改元素。在用户重新加载最新图元或将其保存到中心图元后，将从其他文件中引入修改后的目标图元，更新程序将需要协调更改。</p>
<p>同样重要的是要认识到，当文档与中心文件同步时，元素的ElementId可能会受到影响。如果新元素已添加到同一文件的两个版本中，并且在两个位置使用相同的ElementId，则在将文件同步到中央数据库时，将进行协调。出于这个原因，当使用更新器交叉引用另一个元素中的一个元素时，它们应该使用Element.UniqueId，这可以保证是唯一的。</p>
<p>另一个需要考虑的问题是，如果更新器将某些数据（即作为参数）附加到元素，则它不仅必须确保在添加该数据的元素中维护该信息，而且还必须在该元素通过复制&#x2F;粘贴或组传播复制时协调数据。例如，如果更新程序将参数“钢筋的总重量”添加到钢筋主体，则该参数及其值将复制到复制的钢筋主体，即使钢筋本身可能未与主体一起复制。在这种情况下，更新程序需要确保在新复制的钢筋主体中重置参数值。</p>
<h2 id="注册Updater"><a href="#注册Updater" class="headerlink" title="注册Updater"></a>注册Updater</h2><p>Updater必须注册，以便在模型更改时得到通知。应用程序级别的UpdaterRegistry类提供了注册&#x2F;取消注册以及操作为Updater设置的选项的能力。Updater可以从任何API回调中注册，并且可以注册为应用程序范围或特定于文档，这意味着它们将仅由对指定文档的更改触发。为了使用UpdaterRegistry功能，Revit附加模块必须在清单文件中注册，并且UpdaterId返回的ID。任何更新程序的GetAddInId（）（从GetUpdaterId（）获得）必须与附加模块清单文件中的AddInId字段匹配。外接程序不能添加、删除或修改不属于它的更新程序。</p>
<h3 id="触发"><a href="#触发" class="headerlink" title="触发"></a>触发</h3><p>除了调用UpdaterRegistry.RegisterUpdater（）方法之外，Updater还应该通过AddTrigger（）方法添加一个或多个更新触发器。这些触发器向UpdaterRegistry指示哪些事件应该触发Updaters Execute（）方法运行。它们可以在应用程序范围内设置，也可以应用于特定文档中所做的更改。更新触发器是通过将更改范围和更改类型配对来指定的。</p>
<p>变更范围是这两种之一：</p>
<ul>
<li>文档中元素ID的显式列表-只有对这些元素的更改才会触发Updater</li>
<li>通过ElementFilter传递的元素的隐式列表-每个更改的元素都将针对过滤器运行，如果有任何通过，则会触发Updater</li>
</ul>
<p>有几个选项可用于更改类型。ChangeTypes从Element类的静态方法中获得。</p>
<ul>
<li>Element addition - 通过Element.GetChangeTypeElementAddition（）</li>
<li>Element deletion - 通过Element.GetChangeTypeElementDeletion（）</li>
<li>Change of element geometry (shape or position) - 通过Element.GetChangeTypeGeometry（）</li>
<li>Changing value of a specific parameter - 通过Element.GetChangeTypeParameter（）</li>
<li>Any change of element - 通过Element.GetChangeTypeAny（）。</li>
</ul>
<p>请注意，几何图形更改可能由于多种原因而触发，例如图元类型更改、属性和参数修改、移动和旋转，或者在再生期间从其他修改的图元对图元施加的更改。</p>
<p>还要注意的是，最后一个选项，任何元素的更改，只会触发Updater修改预先存在的元素，而不会触发Updater修改新添加或删除的元素。此外，当对实例使用此触发器时，只有对其类型的某些修改才会触发Updater。影响实例本身的更改（如修改实例的几何体）将触发Updater。但是，不直接修改实例并且不会导致对实例进行任何可识别的更改的更改（例如对文本参数的更改）将不会触发实例的Updater。要根据这些更改触发，Type也必须包含在触发器的更改范围中。</p>
<h3 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h3><p>Revit对多个Updater进行排序以按正确顺序执行的主要方法是查看给定Updater返回的ChangePriority。一个Updater报告一组更基本的元素（例如GridsLevelsReferencePlanes）的优先级，将在Updater报告由这些基本元素（例如Annotations）驱动的元素的优先级之前执行。为Updater修改的图元报告适当的更改优先级将使应用程序的用户受益：Revit不太可能由于其他Updater所做的更改而不得不再次执行Updater。</p>
<p>对于报告相同更改优先级的Updater，执行顺序基于UpdaterId的排序。方法UpdaterRegistry.SetExecutionOrder（）允许您在任何两个注册的Updater（甚至是由其他API外接程序注册的Updater）之间设置执行顺序，只要您的代码知道这两个Updater的ID。</p>
<h2 id="Exposure-to-End-User"><a href="#Exposure-to-End-User" class="headerlink" title="Exposure to End-User"></a>Exposure to End-User</h2><p>当更新程序正常工作时，它们对用户是透明的。但在某些特殊情况下，Revit将向用户显示有关第三方更新程序的警告。这些消息将使用GetUpdaterName（）方法的值来引用更新程序。</p>
<h3 id="未安装Updater"><a href="#未安装Updater" class="headerlink" title="未安装Updater"></a>未安装Updater</h3><p>如果文档由非可选Updater修改，然后在未安装该Updater时加载，则会显示类似于以下内容的任务对话框：</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-301A03BC-C348-483D-980C-30B05831F84B-low.png"></p>
<p>图135：缺少第三方Updater警告</p>
<h3 id="更新程序执行无效操作"><a href="#更新程序执行无效操作" class="headerlink" title="更新程序执行无效操作"></a>更新程序执行无效操作</h3><p>如果更新程序出现错误（如未处理的异常），则会显示类似于以下内容的消息，为用户提供禁用更新程序的选项：</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-D68E0684-0F8A-47D5-9803-61523979E454-low.png"></p>
<p>图136：更新程序执行了无效操作</p>
<p>如果用户选择“取消”，则整个事务将回滚。在本章前面的墙更新程序示例中，新添加的墙被删除。如果用户选择DisableUpdater，则不再调用更新程序，但事务不会回滚。</p>
<h3 id="无限循环"><a href="#无限循环" class="headerlink" title="无限循环"></a>无限循环</h3><p>如果Updater陷入无限循环，Revit将通知用户并在Revit任务期间禁用更新程序。</p>
<h3 id="两个Updater尝试编辑同一元素"><a href="#两个Updater尝试编辑同一元素" class="headerlink" title="两个Updater尝试编辑同一元素"></a>两个Updater尝试编辑同一元素</h3><p>如果Updater尝试编辑由同一事务中的另一Updater更新的元素的相同参数，或者如果Updater尝试以与另一Updater所做的更改冲突的方式编辑元素的几何图形，则Updater被取消，显示错误消息，并且用户可以选择禁用更新器。</p>
<h3 id="本地不存在Updater修改的中心文档"><a href="#本地不存在Updater修改的中心文档" class="headerlink" title="本地不存在Updater修改的中心文档"></a>本地不存在Updater修改的中心文档</h3><p>如果用户重新加载最新版本或使用未在本地安装的Updater修改的中心文件保存到中心，则会显示一个任务对话框，为用户提供继续或取消同步的选项。此警告表示，以后将中心模型与第三方Updater一起使用时，继续操作可能会导致中心模型出现问题。</p>
<h2 id="注：翻译自Revit-API-Developers-Guide"><a href="#注：翻译自Revit-API-Developers-Guide" class="headerlink" title="注：翻译自Revit API Developers Guide"></a><em><strong>注：</strong></em>翻译自<a href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_html">Revit API Developers Guide</a></h2>]]></content>
      <categories>
        <category>Revit二次开发人员指南</category>
      </categories>
      <tags>
        <tag>Revit</tag>
      </tags>
  </entry>
  <entry>
    <title>33命令</title>
    <url>/2024/11/23/Revit%E4%BA%8C%E5%BC%80%E6%8C%87%E5%8D%97/33%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="命令"><a href="#命令" class="headerlink" title="命令"></a><a href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_Advanced_Topics_Commands_html">命令</a></h1><p>Revit API 提供对现有 Revit 命令的访问，这些命令位于选项卡、应用程序菜单或右键单击菜单中。使用 API 处理 Revit 命令的主要方法是替换现有命令实现或发布命令。</p>
<h3 id="替代-Revit-命令"><a href="#替代-Revit-命令" class="headerlink" title="替代 Revit 命令"></a>替代 Revit 命令</h3><p>AddInCommandBinding 类可用于替代 Revit 中的现有命令。它有三个与替换现有命令实现相关的事件。</p>
<ul>
<li><strong>BeforeExecuted</strong> - 此只读事件在关联命令执行之前发生。应用程序可以对此事件做出反应，但不能更改文档或影响命令的调用。</li>
<li><strong>CanExecute</strong> - 当关联的命令启动检查以确定是否可以在命令目标上执行命令时出现。</li>
<li><strong>Executed</strong> - 当执行关联的命令时，将发生此事件，并且应在此处执行任何覆盖实现。</li>
</ul>
<p>要创建 commandbinding，请调用 UIApplication.CreateAddInCommandBinding（） 或 UIControlledApplication.CreateAddInCommandBinding（）。这两种方法都需要 RevitCommandId ID 来标识要替换的命令处理程序。RevitCommandId 有两种用于获取命令 ID 的静态方法：</p>
<ul>
<li><strong>LookupCommandId</strong> - 使用给定的 ID 字符串检索 Revit 命令 ID。要查找命令 ID 字符串，请打开 Revit 的会话，调用所需的命令，关闭 Revit，然后查看该会话的日志。选择时记录的 “Jrn.Command” 条目将具有 LookupCommandId（） 所需的字符串，并且看起来类似于 “ID_EDIT_DESIGNOPTIONS”。</li>
<li><strong>LookupPostableCommandId</strong> - 使用 PostableCommand 枚举检索 Revit 命令 ID。这仅适用于可提交的命令（将在下一节中讨论）。</li>
</ul>
<p>以下示例摘自 Revit 2014 SDK 的 DisableCommand 示例，演示了如何创建 AddInCommandBinding 并替代实现以禁用该命令，并向用户发送消息。</p>
<p>代码区域：替代命令</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> </span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> Implements the Revit add-in interface IExternalApplication</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Application</span> : <span class="title">IExternalApplication</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">region</span> IExternalApplication Members</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> </span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> Implements the OnStartup event</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> </span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> </span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">OnStartup</span>(<span class="params">UIControlledApplication application</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Lookup the desired command by name</span></span><br><span class="line">        s_commandId = RevitCommandId.LookupCommandId(s_commandToDisable);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Confirm that the command can be overridden</span></span><br><span class="line">        <span class="keyword">if</span> (!s_commandId.CanHaveBinding)</span><br><span class="line">        &#123;</span><br><span class="line">            ShowDialog(<span class="string">&quot;Error&quot;</span>, <span class="string">&quot;The target command &quot;</span> + s_commandToDisable +</span><br><span class="line">                        <span class="string">&quot; selected for disabling cannot be overridden&quot;</span>);</span><br><span class="line">   <span class="keyword">return</span> Result.Failed;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create a binding to override the command.</span></span><br><span class="line">        <span class="comment">// Note that you could also implement .CanExecute to override the accessibiliy of the command.</span></span><br><span class="line">        <span class="comment">// Doing so would allow the command to be grayed out permanently or selectively, however,</span></span><br><span class="line">        <span class="comment">// no feedback would be available to the user about why the command is grayed out.</span></span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            AddInCommandBinding commandBinding = application.CreateAddInCommandBinding(s_commandId);</span><br><span class="line">            commandBinding.Executed += DisableEvent;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Most likely, this is because someone else has bound this command already.</span></span><br><span class="line">        <span class="keyword">catch</span> (Exception)</span><br><span class="line">        &#123;</span><br><span class="line">            ShowDialog(<span class="string">&quot;Error&quot;</span>, <span class="string">&quot;This add-in is unable to disable the target command &quot;</span> + s_commandToDisable +</span><br><span class="line">                        <span class="string">&quot;; most likely another add-in has overridden this command.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Result.Succeeded;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> </span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> Implements the OnShutdown event</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> </span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> </span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">OnShutdown</span>(<span class="params">UIControlledApplication application</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Remove the command binding on shutdown</span></span><br><span class="line">        <span class="keyword">if</span> (s_commandId.HasBinding)</span><br><span class="line">            application.RemoveAddInCommandBinding(s_commandId);</span><br><span class="line">        <span class="keyword">return</span> Result.Succeeded;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">endregion</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> </span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> A command execution method which disables any command it is applied to (with a user-visible message).</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> </span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> Event sender.</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> Arguments.</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">DisableEvent</span>(<span class="params"><span class="built_in">object</span> sender, ExecutedEventArgs <span class="keyword">args</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        ShowDialog(<span class="string">&quot;Disabled&quot;</span>, <span class="string">&quot;Use of this command has been disabled.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> </span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> Show a task dialog with a message and title.</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> </span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> The title.</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> The message.</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ShowDialog</span>(<span class="params"><span class="built_in">string</span> title, <span class="built_in">string</span> message</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Show the user a message.</span></span><br><span class="line">        TaskDialog td = <span class="keyword">new</span> TaskDialog(title)</span><br><span class="line">        &#123;</span><br><span class="line">            MainInstruction = message,</span><br><span class="line">            TitleAutoPrefix = <span class="literal">false</span></span><br><span class="line">        &#125;;</span><br><span class="line">        td.Show();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> </span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> The string name of the command to disable.  To lookup a command id string, open a session of Revit,</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> invoke the desired command, close Revit, then look to the journal from that session.  The command</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> id string will be toward the end of the journal, look for the &quot;Jrn.Command&quot; entry that was recorded</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> when it was selected.</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> </span></span><br><span class="line">    <span class="keyword">static</span> String s_commandToDisable = <span class="string">&quot;ID_EDIT_DESIGNOPTIONS&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> </span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> The command id, stored statically to allow for removal of the command binding.</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> </span></span><br><span class="line">    <span class="keyword">static</span> RevitCommandId s_commandId;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="发布命令"><a href="#发布命令" class="headerlink" title="发布命令"></a>发布命令</h3><p>方法 UIApplication.PostCommand（） 将命令发布到 Revit 消息队列，以便在控件从当前 API 应用程序返回时调用该命令。只有某些命令可以以这种方式发布。它们包括 Autodesk.Revit.UI.PostableCommand 枚举类型中的所有命令，以及由任何附加模块创建的外部命令。</p>
<p>注意：使用 PostCommand（） 时，即使是可发布的命令也可能无法执行。发生这种情况的一个原因是，如果已经发布了另一个命令。在给定时间，只能将一个命令发布到 Revit，因此，如果发布第二个命令，PostCommand（） 将引发异常。已发布的命令可能无法执行的另一个原因是要执行的命令当时无法访问。它是否可访问仅在 Revit 从 API 上下文返回时确定，因此，由于此原因而执行失败时，不会直接报告给发布命令的应用程序。UIApplication 的 API 应用程序。CanPostCommand（） 可用于识别是否可以发布给定的命令，这意味着它是 PostableCommand 的成员还是外部命令。它不标识该命令当前是否可访问。</p>
<p>PostCommand（） 和 CanPostCommand（） 都需要 RevitCommandId，可以按照上面的“替代 Revit 命令”部分所述获取该 ID。</p>
<h2 id="注：翻译自Revit-API-Developers-Guide"><a href="#注：翻译自Revit-API-Developers-Guide" class="headerlink" title="注：翻译自Revit API Developers Guide"></a><em><strong>注：</strong></em>翻译自<a href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_html">Revit API Developers Guide</a></h2>]]></content>
      <categories>
        <category>Revit二次开发人员指南</category>
      </categories>
      <tags>
        <tag>Revit</tag>
      </tags>
  </entry>
  <entry>
    <title>34故障发布和处理</title>
    <url>/2024/12/30/Revit%E4%BA%8C%E5%BC%80%E6%8C%87%E5%8D%97/34%E6%95%85%E9%9A%9C%E5%8F%91%E5%B8%83%E5%92%8C%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h1 id="故障发布和处理"><a href="#故障发布和处理" class="headerlink" title="故障发布和处理"></a>故障发布和处理</h1><p>Revit API提供了在发生用户可见的问题时发布故障以及响应由Revit或Revit附加模块发布的故障的功能。</p>
<p>本节中的页面</p>
<ul>
<li>发布故障</li>
<li>处理故障</li>
</ul>
<h2 id="发布故障"><a href="#发布故障" class="headerlink" title="发布故障"></a>发布故障</h2><p>要使用故障发布机制报告问题，需要执行以下步骤：</p>
<ol>
<li>在ExternalApplication的OnStartup（）调用过程中，必须在FailureValidationRegistry中定义并注册Revit中尚未定义的新故障。</li>
<li>从BuiltInFailures类或使用与FailureDefinition相关的类从预注册的自定义故障中查找故障定义ID。</li>
<li>使用与FailureMessage相关的类设置与失败相关的选项和详细信息，将失败发布到有问题的文档。</li>
</ol>
<p><strong>定义和注册故障</strong></p>
<p>在Revit应用程序启动期间，必须通过创建一个FailureDefinition对象来定义和注册Revit中的每个可能的故障，该对象包含有关故障的一些永久性信息，例如标识、严重性、基本描述、解决方法类型和默认解决方法。</p>
<p>下面的示例创建了两个新的故障，一个警告和一个错误，可用于太高的墙。在这个例子中，它们与一个更新程序一起使用，后者将执行失败发布（在本章后续的代码示例中）。FailureFailitionIds保存在Updater类中，因为在发布失败时需要它们。以下各节将更详细地解释FailureDefinition. conf FailureDefinition（）方法参数。</p>
<p>代码区域26-1：定义和注册故障</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">WallWarnUpdater wallUpdater = <span class="keyword">new</span> WallWarnUpdater();</span><br><span class="line">UpdaterRegistry.RegisterUpdater(wallUpdater);</span><br><span class="line">ElementClassFilter filter = <span class="keyword">new</span> ElementClassFilter(<span class="keyword">typeof</span>(Wall));</span><br><span class="line">UpdaterRegistry.AddTrigger(wallUpdater.GetUpdaterId(), filter, Element.GetChangeTypeGeometry());</span><br><span class="line"></span><br><span class="line"><span class="comment">// define a new failure id for a warning about walls</span></span><br><span class="line">FailureDefinitionId warnId = <span class="keyword">new</span> FailureDefinitionId(<span class="keyword">new</span> Guid(<span class="string">&quot;FB4F5AF3-42BB-4371-B559-FB1648D5B4D1&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// register the new warning using FailureDefinition</span></span><br><span class="line">FailureDefinition failDef = FailureDefinition.CreateFailureDefinition(warnId, FailureSeverity.Warning, <span class="string">&quot;Wall is too big (&gt;100&#x27;). Performance problems may result.&quot;</span>);</span><br><span class="line"></span><br><span class="line">FailureDefinitionId failId = <span class="keyword">new</span> FailureDefinitionId(<span class="keyword">new</span> Guid(<span class="string">&quot;691E5825-93DC-4f5c-9290-8072A4B631BC&quot;</span>));</span><br><span class="line"></span><br><span class="line">FailureDefinition failDefError = FailureDefinition.CreateFailureDefinition(failId, FailureSeverity.Error, <span class="string">&quot;Wall is WAY too big (&gt;200&#x27;). Performance problems may result.&quot;</span>);</span><br><span class="line"><span class="comment">// save ids for later reference</span></span><br><span class="line">wallUpdater.WarnId = warnId;</span><br><span class="line">wallUpdater.FailureId = failId;</span><br></pre></td></tr></table></figure>

<p><strong>故障排除Id</strong></p>
<p>必须使用唯一的FailureDefinition Id作为注册FailureDefinition的键。应使用故障诊断生成工具创建每个唯一的故障诊断ID。稍后，可以使用FailureDefinition Id在FailureDefinition Registry中查找FailureDefinition，并创建和发布FailureMessages。</p>
<p><strong>严重程度</strong></p>
<p>注册新故障时，将指定严重性，沿着指定FailureValidationId和可向用户显示的故障文本描述。严重性决定了文档中允许的操作以及是否可以提交事务。严重性选项包括：</p>
<ul>
<li><em><strong>Warning</strong></em> - 最终用户可以忽略的故障。此严重性的故障不会阻止提交事务。当Revit需要向用户传达问题，但该问题不会阻止用户继续处理文档时，应使用此严重性</li>
<li><em><strong>Error</strong></em> - 无法忽略的故障。如果发布了此严重性的FailureMeassage，则无法提交当前事务，除非通过适当的FailureResolution解决故障。如果问题未解决，则文档上的工作无法继续，则应使用此严重性。如果故障没有可用的预定义解决方案或这些解决方案无法解决问题，则必须中止事务以继续处理文档。强烈建议在此严重性的每个故障中至少有一个解决方案。</li>
<li><em><strong>DocumentCorruption</strong></em> - 由于已知的文档损坏而强制事务尽快回滚的失败。当发布此严重性的故障时，不允许从文档中阅读信息。必须先回滚当前事务才能处理文档。仅当文档中存在已知的数据损坏时才使用此严重性。通常应避免这种类型的故障，除非无法防止损坏或在本地进行恢复。</li>
</ul>
<p>定义新的FailureDefinition时，不能指定第四个严重性None。</p>
<p><strong>故障解决方案</strong></p>
<p>当故障可以解决时，所有可能的解决方案都应该在FailureDefinition类中预定义。这将通知Revit针对给定故障可能使用的故障解决方案。FailureDefinition包含适用于故障的解决方案类型的完整列表，包括用户可见的解决方案标题。</p>
<p>解决方案的数量不受限制，但从2011年Revit API开始，唯一公开的故障解决方案是DeleteElements。当指定多个分辨率时，除非使用SetDefaultResolutionType（）方法显式更改，否则添加的第一个分辨率将成为默认分辨率。默认分辨率由Revit故障处理机制用于在适用时自动解决故障。Revit UI仅使用默认分辨率，但Revit附加模块可以通过Revit API使用任何适用的分辨率，并可以提供用于执行此操作的替代UI（如本章后面的“处理故障”部分所述）。</p>
<p>在严重性为DocumentCorruption的故障的情况下，在故障解决可能发生时，事务已经中止，因此没有什么需要解决的。因此，不应将FailureResolutions添加到严重性为DocumentCorruption的API定义的故障中。</p>
<p><strong>发布故障</strong></p>
<p>PostFailure（）方法用于将问题通知给文档。失败将被验证，并可能在事务结束时解决。通过此方法发布的错误在解决后将不会存储在文档中。失败过帐用于处理文档的状态，该状态可能在事务结束之前发生更改，或者在有必要将解决方案推迟到事务结束时发生更改。并非外部命令遇到的所有失败都应该发布失败。如果失败与文档无关，则应使用任务对话框。例如，如果Revit UI处于无效状态，则无法执行外部命令。</p>
<p>若要发布故障，请使用定义自定义故障时的FailureFailitionId创建新的FailureMessage，或使用Revit API提供的BuiltInFailure。在FailureMessage对象中设置任何其他信息，如失败元素，然后调用Document.PostFailure（），传入新的FailureMessage。请注意，文档必须是可修改的，才能发布失败。</p>
<p>PostFailure（）返回的唯一FailureMessageKey可以在事务的生命周期内存储，并用于删除不再相关的失败消息。如果相同的FailureMessage被发布两次或更多次，则返回相同的FailureMessageKey。如果发布的故障的严重性为DocumentCorruption，则返回无效的FailureMessageKey。这是因为无法取消发布DocumentCorruption失败。</p>
<p>下面的示例显示一个IUpdate类（在上面的“定义和注册故障”代码区域中引用），该类根据Execute（）方法中接收到的信息发布新故障。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">WallWarnUpdater</span> : <span class="title">IUpdater</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> AddInId m_appId;</span><br><span class="line">    UpdaterId m_updaterId;</span><br><span class="line">    FailureDefinitionId m_failureId = <span class="literal">null</span>;</span><br><span class="line">    FailureDefinitionId m_warnId = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// constructor takes the AddInId for the add-in associated with this updater</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WallWarnUpdater</span>(<span class="params">AddInId id</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_appId = id;</span><br><span class="line">        m_updaterId = <span class="keyword">new</span> UpdaterId(m_appId, </span><br><span class="line">            <span class="keyword">new</span> Guid(<span class="string">&quot;69797663-7BCB-44f9-B756-E4189FE0DED8&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Execute</span>(<span class="params">UpdaterData data</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Document doc = data.GetDocument();</span><br><span class="line">        Autodesk.Revit.ApplicationServices.Application app = doc.Application;</span><br><span class="line">        <span class="keyword">foreach</span> (ElementId id <span class="keyword">in</span> data.GetModifiedElementIds())</span><br><span class="line">        &#123;</span><br><span class="line">            Wall wall = doc.GetElement(id) <span class="keyword">as</span> Wall;</span><br><span class="line">            Autodesk.Revit.DB.Parameter p = wall.LookupParameter(<span class="string">&quot;Unconnected Height&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (p != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (p.AsDouble() &gt; <span class="number">200</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    FailureMessage failMessage = <span class="keyword">new</span> FailureMessage(FailureId);</span><br><span class="line">                    failMessage.SetFailingElement(id);</span><br><span class="line">                    doc.PostFailure(failMessage);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (p.AsDouble() &gt; <span class="number">100</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    FailureMessage failMessage = <span class="keyword">new</span> FailureMessage(WarnId);</span><br><span class="line">                    failMessage.SetFailingElement(id);</span><br><span class="line">                    doc.PostFailure(failMessage);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> FailureDefinitionId FailureId</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> m_failureId; &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; m_failureId = <span class="keyword">value</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> FailureDefinitionId WarnId</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> m_warnId; &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; m_warnId = <span class="keyword">value</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">GetAdditionalInformation</span>()</span> </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Give warning and error if wall is too tall&quot;</span>; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ChangePriority <span class="title">GetChangePriority</span>()</span> </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">return</span> ChangePriority.FloorsRoofsStructuralWalls; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UpdaterId <span class="title">GetUpdaterId</span>()</span> </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">return</span> m_updaterId; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">GetUpdaterName</span>()</span> </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Wall Height Check&quot;</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>删除已发布的故障</strong></p>
<p>由于在同一事务中可能存在对文档的多次更改和多次重新生成，因此可能有些故障不再相关，并且可能需要将其删除以防止“假警报”。通过调用Document.UnpostFailure（）方法并传入在调用PostFailure（）时获得的FailureMessageKey，可以取消发送特定的消息。如果失败的严重性是DocumentCorruption，UnpostFailure（）将抛出异常。</p>
<p>当事务即将回滚时，还可以使用Transaction.SetFailureHandlingOptions（）方法自动删除所有已发布的失败（以便用户不必点击取消）。</p>
<h2 id="处理故障"><a href="#处理故障" class="headerlink" title="处理故障"></a>处理故障</h2><p>通常，在事务结束时（特别是在调用Transaction.Commit（）或Transaction.Rollback（）时），由Revit的标准故障解决UI处理发布的故障。向用户呈现处理故障的信息和选项。</p>
<p>如果文档上的某个操作（或一组操作）需要Revit附加模块对某些错误进行特殊处理，则可以自定义故障处理以执行此解决方案。可提供自定义故障处理：</p>
<ul>
<li>对于使用接口IFailuresPreprocessor的给定事务。</li>
<li>对于使用FailuresProcessing事件的所有可能的错误。</li>
</ul>
<p>最后，该API提供了使用接口IFailuresProcessor完全替换标准故障处理用户界面的能力。虽然前两种处理故障的方法在大多数情况下应该足够了，但最后一个选项可以用于特殊情况，例如提供更好的故障处理UI或将应用程序用作Revit上的前端时。</p>
<p><strong>故障处理概述</strong></p>
<p>重要的是要记住，在调用Transaction.Commit（）和实际处理失败之间会发生许多事情。自动连接、重叠检查、组检查和工作集可编辑性检查仅举几例。这些检查和更改可能会使某些故障消失，或者更有可能会发布新的故障。因此，无法得出调用Transaction.Commit（）时要处理的故障状态的结论。为了正确处理故障，有必要连接到实际的故障处理机制。</p>
<p>当失败处理开始时，对应该在事务中进行的文档的所有更改都将被执行，并且所有失败都将被发布。因此，在故障处理期间，不允许对文档进行不受控的更改。通过FailuresAccessor提供的受限接口解决故障的能力有限。如果发生这种情况，则必须重复所有事务结束检查和失败处理。因此，在一个事务结束时可能会有几个故障解决周期。</p>
<p>每个故障处理周期包括3个步骤：</p>
<ol>
<li>故障预处理（FailuresPreprocessor）</li>
<li>广播故障处理事件（FailuresProcessing事件）</li>
<li>最终处理（FailuresProcessor）</li>
</ol>
<p>这3个步骤中的每一个都可以通过返回不同的FailureProcessingResults来控制接下来发生的事情。这些选项包括：</p>
<ul>
<li><em><strong>Continue</strong></em> - 对执行流没有影响。如果FailuresProcessor返回“Continue”（继续），但未解决故障，则Revit将按照返回“ProceedWithRollBack”的方式进行操作。</li>
<li><em><strong>ProceedWithCommit</strong></em> - 中断故障处理，并立即触发另一个事务结束检查循环，然后进行另一个故障处理。在尝试解决故障后应返回。如果返回时没有任何成功的故障解决方案，则很容易导致无限循环。如果事务已经在回滚，则无法返回，在这种情况下将被视为“ProceedWithRollBack”。</li>
<li><em><strong>ProceedWithRollback</strong></em> -继续执行失败处理，但强制回滚事务，即使最初请求提交事务也是如此。如果在返回ProceedWithRollBack之前，FailureHandlingOptions被设置为在回滚后清除错误，则不会进行进一步的错误处理，所有失败都将被删除，事务将以静默方式回滚。否则，默认的失败处理将继续，失败可能会传递给用户，但保证事务被回滚。</li>
<li><em><strong>WaitForUserInput</strong></em> -只有当FailuresProcessor正在等待外部事件（通常是用户输入）来完成故障处理时，才能返回。</li>
</ul>
<p>根据事务中发布的故障的严重性以及事务是正在提交还是正在回滚，这3个步骤中的每一个都可能具有某些解决错误的选项。有关文档中发布的故障的所有信息、有关执行某些操作以解决故障的能力的信息以及执行此类操作的API都通过FailuresAccessor类提供。文档可用于获取其他信息，但只能通过FailuresAccessor进行更改。</p>
<p><strong>故障访问器</strong></p>
<p>FailuresAccessor对象作为参数传递给每个失败处理步骤，并且是获取文档中有关失败的信息的唯一可用接口。虽然允许在故障处理期间阅读文档，但在故障解决期间修改文档的唯一方法是通过此类提供的方法。从失败处理返回后，类的实例被停用，不能再使用。</p>
<p><strong>故障访问器提供的信息</strong></p>
<p>FailuresAccessor对象提供了一些通用信息，例如：</p>
<ul>
<li>正在处理或预处理失败的文档</li>
<li>文档中公布的最高失效严重度</li>
<li>正在完成的事务的事务名称和失败处理选项</li>
<li>是否请求提交或回滚事务。</li>
</ul>
<p>FailuresAccessor对象还通过GetFailuresMessages（）方法提供有关特定故障的信息。</p>
<p><strong>解决故障的选项</strong></p>
<p>FailuresAccessor对象提供了几种解决故障的方法：</p>
<ul>
<li>可以使用DeleteWarning（）或DeleteAllWarning（）方法删除严重性为Warning的故障消息。</li>
<li>ResolveFailure（）或ResolveFailures（）方法可用于使用为每个故障设置的最后一个故障解决类型来解决一个或多个故障。</li>
<li>DeleteElements（）可以通过删除与失败相关的元素来解决失败。</li>
<li>或者使用ReplaceFailures（）方法删除所有失败消息并将其替换为一个“一般”失败。</li>
</ul>
<p><strong>IFailuresPreprocessor</strong></p>
<p>IFailuresPreprocessor接口可用于仅为特定事务提供自定义故障处理。IFailuresPreprocessor是一个接口，可用于执行预处理步骤，以过滤掉预期的事务失败或发布新的失败。故障可以通过以下方式“过滤掉”：</p>
<ul>
<li>静默地移除已知为事务发布的并且在特定事务的上下文中被认为与用户无关的警告</li>
<li>静默地解决已知为事务发布的某些故障，并且这些故障应始终在给定事务的上下文中解决</li>
<li>对于给定的工作流，在不应提交“不完美”事务的情况下静默地中止事务或者中止事务比用户交互更可取。</li>
</ul>
<p>IFailuresPreprocessor接口在故障解决过程中首先获得控制权。它几乎等同于在完成事务之前检查和解决故障，除了IFailuresPreprocessor在正确的时间获得控制权，在所有故障保证被发布和&#x2F;或所有不相关的被删除之后。</p>
<p>每个事务只能有一个IFailuresPreprocessor，并且没有默认的故障预处理器。如果没有附加到事务（通过故障处理选项），则简单地省略故障解决的第一步。</p>
<p>代码区域26-3：处理来自IFailuresPreprocessor的故障</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SwallowTransactionWarning</span> : <span class="title">IExternalCommand</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">public</span> Autodesk.Revit.UI.<span class="function">Result <span class="title">Execute</span>(<span class="params">ExternalCommandData commandData, <span class="keyword">ref</span> <span class="built_in">string</span> message, ElementSet elements</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">                Autodesk.Revit.ApplicationServices.Application app =</span><br><span class="line">                        commandData.Application.Application;</span><br><span class="line">                Document doc = commandData.Application.ActiveUIDocument.Document;</span><br><span class="line">                UIDocument uidoc = commandData.Application.ActiveUIDocument;</span><br><span class="line"></span><br><span class="line">                FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(doc);</span><br><span class="line">                ICollection elementCollection =</span><br><span class="line">                        collector.OfClass(<span class="keyword">typeof</span>(Level)).ToElements();</span><br><span class="line">                Level level = elementCollection.Cast().ElementAt(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">                Transaction t = <span class="keyword">new</span> Transaction(doc);</span><br><span class="line">                t.Start(<span class="string">&quot;room&quot;</span>);</span><br><span class="line">                FailureHandlingOptions failOpt = t.GetFailureHandlingOptions();</span><br><span class="line">                failOpt.SetFailuresPreprocessor(<span class="keyword">new</span> RoomWarningSwallower());</span><br><span class="line">                t.SetFailureHandlingOptions(failOpt);</span><br><span class="line"></span><br><span class="line">                doc.Create.NewRoom(level, <span class="keyword">new</span> UV(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">                t.Commit();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> Autodesk.Revit.UI.Result.Succeeded;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">RoomWarningSwallower</span> : <span class="title">IFailuresPreprocessor</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> FailureProcessingResult <span class="title">PreprocessFailures</span>(<span class="params">FailuresAccessor failuresAccessor</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">                IList failList = <span class="keyword">new</span> List();</span><br><span class="line">                <span class="comment">// Inside event handler, get all warnings</span></span><br><span class="line">                failList = failuresAccessor.GetFailureMessages();                <span class="keyword">foreach</span> (FailureMessageAccessor failure <span class="keyword">in</span> failList)</span><br><span class="line">                &#123; </span><br><span class="line">                        <span class="comment">// check FailureDefinitionIds against ones that you want to dismiss, FailureDefinitionId failID = failure.GetFailureDefinitionId();</span></span><br><span class="line">                        <span class="comment">// prevent Revit from showing Unenclosed room warnings</span></span><br><span class="line">                        <span class="keyword">if</span> (failID == BuiltInFailures.RoomFailures.RoomNotEnclosed)</span><br><span class="line">                        &#123;</span><br><span class="line">                                failuresAccessor.DeleteWarning(failure);</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> FailureProcessingResult.Continue;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>故障处理事件</strong></p>
<p>FailuresProcessing事件最适合于希望在没有用户界面的情况下为整个会话或许多不相关的事务提供自定义故障处理的应用程序。通过此事件处理故障的一些用例包括：</p>
<ul>
<li>自动删除某些警告和&#x2F;或基于办公室标准（或其他准则）自动解决某些错误</li>
<li>自定义故障记录</li>
</ul>
<p>FailuresProcessing事件在IFailuresPreprocessor（如果有）完成后引发。它可以有任意数量的处理程序，并且所有的处理程序都将被调用。由于事件处理程序无法返回值，因此应该使用事件参数上的SetProcessingResult（）来传递状态。只能设置Continue、ProceedWithRollback或ProceedWithCommit。</p>
<p>下面的示例演示FailuresProcessing事件的事件处理程序。</p>
<p>代码区域26-4：处理FailuresProcessing事件</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">CheckWarnings</span>(<span class="params"><span class="built_in">object</span> sender, FailuresProcessingEventArgs e</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        FailuresAccessor fa = e.GetFailuresAccessor();</span><br><span class="line">        IList failList = <span class="keyword">new</span> List();</span><br><span class="line">        failList = fa.GetFailureMessages(); <span class="comment">// Inside event handler, get all warnings</span></span><br><span class="line">        <span class="keyword">foreach</span> (FailureMessageAccessor failure <span class="keyword">in</span> failList)</span><br><span class="line">        &#123; </span><br><span class="line"></span><br><span class="line">                <span class="comment">// check FailureDefinitionIds against ones that you want to dismiss, FailureDefinitionId failID = failure.GetFailureDefinitionId();</span></span><br><span class="line">                <span class="comment">// prevent Revit from showing Unenclosed room warnings</span></span><br><span class="line">                <span class="keyword">if</span> (failID == BuiltInFailures.RoomFailures.RoomNotEnclosed)</span><br><span class="line">                &#123;</span><br><span class="line">                        fa.DeleteWarning(failure);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>故障处理器</strong></p>
<p>在处理FailuresProcessing事件之后，IFailuresProcessor接口最后获得控制权。Revit任务中只有一个活动IFailuresProcessor。要注册故障处理器，从IFailuresProcessor派生一个类，并使用Application.RegisterFailuresProcessor（）方法注册它。如果先前注册的处理器出现故障，则将其丢弃。如果Revit附加模块选择为Revit注册故障处理器，则该处理器将成为任务中所有Revit错误的默认错误处理程序，并且不会显示标准的Revit错误对话框。如果未设置故障处理器，则Revit UI中有一个默认的故障处理器，用于调用所有常规的Revit错误对话框。只有在使用自定义故障解决处理程序（可以是交互式的，也可以没有用户界面）替换现有Revit故障UI时，才应覆盖FailuresProcessor。</p>
<p>如果传递给RegisterFailuresProcessor（）方法NULL，则任何失败的事务都将被静默中止（除非通过前两个失败处理步骤解决了失败）。</p>
<p>允许IFailuresProcessor.ProcessFailures（）方法返回WaitForUserInput，这将使事务挂起。在这种情况下，预计FailuresProcessor会在屏幕上留下一些UI，这些UI最终将提交或回滚挂起的事务-否则挂起状态将无限期地持续下去，基本上会冻结文档。</p>
<p>以下实现IFailuresProcessor的示例检查故障，删除失败的元素并为用户设置适当的消息。</p>
<p>代码区域26-5：IFailuresProcessor</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">Autodesk.Revit.Attributes.Transaction(Autodesk.Revit.Attributes.TransactionMode.Manual)</span>]<span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyFailuresUI</span> : <span class="title">IExternalApplication</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">static</span> AddInId m_appId = <span class="keyword">new</span> AddInId(<span class="keyword">new</span> Guid(<span class="string">&quot;9F179363-B349-4541-823F-A2DDB2B86AF3&quot;</span>));</span><br><span class="line">        <span class="keyword">public</span> Autodesk.Revit.UI.<span class="function">Result <span class="title">OnStartup</span>(<span class="params">UIControlledApplication uiControlledApplication</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">                IFailuresProcessor myFailUI = <span class="keyword">new</span> FailUI();</span><br><span class="line">                Autodesk.Revit.ApplicationServices.Application.RegisterFailuresProcessor(myFailUI);</span><br><span class="line">                <span class="keyword">return</span> Result.Succeeded;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Autodesk.Revit.UI.<span class="function">Result <span class="title">OnShutdown</span>(<span class="params">UIControlledApplication application</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">return</span> Result.Succeeded;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">FailUI</span> : <span class="title">IFailuresProcessor</span></span><br><span class="line">        &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Dismiss</span>(<span class="params">Document document</span>)</span></span><br><span class="line">                &#123;</span><br><span class="line">                        <span class="comment">// This method is being called in case of exception or document destruction to </span></span><br><span class="line">                        <span class="comment">// dismiss any possible pending failure UI that may have left on the screen</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="function"><span class="keyword">public</span> FailureProcessingResult <span class="title">ProcessFailures</span>(<span class="params">FailuresAccessor failuresAccessor</span>)</span></span><br><span class="line">                &#123;</span><br><span class="line">                        IList resolutionTypeList =</span><br><span class="line">                                <span class="keyword">new</span> List(); </span><br><span class="line">                        IList failList = <span class="keyword">new</span> List();</span><br><span class="line">                        <span class="comment">// Inside event handler, get all warnings</span></span><br><span class="line">                        failList = failuresAccessor.GetFailureMessages(); </span><br><span class="line">                        <span class="built_in">string</span> errorString = <span class="string">&quot;&quot;</span>;</span><br><span class="line">                        <span class="built_in">bool</span> hasFailures = <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">foreach</span> (FailureMessageAccessor failure <span class="keyword">in</span> failList)</span><br><span class="line">                        &#123;</span><br><span class="line"></span><br><span class="line">                                <span class="comment">// check how many resolutions types were attempted to try to prevent</span></span><br><span class="line">                                <span class="comment">// entering infinite loop</span></span><br><span class="line">                                resolutionTypeList = </span><br><span class="line">                                        failuresAccessor.GetAttemptedResolutionTypes(failure);</span><br><span class="line">                                <span class="keyword">if</span> (resolutionTypeList.Count &gt;= <span class="number">3</span>)</span><br><span class="line">                                &#123;</span><br><span class="line">                                        TaskDialog.Show(<span class="string">&quot;Error&quot;</span>, <span class="string">&quot;Cannot resolve failures - transaction will be rolled back.&quot;</span>);</span><br><span class="line">                                        <span class="keyword">return</span> FailureProcessingResult.ProceedWithRollBack;</span><br><span class="line">                                &#125;</span><br><span class="line"></span><br><span class="line">                                errorString += <span class="string">&quot;IDs &quot;</span>;</span><br><span class="line">                                <span class="keyword">foreach</span> (ElementId id <span class="keyword">in</span> failure.GetFailingElementIds())</span><br><span class="line">                                &#123;</span><br><span class="line">                                        errorString += id + <span class="string">&quot;, &quot;</span>;</span><br><span class="line">                                        hasFailures = <span class="literal">true</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                                errorString += <span class="string">&quot;\nWill be deleted because: &quot;</span> + failure.GetDescriptionText() + <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">                                failuresAccessor.DeleteElements(</span><br><span class="line">                                                        failure.GetFailingElementIds() <span class="keyword">as</span> IList);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (hasFailures)</span><br><span class="line">                        &#123;</span><br><span class="line">                                TaskDialog.Show(<span class="string">&quot;Error&quot;</span>, errorString);</span><br><span class="line">                                <span class="keyword">return</span> FailureProcessingResult.ProceedWithCommit;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">return</span> FailureProcessingResult.Continue;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="注：翻译自Revit-API-Developers-Guide"><a href="#注：翻译自Revit-API-Developers-Guide" class="headerlink" title="注：翻译自Revit API Developers Guide"></a><em><strong>注：</strong></em>翻译自<a href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_html">Revit API Developers Guide</a></h2>]]></content>
      <categories>
        <category>Revit二次开发人员指南</category>
      </categories>
      <tags>
        <tag>Revit</tag>
      </tags>
  </entry>
  <entry>
    <title>35性能顾问</title>
    <url>/2024/12/30/Revit%E4%BA%8C%E5%BC%80%E6%8C%87%E5%8D%97/35%E6%80%A7%E8%83%BD%E9%A1%BE%E9%97%AE/</url>
    <content><![CDATA[<h1 id="性能顾问"><a href="#性能顾问" class="headerlink" title="性能顾问"></a>性能顾问</h1><p>Revit API的性能顾问功能旨在分析文档，并为用户标记可能导致性能下降的任何元素和&#x2F;或设置。Performance Adviser命令执行一组规则并在标准审阅警告对话框中显示其结果。</p>
<p>性能顾问的API由两个类组成：</p>
<ul>
<li>PerformanceAdviser -一个应用程序范围的对象，具有双重角色，既可以作为运行的规则注册表，以检测潜在的性能问题，也可以作为执行这些问题的引擎</li>
<li>IPerformanceAdviserRule - 允许您为Performance Adviser定义新规则的接口</li>
</ul>
<p><strong>性能顾问</strong></p>
<p>PerformanceAdviser用于添加或删除要检查的规则、启用和禁用规则、获取有关列表中规则的信息以及执行列表中的部分或全部规则。创建新规则的应用程序应在应用程序启动期间使用AddRule（）注册新规则，并在应用程序关闭期间使用DeleteRule（）取消注册。ExecuteAllRules（）将对给定文档执行列表中的所有规则，而ExecuteRules（）可用于执行文档中的选定规则。这两种方法都将返回一个失败消息列表，解释在文档中检测到的性能问题。</p>
<p>下面的示例演示循环遍历所有Performance Adviser规则并执行文档的所有规则。</p>
<p>代码区域：性能顾问</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Get the name of each registered PerformanceRule and then execute all of them.</span></span><br><span class="line"><span class="keyword">foreach</span> (PerformanceAdviserRuleId id <span class="keyword">in</span> PerformanceAdviser.GetPerformanceAdviser().GetAllRuleIds())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> ruleName = PerformanceAdviser.GetPerformanceAdviser().GetRuleName(id);</span><br><span class="line">&#125;</span><br><span class="line">PerformanceAdviser.GetPerformanceAdviser().ExecuteAllRules(document);</span><br></pre></td></tr></table></figure>

<p><strong>IPerformanceAdviserRule</strong></p>
<p>创建IPerformanceAdviserRule接口的实例，以便为Performance Adviser创建新规则。规则可以特定于元素，也可以是文档范围的规则。需要实施以下方法：</p>
<ul>
<li>GetName() - 命名规则的短字符串</li>
<li>GetDescription() - 规则的一到两句描述</li>
<li>InitCheck() -在检查开始时由性能顾问调用一次的方法。如果rule检查整个文档而不是特定元素，则应在此方法中执行检查。</li>
<li>FinalizeCheck() -在检查结束时由性能顾问调用一次的方法。在规则执行期间发现的任何有问题的结果都可以在此消息期间使用FailureMessage报告</li>
<li>WillCheckElements() - 指示规则是否需要在单个元素上执行</li>
<li>GetElementFilter() - 检索一个过滤器以限制要检查的元素</li>
<li>ExecuteElementCheck() - 性能顾问为每个要检查的元素调用的方法</li>
</ul>
<p>The following excerpt from the PerformanceAdviserControl sample in the Revit API SDK Samples folder demonstrates the 以下摘录摘自Revit API SDK Samples文件夹中的PerformanceAdviserControl示例，演示了用于标识文档中任何正面翻转的门的自定义规则的实现。(在示例项目查看完整类实现。）</p>
<p>代码区域：实现IPerformanceAdviserRule</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">FlippedDoorCheck</span> : <span class="title">Autodesk.Revit.DB.IPerformanceAdviserRule</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">region</span> Constructor</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> </span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> Set up rule name, description, and error handling</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FlippedDoorCheck</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_name = <span class="string">&quot;Flipped Door Check&quot;</span>;</span><br><span class="line">        m_description = <span class="string">&quot;An API-based rule to search for and return any doors that are face-flipped&quot;</span>;</span><br><span class="line">        m_doorWarningId = <span class="keyword">new</span> Autodesk.Revit.DB.FailureDefinitionId(<span class="keyword">new</span> Guid(<span class="string">&quot;25570B8FD4AD42baBD78469ED60FB9A3&quot;</span>));</span><br><span class="line">        m_doorWarning = Autodesk.Revit.DB.FailureDefinition.CreateFailureDefinition(m_doorWarningId, Autodesk.Revit.DB.FailureSeverity.Warning, <span class="string">&quot;Some doors in this project are face-flipped.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">endregion</span></span></span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">region</span> IPerformanceAdviserRule implementation</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> </span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> Does some preliminary work before executing tests on elements.  In this case,</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> we instantiate a list of FamilyInstances representing all doors that are flipped.</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> </span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> The document being checked</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">InitCheck</span>(<span class="params">Autodesk.Revit.DB.Document document</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">if</span> (m_FlippedDoors == <span class="literal">null</span>)</span><br><span class="line">          m_FlippedDoors = <span class="keyword">new</span> List&lt;Autodesk.Revit.DB.ElementId&gt;();</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">          m_FlippedDoors.Clear();</span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> </span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> This method does most of the work of the IPerformanceAdviserRule implementation.</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> It is called by PerformanceAdviser.</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> It examines the element passed to it (which was previously filtered by the filter</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> returned by GetElementFilter() (see below)).  After checking to make sure that the</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> element is an instance, it checks the FacingFlipped property of the element.</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> If it is flipped, it adds the instance to a list to be used later.</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> </span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> The active document</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> The current element being checked</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ExecuteElementCheck</span>(<span class="params">Autodesk.Revit.DB.Document document, Autodesk.Revit.DB.Element element</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((element <span class="keyword">is</span> Autodesk.Revit.DB.FamilyInstance))</span><br><span class="line">        &#123;</span><br><span class="line">             Autodesk.Revit.DB.FamilyInstance doorCurrent = element <span class="keyword">as</span> Autodesk.Revit.DB.FamilyInstance;</span><br><span class="line">             <span class="keyword">if</span> (doorCurrent.FacingFlipped)</span><br><span class="line">                 m_FlippedDoors.Add(doorCurrent.Id);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> </span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> This method is called by PerformanceAdviser after all elements in document</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> matching the ElementFilter from GetElementFilter() are checked by ExecuteElementCheck().</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> This method checks to see if there are any elements (door instances, in this case) in the</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> m_FlippedDoor instance member.  If there are, it iterates through that list and displays</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> the instance name and door tag of each item.</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> </span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> The active document</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">FinalizeCheck</span>(<span class="params">Autodesk.Revit.DB.Document document</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (m_FlippedDoors.Count == <span class="number">0</span>)</span><br><span class="line">            System.Diagnostics.Debug.WriteLine(<span class="string">&quot;No doors were flipped.  Test passed.&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//Pass the element IDs of the flipped doors to the revit failure reporting APIs.</span></span><br><span class="line">            Autodesk.Revit.DB.FailureMessage fm = <span class="keyword">new</span> Autodesk.Revit.DB.FailureMessage(m_doorWarningId);</span><br><span class="line">            fm.SetFailingElements(m_FlippedDoors);</span><br><span class="line">            Autodesk.Revit.DB.Transaction failureReportingTransaction = <span class="keyword">new</span> Autodesk.Revit.DB.Transaction(document, <span class="string">&quot;Failure reporting transaction&quot;</span>);</span><br><span class="line">            failureReportingTransaction.Start();</span><br><span class="line">            document.PostFailure(fm);</span><br><span class="line">            failureReportingTransaction.Commit();</span><br><span class="line">            m_FlippedDoors.Clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> </span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> Gets the description of the rule</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> </span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> The rule description</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">GetDescription</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> m_description;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> </span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> This method supplies an element filter to reduce the number of elements that PerformanceAdviser</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> will pass to GetElementCheck().  In this case, we are filtering for door elements.</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> </span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> The document being checked</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> A door element filter</span></span><br><span class="line">    <span class="keyword">public</span> Autodesk.Revit.DB.<span class="function">ElementFilter <span class="title">GetElementFilter</span>(<span class="params">Autodesk.Revit.DB.Document document</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Autodesk.Revit.DB.ElementCategoryFilter(Autodesk.Revit.DB.BuiltInCategory.OST_Doors);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> </span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> Gets the name of the rule</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> </span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> The rule name</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">GetName</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> m_name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> </span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> Returns true if this rule will iterate through elements and check them, false otherwise</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> </span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> True</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">WillCheckElements</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">endregion</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="注：翻译自Revit-API-Developers-Guide"><a href="#注：翻译自Revit-API-Developers-Guide" class="headerlink" title="注：翻译自Revit API Developers Guide"></a><em><strong>注：</strong></em>翻译自<a href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_html">Revit API Developers Guide</a></h2>]]></content>
      <categories>
        <category>Revit二次开发人员指南</category>
      </categories>
      <tags>
        <tag>Revit</tag>
      </tags>
  </entry>
  <entry>
    <title>36点云</title>
    <url>/2024/12/30/Revit%E4%BA%8C%E5%BC%80%E6%8C%87%E5%8D%97/36%E7%82%B9%E4%BA%91/</url>
    <content><![CDATA[<h1 id="点云"><a href="#点云" class="headerlink" title="点云"></a>点云</h1><p>Revit API提供了两种处理点云的方法。第一种方法允许您创建新的点云实例，读取和过滤点，选择整体点的子集，以及选择要高亮显示或隔离的点。第二种方法允许您使用自己的点云引擎并处理不支持的文件格式（即.pcg、.rcp或.rcs以外的格式），从而向Revit提供点以供用户查看。</p>
<ul>
<li>客户端API</li>
<li>创建新的点云实例</li>
<li>读取和过滤点</li>
<li>点集选择</li>
<li>控制点云高亮显示</li>
<li>引擎API<ul>
<li>注册点云文件扩展名</li>
<li>向Revit提供点以进行渲染</li>
</ul>
</li>
</ul>
<p> 本节中的页面</p>
<ul>
<li>点云客户端</li>
<li>点云引擎</li>
</ul>
<h2 id="点云客户端"><a href="#点云客户端" class="headerlink" title="点云客户端"></a>点云客户端</h2><p>点云客户端API支持在Revit中读取和修改点云实例。</p>
<p>点云实例提供的点来自点云引擎，该引擎可以是Revit中的内置引擎，也可以是作为应用程序加载的第三方引擎。客户端点云API应用程序不需要关心引擎如何存储点并将点提供给Revit的详细信息。相反，客户端API可用于创建点云、操作其属性以及读取找到的与给定过滤器匹配的点。</p>
<p>与点云相关的主要类有：</p>
<ul>
<li><strong>PointCloudType</strong> - 加载到Revit文档中的点云类型。每个PointCloudType映射到单个文件或标识符（取决于控制它的点云引擎的类型）。</li>
<li><strong>PointCloudInstance</strong> - Revit项目中某个位置的点云实例。</li>
<li><strong>PointCloudFilter</strong> - 在提取点时确定感兴趣体积的过滤器。</li>
<li><strong>PointCollection</strong> -从实例和过滤器获得的点的集合。</li>
<li><strong>PointIterator</strong> - PointCollection中的点的迭代器。</li>
<li><strong>CloudPoint</strong> - 单个点云点，表示云坐标中的X、Y、Z位置和颜色。</li>
<li><strong>PointCloudOverrides</strong> -及其相关设置类指定要应用于PointCloudInstance元素或元素内扫描的视图存储的图形覆盖。</li>
</ul>
<p><strong>点云文件路径</strong></p>
<p>处理点云的两个重要路径位置可作为只读数据提供：</p>
<ol>
<li>PointCloudType.GetPath（）-从中加载点的链接源的路径</li>
<li>Application.PointCloudsRootPath -点云文件的根路径，Revit使用该路径计算点云文件的相对路径</li>
</ol>
<p><strong>创建点云</strong></p>
<p>要在Revit文档中创建新的点云，请创建PointCloudType，然后使用它创建PointCloudInstance。静态PointCloudType.Create（）方法需要引擎标识符（因为它是由第三方向Revit注册的），或者点云文件的文件扩展名（如果它是受支持的文件类型）。对于非基于文件的引擎，它还需要文件名或标识字符串。在以下示例中，pcg文件用于在Revit文档中创建点云。</p>
<p>代码区域：从rcs文件创建点云</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> PointCloudInstance <span class="title">CreatePointCloud</span>(<span class="params">Document doc</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    PointCloudType type = PointCloudType.Create(doc, <span class="string">&quot;rcs&quot;</span>, <span class="string">&quot;c:\32_cafeteria.rcs&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> (PointCloudInstance.Create(doc, type.Id, Transform.Identity));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/PointCloudInstance.png"></p>
<p>访问点云中的点有两种方法可以访问点云中的点：1.使用lEnumerable接口直接从PointCollection返回迭代resultingl点2。无论<br>采用哪种方式，从PointCloudlnstance访问点集合的第一步是使用PointCloudlnstance方法。GetPoints（PointCloudFilterfilter，double<br>averageDistance,int numPoints）注意，作为Revit和点云引擎使用的搜索算法的结果，可能不会返回所请求的确切点数。虽然第二种选择涉及到直接处理指针，但在遍历大量的点缓冲区时，可能会有性能上的提升。不过，这个选项只能在c#和c++&#x2F;CLI中实现。下面两个例子展示了如何使用这两种方法中的一种来迭代点云的一部分。</p>
<p>代码区域：通过迭代阅读点云点</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">GetPointCloudDataByIteration</span>(<span class="params">PointCloudInstance pcInstance, PointCloudFilter pointCloudFilter</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// read points by iteration</span></span><br><span class="line">    <span class="built_in">double</span> averageDistance = <span class="number">0.001</span>;</span><br><span class="line">    PointCollection points = pcInstance.GetPoints(pointCloudFilter, averageDistance, <span class="number">10000</span>); <span class="comment">// Get points.  Number of points is determined by the needs of the client</span></span><br><span class="line">    <span class="keyword">foreach</span> (CloudPoint point <span class="keyword">in</span> points)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Process each point</span></span><br><span class="line">        System.Drawing.Color color = System.Drawing.ColorTranslator.FromWin32(point.Color);</span><br><span class="line">        String pointDescription = String.Format(<span class="string">&quot;(&#123;0&#125;, &#123;1&#125;, &#123;2&#125;, &#123;3&#125;&quot;</span>, point.X, point.Y, point.Z, color.ToString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码区域：通过指针阅读点云点</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">unsafe</span> <span class="keyword">void</span> <span class="title">GetPointCloudDataByPointer</span>(<span class="params">PointCloudInstance pcInstance, PointCloudFilter pointCloudFilter</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">double</span> averageDistance = <span class="number">0.001</span>;</span><br><span class="line">    PointCollection points = pcInstance.GetPoints(pointCloudFilter, averageDistance, <span class="number">10000</span>);</span><br><span class="line">    CloudPoint pointBuffer = (CloudPoint)points.GetPointBufferPointer().ToPointer();</span><br><span class="line">    <span class="built_in">int</span> totalCount = points.Count;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> numberOfPoints = <span class="number">0</span>; numberOfPoints &lt; totalCount; numberOfPoints++)</span><br><span class="line">    &#123;</span><br><span class="line">        CloudPoint point = (pointBuffer + numberOfPoints);</span><br><span class="line">        <span class="comment">// Process each point</span></span><br><span class="line">        System.Drawing.Color color = System.Drawing.ColorTranslator.FromWin32(point.Color);</span><br><span class="line">        String pointDescription = String.Format(<span class="string">&quot;(&#123;0&#125;, &#123;1&#125;, &#123;2&#125;, &#123;3&#125;&quot;</span>, point.X, point.Y, point.Z, color.ToString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>过滤器</strong></p>
<p>过滤器用于限制阅读点时搜索的体积，也用于管理点云的显示。可以基于平面边界的集合创建PointCloudFilter。过滤器将检查点是否位于每个输入平面的“正”侧，如平面法线的正方向所指示的。因此，这种过滤器隐含地定义了一个体积，它是对应于所有平面的正半空间的交集。这个体积不必闭合，但它将始终是凸的。</p>
<p>The display of point clouds can be controlled by assigning a filter to:<br>点云的显示可以通过将过滤器分配给以下对象来控制：</p>
<ul>
<li>PointCloudInstance.SetSelectionFilter（）</li>
</ul>
<p>Display of the filtered points will be based on the value of the property:<br>过滤点的显示将基于特性的值：</p>
<ul>
<li>PointCloudInstance.FilterAction</li>
</ul>
<p>如果设置为“无”，则忽略选择过滤器。如果将其设置为“高亮显示”，则通过过滤器的点将高亮显示。如果将其设置为“隔离”（Isolate），则只有通过过滤器的点可见。</p>
<p>以下示例将基于点云的边界框高亮显示点云中的点子集。</p>
<p>代码区域：通过指针阅读点云点</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Filter will match 1/8 of the overall point cloud</span></span><br><span class="line"><span class="comment">// Use the bounding box (filter coordinates are in the coordinates of the model)</span></span><br><span class="line">BoundingBoxXYZ boundingBox = pointCloudInstance.get_BoundingBox(<span class="literal">null</span>);</span><br><span class="line">List planes = <span class="keyword">new</span> List();</span><br><span class="line">XYZ midpoint = (boundingBox.Min + boundingBox.Max) / <span class="number">2.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// X boundaries</span></span><br><span class="line">planes.Add(Plane.CreateByNormalAndOrigin(XYZ.BasisX, boundingBox.Min));</span><br><span class="line">planes.Add(Plane.CreateByNormalAndOrigin(-XYZ.BasisX, midpoint));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Y boundaries</span></span><br><span class="line">planes.Add(Plane.CreateByNormalAndOrigin(XYZ.BasisY, boundingBox.Min));</span><br><span class="line">planes.Add(Plane.CreateByNormalAndOrigin(-XYZ.BasisY, midpoint));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Z boundaries</span></span><br><span class="line">planes.Add(Plane.CreateByNormalAndOrigin(XYZ.BasisZ, boundingBox.Min));</span><br><span class="line">planes.Add(Plane.CreateByNormalAndOrigin(-XYZ.BasisZ, midpoint));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create filter</span></span><br><span class="line">PointCloudFilter filter = PointCloudFilterFactory.CreateMultiPlaneFilter(planes);</span><br><span class="line">pointCloudInstance.FilterAction = SelectionFilterAction.Highlight;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> filter;</span><br></pre></td></tr></table></figure>

<p>这是在小管道点云上运行上述示例时的结果：</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/PointCloudHighlight.jpg"></p>
<p>图：带有选择过滤器的点云</p>
<p>Selection.PickBox（）方法调用一个通用的双击编辑器，让用户在屏幕上指定一个矩形区域，可以与PointCloudFilter结合使用，方法是使用生成的PickedBox来生成过滤器的平面边界。</p>
<p> <strong>扫描</strong></p>
<p>.rcp文件可以包含多个扫描。方法PointCloudInstance.GetScans（）返回一个扫描名称列表，可用于为PointCloudInstance中的每次扫描单独设置可见性和固定颜色覆盖。PointCloudInstance.ContainsScan（）指示给定扫描名称是否包含在点云实例中，而PointCloudInstance.GetScanOrigin（）将以模型坐标返回给定扫描的原点。</p>
<p>区域</p>
<p>扫描区域特定于Autodesk ReCap™。如果点云是在ReCap中创建的，则它可能具有区域。PointCloudInstance.GetRegions（）返回区域名称列表，可用于为PointCloudInstance中的每个区域单独设置可见性和固定颜色覆盖。</p>
<p>覆盖</p>
<p>可以使用Revit API修改指定给给定视图的点云替代设置。这些设置对应于Revit UI中“可见性&#x2F;图形替换”任务窗格的“点云”选项卡上的设置。覆盖可以应用于整个点云实例，也可以应用于该实例中的特定扫描。覆盖选项包括设置点云实例中扫描的可见性、将其设置为固定颜色或基于高程、法线或强度的颜色梯度。PointCloudInstance.SupportsOverrides属性标识支持覆盖设置的点云（基于.rcp或.rcs文件的点云）。</p>
<p>设置点云的替代时涉及以下类：</p>
<ul>
<li><strong>PointCloudOverrides</strong> - 用于获取或设置PointCloudInstance、其扫描之一或PointCloudInstance内特定区域的PointCloudOverrideSettings。</li>
<li><strong>PointCloudOverrideSettings</strong> - 用于获取或设置可见性、颜色模式和PointCloudColorSettings。</li>
<li><strong>PointCloudColorSettings</strong> - 于将特定颜色模式的特定颜色指定给PointCloudInstance元素或其扫描之一。如果PointCloudColorMode为“Noise”或“Normals”，则不适用。</li>
</ul>
<h2 id="点云引擎"><a href="#点云引擎" class="headerlink" title="点云引擎"></a>点云引擎</h2><p>可以实现自定义点云引擎，以向Revit提供云点。</p>
<p>点云引擎可以基于文件，也可以不基于文件。基于文件的实现要求将每个点云映射到磁盘上的单个文件。Revit将允许用户通过选择扩展名与引擎标识符匹配的点云文件，直接在文档中创建新的点云实例。这些文件在Revit中被视为外部链接，必要时可以从“管理链接”对话框中重新加载和重新映射。</p>
<p>非基于文件的引擎实现可以从任何地方（例如，从数据库、从服务器、或从较大聚合文件的一部分）获得点云。由于没有用户可以选择的文件，因此Revit的用户界面不允许用户创建此类型的点云。相反，引擎提供程序提供了一个使用PointCloudType.Create（）和PointCloudInstance.Create（）的自定义命令，以创建和放置此类型的点云。“管理链接”对话框将显示此类型的点云，但由于没有与点云关联的文件，因此用户无法管理、重新加载或重新映射此类型的点云。</p>
<p>无论实现的类型如何，自定义引擎实现都包括以下内容：</p>
<ul>
<li>通过PointCloudEngineRegistry向Revit注册的IPointCloudEngine实现。</li>
<li>IPointCloudAccess的实现，它将响应来自Revit的有关单个点云属性的查询。</li>
<li>IPointSetIterator的实现，它将在请求时向Revit返回点集。</li>
</ul>
<p>为了将点云的点提供给Revit，必须实现两个ReadPoints（）方法：</p>
<ul>
<li>IPointCloudAccess.ReadPoints（）-这在一次性调用中提供一组点，可以从Revit或API调用。Revit在某些显示活动（包括选择预高亮显示）中使用此选项。API客户端也可以通过PointCloudInstance.GetPoints（）直接调用此方法。</li>
<li>IPointSetIterator.ReadPoints（）-这提供了点的子集，作为云中点的更大迭代的一部分。Revit在点云的正常显示期间使用此方法;将重复请求点的数量，直到获得足够的点或显示中的某些内容发生更改。在任何给定的点集迭代过程中，引擎实现必须跟踪哪些点已返回到Revit。</li>
</ul>
<p>有关注册和实施基于文件和非基于文件的点云引擎的完整示例，请参见Revit API SDK附带的Samples目录下的PointCloudEngine文件夹。</p>
<h2 id="注：翻译自Revit-API-Developers-Guide"><a href="#注：翻译自Revit-API-Developers-Guide" class="headerlink" title="注：翻译自Revit API Developers Guide"></a><em><strong>注：</strong></em>翻译自<a href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_html">Revit API Developers Guide</a></h2>]]></content>
      <categories>
        <category>Revit二次开发人员指南</category>
      </categories>
      <tags>
        <tag>Revit</tag>
      </tags>
  </entry>
  <entry>
    <title>37分析</title>
    <url>/2024/12/30/Revit%E4%BA%8C%E5%BC%80%E6%8C%87%E5%8D%97/37%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>相关信息</p>
<ul>
<li>绿色建筑工作室API</li>
</ul>
<p>Pages in this section  本节中的页面</p>
<ul>
<li>能量数据</li>
<li>分析可视化</li>
<li>概念能量分析</li>
<li>详细的能源分析模型</li>
</ul>
<h2 id="能量数据"><a href="#能量数据" class="headerlink" title="能量数据"></a>能量数据</h2><p>EnergyDataSettings对象包含gbXML导出和热负荷和冷负荷计算的设置以及概念能量分析的项目级别设置。</p>
<p>EnergyDataSettings对象是从Element基对象派生的。它在每个项目中都是唯一的，类似于ProjectInformation。虽然EnergyDataSettings是Element类的子类，但从Element继承的大多数成员都返回null或空集，但Name、Id、UniqueId和Parameters除外。</p>
<p>下面的代码示例使用EnergyDataSettings类。调用命令后，结果将显示在TaskDialog中。</p>
<p>代码区域28-7：使用EnergyDataSettings类</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetInfo_EnergyData</span>(<span class="params">Document document</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        EnergyDataSettings energyData = EnergyDataSettings.GetFromDocument(document);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != energyData)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">string</span> message = <span class="string">&quot;energyData : &quot;</span>;</span><br><span class="line">                message += <span class="string">&quot;\nBuildingType : &quot;</span> + energyData.BuildingType;</span><br><span class="line">                TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>, message);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="分析可视化"><a href="#分析可视化" class="headerlink" title="分析可视化"></a>分析可视化</h2><p>Revit API提供了一种机制，使外部分析应用程序可以在Revit模型中轻松显示其计算结果。SpatialFieldManager类是将分析结果传回Revit的主要类。它用于创建、删除和修改存储分析结果的“容器”。AnalysisResultSchema类包含有关一个分析结果的所有信息，例如用于结果可视化的所有单位的描述和名称及乘数。可以向SpatialFieldManager注册多个AnalysisResultSchemas。</p>
<p>然后可以使用AnalysisDisplayStyle类控制结果的外观。从插件创建和修改AnalysisDisplayStyle是可选的;最终用户可以通过Revit UI对分析结果的显示进行相同的控制。</p>
<p>Revit API支持的数据模型要求在某组点处指定分析结果，并且在每个点处计算一个或多个不同的数字（“测量值”）。所有模型点的测量次数必须相同。结果数据是暂时的;它只存储在模型中，直到文档关闭。如果模型已保存、关闭并重新打开，则分析结果将不显示。</p>
<p>本节中的页面</p>
<ul>
<li>分析结果管理</li>
<li>创建分析结果数据</li>
<li>分析结果显示</li>
<li>更新分析结果</li>
</ul>
<h3 id="分析结果管理"><a href="#分析结果管理" class="headerlink" title="分析结果管理"></a>分析结果管理</h3><p>新的SpatialFieldManager可以使用静态SpatialFieldManager. stateSpatialFieldManager（）方法添加到视图中。一个视图只能关联一个管理器。如果视图已经有SpatialFieldManager，则可以使用静态方法GetSpatialFieldManager（）检索它。</p>
<p>SpatialFieldManager（）接受一个参数，表示将为每个点计算的测量数。此数字定义了与计算结果的每个点相关联的结果值的数量。例如，如果计算一年中每个月的平均太阳辐射，则每个点将有12个相应的值。</p>
<p>要将分析结果添加到视图中，请调用AddSpatialFieldPrimitive（）以创建新的分析结果容器。存在此方法的四个重载以创建与以下项关联的基元：</p>
<ul>
<li>引用（曲线或面）</li>
<li>曲线与变换</li>
<li>一个面和一个变换</li>
<li>无Revit几何图形-为了在创建与Revit几何图形无关的多个数据点时提高性能，建议创建多个基本体，每个基本体的点不超过500个，而不是创建一个包含所有点的大型基本体。</li>
</ul>
<p>变换重载的一个典型用途是定位结果数据与Revit模型中几何图形的偏移，例如，楼板上方3英尺。</p>
<p>AddSpatialFieldPrimitive（）方法返回SpatialFieldManager中图元的唯一整数标识符，该标识符稍后可用于标识图元以将其移除（RemoveSpatialFieldPrimitive（））或修改图元（UpdateSpatialFieldPrimitive（））。</p>
<p>注意，AddSpatialFieldPrimitive（）方法创建了一个空的分析结果原语。必须调用UpdateSpatialFieldPrimitive（）才能使用点和值填充分析结果数据，如创建分析结果数据部分所示。</p>
<p>UpdateSpatialFieldPrimitive（）方法需要已向SpatialFieldManager注册的AnalysisResultSchema的唯一索引。AnalysisResultSchema保存有关分析结果的信息，例如名称、描述以及用于结果可视化的所有单元的名称和乘数。下面的示例演示如何创建新的AnalysisResultSchema并设置其单位。</p>
<p>代码区域：分析结果架构</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">IList unitNames = <span class="keyword">new</span> List();</span><br><span class="line">unitNames.Add(<span class="string">&quot;Feet&quot;</span>);</span><br><span class="line">unitNames.Add(<span class="string">&quot;Inches&quot;</span>);</span><br><span class="line">IList multipliers = <span class="keyword">new</span> List();</span><br><span class="line">multipliers.Add(<span class="number">1</span>);</span><br><span class="line">multipliers.Add(<span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">AnalysisResultSchema resultSchema = <span class="keyword">new</span> AnalysisResultSchema(<span class="string">&quot;Schema Name&quot;</span>, <span class="string">&quot;Description&quot;</span>);</span><br><span class="line"></span><br><span class="line">resultSchema.SetUnits(unitNames, multipliers);</span><br></pre></td></tr></table></figure>

<p>一旦配置了AnalysisResultschema，就需要使用SpatialFieldManager.RegisterResult（）方法注册它，该方法将返回结果的唯一索引。使用此唯一索引的GetResultSchema（）和SetResultSchema（）可在注册结果后获取和更改结果。</p>
<h3 id="创建分析结果数据"><a href="#创建分析结果数据" class="headerlink" title="创建分析结果数据"></a>创建分析结果数据</h3><p>将基元添加到SpatialFieldManager后，可以使用UpdateSpatialFieldPrimitive（）方法创建分析结果并将其添加到分析结果容器。此方法采用一组计算结果的域点（FieldDomainPoints）和每个点的一组值（FieldValues）。FieldValues的数量必须与域点的数量相对应。然而，每个域点可以具有值阵列，每个值用于该点处的单独测量。</p>
<p>下面的示例在用户选择的元素面上创建一组简单的分析结果。SDK示例SpatialFieldGradient演示了一个更复杂的用例，其中每个点都有多个关联值。</p>
<p>代码区域27-1：创建分析结果</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Document doc = commandData.Application.ActiveUIDocument.Document;</span><br><span class="line">UIDocument uiDoc = commandData.Application.ActiveUIDocument;</span><br><span class="line"></span><br><span class="line">SpatialFieldManager sfm = SpatialFieldManager.GetSpatialFieldManager(doc.ActiveView);</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">null</span> == sfm)</span><br><span class="line">&#123;</span><br><span class="line">        sfm = SpatialFieldManager.CreateSpatialFieldManager(doc.ActiveView, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Reference reference = uiDoc.Selection.PickObject(ObjectType.Face, <span class="string">&quot;Select a face&quot;</span>);</span><br><span class="line"><span class="built_in">int</span> idx = sfm.AddSpatialFieldPrimitive(reference);</span><br><span class="line"></span><br><span class="line">Face face = doc.GetElement(reference).GetGeometryObjectFromReference(reference) <span class="keyword">as</span> Face;</span><br><span class="line"></span><br><span class="line">IList uvPts = <span class="keyword">new</span> List();</span><br><span class="line">BoundingBoxUV bb = face.GetBoundingBox();</span><br><span class="line">UV min = bb.Min;</span><br><span class="line">UV max = bb.Max;</span><br><span class="line">uvPts.Add(<span class="keyword">new</span> UV(min.U,min.V));</span><br><span class="line">uvPts.Add(<span class="keyword">new</span> UV(max.U,max.V));</span><br><span class="line"></span><br><span class="line">FieldDomainPointsByUV pnts = <span class="keyword">new</span> FieldDomainPointsByUV(uvPts);</span><br><span class="line"></span><br><span class="line">List doubleList = <span class="keyword">new</span> List();</span><br><span class="line">IList valList = <span class="keyword">new</span> List();</span><br><span class="line">doubleList.Add(<span class="number">0</span>);</span><br><span class="line">valList.Add(<span class="keyword">new</span> ValueAtPoint(doubleList));</span><br><span class="line">doubleList.Clear();</span><br><span class="line">doubleList.Add(<span class="number">10</span>);</span><br><span class="line">valList.Add(<span class="keyword">new</span> ValueAtPoint(doubleList));</span><br><span class="line"></span><br><span class="line">FieldValues vals = <span class="keyword">new</span> FieldValues(valList);</span><br><span class="line"></span><br><span class="line">AnalysisResultSchema resultSchema = <span class="keyword">new</span> AnalysisResultSchema(<span class="string">&quot;Schema Name&quot;</span>, <span class="string">&quot;Description&quot;</span>);</span><br><span class="line"><span class="built_in">int</span> schemaIndex = sfm.RegisterResult(resultSchema);</span><br><span class="line">sfm.UpdateSpatialFieldPrimitive(idx, pnts, vals, schemaIndex);</span><br></pre></td></tr></table></figure>

<h3 id="分析结果显示"><a href="#分析结果显示" class="headerlink" title="分析结果显示"></a>分析结果显示</h3><p>AnalysisDisplayStyle类可用于控制分析结果在视图中的显示方式。这个静态的函数AnalysisDisplayStyle（）方法可以创建一个彩色的表面显示样式，一个带有文本样式的标记，一个变形的形状样式，图表样式或者矢量样式。对于任何样式，也可以设置颜色和图例设置。</p>
<p>创建新的AnalysisDisplayStyle后，使用View.AnalysisDisplayStyleId将样式指定给视图。虽然分析结果不与文档一起保存，但分析显示样式及其对视图的指定与模型一起保存。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-5AC1C63F-A94F-4BEC-AE0D-6EB1898F0C97-low.png"></p>
<p>下面的示例创建一个新的彩色曲面分析显示样式（如果在文档中尚未找到），然后将其指定给当前视图。</p>
<p>代码区域27-2：设置视图的分析显示样式</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Document doc = commandData.Application.ActiveUIDocument.Document;</span><br><span class="line"></span><br><span class="line">AnalysisDisplayStyle analysisDisplayStyle = <span class="literal">null</span>;</span><br><span class="line"><span class="comment">// Look for an existing analysis display style with a specific name</span></span><br><span class="line">FilteredElementCollector collector1 = <span class="keyword">new</span> FilteredElementCollector(doc);</span><br><span class="line">ICollection collection =        collector1.OfClass(<span class="keyword">typeof</span>(AnalysisDisplayStyle)).ToElements();</span><br><span class="line"><span class="keyword">var</span> displayStyle = <span class="keyword">from</span> element <span class="keyword">in</span> collection </span><br><span class="line">                                        <span class="keyword">where</span> element.Name == <span class="string">&quot;Display Style 1&quot;</span> </span><br><span class="line">                                        <span class="keyword">select</span> element;</span><br><span class="line"></span><br><span class="line">                                        <span class="comment">// If display style does not already exist in the document, create it</span></span><br><span class="line"><span class="keyword">if</span> (displayStyle.Count() == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">        AnalysisDisplayColoredSurfaceSettings coloredSurfaceSettings = <span class="keyword">new</span> AnalysisDisplayColoredSurfaceSettings();</span><br><span class="line">        coloredSurfaceSettings.ShowGridLines = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        AnalysisDisplayColorSettings colorSettings = <span class="keyword">new</span> AnalysisDisplayColorSettings();</span><br><span class="line">        Color orange = <span class="keyword">new</span> Color(<span class="number">255</span>, <span class="number">205</span>, <span class="number">0</span>);</span><br><span class="line">        Color purple = <span class="keyword">new</span> Color(<span class="number">200</span>, <span class="number">0</span>, <span class="number">200</span>);</span><br><span class="line">        colorSettings.MaxColor = orange;</span><br><span class="line">        colorSettings.MinColor = purple;</span><br><span class="line"></span><br><span class="line">        AnalysisDisplayLegendSettings legendSettings = <span class="keyword">new</span> AnalysisDisplayLegendSettings();</span><br><span class="line">        legendSettings.NumberOfSteps = <span class="number">10</span>;</span><br><span class="line">        legendSettings.Rounding = <span class="number">0.05</span>;</span><br><span class="line">        legendSettings.ShowDataDescription = <span class="literal">false</span>;</span><br><span class="line">        legendSettings.ShowLegend = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        FilteredElementCollector collector2 = <span class="keyword">new</span> FilteredElementCollector(doc);</span><br><span class="line">        ICollection elementCollection = collector2.OfClass(<span class="keyword">typeof</span>(TextNoteType)).ToElements();</span><br><span class="line">        <span class="keyword">var</span> textElements = <span class="keyword">from</span> element <span class="keyword">in</span> collector2 </span><br><span class="line">                                                <span class="keyword">where</span> element.Name == <span class="string">&quot;LegendText&quot;</span> </span><br><span class="line">                                                <span class="keyword">select</span> element;</span><br><span class="line">        <span class="comment">// if LegendText exists, use it for this Display Style</span></span><br><span class="line">        <span class="keyword">if</span> (textElements.Count() &gt; <span class="number">0</span>) </span><br><span class="line">        &#123;</span><br><span class="line">                TextNoteType textType = </span><br><span class="line">                        textElements.Cast().ElementAt(<span class="number">0</span>);</span><br><span class="line">                legendSettings.SetTextTypeId(textType.Id, doc);</span><br><span class="line">        &#125;</span><br><span class="line">        analysisDisplayStyle = AnalysisDisplayStyle.CreateAnalysisDisplayStyle(doc, <span class="string">&quot;Display Style 1&quot;</span>, coloredSurfaceSettings, colorSettings, legendSettings);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">        analysisDisplayStyle = </span><br><span class="line">                displayStyle.Cast().ElementAt(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// now assign the display style to the view</span></span><br><span class="line">doc.ActiveView.AnalysisDisplayStyleId = analysisDisplayStyle.Id;</span><br></pre></td></tr></table></figure>

<h3 id="更新分析结果"><a href="#更新分析结果" class="headerlink" title="更新分析结果"></a>更新分析结果</h3><p>Revit分析框架不会自动更新结果，对Revit模型的任何更改都可能使结果无效。</p>
<p>为了使结果保持最新，API开发人员应使用“动态模型更新”触发器或订阅DocumentChanged事件，以便在Revit模型发生更改且以前计算的结果可能无效并需要重新计算时收到通知。有关显示动态模型更新和分析可视化的示例，请参见Revit SDK中的DistanceToSurfaces示例。</p>
<h2 id="概念能量分析"><a href="#概念能量分析" class="headerlink" title="概念能量分析"></a>概念能量分析</h2><p>通过Revit API可以访问由Revit创建的图元和对象，以便对概念设计模型执行能量分析。以下类允许您使用此数据：</p>
<ul>
<li><strong>MassEnergyAnalyticalModel</strong> - 将体量实例与能量分析模型数据和几何图形相关联。</li>
<li><strong>MassLevelData</strong> - 概念建筑模型中可占用楼层（体量楼层）的概念表示。</li>
<li><strong>MassSurfaceData</strong> - 在MassEnergyAnalyticalModel元素中保存面的属性和其他数据</li>
<li><strong>MassZone</strong> - 建筑的单独加热和冷却子体积的概念表达。</li>
<li><strong>ConceptualConstructionType</strong> - 以Revit BIM模型和绿色Building Studio&#x2F;绿色Building XML都能理解的方式描述概念物理、构造和能量属性。</li>
<li><strong>ConceptualSurfaceType</strong> -表示要指定给体量几何图形中的面的概念BIM对象类别。</li>
</ul>
<p>除了这些类之外，还有一个Document.Export（）重载，它采用MassGBXMLExportOptions参数，该参数导出仅包含概念能量分析元素（体量元素）的gBXML文件。</p>
<p><strong>质量能量分析模型</strong></p>
<p>与概念能量分析关联的主类是MassEnergyAnalyticalModel。此类将体量实例与能量分析模型数据和几何图形相关联。几何图形开始时是其关联体量实例几何图形的副本，并根据能量分析模型的要求进行修改。静态方法MassEnergyAnalyticalModel。GetMassEnergyAnalyticalModelIdForMassInstance（）将返回给定体量实例的MassEnergyAnalyticalModel的ElementId。</p>
<p><strong>MassLevelData</strong></p>
<p>MassLevelData是通过将特定标高与Revit项目中的特定体量元素相关联来定义的。这可以使用MassInstanceUtils.AddMassLevelDataToMassInstance（）方法完成。MassLevelData报告与概念空间规划相关的度量，如楼层面积。MassLevelData包含用作“概念能量分析”模型一部分的信息，例如ConceptualConstructionType。通过将体量的所有几何图形合并为单个几何图形，然后获取与MassLevelData的标高相交的区域，可以确定MassLevel数据几何图形。</p>
<p><strong>Masszone</strong></p>
<p>通过将与体量族实例关联的体量级别数据与和同一体量族实例关联的体量能量分析模型的几何图形相交，将体量能量分析模型分割为多个部分，从而创建体量分区。可以使用GetMassZoneIds（）方法检索与MassEnergyAnalyticalModel关联的MassZones的ElementIds。</p>
<p><strong>MassSurfaceData</strong></p>
<p>从MassEnergyAnalyticalModel中，可以获取对其有意义的所有面的引用。使用这些引用，可以使用GetMassSurfaceDataIdForReference（）方法获取与每个面关联的MassSurfaceData。MassSurfaceData保存有关MassEnergyAnalyticalModel元素中的面的属性和其他数据，例如材质值和自动生成的元素的尺寸（例如窗台高度和天窗宽度）。</p>
<p>MassSurfaceData还保存与参考曲面关联的ConceptualConstructionType的ID。ConceptualConstructionType以Revit BIM模型和绿色Building Studio&#x2F;绿色Building XML都能理解的方式描述概念物理、构造和能量属性。这个类有许多静态方法来获取给定文档中建筑物不同方面（如墙和窗）的ConceptualConstructionType的ElementId。</p>
<p>MassSurfaceData的另一个属性是CategoryIdForConceptualSurfaceType，它提供用于其ConceptualSurfaceType的体量子类别ElementId。ConceptualSurfaceType表示要分配给体量几何图形中的面的概念性BIM对象类别。每个体量曲面子类别都有一个ConceptualSurfaceType元素。使用静态方法ConceptualSurfaceType.GetByMassSubCategoryId（），可以从体量子类别ID中获取MassSurfaceData的ConceptualSurfaceType。</p>
<p>在Revit项目中启用“概念能量分析”后，体量面将指定给与这些ConceptualSurfaceType关联的Mass类别的子类别。默认的ConceptualConstructionType与ConceptualSurfaceType相关联。此默认ConceptualConstructionType指定给具有相应子类别的体量面。更改与ConceptualSurfaceType关联的默认ConceptualConstructionType将更新该子类别的所有体量面的ConceptualConstruction类型，用户尚未为其专门提供替代值。</p>
<p><strong>MassInstanceUtils</strong></p>
<p>MassInstancesUtils实用程序类提供静态方法来获取有关体量实例的信息（例如体量实例表示的总可占用楼层面积或总建筑体积），以及创建MassLevelData（体量楼层）以将标高与体量实例关联（如上所述）。</p>
<h2 id="详细的能源分析模型"><a href="#详细的能源分析模型" class="headerlink" title="详细的能源分析模型"></a>详细的能源分析模型</h2><p>Autodesk.Revit.DB.Analysis命名空间包含多个类，用于获取和分析项目详细能量分析模型的内容。</p>
<p>The Export to gbXML and the Heating and Cooling Loads features produce an analytical thermal model from the physical model of a building. The analytical thermal model is composed of spaces, zones and planar surfaces that represent the actual volumetric elements of the building.<br>“导出到gbXML”和“热负荷和冷负荷”功能可从建筑的物理模型生成分析热模型。分析热模型由空间、分区和平面组成，它们表示建筑的实际体积元素。</p>
<p>与详细能量分析模型相关的类包括：</p>
<ul>
<li>EnergyAnalysisDetailModel</li>
<li>EnergyAnalysisDetailModelOptions</li>
<li>EnergyAnalysisOpening </li>
<li>EnergyAnalysisSpace</li>
<li>EnergyAnalysisSurface </li>
<li>Polyloop</li>
</ul>
<p><strong>能量分析模型创建</strong></p>
<p>使用静态方法EnergyAnalysisDetailModel.Create（）创建并填充能量分析模型。EnergyAnalysisDetailModel作为图元存储在Revit模型中，因此EnergyAnalysisDetailModel.Create（）方法要求存在打开的事务。生成的模型总是以世界坐标返回，但方法TransformModel（）根据地平面、共享坐标和真北变换模型中的所有曲面。</p>
<p>如果已创建能量分析模型，则静态方法EnergyAnalysisDetailModel.GetMainEnergyAnalysisDetailModel（）返回给定文档中包含的主EnergyAnalysisDetailModel（如果尚未创建任何模型，则返回null）。能量分析详图模型可以显示在关联视图中。</p>
<p>使用EnergyAnalysisDetailModelOptions类设置适当的选项。</p>
<p>创建能量分析详图模型时可用的选项包括：</p>
<ul>
<li>能量分析模型的计算级别- NotComputed、FirstLevelBoundary（表示分析空间和分区）、SecondLevelBoundary（表示分析表面）或Final（表示构造、明细表和非图形数据</li>
<li>能源模型是否基于房间&#x2F;空间或建筑元素</li>
<li>竖梃是否应导出为着色表面</li>
<li>是否包括遮光表面</li>
<li>是否简化幕墙系统-为true时，将为幕墙&#x2F;系统导出单个大窗&#x2F;洞口，而不考虑系统中的嵌板数量</li>
</ul>
<p>EnergyAnalysisDetailModelOptions.EnergyModelType属性可以设置为SpatialElement（其中能量模型基于房间或空间）或BuildingElement（其中能量模型基于建筑图元体积的分析）。但是，请注意，生成的能量模型还受EnergyDataSettings中的设置（包括EnergyDataSettings.AnalysisType属性）的影响。如果将此属性设置为AnalysisMode.ConceptualMassesAndBuildingElements，则EnergyAnalysisDetailModel将使用概念体量和建筑图元的组合。</p>
<p>以下示例从物理模型创建新的能量分析详细模型，然后显示模型中每个空间的每个曲面的原始图元。</p>
<p>代码区域：能量分析详图模型</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Collect space and surface data from the building&#x27;s analytical thermal model</span></span><br><span class="line">EnergyAnalysisDetailModelOptions options = <span class="keyword">new</span> EnergyAnalysisDetailModelOptions();</span><br><span class="line">options.Tier = EnergyAnalysisDetailModelTier.Final; <span class="comment">// include constructions, schedules, and non-graphical data in the computation of the energy analysis model</span></span><br><span class="line">options.EnergyModelType = EnergyModelType.SpatialElement;   <span class="comment">// Energy model based on rooms or spaces</span></span><br><span class="line"></span><br><span class="line">EnergyAnalysisDetailModel eadm = EnergyAnalysisDetailModel.Create(doc, options); <span class="comment">// Create a new energy analysis detailed model from the physical model</span></span><br><span class="line">IList spaces = eadm.GetAnalyticalSpaces();</span><br><span class="line">StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">builder.AppendLine(<span class="string">&quot;Spaces: &quot;</span> + spaces.Count);</span><br><span class="line"><span class="keyword">foreach</span> (EnergyAnalysisSpace space <span class="keyword">in</span> spaces)</span><br><span class="line">&#123;</span><br><span class="line">    SpatialElement spatialElement = doc.GetElement(space.CADObjectUniqueId) <span class="keyword">as</span> SpatialElement;</span><br><span class="line">    ElementId spatialElementId = spatialElement == <span class="literal">null</span> ? ElementId.InvalidElementId : spatialElement.Id;</span><br><span class="line">    builder.AppendLine(<span class="string">&quot;   &gt;&gt;&gt; &quot;</span> + space.SpaceName + <span class="string">&quot; related to &quot;</span> + spatialElementId);</span><br><span class="line">    IList surfaces = space.GetAnalyticalSurfaces();</span><br><span class="line">    builder.AppendLine(<span class="string">&quot;       has &quot;</span> + surfaces.Count + <span class="string">&quot; surfaces.&quot;</span>);</span><br><span class="line">    <span class="keyword">foreach</span> (EnergyAnalysisSurface surface <span class="keyword">in</span> surfaces)</span><br><span class="line">    &#123;</span><br><span class="line">        builder.AppendLine(<span class="string">&quot;            +++ Surface from &quot;</span> + surface.OriginatingElementDescription);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">TaskDialog.Show(<span class="string">&quot;EAM&quot;</span>, builder.ToString());</span><br></pre></td></tr></table></figure>

<p>创建EnergyAnalysisDetailModel后，可以使用GetAnalyticalOpenings（）、GetAnalyticalSpaces（）、GetAnalyticalShadingSurfaces（）和GetAnalyticalSurfaces（）方法检索与其关联的空间、洞口和曲面。 建议应用程序在访问完数据后创建的EnergyAnalysisDetailModel元素上调用Document.Delete（），但在保存或同步文档之前，将自动删除在主能源模型之后创建的任何能源模型。 </p>
<p> <strong>EnergyAnalysisSpace</strong> </p>
<p>从EnergyAnalysisSpace中，可以检索EnergyAnalysisSurfaces的集合，这些曲面定义由墙的中心平面以及屋顶和楼板的顶平面限定边界的封闭体积。或者，GetClosedShell（）检索Polyloops（平面多边形）的集合，这些多边形定义由内部边界曲面测量的封闭体积。对于二维，请使用GetBoundary（），它返回表示空间的2D边界的多边形环集合，该空间定义了由内部边界曲面测量的封闭区域。 EnergyAnalysisSpace类还具有许多用于访问有关分析空间的信息的属性，例如AnalyticalVolume、SpaceName和Area。 #能量分析Surface 从EnergyAnalysisSpace中，可以检索与曲面关联的主分析空间以及次相邻分析空间。GetAnalyticalOpenings（）方法将检索曲面中所有分析洞口的集合。GetPolyloop（）方法获取描述gbXML中描述的曲面几何的平面多边形。 EnergyAnalysisSurface类具有许多属性，可提供有关分析曲面的更多信息，例如“高度”、“宽度”、“角点”（从外部查看的分析矩形几何图形的左下坐标）和原始图元描述。 曲面类型可以作为EnergyAnalysisSurfaceType或gbXMLSurfaceType提供。gbXML表面类型属性由源元素和空间邻接数确定。可能的类型有：</p>
<table>
<thead>
<tr>
<th><strong>Type 类型</strong></th>
<th><strong>Source element and space adjacencies 源元素和空间邻接</strong></th>
</tr>
</thead>
<tbody><tr>
<td><em>Shade</em></td>
<td>没有关联的源元素和空间邻接关系</td>
</tr>
<tr>
<td><em>Air</em></td>
<td>没有关联的源元素且至少有一个空间邻接</td>
</tr>
<tr>
<td><em>ExteriorWall</em></td>
<td>源图元是一面墙或一面幕墙，有一个空间相邻</td>
</tr>
<tr>
<td><em>InteriorWall</em></td>
<td>源图元是墙或幕墙，并且：存在两个空间邻接关系，或者类型函数参数设置为“Interior”或“CoreShaft”</td>
</tr>
<tr>
<td><em>UndergroundWall</em></td>
<td>源图元是墙或幕墙，并且存在一个空间邻接关系，如果该空间邻接关系低于坡率</td>
</tr>
<tr>
<td><em>SlabOnGrade</em></td>
<td>源元素是一个Floor，并且存在一个空间邻接</td>
</tr>
<tr>
<td><em>RaisedFloor</em></td>
<td>源元素是一个地板，有一个空间邻接，并且位于地面上方</td>
</tr>
<tr>
<td><em>UndergroundSlab</em></td>
<td>源元素是一个地板，有一个空间邻接，并且它位于地面以下</td>
</tr>
<tr>
<td><em>InteriorFloor</em></td>
<td>源图元为楼板，并且：存在两个空间邻接关系或类型函数参数设置为“Interior</td>
</tr>
<tr>
<td><em>Roof</em></td>
<td>源元素是屋顶或天花板，并且有一个空间相邻关系</td>
</tr>
<tr>
<td><em>UndergroundCeiling</em></td>
<td>源图元是屋顶或天花板，并且存在一个空间邻接关系，且该空间邻接关系位于地面以下</td>
</tr>
<tr>
<td><em>Ceiling</em></td>
<td>源图元是Roof或Ceiling，并且存在两个空间邻接关系</td>
</tr>
</tbody></table>
<p><strong>EnergyAnalysisOpening</strong> </p>
<p>从EnergyAnalysisOpening可以检索关联的父分析曲面元素。GetPolyloop（）方法将洞口几何图形作为平面多边形返回。</p>
<p>有许多特性可用于获取有关分析洞口的信息，例如“高度”、“宽度”、“角点”和“洞口名称”。与分析曲面类似，分析洞口类型可以作为简单的EnergyAnalysisOpeningType枚举或gbXMLOpeningType属性获得。洞口的类型取决于洞口的族类别及其包含的图元，如下表所示：</p>
<table>
<thead>
<tr>
<th><strong>Type 类型</strong></th>
<th><strong>Family Category or containing element 家庭类别或包含元素</strong></th>
</tr>
</thead>
<tbody><tr>
<td><em>OperableWindow</em></td>
<td>窗口</td>
</tr>
<tr>
<td><em>NonSlidingDoor</em></td>
<td>门</td>
</tr>
<tr>
<td><em>FixedSkylight</em></td>
<td>屋顶中包含的洞口</td>
</tr>
<tr>
<td><em>FixedWindow</em></td>
<td>幕墙嵌板中包含的洞口</td>
</tr>
<tr>
<td><em>Air</em></td>
<td>Opening of the category Openings</td>
</tr>
</tbody></table>
<h2 id="注：翻译自Revit-API-Developers-Guide"><a href="#注：翻译自Revit-API-Developers-Guide" class="headerlink" title="注：翻译自Revit API Developers Guide"></a><em><strong>注：</strong></em>翻译自<a href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_html">Revit API Developers Guide</a></h2>]]></content>
      <categories>
        <category>Revit二次开发人员指南</category>
      </categories>
      <tags>
        <tag>Revit</tag>
      </tags>
  </entry>
  <entry>
    <title>38地点和位置</title>
    <url>/2024/12/30/Revit%E4%BA%8C%E5%BC%80%E6%8C%87%E5%8D%97/38%E5%9C%B0%E7%82%B9%E5%92%8C%E4%BD%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="地点和位置"><a href="#地点和位置" class="headerlink" title="地点和位置"></a>地点和位置</h1><p>每个建筑物在世界上都有一个独特的位置，因为纬度和经度是独一无二的。此外，一个建筑物相对于其他建筑物可以有许多位置。Revit Platform API Site命名空间使用某些类来保存Revit项目的地理位置信息。</p>
<p>注意：Revit Platform API不显示“场地”菜单功能。只有“site”命名空间提供与“管理”选项卡上的“项目位置”面板上的“位置”选项对应的功能。</p>
<p>本节中的页面</p>
<ul>
<li>Place  地点</li>
<li>City  城市</li>
<li>ProjectLocation  项目地点</li>
<li>Project Position  项目位置</li>
</ul>
<h2 id="地点"><a href="#地点" class="headerlink" title="地点"></a>地点</h2><p>在Revit Platform API中，SiteLocation类包含纬度、经度和时区等位置信息。该信息确定项目在世界上的位置。设置纬度或经度时，请注意：</p>
<ol>
<li>Revit将尝试将坐标与它所知道的城市进行匹配，如果找到匹配，将相应地设置名称。</li>
<li>Revit将尝试自动调整时区值，以匹配使用SunAndShadowSettings.CalculateTimeZone（）设置的新经度或纬度值。对于某些边界情况，计算的时区可能不正确，如果需要，可以直接设置TimeZone属性。</li>
</ol>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-F3A532FC-E537-4CD5-A351-48AC48C21092-low.png" alt="img"></p>
<h2 id="城市"><a href="#城市" class="headerlink" title="城市"></a>城市</h2><p>城市是包含世界上已知城市的地理位置信息的对象。它包含经度、纬度和时区信息。城市列表由Application对象中的Cities属性检索。无法将新城市添加到Revit中的现有列表中。Revit Platform API不会显示当前项目所在的城市。</p>
<h2 id="项目地点"><a href="#项目地点" class="headerlink" title="项目地点"></a>项目地点</h2><p>一个项目只有一个场地，那就是在地球上的绝对位置。但是，它可以相对于周围的项目具有不同的位置。根据所使用的坐标和原点，一个项目中可以有多个ProjectLocation对象。</p>
<p>默认情况下，每个Revit项目至少包含一个命名位置Internal。它是活动项目位置。可以使用Document.ActiveProjectLocation属性检索它。使用Document.ProjectLocations属性检索所有现有的ProjectLocation对象。</p>
<h2 id="项目位置"><a href="#项目位置" class="headerlink" title="项目位置"></a>项目位置</h2><p>项目位置是表示地理偏移和旋转的对象。它通常由ProjectLocation对象用来获取和设置地理信息。下图显示了更改ProjectLocation地理旋转和同一点的坐标后的结果。但是，您无法看到直接更改ProjectLocation地理偏移的结果。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-7242FF42-B873-48EC-8D6C-208675848D2D-low.png" alt="img"></p>
<p>图125：点坐标</p>
<p>注意：东表示位置逆时针旋转;西表示位置顺时针旋转。如果“角度”值介于180度和360度之间，则Revit会自动对其进行变换。例如，如果选择“东”并键入200度作为“角度”，则Revit会将其转换为“西160度”。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-C784E377-BFF8-4CCE-B5A8-77310071FCD3-low.png" alt="img"> </p>
<p>图126：地理偏移和旋转示意图</p>
<p>下面的示例代码说明如何检索ProjectLocation对象。</p>
<p>代码区域21-1：检索ProjectLocation对象</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ShowActiveProjectLocationUsage</span>(<span class="params">Autodesk.Revit.DB.Document document</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Get the project location handle </span></span><br><span class="line">    ProjectLocation projectLocation = document.ActiveProjectLocation;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Show the information of current project location</span></span><br><span class="line">    XYZ origin = <span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    ProjectPosition position = projectLocation.GetProjectPosition(origin);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> == position)</span><br><span class="line">    &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;No project position in origin point.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Format the prompt string to show the message.</span></span><br><span class="line">    String prompt = <span class="string">&quot;Current project location information:\n&quot;</span>;</span><br><span class="line">    prompt += <span class="string">&quot;\n\t&quot;</span> + <span class="string">&quot;Origin point position:&quot;</span>;</span><br><span class="line">    prompt += <span class="string">&quot;\n\t\t&quot;</span> + <span class="string">&quot;Angle: &quot;</span> + position.Angle;</span><br><span class="line">    prompt += <span class="string">&quot;\n\t\t&quot;</span> + <span class="string">&quot;East to West offset: &quot;</span> + position.EastWest;</span><br><span class="line">    prompt += <span class="string">&quot;\n\t\t&quot;</span> + <span class="string">&quot;Elevation: &quot;</span> + position.Elevation;</span><br><span class="line">    prompt += <span class="string">&quot;\n\t\t&quot;</span> + <span class="string">&quot;North to South offset: &quot;</span> + position.NorthSouth;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Angles are in radians when coming from Revit API, so we </span></span><br><span class="line">    <span class="comment">// convert to degrees for display</span></span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">double</span> angleRatio = Math.PI / <span class="number">180</span>;        <span class="comment">// angle conversion factor</span></span><br><span class="line"></span><br><span class="line">    SiteLocation site = projectLocation.GetSiteLocation();</span><br><span class="line">    <span class="built_in">string</span> degreeSymbol = ((<span class="built_in">char</span>)<span class="number">176</span>).ToString();</span><br><span class="line">    prompt += <span class="string">&quot;\n\t&quot;</span> + <span class="string">&quot;Site location:&quot;</span>;</span><br><span class="line">    prompt += <span class="string">&quot;\n\t\t&quot;</span> + <span class="string">&quot;Latitude: &quot;</span> + site.Latitude / angleRatio + degreeSymbol;</span><br><span class="line">    prompt += <span class="string">&quot;\n\t\t&quot;</span> + <span class="string">&quot;Longitude: &quot;</span> + site.Longitude / angleRatio + degreeSymbol;</span><br><span class="line">    prompt += <span class="string">&quot;\n\t\t&quot;</span> + <span class="string">&quot;TimeZone: &quot;</span> + site.TimeZone;</span><br><span class="line"></span><br><span class="line">    TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>, prompt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：一次只有一个活动项目位置。若要查看更改ProjectLocation地理偏移和旋转后的结果，请在平面视图“特性”窗格中将“方向”特性从“项目北”更改为“正北”</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-57E4EC63-4A77-4C7C-91B3-770F3ADDBE6D-low.png"></p>
<p>图128：项目从项目北向正北旋转30度</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-57C77B88-C8F7-4207-9A4F-3728182159F3-low.png"></p>
<p>图129：项目位置信息</p>
<p><strong>创建和删除项目位置</strong></p>
<p>通过使用Duplicate（）方法复制现有项目位置来创建新项目位置。下面的代码示例说明如何使用Duplicate（）方法创建新的项目位置。</p>
<p>代码区域21-2：创建项目位置</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ProjectLocation <span class="title">DuplicateLocation</span>(<span class="params">Autodesk.Revit.DB.Document document, <span class="built_in">string</span> newName</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        ProjectLocation currentLocation = document.ActiveProjectLocation;</span><br><span class="line">        ProjectLocationSet locations = document.ProjectLocations;</span><br><span class="line">        <span class="keyword">foreach</span> (ProjectLocation projectLocation <span class="keyword">in</span> locations)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">if</span> (projectLocation.Name == newName)</span><br><span class="line">                &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;The name is same as a project location&#x27;s name, please change one.&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> currentLocation.Duplicate(newName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面的代码示例阐释如何从当前项目中删除现有项目位置。</p>
<p>代码区域21-3：删除项目位置</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DeleteLocation</span>(<span class="params">Autodesk.Revit.DB.Document document</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ProjectLocation currentLocation = document.ActiveProjectLocation;</span><br><span class="line">    <span class="comment">//There must be at least one project location in the project.</span></span><br><span class="line">    ProjectLocationSet locations = document.ProjectLocations;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1</span> == locations.Size)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> name = <span class="string">&quot;location&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (name != currentLocation.Name)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">foreach</span> (ProjectLocation projectLocation <span class="keyword">in</span> locations)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (projectLocation.Name == name)</span><br><span class="line">            &#123;</span><br><span class="line">                ICollection&lt;Autodesk.Revit.DB.ElementId&gt; elemSet = document.Delete(projectLocation.Id);</span><br><span class="line">                <span class="keyword">if</span> (elemSet.Count &gt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>,<span class="string">&quot;Project Location Deleted!&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注：以下规则适用于删除项目位置：</p>
<ul>
<li>无法删除活动项目位置，因为项目中必须至少有一个项目位置。</li>
<li>如果ProjectLocationSet类实例为只读，则不能删除项目位置。</li>
</ul>
<h2 id="注：翻译自Revit-API-Developers-Guide"><a href="#注：翻译自Revit-API-Developers-Guide" class="headerlink" title="注：翻译自Revit API Developers Guide"></a><em><strong>注：</strong></em>翻译自<a href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_html">Revit API Developers Guide</a></h2>]]></content>
      <categories>
        <category>Revit二次开发人员指南</category>
      </categories>
      <tags>
        <tag>Revit</tag>
      </tags>
  </entry>
  <entry>
    <title>40施工建模</title>
    <url>/2024/12/30/Revit%E4%BA%8C%E5%BC%80%E6%8C%87%E5%8D%97/40%E6%96%BD%E5%B7%A5%E5%BB%BA%E6%A8%A1/</url>
    <content><![CDATA[<h1 id="施工建模"><a href="#施工建模" class="headerlink" title="施工建模"></a>施工建模</h1><p>Revit API允许将图元划分为子零件或收集到程序集中，以支持构造建模工作流，这与使用Revit用户界面的方法大致相同。零件和程序集都可以独立地进行明细表、标记、过滤和导出。您也可以将零件分割成更小的零件。创建程序集类型后，可以在项目中放置其他实例并生成独立的程序集视图。</p>
<p>与构造建模相关的主要类有：</p>
<ul>
<li>AssemblyInstance -这个类结合了多个元素，用于标记、过滤、调度和创建隔离的装配视图。</li>
<li>AssemblyType - 表示构造程序集元素的类型。在项目中创建的每个新的唯一程序集都会自动创建一个相应的AssemblyType。可以从现有AssemblyType将新AssemblyInstance放置到文档中。</li>
<li>PartUtils - 这个实用程序类包含通用的程序集实用程序方法，包括创建程序集、划分程序集和获取程序集信息的能力。</li>
<li>AssemblyViewUtils - 用于创建各种类型的装配视图的实用程序类。</li>
</ul>
<p> 本节中的页面</p>
<ul>
<li>程序集和视图</li>
<li>部分</li>
</ul>
<h2 id="程序集和视图"><a href="#程序集和视图" class="headerlink" title="程序集和视图"></a>程序集和视图</h2><p>可以组合任意数量的模型图元以创建程序集，然后可以编辑、标记、创建明细表和过滤程序集。</p>
<p><strong>创建程序集</strong></p>
<p>AssemblyInstance类的静态Create（）方法用于在项目中创建新的程序集实例。Create（）方法必须在事务内部创建，并且必须在对新创建的程序集实例执行任何操作之前提交事务。在事务处理完成后分配装配件类型。每个唯一程序集都有自己的AssemblyType。</p>
<p>下面的示例创建一个新的程序集实例，更改其AssemblyType的名称，然后为该程序集实例创建一些视图。</p>
<p>代码区域：创建程序集和视图</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function">AssemblyInstance <span class="title">CreateAssemblyAndViews</span>(<span class="params">Autodesk.Revit.DB.Document doc, ICollection elementIds</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    AssemblyInstance assemblyInstance = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">using</span> (Transaction transaction = <span class="keyword">new</span> Transaction(doc))</span><br><span class="line">    &#123;</span><br><span class="line">        ElementId categoryId = doc.GetElement(elementIds.First()).Category.Id; <span class="comment">// use category of one of the assembly elements</span></span><br><span class="line">        <span class="keyword">if</span> (AssemblyInstance.IsValidNamingCategory(doc, categoryId, elementIds))</span><br><span class="line">        &#123;</span><br><span class="line">            transaction.Start(<span class="string">&quot;Create Assembly Instance&quot;</span>);</span><br><span class="line">            assemblyInstance = AssemblyInstance.Create(doc, elementIds, categoryId);</span><br><span class="line">            transaction.Commit(); <span class="comment">// commit the transaction that creates the assembly instance before modifying the instance&#x27;s name</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (transaction.GetStatus() == TransactionStatus.Committed)</span><br><span class="line">            &#123;</span><br><span class="line">                transaction.Start(<span class="string">&quot;Set Assembly Name&quot;</span>);</span><br><span class="line">                assemblyInstance.AssemblyTypeName = <span class="string">&quot;My Assembly Name&quot;</span>;</span><br><span class="line">                transaction.Commit();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (assemblyInstance.AllowsAssemblyViewCreation()) <span class="comment">// create assembly views for this assembly instance</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (transaction.GetStatus() == TransactionStatus.Committed)</span><br><span class="line">                &#123;</span><br><span class="line">                    transaction.Start(<span class="string">&quot;View Creation&quot;</span>);</span><br><span class="line">                    View3D view3d = AssemblyViewUtils.Create3DOrthographic(doc, assemblyInstance.Id);</span><br><span class="line">                    ViewSchedule partList = AssemblyViewUtils.CreatePartList(doc, assemblyInstance.Id);</span><br><span class="line">                    transaction.Commit();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> assemblyInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建AssemblyInstance的另一种方法是使用现有AssemblyType。若要使用AssemblyType创建AssemblyInstance，请使用静态方法AssemblyInstance.PlaceInstance（），并指定要使用的AssemblyType的ElementId和放置程序集的位置。</p>
<p><strong>程序集视图</strong></p>
<p>可以使用AssemblyViewUtils类的静态方法为程序集实例创建各种程序集视图，包括正交三维程序集视图、详图截面程序集视图、材质提取多类别明细表程序集视图、明细表多类别明细表程序集视图、单类别明细表和图纸程序集视图。除图纸视图外，所有这些视图都具有重载的创建方法，这些方法从样板创建明细表或视图。除了模板ID之外，这些重载还有一个参数来指示是否将分配或应用模板。</p>
<p>请注意，程序集视图必须全部指定给程序集类型的同一程序集实例。如果程序集实例可以接受新的程序集视图（因为它已经有视图，或者因为没有程序集实例有视图），则AssemblyInstance.AllowsAssemblyViewCreation（）返回true。</p>
<p>下面的示例从给定模板为装配创建新的单一类别明细表。</p>
<p>代码区域：从模板创建程序集视图</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ViewSchedule <span class="title">CreateScheduleForAssembly</span>(<span class="params">Document doc, AssemblyInstance assemblyInstance, ElementId viewTemplateId</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ViewSchedule schedule = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (assemblyInstance.AllowsAssemblyViewCreation()) <span class="comment">// create assembly views for this assembly instance</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">using</span> (Transaction transaction = <span class="keyword">new</span> Transaction(doc))</span><br><span class="line">        &#123;</span><br><span class="line">            transaction.Start(<span class="string">&quot;Create Schedule&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// use naming category for the schedule</span></span><br><span class="line">            <span class="keyword">if</span> (ViewSchedule.IsValidCategoryForSchedule(assemblyInstance.NamingCategoryId))</span><br><span class="line">            &#123;</span><br><span class="line">                schedule = AssemblyViewUtils.CreateSingleCategorySchedule(doc, assemblyInstance.Id, assemblyInstance.NamingCategoryId, viewTemplateId, <span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            transaction.Commit();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (schedule != <span class="literal">null</span> &amp;&amp; transaction.GetStatus() == TransactionStatus.Committed)</span><br><span class="line">            &#123;</span><br><span class="line">                transaction.Start(<span class="string">&quot;Edit Schedule&quot;</span>);</span><br><span class="line">                schedule.ViewName = <span class="string">&quot;AssemblyViewSchedule&quot;</span>;</span><br><span class="line">                transaction.Commit();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> schedule;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在使用任何这些新创建的程序集视图之前，必须重新生成文档。在上面的示例中，您会注意到事务是在创建新的组装视图之后提交的。Commit（）方法自动重新生成文档。</p>
<h2 id="部分"><a href="#部分" class="headerlink" title="部分"></a>部分</h2><p>可以从具有分层结构的元素生成零件，例如：</p>
<ul>
<li>墙（不包括叠层墙和幕墙）</li>
<li>楼层（不包括形状编辑的楼层）</li>
<li>屋顶（不包括有屋脊的屋顶）</li>
<li>Ceilings 天花板</li>
<li>结构板基础</li>
</ul>
<p>在Revit API中，可以使用PartUtils类将图元划分为多个部分。静态方法PartUtils.ObjectParts（）用于从一个或多个元素创建程序集。请注意，与API中的大多数元素创建方法不同的是，RectorParts（）实际上并不创建或返回程序集，而是实例化一个名为PartMaker的元素。在再生过程中，PartMaker使用其嵌入的规则来驱动所需零件的创建。</p>
<p>API还提供了一个细分程序集的接口。PartUtils. DivideParts（）接受一个程序集ID集合、一个”相交元素” ID集合（可以是层和网格）和一个曲线集合作为输入。该例程使用相交的元素和曲线作为边界，从中分割并生成新零件。</p>
<p>The GetAssociatedParts() method can be called to find some or all of the parts associated with an element, or use HasAssociatedParts() to determine if an element has parts.<br>可以调用GetAssociatedParts（）方法来查找与元素关联的部分或全部部分，或者使用HasAssociatedParts（）来确定元素是否有部分。</p>
<p>您可以通过API删除零件，方法是删除单个零件元素，或删除与零件关联的PartMaker（这将在下次再生后删除此PartMaker生成的所有零件）。</p>
<p>可以在Revit API中操作零件，操作方式与在Revit用户界面中操作零件的方式大致相同。例如，可以使用PartUtils. SetFaceOffset（）偏移零件的外部边界。</p>
<p>下面的示例将偏移零件的所有可以偏移的面。</p>
<p>代码区域：零件的偏移面</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Part part = doc.GetElement(uidoc.Selection.PickObject(ObjectType.Element)) <span class="keyword">as</span> Part;</span><br><span class="line">Autodesk.Revit.DB.GeometryElement geomElem = part.get_Geometry(newOptions());</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span>(GeometryObject geomObject <span class="keyword">in</span> geomElem)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (geomObjectisSolid)</span><br><span class="line">    &#123;</span><br><span class="line">        Solidsolid = geomObject <span class="keyword">as</span> Solid;</span><br><span class="line">        FaceArray faceArray = solid.Faces;</span><br><span class="line">        <span class="keyword">foreach</span> (FacefaceinfaceArray)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (part.CanOffsetFace(face))</span><br><span class="line">            &#123;</span><br><span class="line">                part.SetFaceOffset(face, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/OffsetParts.jpg"></p>
<p>偏移选定零件的面之前和之后</p>
<h2 id="注：翻译自Revit-API-Developers-Guide"><a href="#注：翻译自Revit-API-Developers-Guide" class="headerlink" title="注：翻译自Revit API Developers Guide"></a><em><strong>注：</strong></em>翻译自<a href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_html">Revit API Developers Guide</a></h2>]]></content>
      <categories>
        <category>Revit二次开发人员指南</category>
      </categories>
      <tags>
        <tag>Revit</tag>
      </tags>
  </entry>
  <entry>
    <title>41链接文件</title>
    <url>/2024/12/30/Revit%E4%BA%8C%E5%BC%80%E6%8C%87%E5%8D%97/41%E9%93%BE%E6%8E%A5%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="链接文件"><a href="#链接文件" class="headerlink" title="链接文件"></a>链接文件</h1><p>Revit API可以确定Revit中的哪些图元是对外部文件（“链接文件”）的引用，并可以对Revit加载外部文件的方式进行一些修改。</p>
<p>包含ExternalFileReference的元素是引用基.rvt文件之外的某个文件的元素。示例包括Revit链接、CAD链接、存储注释记号文件位置的图元和渲染贴花。IsExternalFileReference（）返回元素是否表示外部文件。GetExternalFileReference（）返回给定Element的ExternalFileReference，其中包含与该元素引用的外部文件有关的信息。</p>
<p>以下类与Revit API中的链接文件关联：</p>
<ul>
<li>ExternalFileReference - 非Element类，包含Revit项目引用的单个外部文件的路径和类型信息。</li>
<li>ExternalFileUtils -一个实用程序类，允许用户查找所有外部文件引用，从元素中获取外部文件引用，或者告诉元素是否是外部文件引用。</li>
<li>RevitLinkType -表示链接到Revit项目的Revit文件的图元。</li>
<li>ModelPath - 包含文件（不一定是.rvt文件）路径信息的非元素类。路径可以指向本地或网络驱动器上的某个位置，也可以指向Revit Server位置。</li>
<li>ModelPathUtils -一个实用程序类，它提供了在字符串和ModelPaths之间进行转换的方法。</li>
<li>TransmissionData -一个类，用于存储文档中所有外部文件引用的信息。无需打开文档即可读取Revit项目的TransmissionData。</li>
</ul>
<p><strong>模型路径</strong></p>
<p>ModelPaths是指向另一个文件的路径。它们可以引用Revit模型，也可以引用Revit的任何外部文件引用（如DWG链接）。路径可以是相对路径，也可以是绝对路径，但它们必须包含指示文件类型的扩展名。相对路径通常相对于当前打开的文档。如果当前文档是工作共享的，则路径将被视为相对于中心模型。若要创建ModelPath，请使用派生类FilePath或ServerPath之一。</p>
<p>ModelPathUtils类包含用于将ModelPaths与用户可见的路径字符串相互转换的实用函数，以及用于确定字符串是否为有效的服务器路径的实用函数。</p>
<p>共享坐标使其他链接模型能够知道一个链接文件的位置。</p>
<ul>
<li><p>从指定的链接实例获取项目坐标。这适用于Revit链接（RevitLinkInstance）和DWG链接（ImportInstance）。</p>
</li>
<li><p>将共享坐标发布到指定的ProjectLocation。此方法仅适用于Revit链接。这些只读属性提供有关SiteLocation的地理坐标系的信息。地理坐标系是从AutoCAD或Civil 3D的DWG文件导入的。如果SiteLocation具有地理坐标系信息，则当模型的测量点移动时，SiteLocation的纬度和经度将自动更新。</p>
</li>
<li><p>SiteLocation. GeoCoordinateSystemId-获取与地理坐标系ID对应的字符串，例如SiteLocation的”AMG-50”或”Beijing1954&#x2F;a.GK3d-40”。如果没有为SiteLocation指定坐标系，则该值将为空字符串。</p>
</li>
<li><p>GeoCoordinateSystemDefinition -获取描述地理坐标系的XML字符串。如果没有为SiteLocation指定坐标系，则该值将为空字符串。</p>
</li>
</ul>
<p>本节中的页面</p>
<ul>
<li>Revit 链接</li>
<li>管理外部文件</li>
</ul>
<h2 id="Revit-链接"><a href="#Revit-链接" class="headerlink" title="Revit 链接"></a>Revit 链接</h2><p>Revit文档可以包含指向各种外部文件（包括其他Revit文档）的链接。Revit API中的这些链接类型由RevitLinkType和RevitLinkInstance类表示。RevitLinkType类表示引入到当前文档（“主体”）中的另一个Revit文档（“链接”），而RevitLinkInstance类表示RevitLinkType的实例。</p>
<p><strong>创建新链接</strong></p>
<p>要创建新的Revit链接，请使用静态RevitLinkType.Create（）方法（该方法将创建新的Revit链接类型并加载链接文档）和静态RevitLinkInstance.Create（）方法（将链接的实例放置在模型中）。RevitLinkType.Create（）方法需要一个文档（将作为宿主）、要链接的文件的ModelPath和RevitLinkOptions对象。RevitLinkOptions类表示用于创建和加载Revit链接的选项。选项包括Revit是否存储链接文件和工作集配置的相对路径或绝对路径。WorksetConfiguration类用于指定创建链接时将打开哪些工作集（如果有）。请注意，相对路径或绝对路径决定了Revit存储路径的方式，但传递到Create（）方法中的ModelPath需要完整的路径才能最初查找链接的文档。</p>
<p>下面的示例演示RevitLinkType.Create（）的用法。变量pathName是磁盘上要链接的文件的完整路径。</p>
<p>代码区域：创建新的Revit链接</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ElementId <span class="title">CreateRevitLink</span>(<span class="params">Document doc, <span class="built_in">string</span> pathName</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    FilePath path = <span class="keyword">new</span> FilePath(pathName);</span><br><span class="line">    RevitLinkOptions options = <span class="keyword">new</span> RevitLinkOptions(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">// Create new revit link storing absolute path to file</span></span><br><span class="line">    LinkLoadResult result = RevitLinkType.Create(doc, path, options);</span><br><span class="line">    <span class="keyword">return</span> (result.ElementId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建RevitLinkType后，可以将实例添加到文档中。在下面的示例中，添加了两个RevitLinkType实例，偏移量为100 ‘。在创建RevitLinkInstance之前，Revit链接将显示在“管理链接”窗口中，但链接文件的图元在任何视图中都不可见。</p>
<p>代码区域：创建新的Revit Link实例</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">CreateLinkInstances</span>(<span class="params">Document doc, ElementId linkTypeId</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Create revit link instance at origin</span></span><br><span class="line">    RevitLinkInstance.Create(doc, linkTypeId);</span><br><span class="line">    RevitLinkInstance instance2 = RevitLinkInstance.Create(doc, linkTypeId);</span><br><span class="line">    <span class="comment">// Offset second instance by 100 feet</span></span><br><span class="line">    Location location = instance2.Location;</span><br><span class="line">    location.Move(<span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">-100</span>, <span class="number">0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的例子使用本地磁盘上的文件。下面是一个更复杂的示例，涉及到Revit服务器上模型的链接。</p>
<p>代码区域：创建指向Revit服务器上模型的新Revit链接</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CreateLinkToServerModel</span>(<span class="params">UIApplication uiApp</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    UIDocument uiDoc = uiApp.ActiveUIDocument;</span><br><span class="line">    Document doc = uiDoc.Document;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Try to get the server path for the particular model on the server</span></span><br><span class="line">    Application application = uiApp.Application;</span><br><span class="line">    String hostId = application.GetRevitServerNetworkHosts().First();</span><br><span class="line">    String rootFolder = <span class="string">&quot;|&quot;</span>;</span><br><span class="line">    ModelPath serverPath = FindWSAPIModelPathOnServer(application, hostId, rootFolder, <span class="string">&quot;Wall pin model for updaters.rvt&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> (Transaction t = <span class="keyword">new</span> Transaction(doc, <span class="string">&quot;Create link&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        t.Start();</span><br><span class="line">        RevitLinkOptions options = <span class="keyword">new</span> RevitLinkOptions(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        LinkLoadResult result = RevitLinkType.Create(doc, serverPath, options);</span><br><span class="line"></span><br><span class="line">        RevitLinkInstance.Create(doc, result.ElementId);</span><br><span class="line">        t.Commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ModelPath <span class="title">FindWSAPIModelPathOnServer</span>(<span class="params">Application app, <span class="built_in">string</span> hostId, <span class="built_in">string</span> folderName, <span class="built_in">string</span> fileName</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Connect to host to find list of available models (the &quot;/contents&quot; flag)</span></span><br><span class="line">    XmlDictionaryReader reader = GetResponse(app, hostId, folderName + <span class="string">&quot;/contents&quot;</span>);</span><br><span class="line">    <span class="built_in">bool</span> found = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Look for the target model name in top level folder</span></span><br><span class="line">    List folders = <span class="keyword">new</span> List();</span><br><span class="line">    <span class="keyword">while</span> (reader.Read())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Save a list of subfolders, if found</span></span><br><span class="line">        <span class="keyword">if</span> (reader.NodeType == XmlNodeType.Element &amp;&amp; reader.Name == <span class="string">&quot;Folders&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (reader.Read())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (reader.NodeType == XmlNodeType.EndElement &amp;&amp; reader.Name == <span class="string">&quot;Folders&quot;</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (reader.NodeType == XmlNodeType.Element &amp;&amp; reader.Name == <span class="string">&quot;Name&quot;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    reader.Read();</span><br><span class="line">                    folders.Add(reader.Value);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Check for a matching model at this folder level</span></span><br><span class="line">        <span class="keyword">if</span> (reader.NodeType == XmlNodeType.Element &amp;&amp; reader.Name == <span class="string">&quot;Models&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            found = FindModelInServerResponseJson(reader, fileName);</span><br><span class="line">            <span class="keyword">if</span> (found)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    reader.Close();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Build the model path to match the found model on the server</span></span><br><span class="line">    <span class="keyword">if</span> (found)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Server URLs use &quot;|&quot; for folder separation, Revit API uses &quot;/&quot;</span></span><br><span class="line">        String folderNameFragment = folderName.Replace(<span class="string">&#x27;|&#x27;</span>, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Add trailing &quot;/&quot; if not present</span></span><br><span class="line">        <span class="keyword">if</span> (!folderNameFragment.EndsWith(<span class="string">&quot;/&quot;</span>))</span><br><span class="line">            folderNameFragment += <span class="string">&quot;/&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Build server path</span></span><br><span class="line">        ModelPath modelPath = <span class="keyword">new</span> ServerPath(hostId, folderNameFragment + fileName);</span><br><span class="line">        <span class="keyword">return</span> modelPath;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Try subfolders</span></span><br><span class="line">        <span class="keyword">foreach</span> (String folder <span class="keyword">in</span> folders)</span><br><span class="line">        &#123;</span><br><span class="line">            ModelPath modelPath = FindWSAPIModelPathOnServer(app, hostId, folder, fileName);</span><br><span class="line">            <span class="keyword">if</span> (modelPath != <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">return</span> modelPath;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This string is different for each RevitServer version</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">string</span> s_revitServerVersion = <span class="string">&quot;/RevitServerAdminRESTService2014/AdminRESTService.svc/&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> XmlDictionaryReader <span class="title">GetResponse</span>(<span class="params">Application app, <span class="built_in">string</span> hostId, <span class="built_in">string</span> info</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Create request    WebRequest request = WebRequest.Create(&quot;http://&quot; + hostId + s_revitServerVersion + info);</span></span><br><span class="line">    request.Method = <span class="string">&quot;GET&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add the information the request needs</span></span><br><span class="line"></span><br><span class="line">    request.Headers.Add(<span class="string">&quot;User-Name&quot;</span>, app.Username);</span><br><span class="line">    request.Headers.Add(<span class="string">&quot;User-Machine-Name&quot;</span>, app.Username);</span><br><span class="line">    request.Headers.Add(<span class="string">&quot;Operation-GUID&quot;</span>, Guid.NewGuid().ToString());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read the response</span></span><br><span class="line">    XmlDictionaryReaderQuotas quotas =</span><br><span class="line">        <span class="keyword">new</span> XmlDictionaryReaderQuotas();</span><br><span class="line">    XmlDictionaryReader jsonReader =</span><br><span class="line">        JsonReaderWriterFactory.CreateJsonReader(request.GetResponse().GetResponseStream(), quotas);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> jsonReader;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">bool</span> <span class="title">FindModelInServerResponseJson</span>(<span class="params">XmlDictionaryReader reader, <span class="built_in">string</span> fileName</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Read through entries in this section</span></span><br><span class="line">    <span class="keyword">while</span> (reader.Read())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (reader.NodeType == XmlNodeType.EndElement &amp;&amp; reader.Name == <span class="string">&quot;Models&quot;</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (reader.NodeType == XmlNodeType.Element &amp;&amp; reader.Name == <span class="string">&quot;Name&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            reader.Read();</span><br><span class="line">            String modelName = reader.Value;</span><br><span class="line">            <span class="keyword">if</span> (modelName.Equals(fileName))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// Match found, stop looping and return</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在下面的示例中，将获取WorksetConfiguration并对其进行修改，以便在创建新链接之前仅打开一个指定的工作集并将其设置回RevitLinkOptions。</p>
<p>代码区域：创建打开一个工作集的链接</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">CreateRevitLinkWithOneWorksetOpen</span>(<span class="params">Document doc, <span class="built_in">string</span> pathName, <span class="built_in">string</span> worksetName</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    FilePath path = <span class="keyword">new</span> FilePath(pathName);</span><br><span class="line">    RevitLinkOptions options = <span class="keyword">new</span> RevitLinkOptions(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get info on all the user worksets in the project prior to opening</span></span><br><span class="line">    IList worksets = WorksharingUtils.GetUserWorksetInfo(path);</span><br><span class="line">    IList worksetIds = <span class="keyword">new</span> List();</span><br><span class="line">    <span class="comment">// Find worksetName</span></span><br><span class="line">    <span class="keyword">foreach</span> (WorksetPreview worksetPrev <span class="keyword">in</span> worksets)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (worksetPrev.Name.CompareTo(worksetName) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            worksetIds.Add(worksetPrev.Id);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// close all worksets but the one specified</span></span><br><span class="line">    WorksetConfiguration worksetConfig = <span class="keyword">new</span> WorksetConfiguration(WorksetConfigurationOption.CloseAllWorksets);</span><br><span class="line">    <span class="keyword">if</span> (worksetIds.Count &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        worksetConfig.Open(worksetIds);</span><br><span class="line">    &#125;</span><br><span class="line">    options.SetWorksetConfiguration(worksetConfig);</span><br><span class="line"></span><br><span class="line">    LinkLoadResult result = RevitLinkType.Create(doc, path, options);</span><br><span class="line">    RevitLinkType type = doc.GetElement(result.ElementId) <span class="keyword">as</span> RevitLinkType;</span><br><span class="line">    <span class="keyword">return</span> (result.LoadResult == LinkLoadResultType.LinkLoaded);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>无论是创建还是加载链接，都将返回LinkLoadResult。此类有一个属性来确定链接是否已加载。它还有一个ElementId属性，该属性是创建或加载的链接模型的ID。 RevitLinkInstance.Create（ImportPlacement放置）创建链接的Revit项目的新实例（RevitLinkType）。根据输入放置类型，将按原点到原点或按共享坐标放置图形。 #加载和卸载链接 RevitLinkType有几种与加载链接相关的方法。Load（）、LoadFrom（）和Unload（）允许加载或卸载链接，或者从新位置加载链接。这些方法重新生成文档。文档的撤消历史记录将通过这些方法清除。所有显式启动的事务阶段（例如事务、事务组和子事务）必须在调用这些方法之前完成。 静态方法RevitLinkType.IsLoaded（）将返回链接是否已加载。 #获取链接信息 文档中的每个RevitLinkType都可以有一个或多个关联的RevitLinkType。RevitLinkInstance.GetLinkDocument（）方法返回与Revit链接关联的Document。不能修改此单据，这意味着不能执行需要交易或修改单据在内存中状态的操作（如保存和关闭）。 可以使用从RevitLinkInstance.GetTypeId（）方法获得的ElementId从文档中检索RevitLinkInstance的关联RevitLinkType。链接文件的RevitLinkType有几个与嵌套链接相关的方法和属性。链接到另一个文档的文档本身可能具有链接。如果RevitLinkType是嵌套链接（即，它有其他链接作为父链接），IsNested属性返回true;如果它是顶级链接，IsNested属性返回false。方法GetParentId（）将获取此链接的直接父级的ID，而GetRootId（）将返回此链接最终链接的顶级链接的ID。如果此链接是顶级链接，则这两个方法都将返回invalidElementId。方法GetChildIds（）将返回所有直接链接到此链接的链接的元素ID。 例如，如果C链接到文档B，而B又链接到文档A，则为C链接调用GetParentId（）将返回文档B的ID，为C链接调用GetRootId（）将返回文档A的ID。为文档A调用GetChildIds（）将只返回B的链接的id，因为C不是A下的直接链接。 RevitLinkType还有一个PathType属性，该属性指示外部文件参照的路径是相对于主体文件的位置（或相对于中心模型的位置（如果主体是工作共享的）），还是相对于磁盘或网络上某个位置的绝对路径，或者路径是相对于Revit Server位置。 RevitLinkType的AttachmentType属性指示链接是附件还是覆盖。“附件”链接被认为是其父链接的一部分，如果其父链接到另一个文档中，“附件”链接将被沿着。“覆盖”链接只有在直接打开父链接时才可见。 下面的示例获取文档中的所有RevitLinkList并显示有关它们的一些信息。</p>
<p>代码区域：获取链接信息</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetAllRevitLinkInstances</span>(<span class="params">Document doc</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(doc);</span><br><span class="line">    collector.OfClass(<span class="keyword">typeof</span>(RevitLinkInstance));</span><br><span class="line">    StringBuilder linkedDocs = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">foreach</span> (Element elem <span class="keyword">in</span> collector)</span><br><span class="line">    &#123;</span><br><span class="line">        RevitLinkInstance instance = elem <span class="keyword">as</span> RevitLinkInstance;</span><br><span class="line">        Document linkDoc = instance.GetLinkDocument();</span><br><span class="line">        linkedDocs.AppendLine(<span class="string">&quot;FileName: &quot;</span> + Path.GetFileName(linkDoc.PathName));</span><br><span class="line">        RevitLinkType type = doc.GetElement(instance.GetTypeId()) <span class="keyword">as</span> RevitLinkType;</span><br><span class="line">        linkedDocs.AppendLine(<span class="string">&quot;Is Nested: &quot;</span> + type.IsNestedLink.ToString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TaskDialog.Show(<span class="string">&quot;Revit Links in Document&quot;</span>, linkedDocs.ToString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>链接几何图形</strong></p>
<p><strong>共享坐标</strong></p>
<p>RevitLinkType方法SavePositions（）和HasSaveablePositions（）支持将共享坐标更改保存回链接文档。使用HasSaveablePositions（）确定链接是否具有可以保存的共享定位更改。调用SavePositions（）将共享坐标更改保存回链接文档。SavePositions（）需要ISaveSharedCoordinatesCallback接口的实例，以解决Revit遇到已修改链接时的情况。接口的GetSaveModifiedLinksOption（）方法确定Revit是应保存链接、不保存链接还是完全放弃共享定位。</p>
<p>虽然SavePositions（）不清除文档的撤消历史记录，但它不能撤消，因为它将链接的共享坐标更改保存到磁盘。</p>
<p><strong>几何参照的转换</strong></p>
<p>Reference类具有与链接文件相关的成员，这些成员允许在仅引用链接内容的Reference对象和引用宿主的Reference对象之间进行转换。例如，这允许应用程序查看链接中的几何图形，查找所需的面，并将该面的参照转换为主体中适合用于放置基于面的实例的参照。此外，这些Reference成员还可以在主体中获取引用（例如，从尺寸或族中），并将其转换为链接中的引用，以便在Element.GetGeometryObjectFromReference（）中使用。</p>
<p>Reference.LinkedElementId属性表示此引用所引用的链接文档中顶级元素的ID，或InvalidElementId表示未引用链接RVT文件中元素的引用。Reference.RightLinkReference（）方法使用RevitLinkInstance从Revit链接中的参照创建Reference和Reference.ReferenceInLink（）方法可从宿主文件中的引用创建Revit链接中的引用</p>
<p><strong>拾取链接中的元素</strong></p>
<p>选择方法PickObject（）和PickObjects（）允许选择Revit链接中的对象。若要允许用户选择链接文件中的元素，请对PickObject（）或PickObjects（）的第一个参数使用ObjectType.LinkedElement枚举值。请注意，此选项仅允许选择链接中的元素，而不允许选择宿主文档中的元素。</p>
<p>在下面的示例中，ISelectionFilter用于仅允许在链接文件中选择墙。</p>
<p>代码区域：选择链接文件中的元素</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SelectElementsInLinkedDoc</span>(<span class="params">Autodesk.Revit.DB.Document document</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    UIDocument uidoc = <span class="keyword">new</span> UIDocument(document);</span><br><span class="line">    Selection choices = uidoc.Selection;</span><br><span class="line">    <span class="comment">// Pick one wall from Revit link</span></span><br><span class="line">    WallInLinkSelectionFilter wallFilter = <span class="keyword">new</span> WallInLinkSelectionFilter();</span><br><span class="line">    Reference elementRef = choices.PickObject(ObjectType.LinkedElement, wallFilter, <span class="string">&quot;Select a wall in a linked document&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (elementRef != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>, <span class="string">&quot;Element from link document selected.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This filter allows selection of only a certain element type in a link instance.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">WallInLinkSelectionFilter</span> : <span class="title">ISelectionFilter</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> RevitLinkInstance m_currentInstance = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">AllowElement</span>(<span class="params">Element e</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Accept any link instance, and save the handle for use in AllowReference()</span></span><br><span class="line">        m_currentInstance = e <span class="keyword">as</span> RevitLinkInstance;</span><br><span class="line">        <span class="keyword">return</span> (m_currentInstance != <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">AllowReference</span>(<span class="params">Reference refer, XYZ point</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (m_currentInstance == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Get the handle to the element in the link</span></span><br><span class="line">        Document linkedDoc = m_currentInstance.GetLinkDocument();</span><br><span class="line">        Element elem = linkedDoc.GetElement(refer.LinkedElementId);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Accept the selection if the element exists and is of the correct type</span></span><br><span class="line">        <span class="keyword">return</span> elem != <span class="literal">null</span> &amp;&amp; elem <span class="keyword">is</span> Wall;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="管理外部文件"><a href="#管理外部文件" class="headerlink" title="管理外部文件"></a>管理外部文件</h2><p><strong>ExternalFileUtils</strong> </p>
<p>顾名思义，这个实用程序类提供有关外部文件引用的信息。ExternalFileUtils.GetAllExternalFileReferences（）方法返回文档中作为外部文件引用的所有元素的ElementId集合。(Note它不会返回嵌套的Revit链接的ID;它只返回顶级参照。）此实用程序类还有另外两个方法，IsExternalFileReference（）和GetExternalFileReference（），它们执行与Element类的类似命名方法相同的功能，但可以在您拥有ElementId而不是首先获取Element时使用。</p>
<p>TransmissionDataTransmissionData存储有关外部文件引用的先前状态和请求状态的信息。这意味着它存储最近打开此TransmissionData文档时的引用的加载状态和路径。它还存储加载状态和路径信息，以便Revit在下次打开文档时执行操作。</p>
<p>因此，可以使用TransmissionData对外部文件参照执行操作，而无需打开整个关联的Revit文档。方法ReadTransmissionData和WriteTransmissionData可用于获取有关外部引用的信息，或更改该信息。例如，使用TransmissionData对象调用WriteTransmissionData，该对象已将所有引用设置为LinkedFileStatus.Unloaded，这将导致下次打开文档时不加载任何引用。</p>
<p>TransmissionData无法添加或删除对外部文件的引用。如果使用与外部文件引用元素不对应的ElementId调用AddExternalFileReference，则文件加载时将忽略该信息。</p>
<p>以下示例读取给定位置的文件的TransmissionData，并将所有Revit链接设置为在下次打开文档时卸载。</p>
<p>代码区域：卸载Revit链接</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UnloadRevitLinks</span>(<span class="params">ModelPath location</span>)</span></span><br><span class="line"><span class="function"><span class="comment">/// This method will set all Revit links to be unloaded the next time the document at the given location is opened. </span></span></span><br><span class="line"><span class="function"><span class="comment">/// The TransmissionData for a given document only contains top-level Revit links, not nested links.</span></span></span><br><span class="line"><span class="function"><span class="comment">/// However, nested links will be unloaded if their parent links are unloaded, so this function only needs to look at the document&#x27;s immediate links. </span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// access transmission data in the given Revit file</span></span><br><span class="line">    TransmissionData transData = TransmissionData.ReadTransmissionData(location);</span><br><span class="line">    <span class="keyword">if</span> (transData != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// collect all (immediate) external references in the model</span></span><br><span class="line">        ICollection externalReferences = transData.GetAllExternalFileReferenceIds();</span><br><span class="line">        <span class="comment">// find every reference that is a link</span></span><br><span class="line">        <span class="keyword">foreach</span> (ElementId refId <span class="keyword">in</span> externalReferences)</span><br><span class="line">        &#123;</span><br><span class="line">            ExternalFileReference extRef = transData.GetLastSavedReferenceData(refId);</span><br><span class="line">            <span class="keyword">if</span> (extRef.ExternalFileReferenceType == ExternalFileReferenceType.RevitLink)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// we do not want to change neither the path nor the path-type</span></span><br><span class="line">                <span class="comment">// we only want the links to be unloaded (shouldLoad = false)</span></span><br><span class="line">                transData.SetDesiredReferenceData(refId, extRef.GetPath(), extRef.PathType, <span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// make sure the IsTransmitted property is set </span></span><br><span class="line">        transData.IsTransmitted = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// modified transmission data must be saved back to the model</span></span><br><span class="line">        TransmissionData.WriteTransmissionData(location, transData);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        Autodesk.Revit.UI.TaskDialog.Show(<span class="string">&quot;Unload Links&quot;</span>, <span class="string">&quot;The document does not have any transmission data&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为服务器上的位置构造ModelPath</p>
<p>要读取TransmissionData对象，需要调用静态方法TransmissionData.ReadTransmissionData。它需要一个ModelPath对象。</p>
<p>有两种方法可以构造引用中心文件的ModelPath对象。第一种方法涉及使用ModelPathUtils和基本ModelPath类。其步骤如下：</p>
<ol>
<li><p>编写中心文件的用户可见路径字符串：ModelPathUtils.GetRevitServerPrefix（）+“相对路径”。</p>
<p>注意：“相对路径”中使用的文件夹分隔符是正斜杠（&#x2F;）。正确的分隔符是正斜杠。</p>
</li>
<li><p>通过ModelPathUtils.ConvertUserVisiblePathToModelPath（）方法创建ModelPath对象。传入在上一步中编写的字符串。</p>
</li>
<li><p>通过TransmissionData：：ReadTransmissionData（）方法读取传输数据。传入在上一步中获得的ModelPath。</p>
</li>
</ol>
<p>以下示例演示了此方法，假定中心文件testmodel.rvt存储在Revit Server的根文件夹SHACNG 035 WQRP中。</p>
<p>代码区域：使用ModelPath构造中心文件的路径</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">TransactionAttribute(Autodesk.Revit.Attributes.TransactionMode.Manual)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">RevitCommand</span> : <span class="title">IExternalCommand</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Result <span class="title">Execute</span>(<span class="params">ExternalCommandData commandData,         <span class="keyword">ref</span> <span class="built_in">string</span> messages, ElementSet elements</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    UIApplication app = commandData.Application;</span><br><span class="line">    Document doc = app.ActiveUIDocument.Document;</span><br><span class="line">    Transaction trans = <span class="keyword">new</span> Transaction(doc, <span class="string">&quot;ExComm&quot;</span>);</span><br><span class="line">    trans.Start();</span><br><span class="line">    <span class="built_in">string</span> visiblePath = ModelPathUtils.GetRevitServerPrefix() + <span class="string">&quot;/testmodel.rvt&quot;</span>;</span><br><span class="line">    ModelPath serverPath = ModelPathUtils.ConvertUserVisiblePathToModelPath(visiblePath);</span><br><span class="line">    TransmissionData transData = TransmissionData.ReadTransmissionData(serverPath);</span><br><span class="line">    <span class="built_in">string</span> mymessage = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (transData != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">         <span class="comment">//access the data in the transData here.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      Autodesk.Revit.UI.TaskDialog.Show(<span class="string">&quot;Unload Links&quot;</span>,</span><br><span class="line">      <span class="string">&quot;The document does not have any transmission data&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    trans.Commit();</span><br><span class="line">    <span class="keyword">return</span> Result.Succeeded;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>构造引用中心文件的ModelPath对象的第二种方法是使用子类ServerPath。如果程序知道本地服务器名称，则可以使用此方法，但不建议使用此方法，因为Revit用户可以从Revit UI更改服务器名称。其步骤如下： 1. 使用ServerPath构造函数创建ServerPath对象。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> ServerPath(“ServerNameOrServerIp”, “relative path without the initial forward slash”).</span><br></pre></td></tr></table></figure>

<p>注意：第一个参数是服务器名称，而不是ModelPathUtils.GetRevitServerPrefix（）返回的字符串，第二个参数不包括首个正斜杠。请参见下面的示例代码。文件夹分隔符也是一个正斜杠（&#x2F;）。 1. 通过TransmissionData.ReadTransmissionData（）方法读取TransmissionData对象。 下面的代码演示了此方法。</p>
<p>代码区域：使用ServerPath构造中心文件的路径</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">TransactionAttribute(Autodesk.Revit.Attributes.TransactionMode.Manual)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">RevitCommand</span> : <span class="title">IExternalCommand</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Result <span class="title">Execute</span>(<span class="params">ExternalCommandData commandData,</span></span></span><br><span class="line"><span class="params"><span class="function">         <span class="keyword">ref</span> <span class="built_in">string</span> messages, ElementSet elements</span>)</span></span><br><span class="line">  &#123;</span><br><span class="line">    UIApplication app = commandData.Application;</span><br><span class="line">    Document doc = app.ActiveUIDocument.Document;</span><br><span class="line">    Transaction trans = <span class="keyword">new</span> Transaction(doc, <span class="string">&quot;ExComm&quot;</span>);</span><br><span class="line">    trans.Start();</span><br><span class="line">    ServerPath serverPath = <span class="keyword">new</span> ServerPath(<span class="string">&quot;SHACNG035WQRP&quot;</span>, <span class="string">&quot;testmodel.rvt&quot;</span>);</span><br><span class="line">    TransmissionData transData = TransmissionData.ReadTransmissionData(serverPath);</span><br><span class="line">    <span class="built_in">string</span> mymessage = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (transData != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="comment">//access the data in the transData here.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      Autodesk.Revit.UI.TaskDialog.Show(<span class="string">&quot;Unload Links&quot;</span>,</span><br><span class="line">         <span class="string">&quot;The document does not have any transmission data&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    trans.Commit();</span><br><span class="line">    <span class="keyword">return</span> Result.Succeeded;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="注：翻译自Revit-API-Developers-Guide"><a href="#注：翻译自Revit-API-Developers-Guide" class="headerlink" title="注：翻译自Revit API Developers Guide"></a><em><strong>注：</strong></em>翻译自<a href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_html">Revit API Developers Guide</a></h2>]]></content>
      <categories>
        <category>Revit二次开发人员指南</category>
      </categories>
      <tags>
        <tag>Revit</tag>
      </tags>
  </entry>
  <entry>
    <title>42导出</title>
    <url>/2024/12/30/Revit%E4%BA%8C%E5%BC%80%E6%8C%87%E5%8D%97/42%E5%AF%BC%E5%87%BA/</url>
    <content><![CDATA[<h1 id="导出"><a href="#导出" class="headerlink" title="导出"></a>导出</h1><p>Revit API允许将Revit文档或其中的一部分导出为各种格式，以便与其他软件一起使用。Document类具有重载的Export（）方法，该方法将使用Revit中的内置导出器（如果可用）启动文档的导出。对于更高级的需求，可以使用Revit附加模块自定义某些类型的导出，例如导出到IFC和导出到Navisworks。(Note，Navisworks导出仅作为附加模块导出器提供）。</p>
<p>下表概述了Document.Export（）方法重载。</p>
<p>表：Document.Export（）方法</p>
<table>
<thead>
<tr>
<th>格式</th>
<th><strong>Export() parameters</strong></th>
<th><strong>Comments</strong></th>
</tr>
</thead>
<tbody><tr>
<td>gbXML</td>
<td>String, String, MassGBXMLExportOptions</td>
<td>从体量模型文档导出gbXML文件</td>
</tr>
<tr>
<td>gbXML</td>
<td>String, String, GBXMLExportOptions</td>
<td>以Green-Building XML格式导出文档。如果将EnergyDataSettings设置为使用概念模型，则无法使用此函数：请改用上述方法。</td>
</tr>
<tr>
<td>IFC</td>
<td>String, String, IFCExportOptions</td>
<td>将文档导出为行业标准类（IFC）格式。</td>
</tr>
<tr>
<td>NWC</td>
<td>String, String, NavisworksExportOptions</td>
<td>将Revit项目导出为Navisworks .nwc格式。请注意，要使用此功能，必须在Revit任务中注册兼容的Navisworks导出器附加模块。</td>
</tr>
<tr>
<td>DWF</td>
<td>String, String, ViewSet, DWFExportOptions</td>
<td>以XML格式导出当前视图或选定的视图。</td>
</tr>
<tr>
<td>DWFX</td>
<td>String, String, ViewSet, DWFXExportOptions</td>
<td>以DWFX格式导出当前视图或选定的视图。</td>
</tr>
<tr>
<td>FBX</td>
<td>String, String, ViewSet, FBXExportOptions</td>
<td>以3D-Studio Max（FBX）格式导出文档。</td>
</tr>
<tr>
<td>DGN</td>
<td>String, String, ICollection(ElementId), DGNExportOptions</td>
<td>以DGN格式导出选定的视图。</td>
</tr>
<tr>
<td>DWG</td>
<td>String, String, ICollection(ElementId), DWGExportOptions</td>
<td>以DWG格式导出选定的视图。</td>
</tr>
<tr>
<td>DXF</td>
<td>String, String, ICollection(ElementId), DXFExportOptions</td>
<td>以XML格式导出选定的视图。</td>
</tr>
<tr>
<td>SAT</td>
<td>String, String, ICollection(ElementId), SATExportOptions</td>
<td>以SAT格式导出当前视图或选定的视图。</td>
</tr>
<tr>
<td>ADSK</td>
<td>String, String, View3D, ViewPlan, BuildingSiteExportOptions</td>
<td>以Autodesk Civil 3D ®格式导出文档。</td>
</tr>
</tbody></table>
<p><strong>导出为gbXML</strong></p>
<p>有两种方法可以导出为绿色建筑XML格式。最后一个参数为MassGBXMLExportOptions的参数仅适用于包含一个或多个概念体量族实例的项目。要传递到此方法中的MassGBXMLExportOptions对象可以仅使用要在导出的gbXML中分析的体量分区的ID来构造，也可以使用体量分区ID和要在导出的gbXML中用作着色表面的体量的ID来构造。使用体量时，它们不能有体量楼层或体量分区，以免在gbXML输出中出现重复的曲面信息。</p>
<p>用于其他gbXML导出选项的GBXMLExportOptions对象没有要指定的设置。它使用所有默认设置。注意，该方法不生成能量模型。在调用此导出之前，主能量模型必须已存储在文档中。</p>
<p><strong>导出到IFC</strong></p>
<p>使用IFC选项调用Document.Export（）将使用默认的Revit IFC导出实现或自定义IFC导出（如果已在Revit的当前任务中注册）。在这两种情况下，IFCExportOptions类都用于设置导出选项，例如是否导出Revit当前支持的IFC标准数量，或是否允许按标高分割多层墙和柱。</p>
<p><strong>导出到Navisworks</strong></p>
<p>Navisworks的Export方法需要在当前Revit任务中注册兼容的Navisworks导出器附加模块。如果没有注册兼容的导出器，则该方法将引发异常。使用OptionalFunctionalityUtils.IsNavisworksExporterAvailable（）方法确定Navisworks导出程序是否已注册。</p>
<p>NavisworksExportOptions对象可用于设置导出到Navisworks的许多导出设置，例如是否将文件划分为级别以及是否导出房间几何图形。此外，NavisworksExportOptions.ExportScope属性指定导出范围。默认值为“模型”。其他选项包括View和SelectedElements。当设置为“视图”时，NavisworksExportOptions。ViewId属性应相应设置。此属性仅在导出范围设置为View时使用。当设置为SelectedElements时，NavisworksExportOptions。应该使用要导出的元素的id调用SetSelectedElementIds（）方法。</p>
<p><strong>导出到DXF和DWFX</strong></p>
<p>可以使用相应的Document.Export（）重载导出DWFX和DWFX文件。这两个方法都有一个ViewSet参数，表示要导出的视图。ViewSet中的所有视图都必须是可打印的，才能使导出成功。这可以使用每个视图的View.CanBePrinted属性进行检查。最后一个参数是DWFExportOptions或DWFXExportOptions。DWFXExportOptions派生自DWFExportOptions，并具有所有相同的导出设置。选项包括是否导出裁剪框、图像质量是否将纹理导出为3D打印文件以及纸张格式。</p>
<p>代码区域：Export DWF</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">ExportViewToDWF</span>(<span class="params">Document document, View view, <span class="built_in">string</span> pathname</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    DWFExportOptions dwfOptions = <span class="keyword">new</span> DWFExportOptions();</span><br><span class="line">    <span class="comment">// export with crop box and area and room geometry</span></span><br><span class="line">    dwfOptions.CropBoxVisible = <span class="literal">true</span>;</span><br><span class="line">    dwfOptions.ExportingAreas = <span class="literal">true</span>;</span><br><span class="line">    dwfOptions.ExportTexture = <span class="literal">false</span>;</span><br><span class="line">    ViewSet views = <span class="keyword">new</span> ViewSet();</span><br><span class="line">    views.Insert(view);</span><br><span class="line">    <span class="keyword">return</span> (document.Export(Path.GetDirectoryName(pathname),</span><br><span class="line">        Path.GetFileNameWithoutExtension(pathname), views, dwfOptions));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>导出到3D-Studio Max</strong></p>
<p>FBX导出要求存在某些可选模块，这些模块可能不是已安装的Revit的一部分，因此OptionalFunctionalityUtils。IsFBXExportAvailable（）方法报告FBX导出功能是否可用。用于导出到3D-Studio Max的Export（）方法有一个ViewSet参数，表示要导出的视图集。仅允许3D视图。FBXExportOptions参数可用于指定是否在不带边界边的情况下导出、是否使用详细级别以及在视图导出失败时是否应停止导出过程。</p>
<p><strong>导出为CAD图形</strong></p>
<p>输出为DGN、DWG和DXF格式文件具有类似的输出方法和选项。</p>
<p>DGN、DWG和DXF导出都需要存在某些可选模块，这些模块可能不是已安装的Revit版本的一部分，因此OptionalFunctionalityUtils类作为相应的方法来报告这些类型的导出功能是否可用。</p>
<p>用于导出为DGN、DWG和DWG格式的Export（）方法都有一个参数，表示要导出的视图（作为视图的ElementId的ICollection）。必须至少存在一个有效视图，并且该视图必须是可打印的，导出才能成功。这可以使用每个视图的View.CanBePrinted属性进行检查。</p>
<p>每种格式的导出选项都派生自BaseExportOptions，因此有许多通用的导出设置，例如颜色模式或是否隐藏范围框。BaseExportOptions还有一个名为GetPredefinedSetupNames（）的静态方法，它将返回文档的任何预定义设置。然后，可以将预定义设置的名称传递到静态方法GetPredefinedOptions（）中，该方法可从相应的选项类获得：DWGExportOptions、DGNExportOptions或DXFExportOptions。DWG和DWG文件的导出选项具有更多的共同选项，因为它们共享基类ACADExportOptions。</p>
<p>以下示例使用第一个预定义设置名称和预定义选项将活动视图（如果可以打印）导出到DGN文件，而不进行任何更改。</p>
<p>代码区域：出口DGN</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">ExportDGN</span>(<span class="params">Document document, View view</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">bool</span> exported = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// Get predefined setups and export the first one</span></span><br><span class="line">    IList setupNames = BaseExportOptions.GetPredefinedSetupNames(document);</span><br><span class="line">    <span class="keyword">if</span> (setupNames.Count &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Get predefined options for first predefined setup</span></span><br><span class="line">        DGNExportOptions dgnOptions = DGNExportOptions.GetPredefinedOptions(document, setupNames[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// export the active view if it is printable</span></span><br><span class="line">        <span class="keyword">if</span> (document.ActiveView.CanBePrinted == <span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ICollection views = <span class="keyword">new</span> List();</span><br><span class="line">            views.Add(view.Id);</span><br><span class="line">            exported = document.Export(Path.GetDirectoryName(document.PathName),</span><br><span class="line">                Path.GetFileNameWithoutExtension(document.PathName), views, dgnOptions);</span><br><span class="line">        &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> exported;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于这些文件类型，可以指定或修改各种映射设置，例如通过创建相应的表并将其传递到BaseExportOptions类的相应方法来指定或修改图层映射或文本字体映射。对于图层映射，您也可以将字符串值传递给预定义图层映射样式的BaseExportOptions.LayerMapping或图层映射文件的文件名。有关创建或修改导出表的详细信息，请参阅导出表主题。</p>
<p><strong>导出到SAT</strong></p>
<p>SAT的Export方法有一个表示要导出的视图的参数（作为视图的ElementId的ICollection）。必须至少存在一个有效视图，并且该视图必须是可打印的，导出才能成功。这可以使用每个视图的View.CanBePrinted属性进行检查。SATExportOptions对象没有要指定的设置。它使用所有默认设置。</p>
<p>导出到 Civil Engineering Design程序</p>
<p>最后一个Export（）方法以土木工程设计应用程序的格式导出文档的3D视图。该方法的一个参数是指定总面积平面的视图平面。视图平面上的所有区域都将被导出，并且它必须是“总建筑”面积平面。若要检查其面积方案是否为Gross Building，请使用AreaScheme.GrossBuildingArea属性。BuildingSiteExportOptions对象允许自定义设置值，如总面积或总占用率。</p>
<p>本节中的页面</p>
<ul>
<li>导出表</li>
<li>IFC导出</li>
<li>自定义导出</li>
</ul>
<h2 id="导出表"><a href="#导出表" class="headerlink" title="导出表"></a>导出表</h2><p>下表中列出的类公开了对用于在导出为各种格式（如DWG和DGN）时进行映射的表的读写访问权限。每个类都包含（key，info）对映射数据。</p>
<table>
<thead>
<tr>
<th><strong>Class</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody><tr>
<td>ExportLayerTable</td>
<td>表示支持将各种图层特性（类别、名称、颜色名称）映射到目标导出格式中的图层名称的表。</td>
</tr>
<tr>
<td>ExportLinetypeTable</td>
<td>表示一个表，该表支持线型名称的映射（采用目标导出格式）。</td>
</tr>
<tr>
<td>ExportPatternTable</td>
<td>表示支持将FillPattern名称和id映射到目标导出格式中的FillPattern名称的表。</td>
</tr>
<tr>
<td>ExportFontTable</td>
<td>表示支持目标导出格式的字体名称映射的表。</td>
</tr>
<tr>
<td>ExportLineweightTable</td>
<td>表示支持目标导出格式的线宽名称映射的表。</td>
</tr>
</tbody></table>
<p>这些表中的大多数都可以通过BaseExportOptions类（DGN、DWG和DWG格式选项的基类）获得。ExportLineweightTable可从DGNExportOptions类中获得。每个表都有一个对应的Get和Set方法。要修改映射，请获取相应的表，进行更改，然后将其设置回选项类。 以下示例在导出DWG文件之前修改ExportLayerTable。</p>
<p>代码区域：导出具有修改的ExportLayerTable的DWG</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">ExportDWGModifyLayerTable</span>(<span class="params">Document document, View view</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">bool</span> exported = <span class="literal">false</span>;</span><br><span class="line">    IList setupNames = BaseExportOptions.GetPredefinedSetupNames(document);</span><br><span class="line">    <span class="keyword">if</span> (setupNames.Count &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Get the export options for the first predefined setup</span></span><br><span class="line">        DWGExportOptions dwgOptions = DWGExportOptions.GetPredefinedOptions(document, setupNames[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Get the export layer table</span></span><br><span class="line">        ExportLayerTable layerTable = dwgOptions.GetExportLayerTable();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Find the first mapping for the Ceilings category</span></span><br><span class="line">        <span class="built_in">string</span> category = <span class="string">&quot;Ceilings&quot;</span>;</span><br><span class="line">        ExportLayerKey targetKey = layerTable.GetKeys().First(layerKey =&gt; layerKey.CategoryName == category);</span><br><span class="line">        ExportLayerInfo targetInfo = layerTable[targetKey];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// change the color name and cut color number for this mapping</span></span><br><span class="line">        targetInfo.ColorName = <span class="string">&quot;31&quot;</span>;</span><br><span class="line">        targetInfo.CutColorNumber = <span class="number">31</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Set the change back to the map</span></span><br><span class="line">        layerTable[targetKey] = targetInfo;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Set the modified table back to the options</span></span><br><span class="line">        dwgOptions.SetExportLayerTable(layerTable);</span><br><span class="line"></span><br><span class="line">        ICollection views = <span class="keyword">new</span> List();</span><br><span class="line">        views.Add(view.Id);</span><br><span class="line"></span><br><span class="line">        exported = document.Export(Path.GetDirectoryName(document.PathName),</span><br><span class="line">            Path.GetFileNameWithoutExtension(document.PathName), views, dwgOptions);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> exported;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="IFC导出"><a href="#IFC导出" class="headerlink" title="IFC导出"></a>IFC导出</h2><p><strong>自定义IFC导出</strong></p>
<p>Revit API允许自定义应用程序覆盖IFC导出过程的默认实现。</p>
<p>在Revit中注册IExporterIFC对象后，当用户从UI和API方法Document.Export（String，String，IFCExportOptions）调用到IFC的导出时，都将使用该对象。在这两种情况下，如果未注册自定义IFC导出器，则将使用IFC导出的默认Revit实现。</p>
<p>从API调用IFC导出时，IFCExportOptions可用于设置用户从“导出IFC”对话框中可用的相同导出选项。</p>
<p><strong>IExporterIFC</strong></p>
<p>接口IExporterIFC只有一个要实现的方法ExportIFC（）。此方法由Revit调用以执行到IFC的导出。ExporterIFC对象作为其参数之一传递给此方法。ExporterIFC是Revit提供的用于实现IFC导出的主类。它包含有关用户为导出操作选择的选项的信息，以及用于访问正确实现导出所需的特定数据类型的成员的信息。</p>
<p>Autodesk.Revit.DB.IFC命名空间包含许多与IFC相关的API类，IFC导出过程的自定义实现可以使用这些类。有关自定义IFC导出应用程序的完整示例，请参见<a href="http://sourceforge.net/projects/ifcexporter/%E4%B8%8A%E7%9A%84%E5%BC%80%E6%94%BE%E6%BA%90%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B%E3%80%82">http://sourceforge.net/projects/ifcexporter/上的开放源代码示例。</a></p>
<h2 id="自定义导出"><a href="#自定义导出" class="headerlink" title="自定义导出"></a>自定义导出</h2><p>使用自定义导出过程从Revit文档导出三维视图。</p>
<p>Revit API提供了一组类，可以通过自定义导出上下文导出三维视图。这些类提供对渲染输出管道的访问，Revit通过该管道将模型的图形三维表示发送到输出设备。在自定义导出的情况下，“设备”由上下文对象表示，该上下文对象可以是任何类型的设备。一个文件将是最常见的情况。</p>
<p>自定义导出器的实现提供上下文并调用模型的渲染，然后Revit开始处理模型并通过上下文的方法发送图形数据。数据描述的模型与渲染模型时在Revit中显示的完全一样。数据包括所有几何和材料属性。</p>
<p><strong>CustomExporter类</strong></p>
<p>CustomExporter类允许通过自定义导出上下文导出3D视图。此类的Export（）方法触发Revit中的标准渲染过程，但不是在屏幕或打印机上显示结果，而是通过处理几何和非几何信息的给定自定义上下文传递输出。</p>
<p><strong>IExportContext</strong></p>
<p>IExportContext类的实例作为CustomExporter构造函数的参数传递。然后在导出模型的实体时调用该接口的方法。</p>
<p>虽然可以创建从IExportContext类派生的类，但最好使用其派生类之一：IPhotoRenderContext或IModelExportContext。使用IPhotoRenderContext执行自定义导出时，Revit将遍历模型并输出模型的几何图形，就像处理通过UI调用的渲染命令一样。只有具有实际几何图形且适合在渲染视图中显示的图元才会被处理和输出。</p>
<p>IModelExportContext应用于处理视图中的图元，处理方式与Revit在三维视图中处理图元的方式相同。此上下文支持其他元素，包括三维视图中显示的模型曲线和文本。</p>
<p><strong>RenderNode类</strong></p>
<p>RenderNode是模型导出过程中所有输出节点的基类。节点可以是几何节点（如元素或灯光），也可以是非几何节点（如材质）。某些类型的节点是包含其他渲染节点的容器节点。</p>
<p><strong>CameraInfo</strong></p>
<p>CameraInfo类描述有关3D视图到渲染图像的投影映射的信息。这个类的实例可以通过ViewNode的属性获得。如果为空，则应假定为正交视图。</p>
<h2 id="注：翻译自Revit-API-Developers-Guide"><a href="#注：翻译自Revit-API-Developers-Guide" class="headerlink" title="注：翻译自Revit API Developers Guide"></a><em><strong>注：</strong></em>翻译自<a href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_html">Revit API Developers Guide</a></h2>]]></content>
      <categories>
        <category>Revit二次开发人员指南</category>
      </categories>
      <tags>
        <tag>Revit</tag>
      </tags>
  </entry>
  <entry>
    <title>39工作共享</title>
    <url>/2024/12/30/Revit%E4%BA%8C%E5%BC%80%E6%8C%87%E5%8D%97/39%E5%B7%A5%E4%BD%9C%E5%85%B1%E4%BA%AB/</url>
    <content><![CDATA[<h1 id="工作共享"><a href="#工作共享" class="headerlink" title="工作共享"></a>工作共享</h1><p>工作共享是一种设计方法，它允许多个团队成员同时处理同一个项目模型。启用工作共享后，可以将Revit文档细分为工作集，这些工作集是项目中图元的集合。</p>
<p>本节中的页面</p>
<ul>
<li>工作共享概述</li>
<li>工作集</li>
<li>工作集中的图元</li>
<li>编辑工作集中的图元</li>
<li>打开工作共享文档</li>
<li>可见性和显示</li>
<li>工作共享文件管理</li>
</ul>
<h2 id="工作共享概述"><a href="#工作共享概述" class="headerlink" title="工作共享概述"></a>工作共享概述</h2><p>为Revit创建附加模块时，了解文档在工作共享环境中的功能非常重要。文件是本地文件、中心文件还是由Revit服务器管理的文件会影响对模型所做的更改对其他用户的影响，也会影响模型是否可能过期或工作集是否已被其他用户锁定。</p>
<p><strong>工作流</strong></p>
<p>这是从高层角度来看的工作共享工作流程。当用户打开中心模型时，他们将获得模型的本地副本。编辑图元时，图元将从中心模型中检出，这样其他人就无法编辑它们。仅当执行“带中心”的修改时，局部更改才会提交到中心模型。提交后，其他用户可以通过执行“最新更新”来获取更改。</p>
<p><strong>工作集</strong></p>
<p>图元放置在工作集中。并且可以检出整个工作集，以便用户对工作集中的所有图元具有独占编辑权限。如果添加了新图元，它们将放置在本地模型的活动工作集中。</p>
<p>特定的工作集可以与模型一起打开。只有打开的工作集可见，但模型中的所有图元都可用。工作共享模型也可以是开放的“分离”模型，在这种情况下，不可能更新中心模型。在这种情况下，不需要工作集管理。</p>
<p><strong>工作共享类型</strong></p>
<p>工作共享有两种类型：</p>
<ul>
<li>File-based- 可通过网络访问磁盘上的中心模型</li>
<li>Server-based- Revit服务器管理中心模型和可能本地可用的加速器</li>
</ul>
<h2 id="工作集"><a href="#工作集" class="headerlink" title="工作集"></a>工作集</h2><p>工作集是将Revit文档中的一组图元划分为工作共享子集的一种方法。文档中可能有一个或多个工作集。</p>
<p><strong>在文档中添加工作集</strong></p>
<p>该文档包含一个WorksetTable，该表包含对该文档中包含的所有工作集的引用。每个文档都有一个WorksetTable。即使文档中未启用工作共享，表中也至少有一个默认工作集。IsWorkshared属性可用于确定文档中是否已启用工作共享。WorksetTable类可用于获取活动工作集（如下例所示），并通过调用SetActiveWorksetId（）来设置活动工作集</p>
<p>代码区域：获取活动工作集</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Workset <span class="title">GetActiveWorkset</span>(<span class="params">Document doc</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="comment">// Get the workset table from the document</span></span><br><span class="line">     WorksetTable worksetTable = doc.GetWorksetTable();</span><br><span class="line">     <span class="comment">// Get the Id of the active workset</span></span><br><span class="line">     WorksetId activeId = worksetTable.GetActiveWorksetId();</span><br><span class="line">     <span class="comment">// Find the workset with that Id</span></span><br><span class="line">     Workset workset = worksetTable.GetWorkset(activeId);</span><br><span class="line">     <span class="keyword">return</span> workset;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>过滤工作集</strong></p>
<p>由于Workset类不是从Element派生的，因此可以使用FilteredWorksetCollector在一组工作集中进行搜索、筛选和重命名。可以指定条件来过滤返回的工作集。如果未应用任何条件，则此过滤器将访问文档中的所有工作集。WorksetKind枚举器对于筛选工作集非常有用，如下例所示。WorksetKind标识工作集的细分：</p>
<ul>
<li><strong>User</strong>- 用户管理的三维实例图元工作集</li>
<li><strong>Family</strong>- 保存族符号和族的位置</li>
<li><strong>Standard</strong>- 项目标准所在的位置，包括系统族类型</li>
<li><strong>Other</strong>- 通常不应被应用程序考虑的内部使用的工作集</li>
<li><strong>View</strong>- 包含视图和特定于视图的元素</li>
</ul>
<p>代码区域：过滤工作集</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetWorksetsInfo</span>(<span class="params">Document doc</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    String message = String.Empty;</span><br><span class="line">    <span class="comment">// Enumerating worksets in a document and getting basic information for each</span></span><br><span class="line">    FilteredWorksetCollector collector = <span class="keyword">new</span> FilteredWorksetCollector(doc);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// find all user worksets</span></span><br><span class="line">    collector.OfKind(WorksetKind.UserWorkset);</span><br><span class="line">    IList worksets = collector.ToWorksets();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get information for each workset</span></span><br><span class="line">    <span class="built_in">int</span> count = <span class="number">3</span>; <span class="comment">// show info for 3 worksets only</span></span><br><span class="line">    <span class="keyword">foreach</span> (Workset workset <span class="keyword">in</span> worksets)</span><br><span class="line">    &#123;</span><br><span class="line">        message += <span class="string">&quot;Workset : &quot;</span> + workset.Name;</span><br><span class="line">        message += <span class="string">&quot;\nUnique Id : &quot;</span> + workset.UniqueId;</span><br><span class="line">        message += <span class="string">&quot;\nOwner : &quot;</span> + workset.Owner;</span><br><span class="line">        message += <span class="string">&quot;\nKind : &quot;</span> + workset.Kind;</span><br><span class="line">        message += <span class="string">&quot;\nIs default : &quot;</span> + workset.IsDefaultWorkset;</span><br><span class="line">        message += <span class="string">&quot;\nIs editable : &quot;</span> + workset.IsEditable;</span><br><span class="line">        message += <span class="string">&quot;\nIs open : &quot;</span> + workset.IsOpen;</span><br><span class="line">        message += <span class="string">&quot;\nIs visible by default : &quot;</span> + workset.IsVisibleByDefault;</span><br><span class="line"></span><br><span class="line">        TaskDialog.Show(<span class="string">&quot;GetWorksetsInfo&quot;</span>, message);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == --count)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>工作集属性</strong></p>
<p>Workset类表示Revit文档中的工作集。如上面的过滤工作集示例所示，Workset类提供了许多属性来获取有关给定工作集的信息，例如所有者以及工作集是否可编辑。这些属性是只读的。若要更改现有工作集的名称，请使用静态方法WorksetTable.RenameWorkset（）。</p>
<p><strong>创建工作集</strong></p>
<p>静态Workset.Create（）方法可用于在给定文档中创建具有指定名称的新工作集。只能在启用了工作共享的文档中创建工作集，并且名称必须唯一。静态方法WorksetTable.IsWorksetNameUnique（）将确认给定的名称在文档中是否唯一。下面的示例演示如何创建新工作集。</p>
<p>代码区域：创建新工作集</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Workset <span class="title">CreateWorkset</span>(<span class="params">Document document</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Workset newWorkset = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// Worksets can only be created in a document with worksharing enabled</span></span><br><span class="line">    <span class="keyword">if</span> (document.IsWorkshared)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> worksetName = <span class="string">&quot;New Workset&quot;</span>;</span><br><span class="line">        <span class="comment">// Workset name must not be in use by another workset</span></span><br><span class="line">        <span class="keyword">if</span> (WorksetTable.IsWorksetNameUnique(document, worksetName))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">using</span> (Transaction worksetTransaction = <span class="keyword">new</span> Transaction(document, <span class="string">&quot;Set preview view id&quot;</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                worksetTransaction.Start();</span><br><span class="line">                newWorkset = Workset.Create(document, worksetName);</span><br><span class="line">                worksetTransaction.Commit();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> newWorkset;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="工作集中的图元"><a href="#工作集中的图元" class="headerlink" title="工作集中的图元"></a>工作集中的图元</h2><p>文档中的每个图元必须属于且只能属于一个工作集。每个元素都有一个WorksetId，用于标识该元素所属的唯一工作集。此外，给定WorksetId，可以使用ElementWorksetFilter获取文档中属于该Workset的所有元素，如下所示。</p>
<p>代码区域：ElementWorksetFilter</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">WorksetElements</span>(<span class="params">Document doc, Workset workset</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// filter all elements that belong to the given workset</span></span><br><span class="line">    FilteredElementCollector elementCollector = <span class="keyword">new</span> FilteredElementCollector(doc);</span><br><span class="line">    ElementWorksetFilter elementWorksetFilter = <span class="keyword">new</span> ElementWorksetFilter(workset.Id, <span class="literal">false</span>);</span><br><span class="line">    ICollection worksetElemsfounds = elementCollector.WherePasses(elementWorksetFilter).ToElements();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// how many elements were found?</span></span><br><span class="line">    <span class="built_in">int</span> elementsCount = worksetElemsfounds.Count;</span><br><span class="line">    String message = <span class="string">&quot;Element count : &quot;</span> + elementsCount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get name and/or Id of the elements that pass the given filter and show a few of them</span></span><br><span class="line">    <span class="built_in">int</span> count = <span class="number">5</span>;  <span class="comment">// show info for 5 elements only</span></span><br><span class="line">    <span class="keyword">foreach</span> (Element ele <span class="keyword">in</span> worksetElemsfounds)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != ele)</span><br><span class="line">        &#123;</span><br><span class="line">             message += <span class="string">&quot;\nElementId : &quot;</span> + ele.Id;</span><br><span class="line">             message += <span class="string">&quot;, Element Name : &quot;</span> + ele.Name;</span><br><span class="line"></span><br><span class="line">             <span class="keyword">if</span> (<span class="number">0</span> == --count)</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Autodesk.Revit.UI.TaskDialog.Show(<span class="string">&quot;ElementsOfWorkset&quot;</span>, message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>新元素将自动放置在用户的模型本地副本中的活动工作集中。由于元素的WorksetId是只读属性，因此请使用参数ELEM_PARTITION_PARAM。下面的示例演示如何创建已更改为属于其他工作集的图元。</p>
<p>代码区域：更改新元素的工作集</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Document doc = commandData.View.Document;</span><br><span class="line">String targetWorksetName = <span class="string">&quot;Target workset&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Find target workset</span></span><br><span class="line">FilteredWorksetCollector worksetCollector = <span class="keyword">new</span> FilteredWorksetCollector(doc);</span><br><span class="line">worksetCollector.OfKind(WorksetKind.UserWorkset);</span><br><span class="line">Workset workset = worksetCollector.FirstOrDefault(ws =&gt; ws.Name == targetWorksetName);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Workset not found, abort</span></span><br><span class="line"><span class="keyword">if</span> (workset == <span class="literal">null</span>)</span><br><span class="line">&#123;</span><br><span class="line">    TaskDialog dialog = <span class="keyword">new</span> TaskDialog(<span class="string">&quot;Error&quot;</span>);</span><br><span class="line">    dialog.MainInstruction = String.Format(<span class="string">&quot;There is no workset named &#123;0&#125; in the document. Aborting this operation.&quot;</span>, targetWorksetName);</span><br><span class="line">    dialog.MainIcon = TaskDialogIcon.TaskDialogIconWarning;</span><br><span class="line">    dialog.Show();</span><br><span class="line">    <span class="keyword">return</span> Result.Cancelled;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Find &quot;Level 1&quot; for the new wall</span></span><br><span class="line">FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(doc);</span><br><span class="line">collector.OfClass(<span class="keyword">typeof</span>(Level));</span><br><span class="line">Level level = collector.Cast().First(lvl =&gt; lvl.Name == <span class="string">&quot;Level 1&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> (Transaction t = <span class="keyword">new</span> Transaction(doc, <span class="string">&quot;Add elements by API&quot;</span>))</span><br><span class="line">&#123;</span><br><span class="line">    t.Start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create the wall</span></span><br><span class="line">    Wall wall = Wall.Create(doc, Line.CreateBound(<span class="keyword">new</span> XYZ(<span class="number">25</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="keyword">new</span> XYZ(<span class="number">25</span>, <span class="number">15</span>, <span class="number">0</span>)), level.Id, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get the parameter that stores the workset id</span></span><br><span class="line">    Parameter p = wall.get_Parameter(BuiltInParameter.ELEM_PARTITION_PARAM);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This parameter storage type is Integer</span></span><br><span class="line">    p.Set(workset.Id.IntegerValue);</span><br><span class="line"></span><br><span class="line">    t.Commit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以使用WorksharingUtils类获取元素的当前所有者和签出状态等工作共享信息。它是一个静态类，包含与工作共享相关的实用程序函数。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetElementWorksharingInfo</span>(<span class="params">Document doc, ElementId elemId</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    String message = String.Empty;</span><br><span class="line">    message += <span class="string">&quot;Element Id: &quot;</span> + elemId;</span><br><span class="line"></span><br><span class="line">    Element elem = doc.GetElement(elemId);</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">null</span> == elem)</span><br><span class="line">    &#123;</span><br><span class="line">       message += <span class="string">&quot;Element does not exist&quot;</span>;</span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The workset the element belongs to</span></span><br><span class="line">    WorksetId worksetId = elem.WorksetId;</span><br><span class="line">    message += (<span class="string">&quot;\nWorkset Id : &quot;</span> + worksetId.ToString());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Model Updates Status of the element</span></span><br><span class="line">    ModelUpdatesStatus updateStatus = WorksharingUtils.GetModelUpdatesStatus(doc, elemId);</span><br><span class="line">    message += (<span class="string">&quot;\nUpdate status : &quot;</span> + updateStatus.ToString());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Checkout Status of the element</span></span><br><span class="line">    CheckoutStatus checkoutStatus = WorksharingUtils.GetCheckoutStatus(doc, elemId);</span><br><span class="line">    message += (<span class="string">&quot;\nCheckout status : &quot;</span> + checkoutStatus.ToString());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Getting WorksharingTooltipInfo of a given element Id</span></span><br><span class="line">    WorksharingTooltipInfo tooltipInfo = WorksharingUtils.GetWorksharingTooltipInfo(doc, elemId);</span><br><span class="line">    message += (<span class="string">&quot;\nCreator : &quot;</span> + tooltipInfo.Creator);</span><br><span class="line">    message += (<span class="string">&quot;\nCurrent Owner : &quot;</span> + tooltipInfo.Owner);</span><br><span class="line">    message += (<span class="string">&quot;\nLast Changed by : &quot;</span> + tooltipInfo.LastChangedBy);</span><br><span class="line"></span><br><span class="line">    Autodesk.Revit.UI.TaskDialog.Show(<span class="string">&quot;GetElementWorksharingInfo&quot;</span>, message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="编辑工作集中的图元"><a href="#编辑工作集中的图元" class="headerlink" title="编辑工作集中的图元"></a>编辑工作集中的图元</h2><p><strong>Overview</strong></p>
<p>在团队中工作的用户可能会遇到Revit API附加模块的可用性问题，而不是单个用户可能遇到的问题。特别是，外接程序的设计方式可以防止或创建编辑冲突。例如，如果加载项尝试编辑数千个元素，则所有这些元素都需要由本地用户检出，并且在执行与中心的同步之前，其他用户将无法使用这些元素。或者，某些元素可能已被其他用户检出，无法进行编辑。在通过API对工作共享模型进行更改时，请务必记住这一点。</p>
<p>基本的模型编辑工作流程如下所示：</p>
<table>
<thead>
<tr>
<th align="left">Action 行动</th>
<th align="left">Example 例如</th>
<th align="left">Why this is important 为什么这很重要</th>
</tr>
</thead>
<tbody><tr>
<td align="left">用户更改模型中的某些元素</td>
<td align="left">用户拖动墙</td>
<td align="left">这些变化是“用户变化”。用户必须借用这些元素来进行更改。</td>
</tr>
<tr>
<td align="left">Revit会根据需要重新生成模型中的其他数据</td>
<td align="left">连接墙移动，地板更新，屋顶更新，房间更新，房间标记检查他们是否仍在房间中</td>
<td align="left">这些变化就是“系统变化”。即使它们被更改，它们仍然对其他用户可用。</td>
</tr>
</tbody></table>
<p>大多数API更改都是“用户更改”，并被视为本地用户手动进行的更改。无论是从外部命令、宏还是事件调用，都是如此。唯一的例外是，从更新程序进行的更改被视为系统更改。要解决在尝试编辑工作共享文档中的元素时可能出现的工作共享问题，一种方法是为用于编辑元素的事务设置FailureHandlingOptions。这允许自动捕获和抑制编辑错误并回滚更改，如下所示：</p>
<p>代码区域：取消工作共享错误</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">TryToEditGeometricElement</span>(<span class="params">Element elem, <span class="built_in">bool</span> useFailureHandlingOpts</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Document doc = elem.Document;</span><br><span class="line">    <span class="keyword">using</span> (Transaction t = MakeTransaction(doc, <span class="string">&quot;Move element&quot;</span>, useFailureHandlingOpts))</span><br><span class="line">    &#123;</span><br><span class="line">        t.Start();</span><br><span class="line">        ElementTransformUtils.MoveElement(doc, elem.Id, <span class="keyword">new</span> XYZ(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        t.Commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Transaction <span class="title">MakeTransaction</span>(<span class="params">Document doc, <span class="built_in">string</span> name, <span class="built_in">bool</span> useFailureHandlingOpts</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Transaction t = <span class="keyword">new</span> Transaction(doc, name);</span><br><span class="line">    <span class="keyword">if</span> (useFailureHandlingOpts)</span><br><span class="line">    &#123;</span><br><span class="line">        FailureHandlingOptions opts = t.GetFailureHandlingOptions();</span><br><span class="line">        opts.SetClearAfterRollback(<span class="literal">true</span>);</span><br><span class="line">        opts.SetFailuresPreprocessor(<span class="keyword">new</span> WorksharingErrorsPreprocessor());</span><br><span class="line">        t.SetFailureHandlingOptions(opts);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>WorksharingUtils类可用于修改图元和工作集的所有权。CheckoutElements（）方法为当前用户获取尽可能多的指定图元的所有权，而CheckoutWorksets（）方法对工作集执行相同的操作。这些方法对于尝试在执行编辑之前检出图元非常有用。RelinquishOwnership（）方法根据指定的RelinquishOptions放弃当前用户拥有的图元和工作集。 为获得最佳性能，请在一次大调用中检出所有图元或工作集并放弃项目，而不是在许多次小调用中。</p>
<p>注意：检出图元时，Revit可能会检出使请求的图元可编辑所需的其他图元。例如，如果某个图元位于组中，则Revit将检出整个组。 下面的示例尝试在编辑之前签出给定的元素，并在出现问题时向用户发出消息。</p>
<p>代码区域：签出元素</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">bool</span> <span class="title">AttemptToCheckoutInAdvance</span>(<span class="params">Element element</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Document doc = element.Document;</span><br><span class="line">    String categoryName = element.Category.Name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Checkout attempt</span></span><br><span class="line">    ICollection checkedOutIds = WorksharingUtils.CheckoutElements(doc, <span class="keyword">new</span> ElementId[] &#123; element.Id &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Confirm checkout</span></span><br><span class="line">    <span class="built_in">bool</span> checkedOutSuccessfully = checkedOutIds.Contains(element.Id);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!checkedOutSuccessfully)</span><br><span class="line">    &#123;</span><br><span class="line">        TaskDialog.Show(<span class="string">&quot;Element is not checked out&quot;</span>, <span class="string">&quot;Cannot edit the &quot;</span> + categoryName + <span class="string">&quot; element - &quot;</span> +</span><br><span class="line">                        <span class="string">&quot;it was not checked out successfully and may be checked out to another.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If element is updated in central or deleted in central, it is not editable</span></span><br><span class="line">    ModelUpdatesStatus updatesStatus = WorksharingUtils.GetModelUpdatesStatus(doc, element.Id);</span><br><span class="line">    <span class="keyword">if</span> (updatesStatus == ModelUpdatesStatus.DeletedInCentral || updatesStatus == ModelUpdatesStatus.UpdatedInCentral)</span><br><span class="line">    &#123;</span><br><span class="line">        TaskDialog.Show(<span class="string">&quot;Element is not up to date&quot;</span>, <span class="string">&quot;Cannot edit the &quot;</span> + categoryName + <span class="string">&quot; element - &quot;</span> +</span><br><span class="line">                        <span class="string">&quot;it is not up to date with central, but it is checked out.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下一个示例演示如何检出所有视图工作集。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CheckoutAllViewWorksets</span>(<span class="params">Document doc</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    FilteredWorksetCollector collector = <span class="keyword">new</span> FilteredWorksetCollector(doc);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// find all view worksets</span></span><br><span class="line">    collector.OfKind(WorksetKind.ViewWorkset);</span><br><span class="line">    ICollection viewworksets = collector.ToWorksetIds();</span><br><span class="line">    ICollection checkoutworksets = WorksharingUtils.CheckoutWorksets(doc, viewworksets);</span><br><span class="line">    TaskDialog.Show(<span class="string">&quot;Checked out worksets&quot;</span>, <span class="string">&quot;Number of worksets checked out: &quot;</span> + checkoutworksets.Count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="打开工作共享文档"><a href="#打开工作共享文档" class="headerlink" title="打开工作共享文档"></a>打开工作共享文档</h2><p>Application.OpenDocumentFile（ModelPath，OpenOptions）方法可用于设置与打开工作共享文档相关的选项。除了从中心文档拆离或允许本地文件由其所有者以外的用户以只读方式打开的选项外，还可以设置与工作集相关的选项。打开工作共享文档时，将自动打开所有系统工作集，但是可以指定打开或关闭用户创建的工作集。可以展开和显示打开的工作集中的图元。但是，关闭的工作集中的图元不会显示，以避免展开它们。通过仅打开当前任务中所需的工作集，可以减少Revit的内存占用量，从而有助于提高性能。</p>
<p>在下面的示例中，打开了一个文档，其中指定了两个要打开的工作集。请注意，WorksharingUtils.GetUserWorksetInfo（）方法可用于访问关闭的Revit文档中的工作集信息。</p>
<p>代码区域：打开工作共享文档</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function">Document <span class="title">OpenDocumentWithWorksets</span>(<span class="params">Application app, ModelPath projectPath</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Document doc = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Get info on all the user worksets in the project prior to opening</span></span><br><span class="line">        IList worksets = WorksharingUtils.GetUserWorksetInfo(projectPath);</span><br><span class="line">        IList worksetIds = <span class="keyword">new</span> List();</span><br><span class="line">        <span class="comment">// Find two predetermined worksets</span></span><br><span class="line">        <span class="keyword">foreach</span> (WorksetPreview worksetPrev <span class="keyword">in</span> worksets)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (worksetPrev.Name.CompareTo(<span class="string">&quot;Workset1&quot;</span>) == <span class="number">0</span> ||</span><br><span class="line">                worksetPrev.Name.CompareTo(<span class="string">&quot;Workset2&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                worksetIds.Add(worksetPrev.Id);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        OpenOptions openOptions = <span class="keyword">new</span> OpenOptions();</span><br><span class="line">        <span class="comment">// Setup config to close all worksets by default</span></span><br><span class="line">        WorksetConfiguration openConfig = <span class="keyword">new</span> WorksetConfiguration(WorksetConfigurationOption.CloseAllWorksets);</span><br><span class="line">        <span class="comment">// Set list of worksets for opening </span></span><br><span class="line">        openConfig.Open(worksetIds);</span><br><span class="line">        openOptions.SetOpenWorksetsConfiguration(openConfig);</span><br><span class="line">        doc = app.OpenDocumentFile(projectPath, openOptions);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception e)</span><br><span class="line">    &#123;</span><br><span class="line">        TaskDialog.Show(<span class="string">&quot;Open File Failed&quot;</span>, e.Message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> doc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另一个选项是在打开文档时仅打开上次查看的工作集。</p>
<p>代码区域：打开上次查看的工作集</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Document <span class="title">OpenLastViewed</span>(<span class="params">UIApplication uiApplication</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Application application = uiApplication.Application;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Setup options</span></span><br><span class="line">    OpenOptions options1 = <span class="keyword">new</span> OpenOptions();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Default config opens all.  Close all first, then open last viewed to get the correct settings.</span></span><br><span class="line">    WorksetConfiguration worksetConfig = <span class="keyword">new</span> WorksetConfiguration(WorksetConfigurationOption.OpenLastViewed);</span><br><span class="line">    options1.SetOpenWorksetsConfiguration(worksetConfig);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Open the document</span></span><br><span class="line">    Document openedDoc = application.OpenDocumentFile(GetWSAPIModelPath(<span class="string">&quot;WorkaredFileSample.rvt&quot;</span>), options1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> openedDoc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ModelPath <span class="title">GetWSAPIModelPath</span>(<span class="params"><span class="built_in">string</span> fileName</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Utility to get a local path for a target model file</span></span><br><span class="line">    FileInfo filePath = <span class="keyword">new</span> FileInfo(Path.Combine(<span class="string">@&quot;C:\Documents\Revit Projects&quot;</span>, fileName));</span><br><span class="line">    ModelPath mp = ModelPathUtils.ConvertUserVisiblePathToModelPath(filePath.FullName);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下两个示例演示了如何首先从磁盘或Revit服务器创建新的本地，然后将其打开。请注意，下面的示例使用了上一个示例中使用的GetWSAPIModelPath（）方法。</p>
<p>代码区域：从磁盘打开新本地</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Document <span class="title">OpenNewLocalFromDisk</span>(<span class="params">UIApplication uiApplication</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Create new local from a disk location</span></span><br><span class="line">    ModelPath newLocalPath = GetWSAPIModelPath(<span class="string">&quot;LocalWorksharing.rvt&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> (OpenNewLocalFromModelPath(uiApplication.Application, GetWSAPIModelPath(<span class="string">&quot;NewLocalWorksharing.rvt&quot;</span>), newLocalPath));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Document <span class="title">OpenNewLocalFromModelPath</span>(<span class="params">Application app, ModelPath centralPath, ModelPath localPath</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Create the new local at the given path</span></span><br><span class="line">    WorksharingUtils.CreateNewLocal(centralPath, localPath);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Select specific worksets to open</span></span><br><span class="line">    <span class="comment">// First get a list of worksets from the unopened document</span></span><br><span class="line">    IList worksets = WorksharingUtils.GetUserWorksetInfo(localPath);</span><br><span class="line">    List worksetsToOpen = <span class="keyword">new</span> List();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">foreach</span> (WorksetPreview preview <span class="keyword">in</span> worksets)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Match worksets to open with criteria</span></span><br><span class="line">        <span class="keyword">if</span> (preview.Name.StartsWith(<span class="string">&quot;O&quot;</span>))</span><br><span class="line">            worksetsToOpen.Add(preview.Id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Setup option to open the target worksets</span></span><br><span class="line">    <span class="comment">// First close all, then set specific ones to open</span></span><br><span class="line">    WorksetConfiguration worksetConfig = <span class="keyword">new</span> WorksetConfiguration(WorksetConfigurationOption.CloseAllWorksets);</span><br><span class="line">    worksetConfig.Open(worksetsToOpen);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Open the new local</span></span><br><span class="line">    OpenOptions options1 = <span class="keyword">new</span> OpenOptions();</span><br><span class="line">    options1.SetOpenWorksetsConfiguration(worksetConfig);</span><br><span class="line">    Document openedDoc = app.OpenDocumentFile(localPath, options1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> openedDoc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面的示例使用作为上一示例的一部分演示的OpenNewLocalFromModelPath（）方法。</p>
<p>代码区域：从Revit Server打开新的本地</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> </span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> Get the server path for a particular model and open a new local copy</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Document <span class="title">OpenNewLocalFromServer</span>(<span class="params">UIApplication uiApp</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Create new local from a server location</span></span><br><span class="line">    Application app = uiApp.Application;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get the host id/IP of the server</span></span><br><span class="line">    String hostId = app.GetRevitServerNetworkHosts().First();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// try to get the server path for the particular model on the server</span></span><br><span class="line">    String rootFolder = <span class="string">&quot;|&quot;</span>;</span><br><span class="line">    ModelPath serverPath = FindWSAPIModelPathOnServer(app, hostId, rootFolder, <span class="string">&quot;WorksharingOnServer.rvt&quot;</span>);</span><br><span class="line"></span><br><span class="line">    ModelPath newLocalPath = GetWSAPIModelPath(<span class="string">&quot;WorksharingLocalFromServer.rvt&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> (OpenNewLocalFromModelPath(uiApp.Application, serverPath, newLocalPath));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> </span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> Uses the Revit Server REST API to recursively search the folders of the Revit Server for a particular model.</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> </span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ModelPath <span class="title">FindWSAPIModelPathOnServer</span>(<span class="params">Application app, <span class="built_in">string</span> hostId, <span class="built_in">string</span> folderName, <span class="built_in">string</span> fileName</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Connect to host to find list of available models (the &quot;/contents&quot; flag)</span></span><br><span class="line">    XmlDictionaryReader reader = GetResponse(app, hostId, folderName + <span class="string">&quot;/contents&quot;</span>);</span><br><span class="line">    <span class="built_in">bool</span> found = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Look for the target model name in top level folder</span></span><br><span class="line">    List folders = <span class="keyword">new</span> List();</span><br><span class="line">    <span class="keyword">while</span> (reader.Read())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Save a list of subfolders, if found</span></span><br><span class="line">        <span class="keyword">if</span> (reader.NodeType == XmlNodeType.Element &amp;&amp; reader.Name == <span class="string">&quot;Folders&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (reader.Read())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (reader.NodeType == XmlNodeType.EndElement &amp;&amp; reader.Name == <span class="string">&quot;Folders&quot;</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (reader.NodeType == XmlNodeType.Element &amp;&amp; reader.Name == <span class="string">&quot;Name&quot;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    reader.Read();</span><br><span class="line">                    folders.Add(reader.Value);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Check for a matching model at this folder level</span></span><br><span class="line">        <span class="keyword">if</span> (reader.NodeType == XmlNodeType.Element &amp;&amp; reader.Name == <span class="string">&quot;Models&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            found = FindModelInServerResponseJson(reader, fileName);</span><br><span class="line">            <span class="keyword">if</span> (found)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    reader.Close();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Build the model path to match the found model on the server</span></span><br><span class="line">    <span class="keyword">if</span> (found)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Server URLs use &quot;|&quot; for folder separation, Revit API uses &quot;/&quot;</span></span><br><span class="line">        String folderNameFragment = folderName.Replace(<span class="string">&#x27;|&#x27;</span>, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Add trailing &quot;/&quot; if not present</span></span><br><span class="line">        <span class="keyword">if</span> (!folderNameFragment.EndsWith(<span class="string">&quot;/&quot;</span>))</span><br><span class="line">            folderNameFragment += <span class="string">&quot;/&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Build server path</span></span><br><span class="line">        ModelPath modelPath = <span class="keyword">new</span> ServerPath(hostId, folderNameFragment + fileName);</span><br><span class="line">        <span class="keyword">return</span> modelPath;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Try subfolders</span></span><br><span class="line">        <span class="keyword">foreach</span> (String folder <span class="keyword">in</span> folders)</span><br><span class="line">        &#123;</span><br><span class="line">            ModelPath modelPath = FindWSAPIModelPathOnServer(app, hostId, folder, fileName);</span><br><span class="line">            <span class="keyword">if</span> (modelPath != <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">return</span> modelPath;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This string is different for each RevitServer version</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">string</span> s_revitServerVersion = <span class="string">&quot;/RevitServerAdminRESTService2014/AdminRESTService.svc/&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> </span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> Connect to server to get list of available models and return server response</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> </span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> XmlDictionaryReader <span class="title">GetResponse</span>(<span class="params">Application app, <span class="built_in">string</span> hostId, <span class="built_in">string</span> info</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Create request    WebRequest request = WebRequest.Create(&quot;http://&quot; + hostId + s_revitServerVersion + info);</span></span><br><span class="line">    request.Method = <span class="string">&quot;GET&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add the information the request needs</span></span><br><span class="line"></span><br><span class="line">    request.Headers.Add(<span class="string">&quot;User-Name&quot;</span>, app.Username);</span><br><span class="line">    request.Headers.Add(<span class="string">&quot;User-Machine-Name&quot;</span>, app.Username);</span><br><span class="line">    request.Headers.Add(<span class="string">&quot;Operation-GUID&quot;</span>, Guid.NewGuid().ToString());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read the response</span></span><br><span class="line">    XmlDictionaryReaderQuotas quotas =</span><br><span class="line">        <span class="keyword">new</span> XmlDictionaryReaderQuotas();</span><br><span class="line">    XmlDictionaryReader jsonReader =</span><br><span class="line">        JsonReaderWriterFactory.CreateJsonReader(request.GetResponse().GetResponseStream(), quotas);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> jsonReader;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> </span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> Read through server response to find particular model</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> </span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">bool</span> <span class="title">FindModelInServerResponseJson</span>(<span class="params">XmlDictionaryReader reader, <span class="built_in">string</span> fileName</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Read through entries in this section</span></span><br><span class="line">    <span class="keyword">while</span> (reader.Read())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (reader.NodeType == XmlNodeType.EndElement &amp;&amp; reader.Name == <span class="string">&quot;Models&quot;</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (reader.NodeType == XmlNodeType.Element &amp;&amp; reader.Name == <span class="string">&quot;Name&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            reader.Read();</span><br><span class="line">            String modelName = reader.Value;</span><br><span class="line">            <span class="keyword">if</span> (modelName.Equals(fileName))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// Match found, stop looping and return</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>从中央分离开</strong></p>
<p>如果附加模块将处理工作共享文件，但不需要进行永久更改，则可以打开与中心文件分离的模型。</p>
<p>代码区域：打开分离</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Document <span class="title">OpenDetached</span>(<span class="params">Application application, ModelPath modelPath</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    OpenOptions options1 = <span class="keyword">new</span> OpenOptions();</span><br><span class="line"></span><br><span class="line">    options1.DetachFromCentralOption = DetachFromCentralOption.DetachAndDiscardWorksets;</span><br><span class="line">    Document openedDoc = application.OpenDocumentFile(modelPath, options1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> openedDoc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果应用程序只需要对服务器文件进行只读访问，下面的示例演示了如何在本地复制服务器模型并分离地打开它。请注意，此代码示例重用了前面示例中演示的方法。</p>
<p>代码区域：复制并打开分离</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Document <span class="title">CopyAndOpenDetached</span>(<span class="params">UIApplication uiApp</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Copy a server model locally and open detached</span></span><br><span class="line">    Application application = uiApp.Application;</span><br><span class="line">    String hostId = application.GetRevitServerNetworkHosts().First();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Try to get the server path for the particular model on the server</span></span><br><span class="line">    String rootFolder = <span class="string">&quot;|&quot;</span>;</span><br><span class="line">    ModelPath serverPath = FindWSAPIModelPathOnServer(application, hostId, rootFolder, <span class="string">&quot;ServerModel.rvt&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// For debugging</span></span><br><span class="line">    String sourcePath = ModelPathUtils.ConvertModelPathToUserVisiblePath(serverPath);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Setup the target location for the copy</span></span><br><span class="line">    ModelPath localPath = GetWSAPIModelPath(<span class="string">&quot;CopiedModel.rvt&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy, allowing overwrite</span></span><br><span class="line">    application.CopyModel(serverPath, ModelPathUtils.ConvertModelPathToUserVisiblePath(localPath), <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Open the copy as detached</span></span><br><span class="line">    Document openedDoc = OpenDetached(application, localPath);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> openedDoc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="可见性和显示"><a href="#可见性和显示" class="headerlink" title="可见性和显示"></a>可见性和显示</h2><p><strong>可见性</strong></p>
<p>可以使用View.SetWorksetVisibility（）为特定视图设置工作集的可见性。“工作集可见性”（WorksetVisibility）选项为“可见”（Visible）（如果工作集处于打开状态，则可见）、“隐藏”（Hidden）和“全局设置”（GlobalSetting）（表示不替代视图的设置）。相应的View.GetWorksetVisibility（）方法检索该视图中工作集的当前可见性设置。但是，此方法不考虑工作集当前是否处于打开状态。若要确定某个工作集在视图中是否可见（包括考虑该工作集是打开还是关闭），请使用View.IsWorksetVisible（）。</p>
<p>WorksetDefaultVisibilitySettings类管理文档中工作集的默认可见性。它不适用于家庭文件。如果在文档中禁用了工作共享，则所有图元都将移动到一个工作集中;默认情况下，无论当前设置如何，该工作集以及在重新启用工作共享时（重新）创建的任何工作集都是可见的。</p>
<p>下面的示例在给定视图中隐藏工作集，并在默认情况下在其他视图中隐藏该工作集。</p>
<p>代码区域：隐藏工作集</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">HideWorkset</span>(<span class="params">Document doc, View view, WorksetId worksetId</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// get the current visibility</span></span><br><span class="line">    WorksetVisibility visibility = view.GetWorksetVisibility(worksetId);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// and set it to &#x27;Hidden&#x27; if it is not hidden yet</span></span><br><span class="line">    <span class="keyword">if</span> (visibility != WorksetVisibility.Hidden)</span><br><span class="line">    &#123;</span><br><span class="line">        view.SetWorksetVisibility(worksetId, WorksetVisibility.Hidden);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get the workset’s default visibility    WorksetDefaultVisibilitySettings defaultVisibility = WorksetDefaultVisibilitySettings.GetWorksetDefaultVisibilitySettings(doc);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// and making sure it is set to &#x27;false&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">true</span> == defaultVisibility.IsWorksetVisible(worksetId))</span><br><span class="line">    &#123;</span><br><span class="line">        defaultVisibility.SetWorksetVisibility(worksetId, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>显示模式</strong></p>
<p>除了获取和设置有关工作集可见性的信息外，View类还提供了访问有关工作共享显示模式和设置的信息的方法。WorksharingDisplayMode枚举指示视图所处的模式（如果有）：</p>
<table>
<thead>
<tr>
<th>Member Name 成员名称</th>
<th>Description 描述</th>
</tr>
</thead>
<tbody><tr>
<td>Off</td>
<td>无活动的工作共享显示模式。</td>
</tr>
<tr>
<td>CheckoutStatus</td>
<td>视图显示元素的签出状态。</td>
</tr>
<tr>
<td>Owners</td>
<td>视图显示元素的特定所有者。</td>
</tr>
<tr>
<td>ModelUpdates</td>
<td>视图正在显示模型更新。</td>
</tr>
<tr>
<td>Worksets</td>
<td>视图显示每个图元指定给的工作集。</td>
</tr>
</tbody></table>
<p>代码区域：激活不同的工作共享显示模式</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">Execute</span>(<span class="params">ExternalCommandData commandData, <span class="keyword">ref</span> <span class="built_in">string</span> message, ElementSet elements</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    View activeView = commandData.View;</span><br><span class="line">    Document doc = activeView.Document;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Prepare settings</span></span><br><span class="line">    Color red = <span class="keyword">new</span> Color(<span class="number">0xFF</span>, <span class="number">0x00</span>, <span class="number">0x00</span>);</span><br><span class="line">    WorksharingDisplayGraphicSettings settingsToApply = <span class="keyword">new</span> WorksharingDisplayGraphicSettings(<span class="literal">true</span>, red);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Toggle mode based on the current mode</span></span><br><span class="line">    <span class="keyword">using</span> (Transaction t = <span class="keyword">new</span> Transaction(doc, <span class="string">&quot;Toggle display mode&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        t.Start();</span><br><span class="line"></span><br><span class="line">        WorksharingDisplaySettings settings = WorksharingDisplaySettings.GetOrCreateWorksharingDisplaySettings(doc);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (activeView.GetWorksharingDisplayMode())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> WorksharingDisplayMode.Off:</span><br><span class="line">                activeView.SetWorksharingDisplayMode(WorksharingDisplayMode.CheckoutStatus);</span><br><span class="line">                settings.SetGraphicOverrides(CheckoutStatus.OwnedByOtherUser, settingsToApply);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> WorksharingDisplayMode.CheckoutStatus:</span><br><span class="line">                activeView.SetWorksharingDisplayMode(WorksharingDisplayMode.ModelUpdates);</span><br><span class="line">                settings.SetGraphicOverrides(ModelUpdatesStatus.UpdatedInCentral, settingsToApply);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> WorksharingDisplayMode.ModelUpdates:</span><br><span class="line">                activeView.SetWorksharingDisplayMode(WorksharingDisplayMode.Owners);</span><br><span class="line">                settings.SetGraphicOverrides(<span class="string">&quot;Target user&quot;</span>, settingsToApply);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> WorksharingDisplayMode.Owners:</span><br><span class="line">                activeView.SetWorksharingDisplayMode(WorksharingDisplayMode.Worksets);</span><br><span class="line">                settings.SetGraphicOverrides(doc.GetWorksetTable().GetActiveWorksetId(), settingsToApply);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> WorksharingDisplayMode.Worksets:</span><br><span class="line">                activeView.SetWorksharingDisplayMode(WorksharingDisplayMode.Off);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        t.Commit();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Result.Succeeded;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>图形设置</strong></p>
<p>WorksharingDisplaySettings类控制元素在任何工作共享显示模式下显示时的显示方式。存储在这些设置中的颜色是通用设置，由模型中的所有用户共享。是否应用给定的颜色是特定于当前用户的，不会被其他用户共享。请注意，即使在未工作共享的模型中，这些设置也可用。这是为了允许在启用工作集之前预配置显示设置，以便可以将它们存储在样板文件中。</p>
<p>代码区域：工作共享显示图形设置</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> WorksharingDisplayGraphicSettings <span class="title">GetWorksharingDisplaySettings</span>(<span class="params">Document doc, String userName, WorksetId worksetId, <span class="built_in">bool</span> ownedbyCurrentUser</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    WorksharingDisplayGraphicSettings graphicSettings;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get or create a WorksharingDisplaySettings current active document</span></span><br><span class="line">    WorksharingDisplaySettings displaySettings = WorksharingDisplaySettings.GetOrCreateWorksharingDisplaySettings(doc);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get graphic settings for a user, if specified</span></span><br><span class="line">    <span class="keyword">if</span> (!String.IsNullOrEmpty(userName))</span><br><span class="line">        graphicSettings = displaySettings.GetGraphicOverrides(userName);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// get graphicSettings for a workset, if specified</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (worksetId != WorksetId.InvalidWorksetId)</span><br><span class="line">        graphicSettings = displaySettings.GetGraphicOverrides(worksetId);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get graphic settings for the OwnedByCurrentUser status</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (ownedbyCurrentUser)</span><br><span class="line">        graphicSettings = displaySettings.GetGraphicOverrides(CheckoutStatus.OwnedByCurrentUser);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// otherwise get graphic settings for the CurrentWithCentral status</span></span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">          graphicSettings = displaySettings.GetGraphicOverrides(ModelUpdatesStatus.CurrentWithCentral);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> graphicSettings;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重载方法WorksharingDisplaySettings.SetGraphicOverrides（）根据给定条件设置分配给元素的图形替代。</p>
<p>代码区域：图形覆盖</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetWorksharingDisplaySettings</span>(<span class="params">Document doc, WorksetId worksetId, String userName</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    String message = String.Empty;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get or create a WorksharingDisplaySettings current active document</span></span><br><span class="line">    WorksharingDisplaySettings displaySettings = WorksharingDisplaySettings.GetOrCreateWorksharingDisplaySettings(doc);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set a new graphicSettings for CheckoutStatus - NotOwned</span></span><br><span class="line">    WorksharingDisplayGraphicSettings graphicSettings = <span class="keyword">new</span> WorksharingDisplayGraphicSettings(<span class="literal">true</span>, <span class="keyword">new</span> Color(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    displaySettings.SetGraphicOverrides(CheckoutStatus.NotOwned, graphicSettings);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set a new graphicSettings for ModelUpdatesStatus - CurrentWithCentral</span></span><br><span class="line">    graphicSettings = <span class="keyword">new</span> WorksharingDisplayGraphicSettings(<span class="literal">true</span>, <span class="keyword">new</span> Color(<span class="number">128</span>, <span class="number">128</span>, <span class="number">0</span>));</span><br><span class="line">    displaySettings.SetGraphicOverrides(ModelUpdatesStatus.CurrentWithCentral, graphicSettings);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set a new graphicSettings by a given userName</span></span><br><span class="line">    graphicSettings = <span class="keyword">new</span> WorksharingDisplayGraphicSettings(<span class="literal">true</span>, <span class="keyword">new</span> Color(<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>));</span><br><span class="line">    displaySettings.SetGraphicOverrides(userName, graphicSettings);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set a new graphicSettings by a given workset Id</span></span><br><span class="line">    graphicSettings = <span class="keyword">new</span> WorksharingDisplayGraphicSettings(<span class="literal">true</span>, <span class="keyword">new</span> Color(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>));</span><br><span class="line">    displaySettings.SetGraphicOverrides(worksetId, graphicSettings);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>WorksharingDisplaySettings类还可用于控制在文档的显示用户中列出哪些用户。RemoveUsers（）方法从显示的用户列表中删除用户，并永久放弃对图形的任何自定义。只有在文档中不拥有任何元素的用户才能被删除。RestoreUsers（）方法将删除的用户添加回显示的用户列表，并允许为这些用户定制图形。请注意，任何恢复的用户都将显示默认的图形覆盖，并且删除用户之前存在的任何自定义设置都不会恢复。</p>
<p>代码区域：删除用户</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">RemoveAndRestoreUsers</span>(<span class="params">Document doc</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// get or create a WorksharingDisplaySettings current active document</span></span><br><span class="line">    WorksharingDisplaySettings displaySettings = WorksharingDisplaySettings.GetOrCreateWorksharingDisplaySettings(doc);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get all users with GraphicOverrides</span></span><br><span class="line">    ICollection users = displaySettings.GetAllUsersWithGraphicOverrides();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// remove the users from the display settings (they will not have graphic overrides anymore)</span></span><br><span class="line">    ICollection outUserList;</span><br><span class="line">    displaySettings.RemoveUsers(doc, users, <span class="keyword">out</span> outUserList);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// show the current list of removed users</span></span><br><span class="line">    ICollection removedUsers = displaySettings.GetRemovedUsers();</span><br><span class="line"></span><br><span class="line">    String message = <span class="string">&quot;Current list of removed users: &quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (removedUsers.Count &gt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">foreach</span> (String user <span class="keyword">in</span> removedUsers)</span><br><span class="line">        &#123;</span><br><span class="line">           message += <span class="string">&quot;\n&quot;</span> + user;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        message = <span class="string">&quot;[Empty]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TaskDialog.Show(<span class="string">&quot;Users Removed&quot;</span>, message);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// restore the previously removed users</span></span><br><span class="line">    <span class="built_in">int</span> number = displaySettings.RestoreUsers(outUserList);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// again, show the current list of removed users</span></span><br><span class="line">    <span class="comment">// it should not contain the users that were restored</span></span><br><span class="line">    removedUsers = displaySettings.GetRemovedUsers();</span><br><span class="line"></span><br><span class="line">    message = <span class="string">&quot;Current list of removed users: &quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (removedUsers.Count &gt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">foreach</span> (String user <span class="keyword">in</span> removedUsers)</span><br><span class="line">        &#123;</span><br><span class="line">           message += <span class="string">&quot;\n&quot;</span> + user;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        message = <span class="string">&quot;[Empty]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TaskDialog.Show(<span class="string">&quot;Removed Users Restored&quot;</span>, message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="工作共享文件管理"><a href="#工作共享文件管理" class="headerlink" title="工作共享文件管理"></a>工作共享文件管理</h2><p>有几种文档方法可用于工作共享项目文件。</p>
<p><strong>启用工作共享</strong></p>
<p>如果文档尚未进行工作共享（这可以通过Document.IsWorkshared属性确定），则可以使用Document.EnableWorksharing（）方法通过Revit API启用工作共享。此命令将清除文档的撤消历史记录，因此此命令和在此之前执行的其他命令无法撤消。此外，所有显式启动的事务阶段（例如事务、事务组和子事务）必须在调用EnableWorksharing（）之前完成。</p>
<p><strong>重新载入最新</strong></p>
<p>方法Document. BulladLatest（）从中心模型中检索更改（由于与中心模型进行了一次或多次同步），并将这些更改合并到当前会话中。</p>
<p>下面的示例在与用户确认可以更新当前会话后，使用PwadLatest（）更新当前会话。</p>
<p>代码区域：从Central重新加载</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ReloadLatestWithMessage</span>(<span class="params">Document doc</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Tell user what we&#x27;re doing</span></span><br><span class="line">    TaskDialog td = <span class="keyword">new</span> TaskDialog(<span class="string">&quot;Alert&quot;</span>);</span><br><span class="line">    td.MainInstruction = <span class="string">&quot;Application &#x27;Automatic element creator&#x27; needs to reload changes from central in order to proceed.&quot;</span>;</span><br><span class="line">    td.MainContent = <span class="string">&quot;This will update your local with all changes currently in the central model.  This operation &quot;</span> +</span><br><span class="line">                        <span class="string">&quot;may take some time depending on the number of changes available on the central.&quot;</span>;</span><br><span class="line">    td.CommonButtons = TaskDialogCommonButtons.Ok | TaskDialogCommonButtons.Cancel;</span><br><span class="line"></span><br><span class="line">    TaskDialogResult result = td.Show();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result == TaskDialogResult.Ok)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// There are no currently customizable user options for ReloadLatest.</span></span><br><span class="line">        doc.ReloadLatest(<span class="keyword">new</span> ReloadLatestOptions());</span><br><span class="line">        TaskDialog.Show(<span class="string">&quot;Proceeding...&quot;</span>, <span class="string">&quot;Reload operation completed, proceeding with updates.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        TaskDialog.Show(<span class="string">&quot;Canceled.&quot;</span>, <span class="string">&quot;Reload operation canceled, so changes will not be made.  Return to this command later when ready to reload.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>与中心模型同步</strong></p>
<p>方法Document.SynchronizeWithCentral（）会重新加载中心模型中的所有更改，以便当前会话保持最新，然后将本地更改保存回中心。即使未进行任何更改，也会执行保存到中心文件。</p>
<p>使用SynchronizeWithCentral（）时，可以指定用于访问中心模型以及与中心模型同步的选项。访问中心模型的主要选项是确定在中心模型被锁定时调用的行为方式。由于同步需要临时锁定中心模型，因此如果模型已锁定，则无法执行同步。默认行为是等待并反复尝试锁定中心模型，以便继续同步。可以使用SynchronizeWithCentral（）方法的TransactWithCentralOptions参数重写此行为。</p>
<p>该方法的SynchronizeWithCentralOptions参数用于设置实际同步的选项，例如在同步过程中是否应放弃当前用户拥有的图元或工作集。</p>
<p>在下面的示例中，尝试与中心模型同步。如果中心模型被锁定，它将立即放弃。</p>
<p>代码区域：Cumberwith Central</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SyncWithoutRelinquishing</span>(<span class="params">Document doc</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Set options for accessing central model</span></span><br><span class="line">    TransactWithCentralOptions transOpts = <span class="keyword">new</span> TransactWithCentralOptions();</span><br><span class="line">    SynchLockCallback transCallBack = <span class="keyword">new</span> SynchLockCallback();</span><br><span class="line">    <span class="comment">// Override default behavior of waiting to try again if the central model is locked</span></span><br><span class="line">    transOpts.SetLockCallback(transCallBack);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set options for synchronizing with central</span></span><br><span class="line">    SynchronizeWithCentralOptions syncOpts = <span class="keyword">new</span> SynchronizeWithCentralOptions();</span><br><span class="line">    <span class="comment">// Sync without relinquishing any checked out elements or worksets</span></span><br><span class="line">    RelinquishOptions relinquishOpts = <span class="keyword">new</span> RelinquishOptions(<span class="literal">false</span>);</span><br><span class="line">    syncOpts.SetRelinquishOptions(relinquishOpts);</span><br><span class="line">    <span class="comment">// Do not automatically save local model after sync</span></span><br><span class="line">    syncOpts.SaveLocalAfter = <span class="literal">false</span>;</span><br><span class="line">    syncOpts.Comment = <span class="string">&quot;Changes to Workset1&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        doc.SynchronizeWithCentral(transOpts, syncOpts);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception e)</span><br><span class="line">    &#123;</span><br><span class="line">        TaskDialog.Show(<span class="string">&quot;Synchronize Failed&quot;</span>, e.Message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">SynchLockCallback</span> : <span class="title">ICentralLockedCallback</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// If unable to lock central, give up rather than waiting</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">ShouldWaitForLockAvailability</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在下一个示例中，用户在同步之前会收到一条消息，并可以选择在同步时是放弃所有图元，还是保持工作集的检出状态。</p>
<p>代码区域：带消息同步中心</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SynchWithCentralWithMessage</span>(<span class="params">Document doc</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Checkout workset (for use with &quot;keep checked out worksets&quot; option later)</span></span><br><span class="line">    FilteredWorksetCollector fwc = <span class="keyword">new</span> FilteredWorksetCollector(doc);</span><br><span class="line">    fwc.OfKind(WorksetKind.UserWorkset);</span><br><span class="line">    Workset workset1 = fwc.First(ws =&gt; ws.Name == <span class="string">&quot;Workset1&quot;</span>);</span><br><span class="line"></span><br><span class="line">    WorksharingUtils.CheckoutWorksets(doc, <span class="keyword">new</span> WorksetId[] &#123; workset1.Id &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make a change</span></span><br><span class="line">    <span class="keyword">using</span> (Transaction t = <span class="keyword">new</span> Transaction(doc, <span class="string">&quot;Add Level&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        t.Start();</span><br><span class="line">        Level.Create(doc, <span class="number">100</span>);</span><br><span class="line">        t.Commit();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Tell user what we&#x27;re doing</span></span><br><span class="line">    TaskDialog td = <span class="keyword">new</span> TaskDialog(<span class="string">&quot;Alert&quot;</span>);</span><br><span class="line">    td.MainInstruction = <span class="string">&quot;Application &#x27;Automatic element creator&#x27; has made changes and is prepared to synchronize with central.&quot;</span>;</span><br><span class="line">    td.MainContent = <span class="string">&quot;This will update central with all changes currently made in the project by the application or by the user.  This operation &quot;</span> +</span><br><span class="line">                        <span class="string">&quot;may take some time depending on the number of changes made by the app and by the user.&quot;</span>;</span><br><span class="line"></span><br><span class="line">    td.AddCommandLink(TaskDialogCommandLinkId.CommandLink1, <span class="string">&quot;Do not synchronize at this time.&quot;</span>);</span><br><span class="line">    td.AddCommandLink(TaskDialogCommandLinkId.CommandLink2, <span class="string">&quot;Synchronize and relinquish all elements.&quot;</span>);</span><br><span class="line">    td.AddCommandLink(TaskDialogCommandLinkId.CommandLink3, <span class="string">&quot;Synchronize but keep checked out worksets.&quot;</span>);</span><br><span class="line">    td.DefaultButton = TaskDialogResult.CommandLink1;</span><br><span class="line"></span><br><span class="line">    TaskDialogResult result = td.Show();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (result)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> TaskDialogResult.CommandLink1:</span><br><span class="line">        <span class="literal">default</span>:</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// Do not synch.  Nothing to do.</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">case</span> TaskDialogResult.CommandLink2:</span><br><span class="line">        <span class="keyword">case</span> TaskDialogResult.CommandLink3:</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// Prepare to synch</span></span><br><span class="line">                <span class="comment">// TransactWithCentralOptions has to do with the behavior related to locked or busy central models.</span></span><br><span class="line">                <span class="comment">// We&#x27;ll use the default behavior.</span></span><br><span class="line">                TransactWithCentralOptions twcOpts = <span class="keyword">new</span> TransactWithCentralOptions();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Setup synch-with-central options (add a comment about our change)</span></span><br><span class="line">                SynchronizeWithCentralOptions swcOpts = <span class="keyword">new</span> SynchronizeWithCentralOptions();</span><br><span class="line">                swcOpts.Comment = <span class="string">&quot;Synchronized by &#x27;Automatic element creator&#x27; with user acceptance.&quot;</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (result == TaskDialogResult.CommandLink3)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// Setup relinquish options to keep user worksets checked out</span></span><br><span class="line">                    RelinquishOptions rOptions = <span class="keyword">new</span> RelinquishOptions(<span class="literal">true</span>);</span><br><span class="line">                    rOptions.UserWorksets = <span class="literal">false</span>;</span><br><span class="line">                    swcOpts.SetRelinquishOptions(rOptions);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                doc.SynchronizeWithCentral(twcOpts, swcOpts);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>创建新的本地模型</strong></p>
<p>WorksharingUtils. NETNewLocal（）方法将中心模型复制到新的本地文件。此方法不打开新文件。有关创建新的本地模型并将其打开的示例，请参见打开工作共享文档</p>
<h2 id="注：翻译自Revit-API-Developers-Guide"><a href="#注：翻译自Revit-API-Developers-Guide" class="headerlink" title="注：翻译自Revit API Developers Guide"></a><em><strong>注：</strong></em>翻译自<a href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_html">Revit API Developers Guide</a></h2>]]></content>
      <categories>
        <category>Revit二次开发人员指南</category>
      </categories>
      <tags>
        <tag>Revit</tag>
      </tags>
  </entry>
</search>
