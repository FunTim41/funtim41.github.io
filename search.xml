<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>26结构工程</title>
    <url>/2024/12/24/%E4%BA%8C%E5%BC%80%E6%8C%87%E5%8D%97/26%E7%BB%93%E6%9E%84%E5%B7%A5%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="结构工程"><a href="#结构工程" class="headerlink" title="结构工程"></a><a href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_Discipline_Specific_Functionality_Structural_Engineering_html">结构工程</a></h1><p>以下各节介绍了仅与Revit的结构工程功能相关的API功能：</p>
<ul>
<li><p>结构模型元素-讨论仅与Revit的结构工程功能相关的特定元素及其属性。</p>
</li>
<li><p>AnalyticalModel -讨论与分析模型相关的类，如AnalyticalModel、RigidLink和AnalyticalModelSupport。</p>
</li>
<li><p>AnalyticalLink -讨论在分析梁和柱之间创建新的分析链接。</p>
</li>
<li><p>荷载-讨论荷载设置和三种荷载。</p>
</li>
</ul>
<p>您的分析链接-为希望将Revit链接到某些Structural Analysis应用程序的API用户提供建议。</p>
<p>本章包含一些高级主题。如果您不熟悉Revit Platform API，请先阅读基本部分，如“入门”、“元素要素”、“参数”等。</p>
<ul>
<li>本节中的主题<ul>
<li>结构模型元素</li>
<li>分析模型<br>在结构工程中，分析模型是结构物理模型的工程描述。</li>
<li>荷载<br>以下部分确定荷载设置并讨论荷载限制指南。</li>
<li>Analysis Link分析链接</li>
<li>Analytical Links</li>
</ul>
</li>
</ul>
<h2 id="结构模型元素"><a href="#结构模型元素" class="headerlink" title="结构模型元素"></a>结构模型元素</h2><p>结构模型元素实际上是支撑结构的元素，如柱、钢筋、桁架等。以下部分介绍如何操作这些元素。</p>
<p>本节中包含的模型元素特定于Revit的结构工程功能。有关其他结构元素类的详细信息，请参见“墙、楼板、屋顶和洞口”和“族”中的相应部分。</p>
<p>本节中的主题</p>
<ul>
<li>结构柱、梁和支撑</li>
<li>桁架</li>
<li>加强<br>Revit API提供了用于管理有效主体（如混凝土柱、梁、墙、基础和结构楼板）中的钢筋（如钢筋、钢筋或钢筋网）的类。</li>
<li>边界条件</li>
<li>板</li>
</ul>
<h3 id="结构柱、梁和支撑"><a href="#结构柱、梁和支撑" class="headerlink" title="结构柱、梁和支撑"></a>结构柱、梁和支撑</h3><p><strong>结构柱、梁和支撑</strong></p>
<p>结构柱、梁和支撑元素都由FamilyInstance类表示。它们由StructuralType属性区分。</p>
<p>代码区域29-1：柱、梁和支撑的区别</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetStructuralType</span>(<span class="params">FamilyInstance familyInstance</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> message = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">switch</span> (familyInstance.StructuralType)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> StructuralType.Beam:</span><br><span class="line">            message = <span class="string">&quot;FamilyInstance is a beam.&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> StructuralType.Brace:</span><br><span class="line">            message = <span class="string">&quot;FamilyInstance is a brace.&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> StructuralType.Column:</span><br><span class="line">            message = <span class="string">&quot;FamilyInstance is a column.&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> StructuralType.Footing:</span><br><span class="line">            message = <span class="string">&quot;FamilyInstance is a footing.&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="literal">default</span>:</span><br><span class="line">            message = <span class="string">&quot;FamilyInstance is non-structural or unknown framing.&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>,message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以使用类别过滤出与结构柱、梁和支撑对应的FamilySymbol对象。结构梁和支撑的类别为BuiltInCategory.OST_StructuralFraming。结构柱的类别为BuiltInCategory.OST_StructuralColumns。</p>
<p>代码区域29-2：使用BuiltInCategory.OST_StructuralFraming</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetBeamAndColumnSymbols</span>(<span class="params">Document document</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    List&lt;FamilySymbol&gt; columnTypes = <span class="keyword">new</span> List&lt;FamilySymbol&gt;();</span><br><span class="line">    List&lt;FamilySymbol&gt; framingTypes = <span class="keyword">new</span> List&lt;FamilySymbol&gt;();</span><br><span class="line">    FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">    ICollection&lt;Element&gt; elements = collector.OfClass(<span class="keyword">typeof</span>(Family)).ToElements();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">foreach</span>(Element element <span class="keyword">in</span> elements)</span><br><span class="line">    &#123;</span><br><span class="line">        Family family = element <span class="keyword">as</span> Family;</span><br><span class="line">        Category category = family.FamilyCategory;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != category)</span><br><span class="line">        &#123;</span><br><span class="line">            ISet&lt;ElementId&gt; familySymbolIds = family.GetFamilySymbolIds();</span><br><span class="line">            <span class="keyword">if</span> ((<span class="built_in">int</span>)BuiltInCategory.OST_StructuralColumns == category.Id.IntegerValue)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">foreach</span> (ElementId id <span class="keyword">in</span> familySymbolIds)</span><br><span class="line">                &#123;</span><br><span class="line">                    FamilySymbol symbol = family.Document.GetElement(id) <span class="keyword">as</span> FamilySymbol;</span><br><span class="line">                    columnTypes.Add(symbol);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((<span class="built_in">int</span>)BuiltInCategory.OST_StructuralFraming == category.Id.IntegerValue)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">foreach</span> (ElementId id <span class="keyword">in</span> familySymbolIds)</span><br><span class="line">                &#123;</span><br><span class="line">                    FamilySymbol symbol = family.Document.GetElement(id) <span class="keyword">as</span> FamilySymbol;</span><br><span class="line">                    framingTypes.Add(symbol);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> message = <span class="string">&quot;Column Types: &quot;</span>;</span><br><span class="line">    <span class="keyword">foreach</span> (FamilySymbol familySymbol <span class="keyword">in</span> columnTypes)</span><br><span class="line">    &#123;</span><br><span class="line">        message += <span class="string">&quot;\n&quot;</span> + familySymbol.Name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>,message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以使用FamilyInstance.ExtensionUtility属性获取和设置梁缩进属性。如果此属性返回null，则无法修改梁缩进。</p>
<p><strong>BeamSystem</strong></p>
<p>BeamSystem提供对梁系统的完全访问和编辑能力。可以获取和设置其所有属性，例如BeamSystemType、BeamType、Direction和Level。方向不限于一条边。它可以设置为与BeamSystem在同一平面上的任何XYZ坐标。</p>
<p>注意：在UI中或通过API更改了Elevation属性后，不能更改StructuralBeam AnalyticalModel。在下图中，梁系统高程更改为10英尺后，分析模型线仍保留在原始位置。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/CHS/Revit-API/images/GUID-1A4BF557-4296-4FE8-BCA3-CD3E1520BA7A.png"></p>
<p>图156：改变梁系统标高</p>
<h3 id="桁架"><a href="#桁架" class="headerlink" title="桁架"></a>桁架</h3><p><strong>桁架</strong></p>
<p>桁架类表示Revit中的所有桁架类型。TrussType属性指示桁架的类型。</p>
<p>代码区域29-7：在两个柱上创建桁架</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function">Truss <span class="title">CreateTruss</span>(<span class="params">Autodesk.Revit.DB.Document document, FamilyInstance column1, FamilyInstance column2</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Truss truss = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">using</span> (Transaction transaction = <span class="keyword">new</span> Transaction(document, <span class="string">&quot;Add Truss&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (transaction.Start() == TransactionStatus.Started)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//sketchPlane</span></span><br><span class="line">            XYZ origin = <span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            XYZ xDirection = <span class="keyword">new</span> XYZ(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            XYZ yDirection = <span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">            XYZ zDirection = <span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">            Plane plane = Plane.Create(<span class="keyword">new</span> Frame(origin, xDirection, yDirection, zDirection));</span><br><span class="line">            SketchPlane sketchPlane = SketchPlane.Create (document, plane);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//new base Line - use line that spans two selected columns</span></span><br><span class="line">            AnalyticalModel frame1 = column1.GetAnalyticalModel() <span class="keyword">as</span> AnalyticalModel;</span><br><span class="line">            XYZ centerPoint1 = (frame1.GetCurve() <span class="keyword">as</span> Line).GetEndPoint(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            AnalyticalModel frame2 = column2.GetAnalyticalModel() <span class="keyword">as</span> AnalyticalModel;</span><br><span class="line">            XYZ centerPoint2 = (frame2.GetCurve() <span class="keyword">as</span> Line).GetEndPoint(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            XYZ startPoint = <span class="keyword">new</span> XYZ(centerPoint1.X, centerPoint1.Y, <span class="number">0</span>);</span><br><span class="line">            XYZ endPoint = <span class="keyword">new</span> XYZ(centerPoint2.X, centerPoint2.Y, <span class="number">0</span>);</span><br><span class="line">            Autodesk.Revit.DB.Line baseLine = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                baseLine = Line.CreateBound(startPoint, endPoint);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (System.ArgumentException)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Selected columns are too close to create truss.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// use the active view for where the truss&#x27;s tag will be placed; View used in</span></span><br><span class="line">            <span class="comment">// NewTruss should be plan or elevation view parallel to the truss&#x27;s base line </span></span><br><span class="line">            Autodesk.Revit.DB.View view = document.ActiveView;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Get a truss type for the truss</span></span><br><span class="line">            FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">            collector.OfClass(<span class="keyword">typeof</span>(FamilySymbol));</span><br><span class="line">            collector.OfCategory(BuiltInCategory.OST_Truss);</span><br><span class="line"></span><br><span class="line">            TrussType trussType = collector.FirstElement() <span class="keyword">as</span> TrussType;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="literal">null</span> != trussType)</span><br><span class="line">            &#123;</span><br><span class="line">                truss = Truss.Create(document, trussType.Id, sketchPlane.Id, baseLine);</span><br><span class="line">                transaction.Commit();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                transaction.RollBack();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;No truss types found in document.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">return</span> truss;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="加强"><a href="#加强" class="headerlink" title="加强"></a>加强</h3><p>Revit API提供了用于管理有效主体（如混凝土柱、梁、墙、基础和结构楼板）中的钢筋（如钢筋、钢筋或钢筋网）的类。</p>
<p>本节中的主题</p>
<ul>
<li>Rebar 钢筋<br>Rebar类表示用于加强适当元素（如混凝土梁、柱、板或基础）的钢筋。</li>
<li>钢筋连接器<br>钢筋连接器用于连接相邻钢筋。</li>
<li>区域和路径钢筋<br>Revit API提供了表示Revit结构要素中的面积钢筋和路径钢筋的类。</li>
<li>织物增强<br>钢筋网是一层由焊接钢丝网制成的钢筋网，并置于混凝土板或墙内。</li>
<li>钢筋容器<br>钢筋容器是表示一个主体中钢筋聚合的元素。此元素只能通过API创建。</li>
<li>钢筋设置<br>有关模型中钢筋的几个设置在文档级别进行控制，并通过文档的ReinfocementSettings类进行访问。</li>
<li>钢筋舍入<br>钢筋修圆是编制施工图的重要内容。钢筋长度公差小于行业或当地标准通常被视为不适用于指定钢筋。</li>
</ul>
<h4 id="钢筋"><a href="#钢筋" class="headerlink" title="钢筋"></a>钢筋</h4><p>Rebar 类表示用于加固合适元素（如混凝土梁、柱、板或基础）的钢筋。</p>
<p> <strong>创建钢筋</strong></p>
<p>您可以使用以下三种静态 Rebar 方法之一创建钢筋对象。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Rebar Rebar.CreateFromCurves(</span><br><span class="line">        Document doc,</span><br><span class="line">        RebarStyle style,</span><br><span class="line">        RebarBarType rebarType,</span><br><span class="line">        RebarHookType startHook,</span><br><span class="line">        RebarHookType endHook,</span><br><span class="line">        Element host,</span><br><span class="line">        XYZ norm,</span><br><span class="line">        IList&lt;Curve&gt; curves,</span><br><span class="line">        RebarHookOrientation startHookOrient,</span><br><span class="line">        RebarHookOrientation endHookOrient,</span><br><span class="line">        <span class="built_in">bool</span> useExistingShapeIfPossible,</span><br><span class="line">        <span class="built_in">bool</span> createNewShape</span><br><span class="line">);<span class="comment">//在项目中创建 Rebar 元素的新实例。所有曲线都必须属于由法线和原点定义的平面。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Rebar Rebar.CreateFromRebarShape(</span><br><span class="line">        Document doc,</span><br><span class="line">        RebarShape rebarShape,</span><br><span class="line">        RebarBarType rebarType,</span><br><span class="line">        Element host,</span><br><span class="line">        XYZ origin,</span><br><span class="line">        XYZ xVec,</span><br><span class="line">        XYZ yVec</span><br><span class="line">);<span class="comment">//创建一个新的 Rebar 作为 RebarShape 的实例。该实例将具有 RebarShape 中的默认形状参数，其位置基于形状定义中形状的边界框。在计算形状的边界框之前，将从形状中删除钩子。如果在文档中可以找到合适的钩子，它们将被任意分配。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Rebar Rebar.CreateFromCurvesAndShape(</span><br><span class="line">        Document doc,</span><br><span class="line">        RebarShape rebarShape,</span><br><span class="line">        RebarBarType rebarType,</span><br><span class="line">        RebarHookType startHook,</span><br><span class="line">        RebarHookType endHook,  </span><br><span class="line">        Element host,</span><br><span class="line">        XYZ norm,</span><br><span class="line">        IList&lt;Curve&gt; curves,</span><br><span class="line">        RebarHookOrientation startHookOrient,</span><br><span class="line">        RebarHookOrientation endHookOrient</span><br><span class="line">);<span class="comment">//在项目中创建 Rebar 元素的新实例。该实例将具有 RebarShape 中的默认形状参数。所有曲线都必须属于由法线和原点定义的平面。</span></span><br></pre></td></tr></table></figure>

<p>第一个版本从描述钢筋的曲线数组创建钢筋，而第二个版本根据 RebarShape 和位置创建 Rebar 对象。第三个版本从曲线数组中基于 RebarShape 创建钢筋。</p>
<p>使用 CreateFromCurves（） 或 CreateFromCurvesAndShape（） 方法时，参数 RebarBarType 和 RebarHookType 在文档的 RebarBarTypes 和 RebarHookTypes 属性中可用。</p>
<p>以下代码说明了如何创建具有特定布局的 Rebar。</p>
<p>代码区域 29-8：创建具有特定布局的钢筋</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function">Rebar <span class="title">CreateRebar</span>(<span class="params">Autodesk.Revit.DB.Document document, FamilyInstance column, RebarBarType barType, RebarHookType hookType</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Define the rebar geometry information - Line rebar</span></span><br><span class="line">    LocationPoint location = column.Location <span class="keyword">as</span> LocationPoint;</span><br><span class="line">    XYZ origin = location.Point;</span><br><span class="line">    XYZ normal = <span class="keyword">new</span> XYZ(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// create rebar 9&#x27; long</span></span><br><span class="line">    XYZ rebarLineEnd = <span class="keyword">new</span> XYZ(origin.X, origin.Y, origin.Z + <span class="number">9</span>);</span><br><span class="line">    Line rebarLine = Line.CreateBound(origin, rebarLineEnd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create the line rebar</span></span><br><span class="line">    IList&lt;Curve&gt; curves = <span class="keyword">new</span> List&lt;Curve&gt;();</span><br><span class="line">    curves.Add(rebarLine);</span><br><span class="line"></span><br><span class="line">    Rebar rebar = Rebar.CreateFromCurves(document, Autodesk.Revit.DB.Structure.RebarStyle.Standard, barType, hookType, hookType,</span><br><span class="line">                        column, origin, curves, RebarHookOrientation.Right, RebarHookOrientation.Left, <span class="literal">true</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> != rebar)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// set specific layout for new rebar as fixed number, with 10 bars, distribution path length of 1.5&#x27;</span></span><br><span class="line">        <span class="comment">// with bars of the bar set on the same side of the rebar plane as indicated by normal</span></span><br><span class="line">        <span class="comment">// and both first and last bar in the set are shown</span></span><br><span class="line">        rebar.GetShapeDrivenAccessor().SetLayoutAsFixedNumber(<span class="number">10</span>, <span class="number">1.5</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rebar;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>有关创建钢筋元素的更多示例，请参见 Revit SDK 附带的钢筋和 NewRebar 示例应用程序。</p>
<p>下表列出了 Parameter REBAR_ELEM_LAYOUT_RULE的整数值：</p>
<p>表 59：钢筋布局规则</p>
<table>
<thead>
<tr>
<th><strong>Value 值</strong></th>
<th><strong>0</strong></th>
<th><strong>1</strong></th>
<th><strong>2</strong></th>
<th><strong>3</strong></th>
<th><strong>4</strong></th>
</tr>
</thead>
<tbody><tr>
<td>描述</td>
<td>None</td>
<td>固定数量</td>
<td>最大间距</td>
<td>带间距的数字</td>
<td>最小净间距</td>
</tr>
</tbody></table>
<p>The Rebar.GetShapeDrivenAccessor().ScaleToBox（） 方法提供了一种同时设置所有形状参数的方法。该行为类似于放置 Rebar 的 UI。</p>
<p><strong>RebarHostData 和 RebarCoverType</strong></p>
<p>明确保护层与有效钢筋主体的各个面关联。可以通过Autodesk.Revit.Elements.RebarHostData对象访问主体的保护层设置。通过参数提供了一种更简单、功能更弱的访问相同设置的机制。</p>
<p>Cover 由命名为偏移的距离定义，建模为 Autodesk.Revit.DB.Structure.RebarCoverType 的元素。</p>
<p><strong>编号</strong></p>
<p>钢筋是可以通过Revit API控制其编号的元素类别之一。NumberingSchema和NumberingSchemaType类可用于定义钢筋元素的组织方式，以便对其进行编号&#x2F;标记。每个NumberingSchema控制一种特定类型的元素的编号。NumberingSchema的元素也是元素，并且每个Revit文档中的每种类型始终只有一个。所有内置编号架构的可用类型都在NumberingSchemaTypes类中枚举。</p>
<p>属于特定模式（例如NumberingSchemaTypes.StructuralNumberingSchemas.Rebar）的元素（例如Rebar）按顺序组织和编号。序列是共享相同编号分区的元素的集合，编号分区由它们各自的分区参数（NUMBER_PARTITION_PARAM）值定义。编号序列必须至少包含一个元素。换句话说，一旦存在至少一个元素，其分区参数具有不同于其他元素（在相同的编号模式中）的值，则建立序列。如果最后一个元素被删除（删除或移动到不同的序列），那么空序列将不再存在。</p>
<p>元素在创建时（基于当时的编号分区值）被分配给序列，方法是显式修改元素的Partition参数或使用AssignElementsToSequence（）方法。AssignElementsToSequence（）方法优于显式更改Partition参数，因为该方法会立即将更改应用于序列和元素编号，而更改的参数仅在当前事务关闭后生效。</p>
<p>除了直接或间接更改元素的Partition参数外，还可以使用NumberingSchema类的方法重新组织编号序列。MoveSequence（）方法将现有序列的所有元素移动到架构中尚不存在的新序列，从而有效地重命名所有受影响元素上的Partition参数。方法的作用是：在应用匹配策略的同时，从一个序列中删除所有元素，并将它们追加到另一个现有序列的元素中。方法MergeSequences（）接受所有指定序列的元素，并将它们全部移动到新创建的序列中。所有合并的元素将重新编号，并根据需要根据匹配算法进行匹配。</p>
<p>下面的示例使用MoveSequence（）方法在两个编号序列中交换Rebar的编号。</p>
<p>代码区域：交换号码</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> This method uses multiple moving operations to swap numbers</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> for Rebars in two numbering sequences. The sequences are</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> identified by the names of two numbering partitions.</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;document&quot;&gt;</span>Document to modify<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;part1&quot;&gt;</span>Name of the partition of one numbering sequence<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;part2&quot;&gt;</span>Name of the partition of another numbering sequence<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">SwapNumberingSequences</span>(<span class="params">Document document, <span class="built_in">string</span> part1, <span class="built_in">string</span> part2</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Obtain a schema object for a particular kind of elements </span></span><br><span class="line">    NumberingSchema schema = NumberingSchema.GetNumberingSchema(document,NumberingSchemaTypes.StructuralNumberingSchemas.Rebar);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> (Transaction transaction = <span class="keyword">new</span> Transaction(document))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Changes to numbering sequences must be made inside a transaction</span></span><br><span class="line">        transaction.Start(<span class="string">&quot;Swap Numbering Sequences&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We will use a temporary partition for the swap operation,</span></span><br><span class="line">        <span class="comment">// for the move operation only works if the target partition </span></span><br><span class="line">        <span class="comment">// does not exist yet in the same numbering schema.</span></span><br><span class="line">        <span class="comment">// (We assume this TEMPORARY partition does not exist.)</span></span><br><span class="line">        <span class="built_in">string</span> tempPartition = <span class="string">&quot;TEMPORARY&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Step 1</span></span><br><span class="line">        <span class="comment">// First we move all elements from one sequence into </span></span><br><span class="line">        <span class="comment">// a partition we know does not exist. This action will</span></span><br><span class="line">        <span class="comment">// create the temporary partition and remove the original</span></span><br><span class="line">        <span class="comment">// one (part1).</span></span><br><span class="line">        schema.MoveSequence(part1, tempPartition);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Step 2</span></span><br><span class="line">        <span class="comment">// With the sequence in partition &#x27;part1&#x27; removed</span></span><br><span class="line">        <span class="comment">// we can now move elements from the second sequence to it.</span></span><br><span class="line">        <span class="comment">// This action will re-create a sequence in partition &#x27;part1&#x27;</span></span><br><span class="line">        <span class="comment">// and remove the sequence in partition &#x27;part2&#x27;</span></span><br><span class="line">        schema.MoveSequence(part2, part1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Step 3</span></span><br><span class="line">        <span class="comment">// Finally, we can move elements &#x27;parked&#x27; in the temporary</span></span><br><span class="line">        <span class="comment">// sequence to partition &#x27;part2&#x27;, for that partition was</span></span><br><span class="line">        <span class="comment">// removed in the previous step and thus can now be created</span></span><br><span class="line">        <span class="comment">// again. The temporary partition will be automatically </span></span><br><span class="line">        <span class="comment">// removed upon completing this step.</span></span><br><span class="line">        schema.MoveSequence(tempPartition, part2);</span><br><span class="line"></span><br><span class="line">        transaction.Commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不同序列中的元素独立地编号，这意味着即使元素不同，在两个序列中也可能存在具有相同编号的元素。同样，在两个或更多个序列中可能存在完全相同的元素，其具有不同的数字。然而，在每个编号序列内，任何两个相同的元素将总是具有相同的编号，而不同的元件在编号序列内将永远不具有相同的编号。</p>
<p>创建后，Escape元素始终自动编号。每个新元素将获得一个递增的更大的数字。但是，与同一序列中的现有元素匹配的新元素将被分配相同的编号。元素将尽可能长时间地保留其分配的编号。这意味着，例如，如果删除了以前创建的某些钢筋图元，则所有剩余图元（在相同编号序列中）将保留其编号，这可能会导致相应编号序列中出现间隙。对于不需要空位的序列，可以通过调用RemoveGaps（）来移除空位。</p>
<p>下面的示例通过删除编号序列中的任何剩余间隙并设置每个序列的起始编号以使序列中的编号不重叠来合并钢筋元素上的编号。</p>
<p>代码区域：Consolidate Rebar Numbers</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ConsolidateRebarNumbers</span>(<span class="params">Document document</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Obtain a schema object for a particular kind of elements </span></span><br><span class="line">    NumberingSchema schema = NumberingSchema.GetNumberingSchema(document,NumberingSchemaTypes.StructuralNumberingSchemas.Rebar);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Collect the names of partitions of all the numbering sequences currently contained in the schema</span></span><br><span class="line">    IList&lt;<span class="built_in">string</span>&gt; sequences = schema.GetNumberingSequences();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> (Transaction transaction = <span class="keyword">new</span> Transaction(document))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Changes to numbers must be made inside a transaction</span></span><br><span class="line">        transaction.Start(<span class="string">&quot;Consolidate Rebar Numbers&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// First we make sure numbers in all sequences are consecutive</span></span><br><span class="line">        <span class="comment">// by removing possible gaps in numbers. Note: RemoveGaps does</span></span><br><span class="line">        <span class="comment">// nothing for a sequence where there are no gaps present.</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// We also want to find what the maximum range of numbers is</span></span><br><span class="line">        <span class="comment">// of all the sequences (the one the widest span of used numbers)</span></span><br><span class="line">        <span class="built_in">int</span> maxRange = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">foreach</span> (<span class="built_in">string</span> name <span class="keyword">in</span> sequences)</span><br><span class="line">        &#123;</span><br><span class="line">            schema.RemoveGaps(name);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Here we use First() from the Linq extension.</span></span><br><span class="line">            <span class="comment">// There is always at least one range in every sequence,</span></span><br><span class="line">            <span class="comment">// and after gaps are closed there is exactly one range.</span></span><br><span class="line">            IntegerRange range = schema.GetNumbers(name).First();  </span><br><span class="line">            <span class="built_in">int</span> rangeSpan = <span class="number">1</span> + (range.High - range.Low);</span><br><span class="line">            <span class="keyword">if</span> (rangeSpan &gt; maxRange)</span><br><span class="line">            &#123;</span><br><span class="line">                maxRange = rangeSpan;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Next we give sequences different start numbers</span></span><br><span class="line">        <span class="comment">// starting with 100 and then stepping by at least</span></span><br><span class="line">        <span class="comment">// the maximum range we found in the previous step</span></span><br><span class="line">        <span class="built_in">int</span> startNumber = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We round the range up to the closest 100</span></span><br><span class="line">        <span class="built_in">int</span> step = <span class="number">100</span> * (<span class="built_in">int</span>)((maxRange + <span class="number">99</span>) / <span class="number">100.0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">foreach</span> (<span class="built_in">string</span> name <span class="keyword">in</span> sequences)</span><br><span class="line">        &#123;</span><br><span class="line">            schema.ShiftNumbers(name, startNumber);</span><br><span class="line">            startNumber += step;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        transaction.Commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>数字被存储为每个编号元素上的编号参数的值。通过查询NumberingSchema.NumberingParameterId属性获取参数的ID。可以通过查询相应编号元素的参数来获得编号的值。该值是只读的，因此无法设置;它始终根据编号分区中元素的关系以及每个元素编号顺序中的匹配策略计算。</p>
<p>尽管编号总是自动分配给模式的所有元素，但ChangeNumber（）方法为程序员提供了一种方法，只要新编号在编号序列中是唯一的，就可以显式地覆盖特定编号。调用者指定一个要更改的数字和一个要应用的新值，前提是该值在同一编号序列中还不存在。</p>
<p><strong>分布类型</strong></p>
<p>Rebar.DistributionType属性可用于修改钢筋集的类型。钢筋集可以是“均匀”或“可变长度”，对于均匀分布类型：所有钢筋参数与集中的第一个钢筋相同。对于可变长度分布类型：考虑到集合中第一个钢筋的约束，钢筋参数可以变化（主要是长度）。</p>
<p>Rebar.GetParameterValueAtIndex() 方法的作用是：获取位于指定索引处的条形图的参数值。仅接受0和NumberOfBarPositions-1之间的值。如果DistributionType为Uniform，则无论索引如何，返回的ParameterValue都相同。如果DistributionType为VaryingLength，则返回的ParameterValue在给定索引处计算。</p>
<h3 id="边界条件"><a href="#边界条件" class="headerlink" title="边界条件"></a>边界条件</h3><p><strong>边界条件</strong></p>
<p>有三种类型的边界条件：</p>
<ul>
<li>Point 点</li>
<li>Curve 曲线</li>
<li>Area 区域</li>
</ul>
<p>使用以下代码检索类型和相关的几何信息：</p>
<p>代码区域29-9：获取边界条件类型和几何形状</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetInfo_BoundaryConditions</span>(<span class="params">BoundaryConditions boundaryConditions</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> message = <span class="string">&quot;BoundaryConditions : &quot;</span>;</span><br><span class="line"></span><br><span class="line">    boundaryConditions.GetBoundaryConditionsType();</span><br><span class="line">    <span class="keyword">switch</span> (boundaryConditions.GetBoundaryConditionsType())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> BoundaryConditionsType.Point:</span><br><span class="line">            XYZ point = boundaryConditions.Point;</span><br><span class="line">            message += <span class="string">&quot;\nThis BoundaryConditions is a Point Boundary Conditions.&quot;</span>;</span><br><span class="line">            message += <span class="string">&quot;\nLocation point: (&quot;</span> + point.X + <span class="string">&quot;, &quot;</span></span><br><span class="line">                        + point.Y + <span class="string">&quot;, &quot;</span> + point.Z + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> BoundaryConditionsType.Line:</span><br><span class="line">            message += <span class="string">&quot;\nThis BoundaryConditions is a Line Boundary Conditions.&quot;</span>;</span><br><span class="line">            Curve curve = boundaryConditions.GetCurve();</span><br><span class="line">            <span class="comment">// Get curve start point</span></span><br><span class="line">            message += <span class="string">&quot;\nLocation Line: start point: (&quot;</span> + curve.GetEndPoint(<span class="number">0</span>).X + <span class="string">&quot;, &quot;</span></span><br><span class="line">                    + curve.GetEndPoint(<span class="number">0</span>).Y + <span class="string">&quot;, &quot;</span> + curve.GetEndPoint(<span class="number">0</span>).Z + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">            <span class="comment">// Get curve end point</span></span><br><span class="line">            message += <span class="string">&quot;;  end point:(&quot;</span> + curve.GetEndPoint(<span class="number">1</span>).X + <span class="string">&quot;, &quot;</span></span><br><span class="line">                    + curve.GetEndPoint(<span class="number">1</span>).Y + <span class="string">&quot;, &quot;</span> + curve.GetEndPoint(<span class="number">1</span>).Z + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> BoundaryConditionsType.Area:</span><br><span class="line">            message += <span class="string">&quot;\nThis BoundaryConditions is an Area Boundary Conditions.&quot;</span>;</span><br><span class="line">            IList loops = boundaryConditions.GetLoops();</span><br><span class="line">            <span class="keyword">foreach</span> (CurveLoop curveLoop <span class="keyword">in</span> loops)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">foreach</span> (Curve areaCurve <span class="keyword">in</span> curveLoop)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// Get curve start point</span></span><br><span class="line">                    message += <span class="string">&quot;\nCurve start point:(&quot;</span> + areaCurve.GetEndPoint(<span class="number">0</span>).X + <span class="string">&quot;, &quot;</span></span><br><span class="line">                            + areaCurve.GetEndPoint(<span class="number">0</span>).Y + <span class="string">&quot;, &quot;</span> + areaCurve.GetEndPoint(<span class="number">0</span>).Z + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">                    <span class="comment">// Get curve end point</span></span><br><span class="line">                    message += <span class="string">&quot;; Curve end point:(&quot;</span> + areaCurve.GetEndPoint(<span class="number">1</span>).X + <span class="string">&quot;, &quot;</span></span><br><span class="line">                            + areaCurve.GetEndPoint(<span class="number">1</span>).Y + <span class="string">&quot;, &quot;</span> + areaCurve.GetEndPoint(<span class="number">1</span>).Z + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="literal">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>,message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="板"><a href="#板" class="headerlink" title="板"></a>板</h3><p><strong>板</strong></p>
<p>Slab（结构楼板）和Slab Foundation都由Floor类表示，并由IsFoundationSlab属性区分。</p>
<p>板跨方向由API中的IndependentTag类表示，可用方式如下：</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-23AFA5D3-DFA8-48EE-BDC3-EFB37BADCB7D-low.png"></p>
<p>图157：板跨方向</p>
<p>使用NewSlab（）创建板时，不会自动创建跨方向。也没有办法直接创建它们。</p>
<p>“楼板”复合结构图层“结构桥面”属性由以下属性公开：</p>
<ul>
<li>CompoundStructuralLayer.DeckUsage</li>
<li>DeckProfile</li>
</ul>
<p>属性在以下对话框中列出：</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-F892CB9B-E142-4112-8925-32C543D8A9AA-low.png" alt="img"></p>
<p>图158：楼板复合结构层属性</p>
<h2 id="分析模型"><a href="#分析模型" class="headerlink" title="分析模型"></a>分析模型</h2><p>在结构工程中，分析模型是结构物理模型的工程描述。</p>
<p>以下结构图元具有结构杆件分析模型：</p>
<ul>
<li>Structural Columns 结构柱</li>
<li>Structural Framing elements (such as beams and braces)<br>结构框架图元（如梁和支撑）</li>
<li>Structural Floors 结构楼板</li>
<li>Structural Footings 结构基础</li>
<li>Structural Walls 结构墙</li>
</ul>
<p>可以使用GetAnalyticalModel（）方法获得元素的AnalyticalModel。请注意，新创建的结构图元的AnalyticalModel在再生发生之前不可用。根据图元的族，AnalyticalModel可能不存在。如果AnalyticalModel值不适用于图元的族，则GetAnalyticalModel（）方法返回null。在使用这个类之前检查这个值。AnalyticalModel由以下信息组成：</p>
<ul>
<li>元素相对于分析的位置</li>
<li>参数信息，包括投影、硬点、近似和刚性连接</li>
<li>支持信息</li>
<li>手动和自动调整信息</li>
<li>分析偏移</li>
</ul>
<p>在专业中提供特定选项：</p>
<ul>
<li>AnalyticalModelStick -表示结构框架梁、结构框架支撑和结构柱的分析模型。</li>
<li>AnalyticalModelColumn - AnalyticalModelStick的子类，表示结构柱的分析模型。</li>
<li>AnalyticalModelSurface - 表示结构楼板、结构基础底板和结构墙的分析模型。</li>
</ul>
<h3 id="分析位置"><a href="#分析位置" class="headerlink" title="分析位置"></a>分析位置</h3><p>根据与AnalyticalModel相对应的元素类型，可以通过以下三种方法之一来获得元素相对于分析的位置：GetPoint（）、GetCurve（）或GetCurves（）。</p>
<p>请注意，从这些方法检索的曲线没有设置其“引用”（Reference）特性。因此，它们不能用于Curve.GetEndPointReference（）等方法。相反，您可以通过构造包含必要信息的AnalyticalModelModel对象来获取对曲线及其端点的引用，如下例所示。</p>
<p>代码区域29-10：获取分析曲线的参考</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">GetReferenceData</span>(<span class="params">FamilyInstance familyInst</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        AnalyticalModel analyticalModelFrame = familyInst.GetAnalyticalModel();</span><br><span class="line">        Curve analyticalCurve = analyticalModelFrame.GetCurve();</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != analyticalCurve)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="comment">// test the stable reference to the curve.</span></span><br><span class="line">                AnalyticalModelSelector amSelector = <span class="keyword">new</span> AnalyticalModelSelector(analyticalCurve);</span><br><span class="line">                amSelector.CurveSelector = AnalyticalCurveSelector.WholeCurve;</span><br><span class="line">                Reference curveReference = analyticalModelFrame.GetReference(amSelector);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// test the stable reference to the start point of the curve</span></span><br><span class="line">                amSelector.CurveSelector = AnalyticalCurveSelector.StartPoint;</span><br><span class="line">                Reference startPointReference = analyticalModelFrame.GetReference(amSelector);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// test the stable reference to the start point of the curve</span></span><br><span class="line">                amSelector.CurveSelector = AnalyticalCurveSelector.EndPoint;</span><br><span class="line">                Reference endPointReference = analyticalModelFrame.GetReference(amSelector);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>GetPoint()</strong>  </p>
<p>如果AnalyticalModel可以由单个点（即Structural Footing）表示，则此方法将返回该点。否则，它将引发Autodesk.Revit.Exceptions.InapplicableDataException。IsSinglePoint（）方法可用于确定AnalyticalModel是否可由单个点表示。</p>
<p>下面的示例演示如何获取结构基础的分析位置。</p>
<p>代码区域29-11：获取结构基脚的位置</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// retrieve and iterate current selected element</span></span><br><span class="line">UIDocument uidoc = commandData.Application.ActiveUIDocument;</span><br><span class="line">ElementSet selection = uidoc.Selection.Elements;</span><br><span class="line"><span class="keyword">foreach</span> (Element e <span class="keyword">in</span> selection)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">// if the element is structural footing</span></span><br><span class="line">        FamilyInstance familyInst = e <span class="keyword">as</span> FamilyInstance;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != familyInst &amp;&amp; familyInst.StructuralType == StructuralType.Footing)</span><br><span class="line">        &#123;</span><br><span class="line">                AnalyticalModel model = familyInst.GetAnalyticalModel();</span><br><span class="line">                <span class="comment">// structural footing should be expressable as a single point</span></span><br><span class="line">                <span class="keyword">if</span> (model.IsSinglePoint() == <span class="literal">true</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                        XYZ analyticalLocationPoint = model.GetPoint();</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>GetCurve()</strong>  </p>
<p>如果AnalyticalModel可以由单个曲线（即Structural Column或Structural Framing）表示，则此方法将返回该Curve。否则，它将引发Autodesk. Revit. Exceptions. InapplicableDataException。IsSingleCurve（）方法可用于确定AnalyticalModel是否可由单条曲线表示。</p>
<p>代码区域29-12：获取结构柱的曲线</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetColumnCurve</span>(<span class="params">FamilyInstance familyInst</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">// get AnalyticalModel from structural column</span></span><br><span class="line">        <span class="keyword">if</span> (familyInst.StructuralType == StructuralType.Column)</span><br><span class="line">        &#123;</span><br><span class="line">                AnalyticalModel modelColumn = familyInst.GetAnalyticalModel();</span><br><span class="line">                <span class="comment">// column should be represented by a single curve</span></span><br><span class="line">                <span class="keyword">if</span> (modelColumn.IsSingleCurve() == <span class="literal">true</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                        Curve columnCurve = modelColumn.GetCurve();</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>GetCurves()</strong></p>
<p>此方法需要获取由多条曲线定义的AnalyticalModel的曲线，但可用于所有情况。如果AnalyticalModel可以由单个曲线表示，则该方法将返回仅包含一条曲线的List。如果AnalyticalModel可以由单个点表示，则此方法将返回包含该点的长度几乎为0的Curve。此方法将AnalyticalCurveType枚举作为参数。可能的值为：</p>
<ul>
<li><em>RawCurves</em> - 生成的基础分析模型曲线</li>
<li><em>ActiveCurves</em> - 屏幕上显示的曲线（不包括刚性链接）</li>
<li><em>ApproximatedCurves</em> - 使用直线段近似的曲线</li>
</ul>
<p>The following values related to Rigid Links are also available. See the Rigid Links section later in this chapter for more information.<br>也可以使用与刚性链接相关的以下值。有关详细信息，请参见本章后面的“刚性连杆”部分。</p>
<ul>
<li><em>RigidLinkHead</em> -梁的端点0（头部）处的刚性连杆</li>
<li><em>RigidLinkTail</em> - 梁末端1（尾部）的刚性连杆</li>
<li><em>AllRigidLinks</em> - 所有刚性连杆曲线。端点0（头部）处的刚性连杆将位于第一个条目中。末端1（尾部）的刚性连杆将位于最后一个条目中。</li>
</ul>
<p><strong>GetLoops()</strong></p>
<p>对于结构墙、楼板和楼板，建议使用AnalyticalModelSurface类。使用GetLoops（）方法可以基于AnalyticalLoopType参数检索曲面的一组CurveLoop对象。可能的值为：</p>
<ul>
<li><em>All</em> - 所有分析回路</li>
<li><em>External</em> - 在所有其他循环之外循环。</li>
<li><em>Internal</em> - 位于另一个循环内部的循环。在多个嵌套循环的情况下，这将返回除了最外部循环之外的所有循环。</li>
<li><em>Filled</em> - 内部已填充的循环。在多个嵌套循环的情况下，这将返回最外部的循环，并从外部循环到内部循环。在视图中，返回的回路显示为实体的外部轮廓。</li>
<li><em>Void</em> - 内部为空的循环。在多个嵌套循环的情况下，这将返回一系列循环，从第二个最外部开始，每隔一个标题进入最内部。在视图中，返回的回路显示为开口的外部轮廓。下面的示例演示了如何将AnalyticalModelSurface用于结构墙，以获取所有选定墙的外边缘并显示其坐标。</li>
</ul>
<p>代码区域29-13：获取结构墙的曲线</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// retrieve and iterate current selected element</span></span><br><span class="line">UIDocument uidoc = commandData.Application.ActiveUIDocument;</span><br><span class="line">ICollection selectedIds = uidoc.Selection.GetElementIds();</span><br><span class="line">Document document = uidoc.Document;</span><br><span class="line"><span class="keyword">foreach</span> (ElementId id <span class="keyword">in</span> selectedIds)</span><br><span class="line">&#123;</span><br><span class="line">    Element e = document.GetElement(id);</span><br><span class="line">    Wall aWall = e <span class="keyword">as</span> Wall;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> != aWall)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// get AnalyticalModelSurface from Structural Wall</span></span><br><span class="line">        AnalyticalModelSurface modelWall = aWall.GetAnalyticalModel() <span class="keyword">as</span> AnalyticalModelSurface;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == modelWall)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Architecture wall doesn&#x27;t have analytical model</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// get wall curves</span></span><br><span class="line">        StringBuilder wallString = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        wallString.AppendLine(<span class="string">&quot;Wall curves:&quot;</span>);</span><br><span class="line">        IList wallCurveLoops = modelWall.GetLoops(AnalyticalLoopType.External);</span><br><span class="line">        <span class="keyword">foreach</span> (CurveLoop curveloop <span class="keyword">in</span> wallCurveLoops)</span><br><span class="line">        &#123;</span><br><span class="line">            CurveLoopIterator itr = curveloop.GetCurveLoopIterator();</span><br><span class="line">            itr.Reset();</span><br><span class="line">            <span class="keyword">while</span> (itr.MoveNext())</span><br><span class="line">            &#123;</span><br><span class="line">                Curve wallCurve = itr.Current;</span><br><span class="line">                wallString.AppendLine(String.Format(<span class="string">&quot;&#123;0&#125;, &#123;1&#125;&quot;</span>, wallCurve.GetEndPoint(<span class="number">0</span>).ToString(), wallCurve.GetEndPoint(<span class="number">1</span>).ToString()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TaskDialog.Show(<span class="string">&quot;Wall Analytical Model&quot;</span>, wallString.ToString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <strong>局部坐标系</strong></p>
<p>AnalyticalModelStick和AnalyticalModelSurface元素的局部坐标系的方向可以通过调用重载的GetLocalCoordinateSystem（）方法作为变换获得。对于AnalyticalModelSurface，此方法的重载（不带参数）将返回整个模型的局部坐标系方向的变换，而带XYZ点的重载将返回描述曲面上指定点处的局部坐标系的变换。指定的点必须位于分析模型的表面上，否则Revit将引发异常。</p>
<p>当在AnalyticalModelStick类上调用GetLocalCoordinateSystem（）时，您可以可选地调用GetLocalCoordinateSystem（double），传递沿着曲线的距离，该距离由可以在0和1之间变化的参数表示（例如，0.5表示沿着参数化曲线的中点）。也可以调用GetLocalCoordinateSystem（XYZ point），其约束条件与在AnalyticalModelSurface上调用时相同，即指定的点必须位于沿着分析模型。Face.Evaluate或Curve.Evaluate可用于获取位于曲面上或沿曲线沿着的XYZ点。</p>
<h3 id="参数信息"><a href="#参数信息" class="headerlink" title="参数信息"></a>参数信息</h3><p>AnalyticalModel提供对刚性链接、投影和近似等参数信息的访问。</p>
<p><strong>刚性连杆</strong></p>
<p>刚性连杆将梁的分析模型连接到柱的分析模型。使用CanHaveRigidLinks（）方法和AnalyticalModel.RigidLinksOption属性确定刚性链接是否适用于AnalyticalModel。此外，还可以使用HasRigidLinksWith（）确定AnalyticalModel是否具有与特定图元的刚性链接。</p>
<p>通过使用AnalyticalModel.GetCurves（）方法指定AnalyticalCurveType选项RigidLinkHead和RigidLinkTail，可以检索末端链接。或者，将AnalyticalModel.GetRigidLink（）与AnalyticalModel对象一起使用。</p>
<p>结构梁的AnalyticalModel方法GetCurve（）和GetCurves（）之间的一个区别是，GetCurves（）包括单个Curve以及结构梁RigidLink Curve（如果存在）。将AnalyticalCurveType.RigidLinkHead或AnalyticalCurveType.RigidLinkTail枚举值传递给GetCurves（）方法，以获取梁头部或尾部的RigidLink。</p>
<p>虽然不能直接创建刚性连接（因为它不是独立对象），但可以使用梁和&#x2F;或柱的分析模型上的RigidLinksOption属性来创建刚性连接。梁的刚性连接选项将替代柱的选项。</p>
<p>对于结构梁，RigidLinksOption属性可以具有以下值：</p>
<ul>
<li>AnalyticalRigidLinksOption.Enabled - 将形成刚性链接</li>
<li>AnalyticalRigidLinksOption.Disabled -将不形成刚性链接</li>
<li>AnalyticalRigidLinksOption.FromColumn - 可以形成刚性连接，具体取决于相应结构柱的值。</li>
</ul>
<p>对于结构柱，RigidLinksOption属性可以具有以下值：</p>
<ul>
<li>AnalyticalRigidLinksOption.Enabled - 将形成刚性连接，除非相应的结构梁的设置替代。</li>
<li>AnalyticalRigidLinksOption.Disabled - 除非相应结构梁的设置替代，否则不会形成刚性连接。</li>
</ul>
<p>注意：除了设置正确的值外，要创建刚性连杆，图元还必须重叠。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-80B7AF6C-FF62-4431-AA18-69BD624D7C69-low.png"></p>
<p><strong>对齐、投影和延伸</strong></p>
<p>子类AnalyticalModelSurface、AnalyticalModelStick和AnalyticalModelColumn具有支持检查和操作结构元素的对齐、投影和延伸的专用成员。以下代码示例显示如何更改AnalyticalModelSurface或AnalyticalModelStick的投影。</p>
<p>代码区域：更改AnalyticalModelStick投影</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ChangeBeamProjection</span>(<span class="params">FamilyInstance familyInstance</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    AnalyticalModelStick ams = familyInstance.GetAnalyticalModel() <span class="keyword">as</span> AnalyticalModelStick;</span><br><span class="line">    <span class="keyword">if</span> (ams != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Change the Z projection for the end of the beam</span></span><br><span class="line">        StickElementProjectionZ orgEndProj = ams.GetProjectionZ(AnalyticalElementSelector.EndOrTop);</span><br><span class="line">        StickElementProjectionZ newEndProj = StickElementProjectionZ.Bottom;</span><br><span class="line">        <span class="keyword">using</span> (Transaction tran = <span class="keyword">new</span> Transaction(familyInstance.Document, <span class="string">&quot;ChangeProjection&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            tran.Start();</span><br><span class="line">            ams.SetProjection(AnalyticalElementSelector.EndOrTop, ElementId.InvalidElementId, newEndProj);</span><br><span class="line">            tran.Commit();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TaskDialog.Show(<span class="string">&quot;AnalyticalModelStick&quot;</span>, <span class="string">&quot;AnalyticalModelStick ID: &quot;</span> + ams.Id + <span class="string">&quot;; \nOriginal ProjectionZ value was: &quot;</span> + orgEndProj + <span class="string">&quot;; \nNew ProjectionZ value: &quot;</span> + newEndProj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码区域：更改AnalyticalModel曲面投影</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> </span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> Change the Z projection for all surface elements to BottomOrExterior</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ChangeSurfaceProjections</span>(<span class="params">Document document</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">    IList elements = collector.WherePasses(<span class="keyword">new</span> ElementClassFilter(<span class="keyword">typeof</span>(AnalyticalModelSurface))).WhereElementIsNotElementType().ToElements();</span><br><span class="line">    <span class="keyword">if</span> (elements.Count &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">using</span> (Transaction tran = <span class="keyword">new</span> Transaction(document, <span class="string">&quot;Change Surface Projections&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            tran.Start();</span><br><span class="line">            <span class="keyword">foreach</span> (AnalyticalModelSurface ams <span class="keyword">in</span> elements)</span><br><span class="line">            &#123;</span><br><span class="line">                SurfaceElementProjectionZ orgEndProj = ams.ProjectionZ;</span><br><span class="line">                SurfaceElementProjectionZ newEndProj = SurfaceElementProjectionZ.BottomOrExterior;</span><br><span class="line">                ams.ProjectionZ = newEndProj;</span><br><span class="line">            &#125;</span><br><span class="line">            tran.Commit();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下一个示例演示如何设置柱的顶部拉伸。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> </span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> Change the top extension for the column to Reference Level</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ChangeColumnTopExtension</span>(<span class="params">FamilyInstance column</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    AnalyticalModelColumn amc = column.GetAnalyticalModel() <span class="keyword">as</span> AnalyticalModelColumn;</span><br><span class="line">    <span class="keyword">if</span> (amc != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">using</span> (Transaction tran = <span class="keyword">new</span> Transaction(column.Document, <span class="string">&quot;Change Top Extension&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            tran.Start();</span><br><span class="line"></span><br><span class="line">            StickElementExtension orgTopExt = amc.TopExtension;</span><br><span class="line">            StickElementExtension newTopExt = StickElementExtension.ReferenceLevel;</span><br><span class="line">            amc.TopExtension = newTopExt;</span><br><span class="line"></span><br><span class="line">            TaskDialog.Show(<span class="string">&quot;AnalyticalModelColumn&quot;</span>, <span class="string">&quot;AnalyticalModelColumn ID: &quot;</span> + amc.Id + <span class="string">&quot;; \nOriginal TopExtension value was: &quot;</span> + orgTopExt + <span class="string">&quot;; \nNew TopExtension value: &quot;</span> + newTopExt);</span><br><span class="line"></span><br><span class="line">            tran.Commit();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>近似</strong></p>
<p>当AnalyticalModel由曲线而不是直线定义时（即对于弯曲梁），近似值（由直线组成）可能更可取。AnalyticalModel有几种与曲线近似相关的方法。如果CanApproximate（）返回true，请使用Approximate（）方法在非近似（曲线）分析模型和近似（仅由直线组成）分析模型之间切换。切换到近似后，使用GetCurves（）获取近似曲线的直线。</p>
<p>近似将基于近似偏差值（GetApproximationDeviation（））和使用硬点参数（UsesHardPoints（））。这些值也有相应的Set方法。近似偏差限制平滑曲线与由近似生成的线段之间的距离。硬点是弯曲梁上其他结构元素接触的位置。将此参数设置为true时，将强制分段分析模型在附着到曲梁的杆件端点处具有节点</p>
<p><strong>AnalyzeAs</strong></p>
<p>可以通过AnalyticalModel检索和设置Analyze As参数。此参数向分析程序指示应如何分析元素，或元素是否为NotForAnalysis。由于GetAnalyzeAs（）和SetAnalyzeAs（）使用的AnalyzeAs枚举包含用于不同类型元素的枚举值，因此并非所有值都适用于所有分析模型。使用IsAnalyzeAsValid（）方法确定特定值是否适用于分析模型。</p>
<h3 id="手动调节"><a href="#手动调节" class="headerlink" title="手动调节"></a>手动调节</h3><p>结构杆件分析模型的几何图形也可以相对于它所连接的图元进行调整（假设SupportsManualAdjustment（）方法返回true）。使用AnalyticalModel.ManuallyAdjust（）方法相对于另一个图元调整分析模型。</p>
<p>代码区域29-14：相对于另一个图元调整分析模型</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Pick the source analytical line to adjust to</span></span><br><span class="line">Selection sel = app.ActiveUIDocument.Selection;</span><br><span class="line">Reference refAnalytical = sel.PickObject(ObjectType.Element, <span class="string">&quot;Please Pick the source analytical line to adjust to&quot;</span>);</span><br><span class="line">AnalyticalModel aModel = doc.GetElement(refAnalytical) <span class="keyword">as</span> AnalyticalModel;</span><br><span class="line">Curve aCurve = aModel.GetCurve();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get the reference of the start point</span></span><br><span class="line">AnalyticalModelSelector aSelector = <span class="keyword">new</span> AnalyticalModelSelector(aCurve);</span><br><span class="line">aSelector.CurveSelector = AnalyticalCurveSelector.StartPoint;</span><br><span class="line">Reference refSource = aModel.GetReference(aSelector);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Pick the source analytical line to be adjusted</span></span><br><span class="line">Reference refAnalytical2 = sel.PickObject(ObjectType.Element, <span class="string">&quot;Please pick the source analytical line to be adjusted&quot;</span>);</span><br><span class="line">AnalyticalModel aModel2 = doc.GetElement(refAnalytical2) <span class="keyword">as</span> AnalyticalModel;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get the reference of the start point</span></span><br><span class="line">Curve aCurve2 = aModel2.GetCurve();</span><br><span class="line">AnalyticalModelSelector aSelector2 = <span class="keyword">new</span> AnalyticalModelSelector(aCurve2);</span><br><span class="line">aSelector2.CurveSelector = AnalyticalCurveSelector.StartPoint;</span><br><span class="line"><span class="comment">// Can be adjusted to the middle of the line if WholeCurve is used</span></span><br><span class="line">Reference refTarget = aModel2.GetReference(aSelector2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Adjust the analytical line</span></span><br><span class="line">aModel.ManuallyAdjust(refSource, refTarget, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<p>AnalyticalModel还提供了一些方法，用于确定分析模型是否已被手动调整，以及将其重置回相对于其相应物理模型的原始位置。此外，GetManualAdjustmentMatchedElements（）方法检索元素Id的集合，分析模型已根据这些元素Id进行了调整。</p>
<h3 id="分析偏移"><a href="#分析偏移" class="headerlink" title="分析偏移"></a>分析偏移</h3><p>调整分析模型的另一种方法是使用偏移。设置分析偏移与手动调整分析模型不同。分析偏移是应用于整个分析模型的基本偏移，独立于任何其他图元。AnalyticalModel具有获取和设置分析偏移以及确定是否可以更改分析偏移的方法（CanSetAnalyticalOffset（））。</p>
<h3 id="分析模型支撑"><a href="#分析模型支撑" class="headerlink" title="分析模型支撑"></a>分析模型支撑</h3><p>括每个支撑的优先级（如果多个图元提供支撑）以及提供支撑的点、曲线或面。以下示例说明如何在不同条件下使用AnalyticalModelSupport对象。</p>
<p><strong>楼板和结构梁支撑信息</strong></p>
<p>在草图模式下绘制板时，请选择设计栏上的“拾取支座”。如下图所示，板有三个支撑梁。通过迭代板的AnalyticalModelSupports集合，可以获得三个梁以及CurveSupport AnalyticalSupportType。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-93B7CB30-48F8-4580-88F4-973E91BE718B-low.png" alt="img">图160：楼板和结构梁支撑信息</p>
<p><strong>地板和墙壁支撑信息</strong></p>
<p>通过拾取墙作为支撑来绘制板后，无法从楼板的AnalyticalModelSupport集合中获取墙。相反，Floor在Wall的AnalyticalModelSupports集合中可用。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-9EB168A7-3040-465D-B3B8-D9E39529E4B4-low.png" alt="img">图161：地板和墙壁支撑信息</p>
<p><strong>结构柱、梁和支撑支撑信息</strong></p>
<p>在下图中，水平梁有三个点支撑–两个结构柱和一个结构支撑。支撑有三个点支撑–两个结构柱和一个结构梁。两个柱都没有支撑元件。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-F386B22F-C4FD-4DC3-A751-BE9076FDF4C5-low.png" alt="img"><br>图162：StructuralElements支撑信息</p>
<p><strong>梁系统和墙支撑信息</strong></p>
<p>虽然在绘制BeamSystem时可以拾取墙作为支撑，但由于BeamSystem没有AnalyticalModel属性，因此无法直接获得其支撑信息。解决方案是调用GetBeamIds（）方法，以检索Beams的AnalyticalModelSupport集合。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-8B85D42D-52D3-42DA-B416-B5D63B0884D3-low.png" alt="img"></p>
<p>图163：梁系统和墙支撑信息</p>
<p><strong>墙基础和墙支撑信息</strong></p>
<p>对于具有条形基础的墙，该墙具有可用于条形基础的CurveSupport。可以使用AnalyticalModel.GetCurves（）方法获得支撑曲线。在下面的示例中，曲线中有两个圆弧。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-29E58471-AA23-45AE-9DDB-FAAF03462296-low.png" alt="img"><br>图164：墙基础和墙支撑信息</p>
<p><strong>独立基础和结构柱支撑信息</strong></p>
<p>结构柱可以将独立基脚作为点支撑。在这种情况下，基脚可以随支撑的结构柱移动。具有OST_StructuralFoundation类别的FamilyInstance的ElementId可从AnalyticalModelSupport.GetSupportingElement（）方法获得。通常，支撑点是从AnalyticalModel.GetCurve（）方法检索的曲线的底部点。在从GetPoint（）方法获得独立基脚FamilyInstance和AnalyticalModel Point后，也可以使用该选项。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-70211C95-7FE5-4A12-A4E0-52EA53FC2DEB-low.png" alt="img"><br>图165：独立基础（FamilyInstance)和结构柱支撑信息</p>
<h3 id="分析杆件力"><a href="#分析杆件力" class="headerlink" title="分析杆件力"></a>分析杆件力</h3><p>AnalyticalModelStick类可以在杆元素的每一端存储六个内力。在每个端部处，可以存储3个平移力和3个旋转（力矩）力。这些杆件力可以表示模型上的一组特定载荷的结果，也可以表示用于连接设计的设计力。与荷载工况或组合无关。杆件力对应于分析杆模型（位于梁、支撑和柱上）的UI的“杆件力”属性。</p>
<p>这些力由PermanerForces类表示，该类提供获取和设置所有6个力分量（3个力，3个力矩）的访问权限，并通过Start属性指示对象是表示杆件起点处的力还是表示杆件终点处的力：对于起点和终点力，设置为true;对于终点力，设置为false。</p>
<p>开始和结束力和力矩都存储为由力或力矩的分量值组成的XYZ向量。例如，在一个示例中，力。X表示沿X方向作用的力的值。</p>
<h3 id="阅读杆力"><a href="#阅读杆力" class="headerlink" title="阅读杆力"></a>阅读杆力</h3><p>可以通过调用方法AnalyticalModelStick. GetForces（）来访问与分析模型一起存储的杆件力，该方法返回最小计数为零、最大计数为2（每端一个）的GetForces对象列表。如果没有为成员存储成员力，则列表将为空，如果只有一端指定了力，则列表将仅包含一个MemberForces对象。请注意，在UI中设置为“Released”或通过AnalyticalModleStick.SetReleases（）设置为true（已释放）的任何力或力矩方向在通过AnalyticalModleStick. GetReleaserForces（）查询时将报告为0.0。（释放的力或力矩不能抵抗释放方向上的力或力矩。）</p>
<h3 id="设置构件力"><a href="#设置构件力" class="headerlink" title="设置构件力"></a>设置构件力</h3><p>可以通过调用重载的SetForceForces（）方法之一来在AnalyticalModelStick上设置成员力。SetBumerForces（）将用新提供的杆件力覆盖任何现有杆件力。</p>
<p>对于当前释放的任何力或力矩方向，UI和AnalyticalModelStick. GetReleases（）都将返回这些值为零，但如果您通过AnalyticalModelStick. SetReleases（）方法设置它们，它们将被保留，以便如果用户稍后清除释放，或者您通过AnalyticalModelStick.SetReleases（）清除释放，则将报告先前设置的值。</p>
<h3 id="移除杆件力"><a href="#移除杆件力" class="headerlink" title="移除杆件力"></a>移除杆件力</h3><p>Member forces for AnalyticalModelSticks may be removed for both ends at once or only for an individual end. To remove all AnalyticalModelSticks的杆件力可以同时从两端删除，也可以仅从单个端删除。若要移除元素的所有成员力，请调用AnalyticalModelStick. RemoveAllModelerForces（）。若要仅移除起点或终点的杆件力，请调用AnalyticalModelStick. RemoveModelerForces（）并指示要移除的终点。</p>
<h2 id="荷载"><a href="#荷载" class="headerlink" title="荷载"></a>荷载</h2><p>以下部分确定荷载设置并讨论荷载限制指南。</p>
<p><strong>加载设置</strong></p>
<p>API可以访问“设置”对话框”荷载工况“和”荷载组合“选项卡上的所有功能。</p>
<p>以下属性可从相应的LoadCase BuiltInParameter中获得：</p>
<p><strong>表60荷载工况特性和参数</strong></p>
<table>
<thead>
<tr>
<th>**Property **</th>
<th>**BuiltInParameter **</th>
</tr>
</thead>
<tbody><tr>
<td>Case Number</td>
<td>LOAD_CASE _NUMBER</td>
</tr>
<tr>
<td>Nature</td>
<td>LOAD_CASE_NATURE</td>
</tr>
<tr>
<td>Category</td>
<td>LOAD_CASE_CATEGORY</td>
</tr>
</tbody></table>
<p>LOAD_CASE_CATEGORY参数返回ElementId。下表标识了类别和元素ID值之间的映射。</p>
<p>表61：载荷工况类别</p>
<table>
<thead>
<tr>
<th><strong>Load Case Category 荷载工况类别</strong></th>
<th><strong>BuiltInCategory</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Dead Loads  恒载</td>
<td>OST_LoadCasesDead</td>
</tr>
<tr>
<td>Live Loads  活荷载</td>
<td>OST_LoadCasesLive</td>
</tr>
<tr>
<td>Wind Loads  风荷载</td>
<td>OST_LoadCasesWind</td>
</tr>
<tr>
<td>Snow Loads  雪荷载</td>
<td>OST_LoadCasesSnow</td>
</tr>
<tr>
<td>Roof Live Loads  屋顶活荷载</td>
<td>OST_LoadCasesRoofLive</td>
</tr>
<tr>
<td>Accidental Loads  偶然荷载</td>
<td>OST_LoadCasesAccidental</td>
</tr>
<tr>
<td>Temperature Loads  温度荷载</td>
<td>OST_LoadCasesTemperature</td>
</tr>
<tr>
<td>Seismic Loads  地震荷载</td>
<td>OST_LoadCasesSeismic</td>
</tr>
</tbody></table>
<h3 id="创建荷载和荷载组合"><a href="#创建荷载和荷载组合" class="headerlink" title="创建荷载和荷载组合"></a>创建荷载和荷载组合</h3><p>下面的类有一个或多个静态Create（）方法来创建相应的类：</p>
<ul>
<li>LoadUsage </li>
<li>LoadNature</li>
<li>LoadCase </li>
<li>LoadCombination</li>
<li>PointLoad </li>
<li>LineLoad</li>
<li>AreaLoad</li>
</ul>
<p>因为它们都是Element子类，所以可以使用Document.Delete（）删除它们。</p>
<p>荷载组合是通过静态方法LoadCombination.Create（）创建的，该方法有两个重载。第一种方法只接受对要在其中创建加载组合的文档的引用和新组合名称的字符串。第二个函数接受这些参数加上LoadCombinationType和LoadCombinationState。LoadCombinationType可以是Combination（直接荷载组合）或Envelope（多个荷载工况或组合的效应包络）。</p>
<p>LoadCombinationState可以是Serviceability或Ultimate。如果荷载组合代表结构上的服务荷载水平，则使用“可服务性”。这通常用于设计或检查构件挠度或其他可用性标准，如许用应力设计方法。如果荷载组合表示荷载抗力系数设计方法中通常使用的结构上的极限荷载状态或系数荷载状态，请使用极限荷载。</p>
<p>创建LoadCombination后，需要使用LoadComponents填充它，LoadComponents包含荷载组合及其系数。LoadComponents通过调用LoadCombination.SetComponents（）添加到LoadCombination中，并带有组件列表，如下面的代码片段所示。<br>注意：请确保组件列表不涉及其本身。下面的示例演示如何创建荷载组合，以及如何查找或创建用于设置荷载组合构件的荷载工况和荷载性质。</p>
<p>代码区域：创建新的LoadCombination</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function">LoadCombination <span class="title">CreateLoadCombinationLoadCaseLoadUsageLoadNatureAndLoadComponent</span>(<span class="params">Document document</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Create a new load combination</span></span><br><span class="line">    LoadCombination loadCombination = LoadCombination.Create(document, <span class="string">&quot;DL1 + RAIN1&quot;</span>, LoadCombinationType.Combination, LoadCombinationState.Ultimate);</span><br><span class="line">    <span class="keyword">if</span> (loadCombination == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Create new load combination failed.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get all existing LoadCase</span></span><br><span class="line">    FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">    ICollection collection = collector.OfClass(<span class="keyword">typeof</span>(LoadCase)).ToElements();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find LoadCase &quot;DL1&quot;</span></span><br><span class="line">    LoadCase case1 = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">foreach</span> (Element e <span class="keyword">in</span> collection)</span><br><span class="line">    &#123;</span><br><span class="line">        LoadCase loadCase = e <span class="keyword">as</span> LoadCase;</span><br><span class="line">        <span class="keyword">if</span> (loadCase.Name == <span class="string">&quot;DL1&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            case1 = loadCase;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get all existing LoadNature</span></span><br><span class="line">    collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">    collection = collector.OfClass(<span class="keyword">typeof</span>(LoadNature)).ToElements();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find LoadNature &quot;Dead&quot;</span></span><br><span class="line">    LoadNature nature1 = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">foreach</span> (Element e <span class="keyword">in</span> collection)</span><br><span class="line">    &#123;</span><br><span class="line">        LoadNature loadNature = e <span class="keyword">as</span> LoadNature;</span><br><span class="line">        <span class="keyword">if</span> (loadNature.Name == <span class="string">&quot;Dead&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            nature1 = loadNature;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create LoadNature &quot;Dead&quot; if not exist</span></span><br><span class="line">    <span class="keyword">if</span> (nature1 == <span class="literal">null</span>)</span><br><span class="line">        nature1 = LoadNature.Create(document, <span class="string">&quot;Dead&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create LoadCase &quot;DL1&quot; if not exist</span></span><br><span class="line">    <span class="keyword">if</span> (case1 == <span class="literal">null</span>)</span><br><span class="line">        case1 = LoadCase.Create(document, <span class="string">&quot;DL1&quot;</span>, nature1.Id, LoadCaseCategory.Dead);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create LoadNature &quot;Rain&quot;</span></span><br><span class="line">    LoadNature nature2 = LoadNature.Create(document, <span class="string">&quot;Rain&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (nature2 == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Create new load nature failed.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create LoadCase &quot;RAIN1&quot;</span></span><br><span class="line">    LoadCase case2 = LoadCase.Create(document, <span class="string">&quot;RAIN1&quot;</span>, nature2.Id, LoadCaseCategory.Snow);</span><br><span class="line">    <span class="keyword">if</span> (case1 == <span class="literal">null</span> || case2 == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Create new load case failed.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create LoadComponents - they consist of LoadCases or nested LoadCombination and Factors</span></span><br><span class="line">    List components = <span class="keyword">new</span> List();</span><br><span class="line">    components.Add(<span class="keyword">new</span> LoadComponent(case1.Id, <span class="number">2.0</span>));</span><br><span class="line">    components.Add(<span class="keyword">new</span> LoadComponent(case2.Id, <span class="number">1.5</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add components to combination</span></span><br><span class="line">    loadCombination.SetComponents(components);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create LoadUsages</span></span><br><span class="line">    LoadUsage usage1 = LoadUsage.Create(document, <span class="string">&quot;Frequent&quot;</span>);</span><br><span class="line">    LoadUsage usage2 = LoadUsage.Create(document, <span class="string">&quot;Rare&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (usage1 == <span class="literal">null</span> || usage2 == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Create new load usage failed.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add load usages to combination</span></span><br><span class="line">    loadCombination.SetUsageIds(<span class="keyword">new</span> List() &#123;usage1.Id, usage2.Id&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Give the user some information</span></span><br><span class="line">    TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>, <span class="built_in">string</span>.Format(<span class="string">&quot;Load Combination ID=&#x27;&#123;0&#125;&#x27; created successfully.&quot;</span>, loadCombination.Id.IntegerValue));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> loadCombination;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>您还可以通过使用LoadCombination.GetComponents（）修改案例、组件、性质等，进行修改，然后再次调用LoadCombination.SetComponents（）。可以通过调用LoadCombination. GetUsageIds（）来修改LoadCombination的LoadUsages，以获取LoadUsage Ids的列表，修改该列表，然后再次调用SetUsageIds（）。下面的代码示例演示如何修改现有的LoadCombination。</p>
<p>代码区域：修改荷载组合</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ModifyLoadCombinationLoadCaseLoadUsageLoadNatureAndLoadComponent</span>(<span class="params">Document document, LoadCombination loadCombination</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Change name of LoadCombination</span></span><br><span class="line">    loadCombination.Name = <span class="string">&quot;DL2 + RAIN1&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get any LoadCase from combination</span></span><br><span class="line">    <span class="comment">// Combination can have assigned LoadCase or other (nested) LoadCombination so we need to filter out any LoadCombination</span></span><br><span class="line">    LoadCase case1 = <span class="literal">null</span>;</span><br><span class="line">    IList caseAndCombinationIds = loadCombination.GetCaseAndCombinationIds();</span><br><span class="line">    <span class="keyword">foreach</span> (ElementId id <span class="keyword">in</span> caseAndCombinationIds)</span><br><span class="line">    &#123;</span><br><span class="line">        Element element = document.GetElement(id);</span><br><span class="line">        <span class="keyword">if</span> (element <span class="keyword">is</span> LoadCase)</span><br><span class="line">        &#123;</span><br><span class="line">            case1 = (LoadCase)element;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (element <span class="keyword">is</span> LoadCombination)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (case1 == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Can&#x27;t get LoadCase.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Change case name and number</span></span><br><span class="line">    case1.Name = <span class="string">&quot;DL2&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (LoadCase.IsNumberUnique(document, <span class="number">3</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        case1.Number = <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create load nature</span></span><br><span class="line">    LoadNature liveNature = LoadNature.Create(document, <span class="string">&quot;Dead nature&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (liveNature == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Create new load nature failed.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Change nature category and ID for case</span></span><br><span class="line">    case1.SubcategoryId = <span class="keyword">new</span> ElementId(BuiltInCategory.OST_LoadCasesDead);</span><br><span class="line">    case1.NatureId = liveNature.Id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Change factor for case1</span></span><br><span class="line">    IList components = loadCombination.GetComponents();</span><br><span class="line">    <span class="keyword">foreach</span> (LoadComponent loadComponent <span class="keyword">in</span> components)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (loadComponent.LoadCaseOrCombinationId == case1.Id)</span><br><span class="line">        &#123;</span><br><span class="line">            loadComponent.Factor = <span class="number">3.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    loadCombination.SetComponents(components);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Remove one usage from combination</span></span><br><span class="line">    IList usages = loadCombination.GetUsageIds();</span><br><span class="line">    usages.RemoveAt(<span class="number">0</span>);</span><br><span class="line">    loadCombination.SetUsageIds(usages);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Give the user some information</span></span><br><span class="line">    TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>, <span class="built_in">string</span>.Format(<span class="string">&quot;Load Combination ID=&#x27;&#123;0&#125;&#x27; modified successfully.&quot;</span>, loadCombination.Id.IntegerValue));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>LoadCase和LoadNature类中没有Duplicate（）方法。若要实现此功能，必须首先创建一个新的LoadCase（或LoadNature）对象，然后从现有的LoadCase（或LoadNature）复制相应的属性和参数。 以下是演示在VB.NET中创建点荷载的最小示例代码：</p>
<p>代码区域：新PointLoad</p>
<figure class="highlight vb"><table><tr><td class="code"><pre><span class="line"><span class="comment">&#x27;Define the location at which the PointLoad is applied. </span></span><br><span class="line"><span class="keyword">Dim</span> point <span class="keyword">As</span> <span class="built_in">New</span> XYZ(<span class="number">0</span>, <span class="number">0</span>, <span class="number">4</span>)</span><br><span class="line"><span class="comment">&#x27;Define the 3d force. </span></span><br><span class="line"><span class="keyword">Dim</span> force <span class="keyword">As</span> <span class="built_in">New</span> XYZ(<span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>)</span><br><span class="line"><span class="comment">&#x27;Define the 3d moment. </span></span><br><span class="line"><span class="keyword">Dim</span> moment <span class="keyword">As</span> <span class="built_in">New</span> XYZ(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">Dim</span> pointLoad <span class="keyword">As</span> PointLoad = pointLoad.Create(document, point, force, moment, <span class="literal">Nothing</span>, <span class="literal">Nothing</span>)</span><br></pre></td></tr></table></figure>

<h2 id="分析链接"><a href="#分析链接" class="headerlink" title="分析链接"></a>分析链接</h2><p>使用Revit，在创建物理模型时会自动生成结构分析模型。分析模型将链接到结构分析应用程序，物理模型将通过Revit API根据结果自动更新。一些第三方软件开发商已经为其结构分析应用程序提供了双向链接。其中包括：</p>
<ul>
<li>ADAPT Corporation（<a href="http://www.adaptsoft.com/revitstructure/">www.adaptsoft.com/revitstructure/</a>）的ADAPT-Builder Suite</li>
<li>Fastrak和S-Frame来自CSC（<a href="http://www.cscworld.com/">www.cscworld.com</a>）</li>
<li>来自CSI的ETABS（<a href="http://www.csiberkeley.com/">www.csiberkeley.com/</a>）</li>
<li>RFEM来自Dlubal（<a href="https://www.dlubal.com/en/download/rfem_revit_en.pdf">www.dlubal.com/en/download/rfem_revit_en.pdf</a>）</li>
<li>GRAITEC（<a href="http://www.graitec.com/En/revit.asp">www.graitec.com/En/revit.asp</a>）的高级设计、视觉设计、Arche、Effel和SuperSTRESS</li>
<li>来自Nemetschek的Scia工程师（<a href="https://www.scia.net/en/software/product-selection/scia-engineer%EF%BC%89">https://www.scia.net/en/software/product-selection/scia-engineer）</a></li>
<li>来自Oasys Software（Arup）的GSA（<a href="http://www.oasys-software.com/products">www.oasys-software.com/products</a>）</li>
<li>Prokon Software Consultants的ProDESK（<a href="http://www.prokon.com/">www.prokon.com/</a>）</li>
<li>Bentley的RAM Structural System（<a href="http://www.bentley.com/en-US/Products/RAM+Structural+System/">www.bentley.com/en-US/Products/RAM+Structural+System/</a>）</li>
<li>RISA-3D和RISAFloor，来自RISA Technologies（<a href="http://www.risatech.com/partner/revit_structure.asp">www.risatech.com/partner/revit_structure.asp</a>）</li>
<li>SOFiSTiK Structural Desktop Suite来自SOFiSTiK（<a href="http://www.sofistik.com/">http://www.sofistik.com</a>）</li>
<li>来自SPACE GASS（<a href="http://www.example.com)的space/">www.example.com）的SPACE</a> GASS<a href="http://www.spacegass.com/index.asp?resend=/revit.asp">www.spacegass.com/index.asp? resend=/revit.asp</a>）</li>
<li>来自Structural Integrators的Revit Structure STAAD.Pro界面（<a href="http://www.structuralintegrators.com/products/si_xchange.php">structuralintegrators.com&#x2F;products&#x2F;si_xchange.php</a>）</li>
<li>Autodesk的Robot Structural Analysis Professional（<a href="http://www.autodesk.com/products/robot-structural-analysis%EF%BC%89">http://www.autodesk.com/products/robot-structural-analysis）</a></li>
</ul>
<p>The key to linking Revit to other analysis applications is to set up the mapping relationship between the objects in different object models. That means the difficulty and level of the integration depends on the similarity between the two object models.<br>将Revit链接到其他分析应用程序的关键是设置不同对象模型中的对象之间的映射关系。这意味着集成的难度和水平取决于两个对象模型之间的相似性。</p>
<p>For example, during the product design process, design a table with at least the first two columns in the object mapping in the following table: one for the Revit API and the other for the structural analysis application, shown as follows:<br>例如，在产品设计过程中，设计一个表，其中至少包含下表中对象映射的前两列：一列用于Revit API，另一列用于结构分析应用程序，如下所示：</p>
<p><strong>表62：Revit和Analysis应用程序对象映射</strong></p>
<table>
<thead>
<tr>
<th><strong>Revit API</strong></th>
<th><strong>Analysis Application 分析应用</strong></th>
<th><strong>Import to Revit 导入到Revit</strong></th>
</tr>
</thead>
<tbody><tr>
<td>StructuralColumn  结构柱</td>
<td>Column  柱</td>
<td>NewStructuralColumn  新建结构柱</td>
</tr>
<tr>
<td>Property:  属性：</td>
<td></td>
<td></td>
</tr>
<tr>
<td>…</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Location  位置</td>
<td></td>
<td>Read-only;  只读;</td>
</tr>
<tr>
<td>Parameter:  参数名称：</td>
<td></td>
<td></td>
</tr>
<tr>
<td>…</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Analyze as  分析为</td>
<td></td>
<td>Editable;  可编辑;</td>
</tr>
<tr>
<td>AnalyticalModel:  分析模型：</td>
<td></td>
<td></td>
</tr>
<tr>
<td>…</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Profile  轮廓</td>
<td></td>
<td>Read-only;  只读;</td>
</tr>
<tr>
<td>RigidLink</td>
<td></td>
<td>Read-only;  只读;</td>
</tr>
<tr>
<td>…</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Material:  材质：</td>
<td></td>
<td></td>
</tr>
<tr>
<td>…</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="Analytical-Links"><a href="#Analytical-Links" class="headerlink" title="Analytical Links"></a>Analytical Links</h2><p>分析链接是连接2个独立分析节点的图元，具有固定状态等属性。在建模过程中，Revit可以根据某些规则自动创建从分析梁到分析柱的分析链接。也可以在Revit UI中或使用Revit API手动创建。</p>
<p>在Revit API中，分析链接由AnalyticalLink类表示。固定度值可从其关联的AnalyticalLinkType获得。</p>
<p>下面的示例演示了如何读取文档中的所有AnalyticalLinks，并显示一个汇总自动生成和手动创建的AnalyticalLinks数量的TaskDialog。</p>
<p>代码区域：阅读分析链接</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ReadAnalyticalLinks</span>(<span class="params">Document document</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    FilteredElementCollector collectorAnalyticalLinks = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">    collectorAnalyticalLinks.OfClass(<span class="keyword">typeof</span>(AnalyticalLink));</span><br><span class="line"></span><br><span class="line">    IEnumerable alinks = collectorAnalyticalLinks.ToElements().Cast();</span><br><span class="line">    <span class="built_in">int</span> nAutoGeneratedLinks = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">int</span> nManualLinks = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">foreach</span> (AnalyticalLink alink <span class="keyword">in</span> alinks)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (alink.IsAutoGenerated() == <span class="literal">true</span>)</span><br><span class="line">            nAutoGeneratedLinks++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            nManualLinks++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">string</span> msg = <span class="string">&quot;Auto-generated AnalyticalLinks: &quot;</span> + nAutoGeneratedLinks;</span><br><span class="line">    msg += <span class="string">&quot;\nManually created AnalyticalLinks: &quot;</span> + nManualLinks;</span><br><span class="line">    TaskDialog.Show(<span class="string">&quot;AnalyticalLinks&quot;</span>, msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>静态方法AnalyticalLink.Create（）创建一个新的分析链接。不是直接连接两个元素，而是在两个集线器之间创建连接。Hub类表示两个或多个Autodesk Revit元素之间的连接。 以下示例在两个选定的FamilyInstance对象之间创建新的分析链接。它使用一个过滤器来查找模型中的所有中心点，然后GetHub（）方法搜索中心点以查找引用每个FamilyInstance的AnalyticalModel的ID的中心点。</p>
<p>代码区域：创建新的AnalyticalLink</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">CreateLink</span>(<span class="params">Document doc, FamilyInstance fi1, FamilyInstance fi2</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    FilteredElementCollector hubCollector = <span class="keyword">new</span> FilteredElementCollector(doc);</span><br><span class="line">    hubCollector.OfClass(<span class="keyword">typeof</span>(Hub));  <span class="comment">//Get all hubs</span></span><br><span class="line">    ICollection allHubs = hubCollector.ToElements();</span><br><span class="line">    FilteredElementCollector linktypeCollector = <span class="keyword">new</span> FilteredElementCollector(doc);</span><br><span class="line">    linktypeCollector.OfClass(<span class="keyword">typeof</span>(AnalyticalLinkType));</span><br><span class="line">    ElementId firstLinkType = linktypeCollector.ToElementIds().First();  <span class="comment">//Get the first analytical link type.</span></span><br><span class="line">    <span class="comment">// Get hub Ids from two selected family instance items</span></span><br><span class="line">    ElementId startHubId = GetHub(fi1.GetAnalyticalModel().Id, allHubs);</span><br><span class="line">    ElementId endHubId = GetHub(fi2.GetAnalyticalModel().Id, allHubs);</span><br><span class="line">    Transaction tran = <span class="keyword">new</span> Transaction(doc, <span class="string">&quot;Create Link&quot;</span>);</span><br><span class="line">    tran.Start();</span><br><span class="line">    <span class="comment">//Create a link between these two hubs.</span></span><br><span class="line">    AnalyticalLink createdLink = AnalyticalLink.Create(doc, firstLinkType, startHubId, endHubId);    tran.Commit();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Get the first Hub on a given AnalyticalModel element</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> ElementId <span class="title">GetHub</span>(<span class="params">ElementId hostId, ICollection allHubs</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">foreach</span> (Element ehub <span class="keyword">in</span> allHubs)</span><br><span class="line">    &#123;</span><br><span class="line">        Hub hub = ehub <span class="keyword">as</span> Hub;</span><br><span class="line">        ConnectorManager manager = hub.GetHubConnectorManager();</span><br><span class="line">        ConnectorSet connectors = manager.Connectors;</span><br><span class="line">        <span class="keyword">foreach</span> (Connector connector <span class="keyword">in</span> connectors)</span><br><span class="line">        &#123;</span><br><span class="line">            ConnectorSet refConnectors = connector.AllRefs;</span><br><span class="line">            <span class="keyword">foreach</span> (Connector refConnector <span class="keyword">in</span> refConnectors)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (refConnector.Owner.Id == hostId)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> hub.Id;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ElementId.InvalidElementId;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="注：翻译自Revit-API-Developers-Guide"><a href="#注：翻译自Revit-API-Developers-Guide" class="headerlink" title="注：翻译自Revit API Developers Guide"></a><em><strong>注：</strong></em>翻译自<a href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_html">Revit API Developers Guide</a></h2>]]></content>
      <categories>
        <category>Revit二次开发人员指南</category>
      </categories>
      <tags>
        <tag>Revit</tag>
      </tags>
  </entry>
  <entry>
    <title>33命令</title>
    <url>/2024/11/23/%E4%BA%8C%E5%BC%80%E6%8C%87%E5%8D%97/33%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="命令"><a href="#命令" class="headerlink" title="命令"></a><a href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_Advanced_Topics_Commands_html">命令</a></h1><p>Revit API 提供对现有 Revit 命令的访问，这些命令位于选项卡、应用程序菜单或右键单击菜单中。使用 API 处理 Revit 命令的主要方法是替换现有命令实现或发布命令。</p>
<h3 id="替代-Revit-命令"><a href="#替代-Revit-命令" class="headerlink" title="替代 Revit 命令"></a>替代 Revit 命令</h3><p>AddInCommandBinding 类可用于替代 Revit 中的现有命令。它有三个与替换现有命令实现相关的事件。</p>
<ul>
<li><strong>BeforeExecuted</strong> - 此只读事件在关联命令执行之前发生。应用程序可以对此事件做出反应，但不能更改文档或影响命令的调用。</li>
<li><strong>CanExecute</strong> - 当关联的命令启动检查以确定是否可以在命令目标上执行命令时出现。</li>
<li><strong>Executed</strong> - 当执行关联的命令时，将发生此事件，并且应在此处执行任何覆盖实现。</li>
</ul>
<p>要创建 commandbinding，请调用 UIApplication.CreateAddInCommandBinding（） 或 UIControlledApplication.CreateAddInCommandBinding（）。这两种方法都需要 RevitCommandId ID 来标识要替换的命令处理程序。RevitCommandId 有两种用于获取命令 ID 的静态方法：</p>
<ul>
<li><strong>LookupCommandId</strong> - 使用给定的 ID 字符串检索 Revit 命令 ID。要查找命令 ID 字符串，请打开 Revit 的会话，调用所需的命令，关闭 Revit，然后查看该会话的日志。选择时记录的 “Jrn.Command” 条目将具有 LookupCommandId（） 所需的字符串，并且看起来类似于 “ID_EDIT_DESIGNOPTIONS”。</li>
<li><strong>LookupPostableCommandId</strong> - 使用 PostableCommand 枚举检索 Revit 命令 ID。这仅适用于可提交的命令（将在下一节中讨论）。</li>
</ul>
<p>以下示例摘自 Revit 2014 SDK 的 DisableCommand 示例，演示了如何创建 AddInCommandBinding 并替代实现以禁用该命令，并向用户发送消息。</p>
<p>代码区域：替代命令</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> </span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> Implements the Revit add-in interface IExternalApplication</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Application</span> : <span class="title">IExternalApplication</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">region</span> IExternalApplication Members</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> </span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> Implements the OnStartup event</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> </span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> </span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">OnStartup</span>(<span class="params">UIControlledApplication application</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Lookup the desired command by name</span></span><br><span class="line">        s_commandId = RevitCommandId.LookupCommandId(s_commandToDisable);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Confirm that the command can be overridden</span></span><br><span class="line">        <span class="keyword">if</span> (!s_commandId.CanHaveBinding)</span><br><span class="line">        &#123;</span><br><span class="line">            ShowDialog(<span class="string">&quot;Error&quot;</span>, <span class="string">&quot;The target command &quot;</span> + s_commandToDisable +</span><br><span class="line">                        <span class="string">&quot; selected for disabling cannot be overridden&quot;</span>);</span><br><span class="line">   <span class="keyword">return</span> Result.Failed;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create a binding to override the command.</span></span><br><span class="line">        <span class="comment">// Note that you could also implement .CanExecute to override the accessibiliy of the command.</span></span><br><span class="line">        <span class="comment">// Doing so would allow the command to be grayed out permanently or selectively, however,</span></span><br><span class="line">        <span class="comment">// no feedback would be available to the user about why the command is grayed out.</span></span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            AddInCommandBinding commandBinding = application.CreateAddInCommandBinding(s_commandId);</span><br><span class="line">            commandBinding.Executed += DisableEvent;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Most likely, this is because someone else has bound this command already.</span></span><br><span class="line">        <span class="keyword">catch</span> (Exception)</span><br><span class="line">        &#123;</span><br><span class="line">            ShowDialog(<span class="string">&quot;Error&quot;</span>, <span class="string">&quot;This add-in is unable to disable the target command &quot;</span> + s_commandToDisable +</span><br><span class="line">                        <span class="string">&quot;; most likely another add-in has overridden this command.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Result.Succeeded;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> </span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> Implements the OnShutdown event</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> </span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> </span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">OnShutdown</span>(<span class="params">UIControlledApplication application</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Remove the command binding on shutdown</span></span><br><span class="line">        <span class="keyword">if</span> (s_commandId.HasBinding)</span><br><span class="line">            application.RemoveAddInCommandBinding(s_commandId);</span><br><span class="line">        <span class="keyword">return</span> Result.Succeeded;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">endregion</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> </span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> A command execution method which disables any command it is applied to (with a user-visible message).</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> </span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> Event sender.</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> Arguments.</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">DisableEvent</span>(<span class="params"><span class="built_in">object</span> sender, ExecutedEventArgs <span class="keyword">args</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        ShowDialog(<span class="string">&quot;Disabled&quot;</span>, <span class="string">&quot;Use of this command has been disabled.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> </span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> Show a task dialog with a message and title.</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> </span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> The title.</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> The message.</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ShowDialog</span>(<span class="params"><span class="built_in">string</span> title, <span class="built_in">string</span> message</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Show the user a message.</span></span><br><span class="line">        TaskDialog td = <span class="keyword">new</span> TaskDialog(title)</span><br><span class="line">        &#123;</span><br><span class="line">            MainInstruction = message,</span><br><span class="line">            TitleAutoPrefix = <span class="literal">false</span></span><br><span class="line">        &#125;;</span><br><span class="line">        td.Show();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> </span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> The string name of the command to disable.  To lookup a command id string, open a session of Revit,</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> invoke the desired command, close Revit, then look to the journal from that session.  The command</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> id string will be toward the end of the journal, look for the &quot;Jrn.Command&quot; entry that was recorded</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> when it was selected.</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> </span></span><br><span class="line">    <span class="keyword">static</span> String s_commandToDisable = <span class="string">&quot;ID_EDIT_DESIGNOPTIONS&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> </span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> The command id, stored statically to allow for removal of the command binding.</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> </span></span><br><span class="line">    <span class="keyword">static</span> RevitCommandId s_commandId;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="发布命令"><a href="#发布命令" class="headerlink" title="发布命令"></a>发布命令</h3><p>方法 UIApplication.PostCommand（） 将命令发布到 Revit 消息队列，以便在控件从当前 API 应用程序返回时调用该命令。只有某些命令可以以这种方式发布。它们包括 Autodesk.Revit.UI.PostableCommand 枚举类型中的所有命令，以及由任何附加模块创建的外部命令。</p>
<p>注意：使用 PostCommand（） 时，即使是可发布的命令也可能无法执行。发生这种情况的一个原因是，如果已经发布了另一个命令。在给定时间，只能将一个命令发布到 Revit，因此，如果发布第二个命令，PostCommand（） 将引发异常。已发布的命令可能无法执行的另一个原因是要执行的命令当时无法访问。它是否可访问仅在 Revit 从 API 上下文返回时确定，因此，由于此原因而执行失败时，不会直接报告给发布命令的应用程序。UIApplication 的 API 应用程序。CanPostCommand（） 可用于识别是否可以发布给定的命令，这意味着它是 PostableCommand 的成员还是外部命令。它不标识该命令当前是否可访问。</p>
<p>PostCommand（） 和 CanPostCommand（） 都需要 RevitCommandId，可以按照上面的“替代 Revit 命令”部分所述获取该 ID。</p>
<h2 id="注：翻译自Revit-API-Developers-Guide"><a href="#注：翻译自Revit-API-Developers-Guide" class="headerlink" title="注：翻译自Revit API Developers Guide"></a><em><strong>注：</strong></em>翻译自<a href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_html">Revit API Developers Guide</a></h2>]]></content>
      <categories>
        <category>Revit二次开发人员指南</category>
      </categories>
      <tags>
        <tag>Revit</tag>
      </tags>
  </entry>
  <entry>
    <title>32动态模型更新</title>
    <url>/2024/11/29/%E4%BA%8C%E5%BC%80%E6%8C%87%E5%8D%97/32%E5%8A%A8%E6%80%81%E6%A8%A1%E5%9E%8B%E6%9B%B4%E6%96%B0/</url>
    <content><![CDATA[<h1 id="动态模型更新"><a href="#动态模型更新" class="headerlink" title="动态模型更新"></a><a href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_Advanced_Topics_Dynamic_Model_Update_html">动态模型更新</a></h1><p>动态模型更新为Revit API应用程序提供了修改Revit模型的能力，作为对模型中发生的更改（当这些更改即将在事务结束时提交时）的反应。Revit API应用程序可以通过实现IUpdater接口并将其注册到UpdaterRegistry类来创建更新程序。注册包括指定模型中的哪些更改应该触发更新程序。</p>
<p>Pages in this section 本节中的页面</p>
<ul>
<li>实现IUpdater</li>
<li>Execute方法</li>
<li>注册更新程序</li>
<li>Exposure to End-User</li>
</ul>
<h2 id="实现IUpdater"><a href="#实现IUpdater" class="headerlink" title="实现IUpdater"></a>实现IUpdater</h2><p>IUpdater接口要求实现以下5个方法：</p>
<ul>
<li>GetUpdaterId()-此方法应为更新程序返回一个全局唯一的ID，包括应用程序ID和此更新程序的ID。此方法在更新程序注册期间调用一次。</li>
<li>GetUpdateName()-如果在运行时更新程序有问题，则返回一个名称，通过该名称可以向用户标识更新程序。</li>
<li>GetAdditionalInformation()-此方法应返回辅助文本，Revit将使用该文本在未加载更新程序时通知最终用户。</li>
<li>GetChangePriority()-此方法标识更新程序将执行的更改的性质。它用于标识更新程序的执行顺序。此方法在更新程序注册期间调用一次。</li>
<li>Execute()-这是Revit将调用以执行更新的方法。有关Execute()方法的更多信息，请参见下一节。</li>
</ul>
<p>如果一个文档被一个Updater修改了，那么这个文档将存储Updater的唯一ID。如果用户稍后打开文档，但Updater不存在，则Revit将警告用户，以前编辑文档的第三方Updater不可用，除非将Updater标记为可选。默认情况下，Updater是非可选的，只有在必要时才应使用可选Updater。</p>
<p>下面的代码是实现IUpdater接口（为新添加的墙更改WallType）并在OnStartup()方法中注册更新程序的简单示例。它演示了创建和使用Updater的所有关键方面。</p>
<p>代码区域25-1：实现IUpdater的示例</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">WallUpdaterApplication</span> : <span class="title">Autodesk.Revit.UI.IExternalApplication</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Result <span class="title">OnStartup</span>(<span class="params">Autodesk.Revit.UI.UIControlledApplication application</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">                <span class="comment">// Register wall updater with Revit</span></span><br><span class="line">                WallUpdater updater = <span class="keyword">new</span> WallUpdater(application.ActiveAddInId);</span><br><span class="line">                UpdaterRegistry.RegisterUpdater(updater);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Change Scope = any Wall element</span></span><br><span class="line">                ElementClassFilter wallFilter = <span class="keyword">new</span> ElementClassFilter(<span class="keyword">typeof</span>(Wall));</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Change type = element addition</span></span><br><span class="line">                UpdaterRegistry.AddTrigger(updater.GetUpdaterId(), wallFilter, Element.GetChangeTypeElementAddition());</span><br><span class="line">                <span class="keyword">return</span> Result.Succeeded;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Result <span class="title">OnShutdown</span>(<span class="params">Autodesk.Revit.UI.UIControlledApplication application</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">                WallUpdater updater = <span class="keyword">new</span> WallUpdater(application.ActiveAddInId);</span><br><span class="line">                UpdaterRegistry.UnregisterUpdater(updater.GetUpdaterId());</span><br><span class="line">                <span class="keyword">return</span> Result.Succeeded;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">WallUpdater</span> : <span class="title">IUpdater</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">static</span> AddInId m_appId;</span><br><span class="line">        <span class="keyword">static</span> UpdaterId m_updaterId;</span><br><span class="line">        WallType m_wallType = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// constructor takes the AddInId for the add-in associated with this updater</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">WallUpdater</span>(<span class="params">AddInId id</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">                m_appId = id;</span><br><span class="line">                m_updaterId = <span class="keyword">new</span> UpdaterId(m_appId, <span class="keyword">new</span> Guid(<span class="string">&quot;FBFBF6B2-4C06-42d4-97C1-D1B4EB593EFF&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Execute</span>(<span class="params">UpdaterData data</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">                Document doc = data.GetDocument();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Cache the wall type</span></span><br><span class="line">                <span class="keyword">if</span> (m_wallType == <span class="literal">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                        FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(doc);</span><br><span class="line">                        collector.OfClass(<span class="keyword">typeof</span>(WallType));</span><br><span class="line">                        <span class="keyword">var</span> wallTypes = <span class="keyword">from</span> element <span class="keyword">in</span> collector</span><br><span class="line">                                                        <span class="keyword">where</span></span><br><span class="line">                                                                element.Name == <span class="string">&quot;Exterior - Brick on CMU&quot;</span></span><br><span class="line">                                                        <span class="keyword">select</span> element;</span><br><span class="line">                        <span class="keyword">if</span> (wallTypes.Count() &gt; <span class="number">0</span>)</span><br><span class="line">                        &#123;</span><br><span class="line">                                m_wallType = wallTypes.Cast().ElementAt(<span class="number">0</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (m_wallType != <span class="literal">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                        <span class="comment">// Change the wall to the cached wall type.</span></span><br><span class="line">                        <span class="keyword">foreach</span> (ElementId addedElemId <span class="keyword">in</span> data.GetAddedElementIds())</span><br><span class="line">                        &#123;</span><br><span class="line">                                Wall wall = doc.GetElement(addedElemId) <span class="keyword">as</span> Wall;</span><br><span class="line">                                <span class="keyword">if</span> (wall != <span class="literal">null</span>)</span><br><span class="line">                                &#123;</span><br><span class="line">                                        wall.WallType = m_wallType;</span><br><span class="line">                                &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">GetAdditionalInformation</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;Wall type updater example: updates all newly created walls to a special wall&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> ChangePriority <span class="title">GetChangePriority</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">return</span> ChangePriority.FloorsRoofsStructuralWalls;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> UpdaterId <span class="title">GetUpdaterId</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">return</span> m_updaterId;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">GetUpdaterName</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;Wall Type Updater&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Execute方法"><a href="#Execute方法" class="headerlink" title="Execute方法"></a>Execute方法</h2><p>Execute()方法的目的是允许你的Updater对文档的更改做出反应，并做出适当的关联。此方法由Revit在文档事务结束时调用，其中添加、更改或删除了与此Updater的UpdateTrigger匹配的元素。由于其他Updater所做的更改，该方法可能会为同一事务调用多次。更新程序在DocumentChanged事件之前调用，因此此事件将包含所有Updater所做的更改。</p>
<p>在调用此方法期间对文档所做的所有更改都将成为调用事务的一部分，并为撤消和重做操作进行维护。在实现此方法时，您可能不会打开任何新事务（将抛出异常），但可以根据需要使用子事务。</p>
<p>虽然它也可以用于更新文档外部的数据，但这些更改不会成为原始事务的一部分，并且在原始事务撤消或重做时不会受到撤消或重做的影响。如果确实使用此方法修改文档外部的数据，则还应订阅DocumentChanged事件，以便在撤消或重做原始事务时更新数据。</p>
<h3 id="变更范围"><a href="#变更范围" class="headerlink" title="变更范围"></a>变更范围</h3><p>Execute()方法有一个UpdaterData参数，它提供执行更新所需的所有必要数据，包括文档和有关触发更新的更改的信息。三个基本方法（GetAddedElementIds()、GetDeletedElementIds()和GetModifiedElementIds()）标识触发更新的元素。Updater还可以使用IsChangeTriggered()方法来检查特定的更改是否触发了更新。</p>
<h3 id="禁止和警告性变更"><a href="#禁止和警告性变更" class="headerlink" title="禁止和警告性变更"></a>禁止和警告性变更</h3><p>执行Updater时不能调用以下方法，因为它们会在元素之间引入交叉引用。(当这些更改与工作集操作结合使用时，可能导致文档损坏）。当更新程序尝试调用以下任何方法时，将引发ForbiddenForDynamicUpdateException：</p>
<ul>
<li>Autodesk.Revit.DB.ViewSheet.AddView()</li>
<li>Autodesk.Revit.DB.Document.LoadFamily（Autodesk.Revit.DB.Document、Autodesk.Revit.DB.IFamilyLoadOptions）</li>
<li>AreaReinforcement.Create()</li>
<li>PathReinforcement.Create()</li>
</ul>
<p>除了上面列出的禁用方法外，其他要求文档处于无事务状态的API方法也不能被调用。这些方法包括但不限于Save（）、SaveAs（）、Close（）、LoadFamily（）等。有关详细信息，请参阅相应方法的文档。</p>
<p>还禁止从更新程序的Execute（）方法内调用UpdaterRegistry类，例如RegistryUpdater（）或AddTrigger（）。调用任何UpdaterRegistry方法都将引发异常。此规则的一个例外是UpdaterRegistry.UnregisterUpdater（）方法，只要要注销的更新程序不是当前正在执行的更新程序，就可以在执行更新程序期间调用该方法。</p>
<p>尽管在执行Updater期间允许使用以下方法，但当调用的结果是建立元素之间的交叉引用时，它们也可以抛出ForbiddenForDynamicUpdateException。其中一个例子是创建一个与现有面墙相交的面墙，因此这两个面墙必定连接在一起。从Updater调用这些方法时要小心：</p>
<ul>
<li>Autodesk.Revit.Creation.ItemFactoryBase.NewFamilyInstances2()</li>
<li>Autodesk.Revit.Creation.ItemFactoryBase.NewFamilyInstance(Autodesk.Revit.DB.XYZ, Autodesk.Revit.DB.FamilySymbol, Autodesk.Revit.DB.Element,Autodesk.Revit.DB.Structure.StructuralType)</li>
<li>Autodesk.Revit.Creation.Document.NewFamilyInstance(Autodesk.Revit.DB.XYZ, Autodesk.Revit.DB.FamilySymbol, Autodesk.Revit.DB.Element, Autodesk.Revit.DB.Level, Autodesk.Revit.DB.Structure.StructuralType)</li>
<li>Autodesk.Revit.DB.FaceWall.Create()</li>
</ul>
<p>因此，应该注意的是，如果修改它们将是有效的，那么删除和重新创造现有元素应该是有效的。如果删除元素可能是一个简单的解决方案，它不仅会影响Revit的性能，但它将销毁任何引用以“重新创建”其他元素的对象。用户可能会失去工作，因为他们已经完成了限制并宣布了问题中的元素。</p>
<h3 id="管理变更"><a href="#管理变更" class="headerlink" title="管理变更"></a>管理变更</h3><p>更新程序需要能够处理使用它们时可能出现的复杂问题，可能需要协调对元素的后续更改。由更新器修改的元素可能在更新器下一次被调用时改变，并且那些改变可能影响由更新器修改的信息。例如，元素可以由用户显式编辑，或者由于再生触发的传播更改而隐式编辑。</p>
<p>同一个元素也可能被另一个更新器修改，甚至可能在同一个事务中。虽然对完全相同的数据进行显式更改会被跟踪和禁止，但间接或传播的更改仍然是可能的。也许最复杂的情况是，用户和&#x2F;或同一更新程序可以在文件的不同版本中更改元素。在用户重新加载最新图元或将其保存到中心图元后，将从其他文件中引入修改后的目标图元，更新程序将需要协调更改。</p>
<p>同样重要的是要认识到，当文档与中心文件同步时，元素的ElementId可能会受到影响。如果新元素已添加到同一文件的两个版本中，并且在两个位置使用相同的ElementId，则在将文件同步到中央数据库时，将进行协调。出于这个原因，当使用更新器交叉引用另一个元素中的一个元素时，它们应该使用Element.UniqueId，这可以保证是唯一的。</p>
<p>另一个需要考虑的问题是，如果更新器将某些数据（即作为参数）附加到元素，则它不仅必须确保在添加该数据的元素中维护该信息，而且还必须在该元素通过复制&#x2F;粘贴或组传播复制时协调数据。例如，如果更新程序将参数“钢筋的总重量”添加到钢筋主体，则该参数及其值将复制到复制的钢筋主体，即使钢筋本身可能未与主体一起复制。在这种情况下，更新程序需要确保在新复制的钢筋主体中重置参数值。</p>
<h2 id="注册Updater"><a href="#注册Updater" class="headerlink" title="注册Updater"></a>注册Updater</h2><p>Updater必须注册，以便在模型更改时得到通知。应用程序级别的UpdaterRegistry类提供了注册&#x2F;取消注册以及操作为Updater设置的选项的能力。Updater可以从任何API回调中注册，并且可以注册为应用程序范围或特定于文档，这意味着它们将仅由对指定文档的更改触发。为了使用UpdaterRegistry功能，Revit附加模块必须在清单文件中注册，并且UpdaterId返回的ID。任何更新程序的GetAddInId（）（从GetUpdaterId（）获得）必须与附加模块清单文件中的AddInId字段匹配。外接程序不能添加、删除或修改不属于它的更新程序。</p>
<h3 id="触发"><a href="#触发" class="headerlink" title="触发"></a>触发</h3><p>除了调用UpdaterRegistry.RegisterUpdater（）方法之外，Updater还应该通过AddTrigger（）方法添加一个或多个更新触发器。这些触发器向UpdaterRegistry指示哪些事件应该触发Updaters Execute（）方法运行。它们可以在应用程序范围内设置，也可以应用于特定文档中所做的更改。更新触发器是通过将更改范围和更改类型配对来指定的。</p>
<p>变更范围是这两种之一：</p>
<ul>
<li>文档中元素ID的显式列表-只有对这些元素的更改才会触发Updater</li>
<li>通过ElementFilter传递的元素的隐式列表-每个更改的元素都将针对过滤器运行，如果有任何通过，则会触发Updater</li>
</ul>
<p>有几个选项可用于更改类型。ChangeTypes从Element类的静态方法中获得。</p>
<ul>
<li>Element addition - 通过Element.GetChangeTypeElementAddition（）</li>
<li>Element deletion - 通过Element.GetChangeTypeElementDeletion（）</li>
<li>Change of element geometry (shape or position) - 通过Element.GetChangeTypeGeometry（）</li>
<li>Changing value of a specific parameter - 通过Element.GetChangeTypeParameter（）</li>
<li>Any change of element - 通过Element.GetChangeTypeAny（）。</li>
</ul>
<p>请注意，几何图形更改可能由于多种原因而触发，例如图元类型更改、属性和参数修改、移动和旋转，或者在再生期间从其他修改的图元对图元施加的更改。</p>
<p>还要注意的是，最后一个选项，任何元素的更改，只会触发Updater修改预先存在的元素，而不会触发Updater修改新添加或删除的元素。此外，当对实例使用此触发器时，只有对其类型的某些修改才会触发Updater。影响实例本身的更改（如修改实例的几何体）将触发Updater。但是，不直接修改实例并且不会导致对实例进行任何可识别的更改的更改（例如对文本参数的更改）将不会触发实例的Updater。要根据这些更改触发，Type也必须包含在触发器的更改范围中。</p>
<h3 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h3><p>Revit对多个Updater进行排序以按正确顺序执行的主要方法是查看给定Updater返回的ChangePriority。一个Updater报告一组更基本的元素（例如GridsLevelsReferencePlanes）的优先级，将在Updater报告由这些基本元素（例如Annotations）驱动的元素的优先级之前执行。为Updater修改的图元报告适当的更改优先级将使应用程序的用户受益：Revit不太可能由于其他Updater所做的更改而不得不再次执行Updater。</p>
<p>对于报告相同更改优先级的Updater，执行顺序基于UpdaterId的排序。方法UpdaterRegistry.SetExecutionOrder（）允许您在任何两个注册的Updater（甚至是由其他API外接程序注册的Updater）之间设置执行顺序，只要您的代码知道这两个Updater的ID。</p>
<h2 id="Exposure-to-End-User"><a href="#Exposure-to-End-User" class="headerlink" title="Exposure to End-User"></a>Exposure to End-User</h2><p>当更新程序正常工作时，它们对用户是透明的。但在某些特殊情况下，Revit将向用户显示有关第三方更新程序的警告。这些消息将使用GetUpdaterName（）方法的值来引用更新程序。</p>
<h3 id="未安装Updater"><a href="#未安装Updater" class="headerlink" title="未安装Updater"></a>未安装Updater</h3><p>如果文档由非可选Updater修改，然后在未安装该Updater时加载，则会显示类似于以下内容的任务对话框：</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-301A03BC-C348-483D-980C-30B05831F84B-low.png"></p>
<p>图135：缺少第三方Updater警告</p>
<h3 id="更新程序执行无效操作"><a href="#更新程序执行无效操作" class="headerlink" title="更新程序执行无效操作"></a>更新程序执行无效操作</h3><p>如果更新程序出现错误（如未处理的异常），则会显示类似于以下内容的消息，为用户提供禁用更新程序的选项：</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-D68E0684-0F8A-47D5-9803-61523979E454-low.png"></p>
<p>图136：更新程序执行了无效操作</p>
<p>如果用户选择“取消”，则整个事务将回滚。在本章前面的墙更新程序示例中，新添加的墙被删除。如果用户选择DisableUpdater，则不再调用更新程序，但事务不会回滚。</p>
<h3 id="无限循环"><a href="#无限循环" class="headerlink" title="无限循环"></a>无限循环</h3><p>如果Updater陷入无限循环，Revit将通知用户并在Revit任务期间禁用更新程序。</p>
<h3 id="两个Updater尝试编辑同一元素"><a href="#两个Updater尝试编辑同一元素" class="headerlink" title="两个Updater尝试编辑同一元素"></a>两个Updater尝试编辑同一元素</h3><p>如果Updater尝试编辑由同一事务中的另一Updater更新的元素的相同参数，或者如果Updater尝试以与另一Updater所做的更改冲突的方式编辑元素的几何图形，则Updater被取消，显示错误消息，并且用户可以选择禁用更新器。</p>
<h3 id="本地不存在Updater修改的中心文档"><a href="#本地不存在Updater修改的中心文档" class="headerlink" title="本地不存在Updater修改的中心文档"></a>本地不存在Updater修改的中心文档</h3><p>如果用户重新加载最新版本或使用未在本地安装的Updater修改的中心文件保存到中心，则会显示一个任务对话框，为用户提供继续或取消同步的选项。此警告表示，以后将中心模型与第三方Updater一起使用时，继续操作可能会导致中心模型出现问题。</p>
<h2 id="注：翻译自Revit-API-Developers-Guide"><a href="#注：翻译自Revit-API-Developers-Guide" class="headerlink" title="注：翻译自Revit API Developers Guide"></a><em><strong>注：</strong></em>翻译自<a href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_html">Revit API Developers Guide</a></h2>]]></content>
      <categories>
        <category>Revit二次开发人员指南</category>
      </categories>
      <tags>
        <tag>Revit</tag>
      </tags>
  </entry>
  <entry>
    <title>31可停靠对话框窗格</title>
    <url>/2024/11/29/%E4%BA%8C%E5%BC%80%E6%8C%87%E5%8D%97/31%E5%8F%AF%E5%81%9C%E9%9D%A0%E5%AF%B9%E8%AF%9D%E6%A1%86%E7%AA%97%E6%A0%BC/</url>
    <content><![CDATA[<h1 id="可停靠对话框窗格"><a href="#可停靠对话框窗格" class="headerlink" title="可停靠对话框窗格"></a><a href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_Advanced_Topics_Dockable_Dialog_Panes_html">可停靠对话框窗格</a></h1><p>自Revit 2013以来，应用程序可以通过利用Revit API中的Idling事件（用户界面事件和外部事件）类来使用无模式对话框。需要非模态对话框的加载项也可以选择使用可停靠的非模态对话框。与标准的无模式对话框类似，可停靠对话框是注册的Windows Presentation Foundation（WPF）对话框窗格，参与Revit的窗口对接系统。注册的可停靠窗格可以停靠在主Revit窗口的顶部、左侧、右侧和底部，也可以作为选项卡添加到现有系统窗格（例如项目浏览器）。此外，可停靠窗格可以浮动，表现得很像标准的非模态对话框。</p>
<h2 id="IDockablePaneProvider"><a href="#IDockablePaneProvider" class="headerlink" title="IDockablePaneProvider"></a>IDockablePaneProvider</h2><p>注册可停靠窗格需要IDockablePaneProvider接口的实例。在Revit用户界面初始化期间调用此界面的SetupDockableWindow（）方法，以收集有关附加模块可固定窗格窗口的信息。SetupDockableData（）有一个DockablePaneProviderData类型的参数，它是关于新可停靠窗格的信息的容器。</p>
<p>IDockablePaneProvider接口的实现应设置DockablePaneProviderData的FrameworkElement和InitialState属性。FrameworkElement属性是包含窗格用户界面的Windows Presentation Framework对象。</p>
<p><strong>注意：</strong>建议外接程序中的可停靠对话框是实现IDockablePaneProvider的类，并从System.Windows.Controls.Page子类化它。</p>
<p>InitialState属性是对接窗格的初始位置和设置，由DockablePaneState类指示。窗格的停靠位置可以是上、下、左、右、浮动或选项卡式。如果位置为Tabbed，则DockablePaneState.TabBehind属性可用于指定新窗格将显示在哪个窗格后面。如果位置为Floating，则DockablePaneState.FloatingRectangle属性包含确定窗格大小和位置的矩形。</p>
<h2 id="DockablePane-Dockable"><a href="#DockablePane-Dockable" class="headerlink" title="DockablePane Dockable"></a>DockablePane Dockable</h2><p>要在运行时访问可停靠窗格，需要通过调用UIApplication. RegisterDockableList（）方法来注册它。此方法需要新窗格的唯一标识符（DockablePaneId）、指定窗格标题的字符串以及IDockablePaneProvider接口的实现。</p>
<p>可停靠窗格可以通过调用UIApplication. GetDockablePanId（）并传入唯一的DockablePaneId来访问。此方法返回一个DockablePanId。DockablePane.Show（）将在Revit用户界面中的最后停靠位置（如果当前不可见）显示窗格。Dockable.Hide（）将隐藏可见的可停靠窗格。但是，它对内置的Revit可固定窗格没有影响。</p>
<h2 id="注：翻译自Revit-API-Developers-Guide"><a href="#注：翻译自Revit-API-Developers-Guide" class="headerlink" title="注：翻译自Revit API Developers Guide"></a><em><strong>注：</strong></em>翻译自<a href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_html">Revit API Developers Guide</a></h2>]]></content>
      <categories>
        <category>Revit二次开发人员指南</category>
      </categories>
      <tags>
        <tag>Revit</tag>
      </tags>
  </entry>
  <entry>
    <title>30外部事件</title>
    <url>/2024/11/29/%E4%BA%8C%E5%BC%80%E6%8C%87%E5%8D%97/30%E5%A4%96%E9%83%A8%E4%BA%8B%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="外部事件"><a href="#外部事件" class="headerlink" title="外部事件"></a><a href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_Advanced_Topics_External_Events_html">外部事件</a></h1><p>Revit API提供了一个外部事件框架，以适应非模态对话框的使用。它是为异步处理量身定制的，其操作类似于具有默认频率的Idling事件。</p>
<p>要使用外部事件框架实现无模式对话框，请执行以下步骤：</p>
<ol>
<li>通过从IExternalEventException接口派生来实现外部事件处理程序</li>
<li>使用静态ExternalEvent.Create（）方法创建ExternalEvent</li>
<li>当需要执行Revit操作的无模式对话框中发生事件时，调用ExternalEvent.Raise（）</li>
<li>当存在可用的空闲时间周期时，Revit将调用IExternalEvents.Execute（）方法的实现。</li>
</ol>
<h3 id="IExternalEventHandler"><a href="#IExternalEventHandler" class="headerlink" title="IExternalEventHandler"></a>IExternalEventHandler</h3><p>这是要为外部事件实现的接口。实现此接口的类的实例注册到Revit中，每次引发相应的外部事件时，都会调用此接口的Execute方法。</p>
<p>IExternalEventHandler 只有两个方法要实现，Execute（）方法和GetName（），后者应该返回事件的名称。下面是一个基本的实现，它将在引发事件时显示TaskDialog。</p>
<p>**代码区域：实现IExternalEventHandler **</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ExternalEventExample</span> : <span class="title">IExternalEventHandler</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Execute</span>(<span class="params">UIApplication app</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        TaskDialog.Show(<span class="string">&quot;External Event&quot;</span>, <span class="string">&quot;Click Close to close.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">GetName</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;External Event Example&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="外部事件-1"><a href="#外部事件-1" class="headerlink" title="外部事件"></a>外部事件</h3><p>ExternalEvent类用于创建ExternalEvent。此类的实例将在事件创建时返回给外部事件的所有者。事件的所有者将使用此实例来通知Revit应调用该事件。Revit将定期检查是否有任何事件已发出信号（引发），并将执行通过调用事件各自处理程序上的Execute方法引发的所有事件。</p>
<p>下面的示例演示IExternalApplication的实现，该IExternalApplication具有从ExternalCommand（显示在代码区域的末尾）调用的ShowForm（）方法。ShowForm（）方法从上面的例子中创建了一个外部事件处理程序的新实例，创建了一个新的ExternalEvent，然后显示无模式对话框，该对话框稍后将使用传入的ExternalEvent对象来引发事件。</p>
<p><strong>代码区域：创建外部事件</strong></p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ExternalEventExampleApp</span> : <span class="title">IExternalApplication</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// class instance</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ExternalEventExampleApp thisApp = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// ModelessForm instance</span></span><br><span class="line">    <span class="keyword">private</span> ExternalEventExampleDialog m_MyForm;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">OnShutdown</span>(<span class="params">UIControlledApplication application</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (m_MyForm != <span class="literal">null</span> &amp;&amp; m_MyForm.Visible)</span><br><span class="line">        &#123;</span><br><span class="line">            m_MyForm.Close();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Result.Succeeded;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">OnStartup</span>(<span class="params">UIControlledApplication application</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_MyForm = <span class="literal">null</span>;   <span class="comment">// no dialog needed yet; the command will bring it</span></span><br><span class="line">        thisApp = <span class="keyword">this</span>;  <span class="comment">// static access to this application instance</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Result.Succeeded;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//   The external command invokes this on the end-user&#x27;s request</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ShowForm</span>(<span class="params">UIApplication uiapp</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// If we do not have a dialog yet, create and show it</span></span><br><span class="line">        <span class="keyword">if</span> (m_MyForm == <span class="literal">null</span> || m_MyForm.IsDisposed)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// A new handler to handle request posting by the dialog</span></span><br><span class="line">            ExternalEventExample handler = <span class="keyword">new</span> ExternalEventExample();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// External Event for the dialog to use (to post requests)</span></span><br><span class="line">            ExternalEvent exEvent = ExternalEvent.Create(handler);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// We give the objects to the new dialog;</span></span><br><span class="line">            <span class="comment">// The dialog becomes the owner responsible for disposing them, eventually.</span></span><br><span class="line">            m_MyForm = <span class="keyword">new</span> ExternalEventExampleDialog(exEvent, handler);</span><br><span class="line">            m_MyForm.Show();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="meta">Autodesk.Revit.Attributes.Transaction(Autodesk.Revit.Attributes.TransactionMode.Manual)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Command</span> : <span class="title">IExternalCommand</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> Result <span class="title">Execute</span>(<span class="params">ExternalCommandData commandData, <span class="keyword">ref</span> <span class="built_in">string</span> message, ElementSet elements</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            ExternalEventExampleApp.thisApp.ShowForm(commandData.Application);</span><br><span class="line">            <span class="keyword">return</span> Result.Succeeded;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception ex)</span><br><span class="line">        &#123;</span><br><span class="line">            message = ex.Message;</span><br><span class="line">            <span class="keyword">return</span> Result.Failed;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一旦显示非模态对话框，用户就可以与之交互。对话框中的操作可能需要触发Revit中的某些操作。发生这种情况时，将调用ExternalEvent.Raise（）方法。下面的示例是一个简单的无模式对话框的代码，该对话框有两个按钮：一个用于引发事件，另一个用于关闭对话框。</p>
<p>代码区域：引发事件</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">ExternalEventExampleDialog</span> : <span class="title">Form</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> ExternalEvent m_ExEvent;</span><br><span class="line">    <span class="keyword">private</span> ExternalEventExample m_Handler;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ExternalEventExampleDialog</span>(<span class="params">ExternalEvent exEvent, ExternalEventExample handler</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        InitializeComponent();</span><br><span class="line">        m_ExEvent = exEvent;</span><br><span class="line">        m_Handler = handler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnFormClosed</span>(<span class="params">FormClosedEventArgs e</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// we own both the event and the handler</span></span><br><span class="line">        <span class="comment">// we should dispose it before we are closed</span></span><br><span class="line">        m_ExEvent.Dispose();</span><br><span class="line">        m_ExEvent = <span class="literal">null</span>;</span><br><span class="line">        m_Handler = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// do not forget to call the base class</span></span><br><span class="line">        <span class="keyword">base</span>.OnFormClosed(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">closeButton_Click</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">showMessageButton_Click</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_ExEvent.Raise();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用ExternalEvent.Raise（）方法时，Revit将等待可用的Idling计时器，然后调用IExternalEventEvent.Execute（）方法。在这个简单的例子中，它将显示一个TaskDialog，文本为“Click Close to close.”“，如上面第一个代码区域所示。</p>
<p>有关使用外部事件框架的更复杂示例，请参见SDK中ModelessDialog\ModelessForm_ExternalEvent文件夹下的示例代码。它使用一个带有许多按钮的非模态对话框，IExternalEventEvent实现有一个公共属性来跟踪按下了哪个按钮，因此它可以在Execute（）方法中打开该值。</p>
<h2 id="注：翻译自Revit-API-Developers-Guide"><a href="#注：翻译自Revit-API-Developers-Guide" class="headerlink" title="注：翻译自Revit API Developers Guide"></a><em><strong>注：</strong></em>翻译自<a href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_html">Revit API Developers Guide</a></h2>]]></content>
      <categories>
        <category>Revit二次开发人员指南</category>
      </categories>
      <tags>
        <tag>Revit</tag>
      </tags>
  </entry>
  <entry>
    <title>29事件</title>
    <url>/2024/11/29/%E4%BA%8C%E5%BC%80%E6%8C%87%E5%8D%97/29%E4%BA%8B%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="事件"><a href="#事件" class="headerlink" title="事件"></a><a href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_Advanced_Topics_Events_html">事件</a></h1><p>事件是在Revit用户界面或API工作流中执行特定操作时触发的通知。通过订阅事件，可以在操作即将发生或刚刚发生时通知外接程序应用程序，并采取与该事件相关的某些操作。有些事件是成对发生的，一个发生在动作发生之前（“pre”事件），另一个发生在动作发生之后（“post”事件）。在这些前&#x2F;后对中不发生的事件称为“单个”事件。</p>
<p>Revit提供对应用程序级别（如ApplicationClosing或DocumentOpened）和文档级别（如DocumentClosing和DocumentPrinting）的事件的访问。Application类中提供的相同应用程序级别事件也可从ControlledApplication类中获得，ControlledApplication类表示未访问文档的Revit应用程序。ControlledApplication可用于OnStartup（）和OnStartup（）方法中的外接程序。就订阅和取消订阅事件而言，这些类是可互换的;从ControlledApplication类订阅事件与从Application类订阅事件相同。</p>
<p>事件还可以分类为数据库（DB）事件或用户界面（UI）事件。DB事件可从Application和Document类获得，而UI事件可从UIApplication类获得。（目前所有UI事件都仅在应用程序级别）。</p>
<p>有些事件被认为是只读的，这意味着在它们的执行过程中，模型可能不会被修改。事件为只读的事实在API帮助文件中有说明。重要的是要知道，即使在常规事件（即非只读事件）期间，模型也可能处于无法修改的状态。程序员应该检查属性Document.IsModifiable和Document.IsReadOnly以确定模型是否可以修改。</p>
<p> 本节中的页面</p>
<ul>
<li>数据库事件</li>
<li>用户界面事件</li>
<li>注册事件</li>
<li>取消事件</li>
</ul>
<h2 id="数据库事件"><a href="#数据库事件" class="headerlink" title="数据库事件"></a>数据库事件</h2><p>下表列出了数据库事件、它们的类型以及它们是否在应用程序和&#x2F;或文档级别可用：</p>
<p><strong>表53：数据库事件类型</strong></p>
<table>
<thead>
<tr>
<th><strong>Event 事件</strong></th>
<th><strong>Type 类型</strong></th>
<th><strong>Application 应用</strong></th>
<th><strong>Document 文档</strong></th>
</tr>
</thead>
<tbody><tr>
<td>DocumentChanged event</td>
<td>single</td>
<td>X</td>
<td></td>
</tr>
<tr>
<td>DocumentClosing</td>
<td>pre</td>
<td>X</td>
<td>X</td>
</tr>
<tr>
<td>DocumentClosed</td>
<td>post</td>
<td>X</td>
<td></td>
</tr>
<tr>
<td>DocumentCreating</td>
<td>pre</td>
<td>X</td>
<td></td>
</tr>
<tr>
<td>DocumentCreated</td>
<td>post</td>
<td>X</td>
<td></td>
</tr>
<tr>
<td>DocumentOpening</td>
<td>pre</td>
<td>X</td>
<td></td>
</tr>
<tr>
<td>DocumentOpened</td>
<td>post</td>
<td>X</td>
<td></td>
</tr>
<tr>
<td>DocumentPrinting</td>
<td>pre</td>
<td>X</td>
<td>X</td>
</tr>
<tr>
<td>DocumentPrinted</td>
<td>post</td>
<td>X</td>
<td>X</td>
</tr>
<tr>
<td>DocumentSaving</td>
<td>pre</td>
<td>X</td>
<td>X</td>
</tr>
<tr>
<td>DocumentSaved</td>
<td>post</td>
<td>X</td>
<td>X</td>
</tr>
<tr>
<td>DocumentSavingAs</td>
<td>pre</td>
<td>X</td>
<td>X</td>
</tr>
<tr>
<td>DocumentSavedAs</td>
<td>post</td>
<td>X</td>
<td>X</td>
</tr>
<tr>
<td>DocumentSynchronizingWithCentral</td>
<td>pre</td>
<td>X</td>
<td></td>
</tr>
<tr>
<td>DocumentSynchronizedWithCentral</td>
<td>post</td>
<td>X</td>
<td></td>
</tr>
<tr>
<td>FailuresProcessing</td>
<td>single</td>
<td>X</td>
<td></td>
</tr>
<tr>
<td>FileExporting</td>
<td>pre</td>
<td>X</td>
<td></td>
</tr>
<tr>
<td>FileExported</td>
<td>post</td>
<td>X</td>
<td></td>
</tr>
<tr>
<td>FileImporting</td>
<td>pre</td>
<td>X</td>
<td></td>
</tr>
<tr>
<td>FileImported</td>
<td>post</td>
<td>X</td>
<td></td>
</tr>
<tr>
<td>ProgressChanged</td>
<td>single</td>
<td>X</td>
<td></td>
</tr>
<tr>
<td>ViewPrinting</td>
<td>pre</td>
<td>X</td>
<td>X</td>
</tr>
<tr>
<td>ViewPrinted</td>
<td>post</td>
<td>X</td>
<td>X</td>
</tr>
</tbody></table>
<ul>
<li>DocumentChanged -提交、撤消或重做事务时的通知</li>
<li>DocumentClosing -Revit即将关闭文档时的通知</li>
<li>DocumentClosed -Revit关闭文档后立即发出的通知</li>
<li>DocumentCreating -Revit将要创建新文档时的通知</li>
<li>DocumentCreated -Revit完成创建新文档时的通知</li>
<li>DocumentOpening -Revit即将打开文档时的通知</li>
<li>DocumentOpened -Revit打开文档后的通知</li>
<li>DocumentPrinting -Revit将要打印文档的视图或视图集时的通知</li>
<li>DocumentPrinted -在Revit打印完文档的视图或视图集后发出的通知</li>
<li>DocumentSaving -Revit即将保存文档时的通知</li>
<li>DocumentSaved -Revit保存文档后立即发出的通知</li>
<li>DocumentSavingAs -Revit将以新名称保存文档时的通知</li>
<li>DocumentSavedAs -当Revit刚用新名称保存文档时发出的通知</li>
<li>DocumentSynchronizingWithCentral -当Revit要将文档与中心文件同步时发出的通知</li>
<li>DocumentSynchronizedWithCentral -在Revit将文档与中心文件同步后发出的通知</li>
<li>FailuresProcessing -事务结束时Revit处理失败时的通知</li>
<li>FileExporting -Revit即将导出为API支持的文件格式时的通知</li>
<li>FileExported -Revit导出为API支持的文件格式后的通知</li>
<li>FileImporting -Revit将要导入API支持的文件格式时的通知</li>
<li>FileImported -Revit导入API支持的文件格式后的通知</li>
<li>ProgressChanged -当Revit中的操作具有进度条数据时发出的通知</li>
<li>ViewPrinting -Revit即将打印文档视图时的通知</li>
<li>ViewPrinted -在Revit打印完文档视图后立即发出通知</li>
</ul>
<p>本节中的页面</p>
<ul>
<li>DocumentChanged事件</li>
</ul>
<h3 id="DocumentChanged事件"><a href="#DocumentChanged事件" class="headerlink" title="DocumentChanged事件"></a>DocumentChanged事件</h3><p>更改Revit文档时会触发DocumentChanged事件。只要提交、撤消或重做Revit事务，就会引发此事件。这是一个只读事件，旨在允许外部数据与Revit数据库的状态保持同步。若要更新Revit数据库以响应图元中的更改，请使用IUpdater框架。</p>
<p>DocumentChangedEventArgs类由DocumentChanged事件使用。这个类有几个方法来获取任何新添加的元素（GetAddElementIds（））、已删除的元素（GetDeletedElementIds（））或已修改的元素（GetModifiedElementIds（））的元素ID。GetAddElementIds（）和GetModifiedElementIds（）方法具有采用ElementFilter的重载，这使得仅检测感兴趣的更改变得容易。</p>
<h2 id="用户界面事件"><a href="#用户界面事件" class="headerlink" title="用户界面事件"></a>用户界面事件</h2><p>下表列出了用户界面事件、它们的类型以及它们是否在应用程序和&#x2F;或文档级别可用：</p>
<p><strong>表54：UI事件类型</strong></p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>**Event **</td>
<td>**Type **</td>
<td><strong>UIApplication</strong></td>
<td>**ControlledApplication **</td>
<td>**UIDocument **</td>
</tr>
<tr>
<td>ApplicationClosing</td>
<td>pre</td>
<td>X</td>
<td></td>
<td></td>
</tr>
<tr>
<td>ApplicationInitialized</td>
<td>single</td>
<td></td>
<td>X</td>
<td></td>
</tr>
<tr>
<td>DialogBoxShowing</td>
<td>single</td>
<td>X</td>
<td></td>
<td></td>
</tr>
<tr>
<td>DisplayingOptionsDialog</td>
<td>single</td>
<td>X</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Idling</td>
<td>single</td>
<td>X</td>
<td></td>
<td></td>
</tr>
<tr>
<td>ViewActivating</td>
<td>pre</td>
<td>X</td>
<td></td>
<td></td>
</tr>
<tr>
<td>ViewActivated</td>
<td>post</td>
<td>X</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<ul>
<li>ApplicationClosing - 即将关闭Revit应用程序时的通知</li>
<li>ApplicationInitialized-在Revit应用程序初始化后、所有外部应用程序已启动且应用程序已准备好处理文档后发出的通知</li>
<li>DialogBoxShowing-Revit显示对话框或消息框时的通知</li>
<li>DisplayingOptionsDialog -显示Revit选项对话框时的通知</li>
<li>Idling - Revit不在活动工具或事务中时的通知</li>
<li>ViewActivating -Revit即将激活文档视图时的通知</li>
<li>ViewActivated -在Revit激活文档视图后立即发出通知</li>
</ul>
<h2 id="注册事件"><a href="#注册事件" class="headerlink" title="注册事件"></a>注册事件</h2><p>在哪里以及如何注册事件。</p>
<p>使用事件是一个两步的过程。首先，必须有一个处理事件通知的函数。这个函数必须接受两个参数，第一个是Object，表示事件通知的“发送者”，第二个是事件特定的对象，包含特定于该事件的事件参数。例如，若要注册DocumentSavingAs事件，事件处理程序必须采用第二个参数，该参数是DocumentSavingAsEventArgs对象。</p>
<p>使用事件的第二部分是向Revit注册事件。这可以在OnStartup（）函数中通过ControlledApplication参数完成，也可以在Revit启动后的任何时间完成。虽然可以为外部命令和外部应用程序注册事件，但不建议这样做，除非外部命令在同一外部命令中注册和取消注册事件。还要注意，注册到事件和从事件取消注册必须在主线程上执行时发生。如果外部应用程序试图从有效的API上下文外部注册事件（或取消注册），则将引发异常。</p>
<p>下面的示例注册DocumentOpened事件，当触发该事件时，此应用程序将设置项目的地址。</p>
<p><strong>代码区域24-1：注册ControlledApplication.DocumentOpened</strong></p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Application_DocumentOpened</span> : <span class="title">IExternalApplication</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> </span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> </span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> Implement this method to subscribe to event.</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">OnStartup</span>(<span class="params">UIControlledApplication application</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Register event. </span></span><br><span class="line">            application.ControlledApplication.DocumentOpened += <span class="keyword">new</span> EventHandler</span><br><span class="line">                &lt;Autodesk.Revit.DB.Events.DocumentOpenedEventArgs&gt;(application_DocumentOpened);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.Failed;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Result.Succeeded;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">OnShutdown</span>(<span class="params">UIControlledApplication application</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// remove the event.</span></span><br><span class="line">        application.ControlledApplication.DocumentOpened -= application_DocumentOpened;</span><br><span class="line">        <span class="keyword">return</span> Result.Succeeded;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">application_DocumentOpened</span>(<span class="params"><span class="built_in">object</span> sender, DocumentOpenedEventArgs <span class="keyword">args</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// get document from event args.</span></span><br><span class="line">        Document doc = <span class="keyword">args</span>.Document;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Following code snippet demonstrates support of DocumentOpened event to modify the model.</span></span><br><span class="line">        <span class="comment">// Because DocumentOpened supports model changes, it allows user to update document data.</span></span><br><span class="line">        <span class="comment">// Here, this sample assigns a specified value to ProjectInformation.Address property. </span></span><br><span class="line">        <span class="comment">// User can change other properties of document or create(delete) something as he likes.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// Please note that ProjectInformation property is empty for family document.</span></span><br><span class="line">        <span class="comment">// So please don&#x27;t run this sample on family document.</span></span><br><span class="line">        <span class="keyword">using</span> (Transaction transaction = <span class="keyword">new</span> Transaction(doc, <span class="string">&quot;Edit Address&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (transaction.Start() == TransactionStatus.Started)</span><br><span class="line">            &#123;</span><br><span class="line">                doc.ProjectInformation.Address =</span><br><span class="line">                    <span class="string">&quot;United States - Massachusetts - Waltham - 1560 Trapelo Road&quot;</span>;</span><br><span class="line">                transaction.Commit();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="取消事件"><a href="#取消事件" class="headerlink" title="取消事件"></a>取消事件</h2><p>在操作发生之前触发的事件（即DocumentSaving）通常是可取消的。(用可取消属性，以确定事件是否可以取消。）例如，您可能希望在保存模型之前检查模型是否满足某些条件。例如，通过注册DocumentSaving或DocumentSavingAs事件，您可以检查文档中的某些条件并取消Save或Save As操作。事件一旦取消，就无法取消。</p>
<p><em><strong>注意：</strong></em>如果取消了pre事件，则不会通知已订阅该事件的其他事件处理程序。但是，将通知已订阅与前事件相关的后事件的处理程序。下面的DocumentSavingAs事件的事件处理程序检查ProjectInformation Status参数是否为空，如果为空，则取消SaveAs事件。请注意，如果应用程序取消了一个事件，它应该向用户提供一个解释。</p>
<p><strong>代码区域24-2：取消事件</strong></p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">CheckProjectStatusInitial</span>(<span class="params">Object sender, DocumentSavingAsEventArgs <span class="keyword">args</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        Document doc = <span class="keyword">args</span>.Document;</span><br><span class="line">        ProjectInfo proInfo = doc.ProjectInformation;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Project information is only available for project document.</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != proInfo)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">string</span>.IsNullOrEmpty(proInfo.Status))</span><br><span class="line">                &#123;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// cancel the save as process.</span></span><br><span class="line">                        <span class="keyword">args</span>.Cancel = <span class="literal">true</span>;</span><br><span class="line">                        MessageBox.Show(<span class="string">&quot;Status project parameter is not set.  Save is aborted.&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em><strong>注意：</strong></em>虽然大多数事件参数都有Cancel和Cancellable属性，但DocumentChanged和FailuresProcessing事件有相应的Cancel（）和IsCancellable（）方法。</p>
<h2 id="注：翻译自Revit-API-Developers-Guide"><a href="#注：翻译自Revit-API-Developers-Guide" class="headerlink" title="注：翻译自Revit API Developers Guide"></a><em><strong>注：</strong></em>翻译自<a href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_html">Revit API Developers Guide</a></h2>]]></content>
      <categories>
        <category>Revit二次开发人员指南</category>
      </categories>
      <tags>
        <tag>Revit</tag>
      </tags>
  </entry>
  <entry>
    <title>28可扩展储存</title>
    <url>/2024/11/29/%E4%BA%8C%E5%BC%80%E6%8C%87%E5%8D%97/28%E5%8F%AF%E6%89%A9%E5%B1%95%E5%82%A8%E5%AD%98/</url>
    <content><![CDATA[<h1 id="在Revit模型中存储数据"><a href="#在Revit模型中存储数据" class="headerlink" title="在Revit模型中存储数据"></a><a href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_Advanced_Topics_Storing_Data_in_the_Revit_model_html">在Revit模型中存储数据</a></h1><p>使用共享参数或可扩展存储在Revit模型中存储数据。</p>
<p>Revit API提供了两种在Revit模型中存储数据的方法。第一种是使用共享参数。通过Revit API，可以通过编程方式访问通过Revit UI提供的相同共享参数功能。如果共享参数被定义为可见，则用户可以在元素的属性窗口中查看这些参数。可以将共享参数指定给许多（但不是所有）类别的图元。有关详细信息，请参阅共享参数。</p>
<p>另一个选项是可扩展存储，它允许您创建自定义数据结构，然后将该数据的实例分配给模型中的元素。用户在Revit UI中永远看不到这些数据，但其他第三方应用程序可以通过Revit API访问这些数据，具体取决于定义模式时分配给该模式的读&#x2F;写访问权限。与共享参数不同，可扩展存储不限于某些类别的元素。可扩展存储数据可以指定给从Revit模型中的基类Element派生的任何对象。</p>
<p>本节中的页面</p>
<ul>
<li>可扩展存储</li>
</ul>
<h2 id="可扩展存储"><a href="#可扩展存储" class="headerlink" title="可扩展存储"></a>可扩展存储</h2><p>创建您自己的类模式数据结构，并将其实例附加到Revit模型中的任何元素。</p>
<p>基于schema的数据与Revit模型一起保存，并允许更高级别的、元数据增强的、面向对象的数据结构。schema数据可以配置为对所有用户可读和&#x2F;或可写，仅对特定应用程序供应商可读和&#x2F;或可写，或仅对来自供应商的特定应用程序可读和&#x2F;或可写。</p>
<p>在Revit中使用Elements存储数据时，必须执行以下步骤：</p>
<ol>
<li>创建并命名新schema</li>
<li>设置schema的读&#x2F;写访问权限</li>
<li>为schema定义一个或多个数据字段</li>
<li>基于schema创建实体</li>
<li>为实体的字段分配值</li>
<li>将图元与Revit图元关联</li>
</ol>
<h3 id="Schema和SchemaBuilder"><a href="#Schema和SchemaBuilder" class="headerlink" title="Schema和SchemaBuilder"></a>Schema和SchemaBuilder</h3><p>创建可扩展存储的第一步是定义schema。schema类似于面向对象编程语言中的class。使用SchemaBuilder类构造函数创建新schema。SchemaBuilder是一个用于创建schema的帮助类。一旦使用SchemaBuilder完成schema，就可以使用Schema类访问schema的属性。在该阶段，schema不再是可编辑的。</p>
<p>尽管SchemaBuilder构造函数接受一个用于标识schema的字符串，但schema名称也是必需的。创建schema之后，调用SchemaBuilder.SetSchemaName（）为schema分配一个用户友好的标识符。schema名称对于标识错误消息中的schema很有用。</p>
<p>可以独立地设置与schema相关联的实体的读和写访问级别。选项包括Public、Vendor或Application。如果将读或写访问级别设置为Vendor，则必须指定可能访问schema实体的第三方供应商的VendorId。如果将其中一个访问级别设置为应用程序，则必须提供可能访问schema实体的应用程序或外接程序的URL。</p>
<p><em><strong>注意：</strong></em>schema与文档一起存储，任何Revit API附加模块都可以读取文档中的可用schema以及schema的某些数据。然而，对schema的字段的访问是基于在schema中定义的读访问来限制的，并且与特定元素一起存储的实体中的实际数据是基于在定义schema时在schema中设置的读和写访问级别来限制的。</p>
<h3 id="Fields-and-FieldBuilder"><a href="#Fields-and-FieldBuilder" class="headerlink" title="Fields and FieldBuilder"></a>Fields and FieldBuilder</h3><p>一旦创建了schema，就可以定义字段。字段类似于类的属性。它包含名称、文档、值类型和单位类型。字段可以是简单类型、数组或映射。允许以下简单数据类型：</p>
<table>
<thead>
<tr>
<th><strong>Type 类型</strong></th>
<th><strong>Default Value 默认值</strong></th>
</tr>
</thead>
<tbody><tr>
<td>int</td>
<td>0</td>
</tr>
<tr>
<td>short</td>
<td>0</td>
</tr>
<tr>
<td>byte</td>
<td>0</td>
</tr>
<tr>
<td>double</td>
<td>0.0</td>
</tr>
<tr>
<td>float</td>
<td>0.0</td>
</tr>
<tr>
<td>bool</td>
<td>false</td>
</tr>
<tr>
<td>string</td>
<td>Empty string (“”)</td>
</tr>
<tr>
<td>GUID</td>
<td>Guid.Empty {00000000-0000-0000-0000-000000000000} GUID。</td>
</tr>
<tr>
<td>ElementId</td>
<td>ElementId.InvalidElementId</td>
</tr>
<tr>
<td>Autodesk.Revit.DB.XYZ</td>
<td>(0.0,0.0,0.0)</td>
</tr>
<tr>
<td>Autodesk.Revit.DB.UV</td>
<td>(0.0,0.0)</td>
</tr>
</tbody></table>
<p>此外，字段的类型可以是Autodesk. Revit. DB. ExtensibleData. Autonomy。换句话说，它是另一个Schema的实例，也称为SubSchema 或 SubEntity。此类型字段的默认值为Entity，模式为null，guid为Guid.Empty。 使用字符串字段时，请注意Revit对字符串对象的大小限制为16 MB。</p>
<p> 可以使用SchemaBuilder.AddSimpleField（）方法为字段指定名称和类型来创建简单字段。AddSimpleField（）返回一个FieldBuilder，它是一个用于定义Field的帮助类。如果字段的类型被指定为Entity，则使用FieldBuilder.SetSubSchemaString（）指定要存储在此字段中的实体的Schema的类型。 </p>
<p>使用SchemaBuilder.AddArrayField（）方法创建一个字段，该字段包含Schema中的值数组，并具有给定的名称和所包含值的类型。数组字段可以具有与简单字段相同的类型。 </p>
<p>使用SchemaBuilder.AddMapField（）方法创建一个字段，该字段包含Schema中的有序键值映射，并具有给定的名称、键类型和所包含值的类型。支持的值类型与简单字段相同。支持的键类型仅限于int、short、byte、string、bool、ElementId和String。 一旦使用SchemaBuilder完成Schema，就不能再使用FieldBuilder编辑字段。在该阶段，Schema类提供了按名称获取Field的方法，或者获取Schema中定义的所有Field的列表。</p>
<h3 id="Entity"><a href="#Entity" class="headerlink" title="Entity"></a>Entity</h3><p>在为Schema定义了所有字段之后，SchemaBuilder.Finish（）将返回完成的Schema。可以使用该Schema创建新Entity。</p>
<p>对于Schema中的每个字段，可以使用Entity.Set（）存储值，Entity.Set（）接受一个字段和一个值（其类型取决于字段类型）。</p>
<p>一旦为Entity设置了所有适用的字段，就可以使用Element.SetEntity（）方法将其分配给元素。</p>
<p> 要在以后检索数据，请调用Element.GetEntity（），传入相应的Schema。如果没有基于该Schema的Entity与元素一起保存，则将返回无效Entity。若要检查是否返回了有效的Entity，请调用Entity.IsValid（）方法。</p>
<p>可以使用Entity.Get（）方法从实体中获取字段值。 </p>
<p>若要从Element中删除可扩展存储实体，请调用Element.DeleteEntity（），传入用于创建它的Schema。 </p>
<p>要确定与元素一起存储的实体，请使用Element.GetEntitySchemaGuids（）方法，该方法返回元素的任何Entity的Schema的GUID。Schemaguid可以与静态方法Schema.schema（）一起使用，以检索相应的Schemas。 </p>
<p>下面是一个定义可扩展存储模式、创建实体、设置其值、将其分配给元素以及检索数据的示例。</p>
<p>代码区域22-9：可扩展存储</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Create a data structure, attach it to a wall, populate it with data, and retrieve the data back from the wall</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StoreDataInWall</span>(<span class="params">Wall wall, XYZ dataToStore</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        Transaction createSchemaAndStoreData = <span class="keyword">new</span> Transaction(wall.Document, <span class="string">&quot;tCreateAndStore&quot;</span>);</span><br><span class="line">        createSchemaAndStoreData.Start();</span><br><span class="line">        SchemaBuilder schemaBuilder = </span><br><span class="line">                <span class="keyword">new</span> SchemaBuilder(<span class="keyword">new</span> Guid(<span class="string">&quot;720080CB-DA99-40DC-9415-E53F280AA1F0&quot;</span>));</span><br><span class="line">        schemaBuilder.SetReadAccessLevel(AccessLevel.Public); <span class="comment">// allow anyone to read the object</span></span><br><span class="line">        schemaBuilder.SetWriteAccessLevel(AccessLevel.Vendor); <span class="comment">// restrict writing to this vendor only</span></span><br><span class="line">        schemaBuilder.SetVendorId(<span class="string">&quot;ADSK&quot;</span>); <span class="comment">// required because of restricted write-access</span></span><br><span class="line">        schemaBuilder.SetSchemaName(<span class="string">&quot;WireSpliceLocation&quot;</span>);</span><br><span class="line">        <span class="comment">// create a field to store an XYZ</span></span><br><span class="line">        FieldBuilder fieldBuilder = </span><br><span class="line">                schemaBuilder.AddSimpleField(<span class="string">&quot;WireSpliceLocation&quot;</span>, <span class="keyword">typeof</span>(XYZ)); </span><br><span class="line">        fieldBuilder.SetUnitType(UnitType.UT_Length);</span><br><span class="line">        fieldBuilder.SetDocumentation(<span class="string">&quot;A stored location value representing a wiring splice in a wall.&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Schema schema = schemaBuilder.Finish(); <span class="comment">// register the Schema object</span></span><br><span class="line">        Entity entity = <span class="keyword">new</span> Entity(schema); <span class="comment">// create an entity (object) for this schema (class)</span></span><br><span class="line">        <span class="comment">// get the field from the schema</span></span><br><span class="line">        Field fieldSpliceLocation = schema.GetField(<span class="string">&quot;WireSpliceLocation&quot;</span>); </span><br><span class="line">        <span class="comment">// set the value for this entity</span></span><br><span class="line">        entity.Set(fieldSpliceLocation, dataToStore, DisplayUnitType.DUT_METERS); </span><br><span class="line">        wall.SetEntity(entity); <span class="comment">// store the entity in the element</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// get the data back from the wall</span></span><br><span class="line">        Entity retrievedEntity = wall.GetEntity(schema);</span><br><span class="line">        XYZ retrievedData = </span><br><span class="line">                retrievedEntity.Get(schema.GetField(<span class="string">&quot;WireSpliceLocation&quot;</span>),</span><br><span class="line">                DisplayUnitType.DUT_METERS);</span><br><span class="line">        createSchemaAndStoreData.Commit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><h4 id="自我记录和自定义"><a href="#自我记录和自定义" class="headerlink" title="自我记录和自定义"></a>自我记录和自定义</h4><p>通过添加字段、单元、子实体和描述字符串来创建Schema不仅是存储数据的一种方法。对于其他用户来说，它也是一种隐式文档，并且其他人可以通过简单的采用路径在以后创建相同模式的实体。</p>
<h4 id="利用局部性"><a href="#利用局部性" class="headerlink" title="利用局部性"></a>利用局部性</h4><p>因为Schema的Entity是以每个元素为基础存储的，所以当应用程序可能只需要当前选定梁的数据时，不需要读取文档中的所有可扩展存储数据（例如，来自所有梁族实例的所有数据）。这允许更具体地针对数据访问代码和更好的数据访问性能的潜力。</p>
<h2 id="注：翻译自Revit-API-Developers-Guide"><a href="#注：翻译自Revit-API-Developers-Guide" class="headerlink" title="注：翻译自Revit API Developers Guide"></a><em><strong>注：</strong></em>翻译自<a href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_html">Revit API Developers Guide</a></h2>]]></content>
      <categories>
        <category>Revit二次开发人员指南</category>
      </categories>
      <tags>
        <tag>Revit</tag>
      </tags>
  </entry>
  <entry>
    <title>25建筑</title>
    <url>/2024/12/24/%E4%BA%8C%E5%BC%80%E6%8C%87%E5%8D%97/25%E5%BB%BA%E7%AD%91/</url>
    <content><![CDATA[<h1 id="建筑"><a href="#建筑" class="headerlink" title="建筑"></a>建筑</h1><p>本章介绍特定于Revit建筑功能的API功能：</p>
<ul>
<li>与房间相关的功能（Element.Room、RoomTag等）</li>
</ul>
<p> 本节中的主题</p>
<ul>
<li>Rooms</li>
</ul>
<h2 id="房间"><a href="#房间" class="headerlink" title="房间"></a>房间</h2><p><strong>Rooms</strong> </p>
<p>以下各节介绍了有关房间类、其参数以及如何在API中使用房间类的信息。</p>
<p>Room类用于表示房间和图元，例如房间明细表和面积平面。下表列出了API中不同房间、面积及其对应标签的属性和创建函数：</p>
<p><strong>表55：房间、面积和标签关系</strong></p>
<table>
<thead>
<tr>
<th>**Element **</th>
<th>**Class **</th>
<th>**Category **</th>
<th>**Boundary **</th>
<th>**Location **</th>
<th>**Can Create **</th>
</tr>
</thead>
<tbody><tr>
<td>Room in Plan View</td>
<td>Room</td>
<td>OST_Rooms</td>
<td>在封闭区域中有</td>
<td>LocationPoint</td>
<td>NewRoom（），NewRoom（Phase）除外</td>
</tr>
<tr>
<td>Room in Schedule View</td>
<td>Room</td>
<td>OST_Rooms</td>
<td>Null</td>
<td>Null</td>
<td>NewRoom(Phase)</td>
</tr>
<tr>
<td>Area</td>
<td>Room</td>
<td>OST_Areas</td>
<td>总是有</td>
<td>LocationPoint</td>
<td>No</td>
</tr>
<tr>
<td>Room Tag</td>
<td>RoomTag</td>
<td>OST_RoomTags</td>
<td></td>
<td>LocationPoint</td>
<td>Creation.Document.NewRoomTag()</td>
</tr>
<tr>
<td>Area Tag</td>
<td>FamilySymbol</td>
<td>OST_AreaTags</td>
<td></td>
<td>LocationPoint</td>
<td>No</td>
</tr>
</tbody></table>
<p>注：房间名称是房间名称和房间号的组合。例如，对于编号为2且名称为“Master Bedroom”的房间，Room.Name将返回“Master Bedroom 2”。使用ROOM_NAME内置参数获取房间名称。</p>
<p>注意：作为注释元素，特定视图可使用RoomTag. View。不要尝试设置RoomTag.Name属性，因为该名称是自动分配的;否则将引发异常。</p>
<p><strong>创建房间</strong></p>
<p>下面的代码演示了在特定楼层的某个点创建房间的最简单方法：</p>
<p>代码区域28-1：创建房间</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function">Room <span class="title">CreateRoom</span>(<span class="params">Autodesk.Revit.DB.Document document, Level level</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">// Create a UV structure which determines the room location</span></span><br><span class="line">        UV roomLocation = <span class="keyword">new</span> UV(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create a new room</span></span><br><span class="line">        Room room = document.Create.NewRoom(level, roomLocation);</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == room)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Create a new room failed.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> room;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以在房间明细表中创建房间，然后将其插入到平面回路中。</p>
<ul>
<li>Document.NewRoom（Phase）方法用于创建不与任何特定位置关联的新文件室，并将其插入到现有明细表中。在拨打电话之前，确保房间时间表存在或在指定阶段创建房间时间表。</li>
<li>Document.NewRoom（Roomroom，PlanCircuit线路）方法用于从明细表中的房间和PlanCircuit创建房间。<ul>
<li>输入房间必须仅存在于房间明细表中，这意味着它不会显示在任何平面视图中。</li>
<li>调用该方法后，将在PlanCircuit所在的视图中创建具有相同名称和编号的模型房间。</li>
</ul>
</li>
</ul>
<p>有关平面电路的详细信息，请参见平面拓扑。</p>
<p>以下代码说明了整个过程：</p>
<p>代码区域28-2：创建房间并将其插入到平面回路中</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function">Room <span class="title">InsertNewRoomInPlanCircuit</span>(<span class="params">Autodesk.Revit.DB.Document document, Level level, Phase newConstructionPhase</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// create room using Phase</span></span><br><span class="line">    Room newScheduleRoom = document.Create.NewRoom(newConstructionPhase);</span><br><span class="line">            </span><br><span class="line">    <span class="comment">// set the Room Number and Name</span></span><br><span class="line">    <span class="built_in">string</span> newRoomNumber = <span class="string">&quot;101&quot;</span>;</span><br><span class="line">    <span class="built_in">string</span> newRoomName = <span class="string">&quot;Class Room 1&quot;</span>;</span><br><span class="line">    newScheduleRoom.Name = newRoomName;</span><br><span class="line">    newScheduleRoom.Number = newRoomNumber;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get a PlanCircuit</span></span><br><span class="line">    PlanCircuit planCircuit = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// first get the plan topology for given level</span></span><br><span class="line">    PlanTopology planTopology = document.get_PlanTopology(level);</span><br><span class="line">            </span><br><span class="line">    <span class="comment">// Iterate circuits in this plan topology</span></span><br><span class="line">    <span class="keyword">foreach</span> (PlanCircuit circuit <span class="keyword">in</span> planTopology.Circuits)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// get the first circuit we find</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != circuit)</span><br><span class="line">        &#123;</span><br><span class="line">            planCircuit = circuit;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">           </span><br><span class="line">    Room newRoom2 = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> != planCircuit)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">using</span> (Transaction transaction = <span class="keyword">new</span> Transaction(document, <span class="string">&quot;Create Room&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (transaction.Start() == TransactionStatus.Started)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// The input room must exist only in the room schedule, </span></span><br><span class="line">                <span class="comment">// meaning that it does not display in any plan view.</span></span><br><span class="line">                newRoom2 = document.Create.NewRoom(newScheduleRoom, planCircuit);</span><br><span class="line">                <span class="comment">// a model room with the same name and number is created in the </span></span><br><span class="line">                <span class="comment">// view where the PlanCircuit is located</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">null</span> != newRoom2)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// Give the user some information</span></span><br><span class="line">                    TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>, <span class="string">&quot;Room placed in Plan Circuit successfully.&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                transaction.Commit();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> newRoom2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建房间并将其添加到位置后，可以使用Room.Unplace（）方法将其从该位置删除（但在项目中仍然可用）。然后可以将其放置在新的位置。</p>
<h3 id="房间边界"><a href="#房间边界" class="headerlink" title="房间边界"></a>房间边界</h3><p>房间的边界可在房间所在的位置创建封闭区域。</p>
<ul>
<li>边界包括以下要素：<ul>
<li>Walls  </li>
<li>Model lines  </li>
<li>Columns  </li>
<li>Roofs</li>
</ul>
</li>
</ul>
<h4 id="检索房间边界"><a href="#检索房间边界" class="headerlink" title="检索房间边界"></a>检索房间边界</h4><p>房间周围的边界是从基类方法SpatialElement.GetBoundarySegments（）获得的。当房间不在封闭区域中或仅存在于明细表中时，该方法返回null。每个房间可能有几个区域，每个区域都有几个段，因此数据以BoundarySegment列表的形式返回。</p>
<p>下图显示了在Revit UI中选择的房间边界：</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/CHS/Revit-API/images/GUID-4FEC99FB-5F16-4343-8475-ECFF367CB072.png" alt="img"></p>
<p>图138：房间边界</p>
<p>线段列表的大小取决于封闭区域拓扑。每个BoundarySegment列表都创建一个回路或一条连续的线，其中一个线段连接到下一个线段。下面的图片提供了几个例子。在下面的图片中，所有墙都是“房间边界”，模型线类别为OST_AreaSeparationLines。如果某个图元不是“房间边界”，则将其从图元中排除以形成边界。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/CHS/Revit-API/images/GUID-792A1532-E1EE-4186-894F-F593C930B2A6.png" alt="img"></p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/CHS/Revit-API/images/GUID-C259DDE9-9A9E-457F-87C3-3D686A8A9359.png"></p>
<p>下表提供了之前房间的Room.GetBoundarySegments（）.Size结果：</p>
<p><strong>表56：Room.GetBoundarySegments（）.Size</strong></p>
<table>
<thead>
<tr>
<th><strong>Room 房间</strong></th>
<th>**Room.GetBoundarySegments().Size **</th>
</tr>
</thead>
<tbody><tr>
<td>Room 1、2、3</td>
<td>1</td>
</tr>
<tr>
<td>Room 4</td>
<td>2</td>
</tr>
<tr>
<td>Room 5、6</td>
<td>3</td>
</tr>
</tbody></table>
<p>注意：由模型线连接的墙被视为连续的线段。单个模型线将被忽略。</p>
<p>获取IList&lt;IList<BoundarySegment>后，通过迭代列表获取BoundarySegment。</p>
<p><strong>BoundarySegment</strong> </p>
<p>构成区域的线段由BoundarySegment类表示;其ElementId属性返回对应元素的id，条件如下：</p>
<ul>
<li>对于ModelCurve元素，类别必须是BuiltInCategory.OST_AreaSeparationLines，这意味着它表示房间分隔符。</li>
<li>对于墙、柱和屋顶等其他图元，如果图元是房间边界，则“房间边界”参数（BuiltInParameter.WALL_ATTR_ROOM_BOUNDING）必须为真，如下图所示。</li>
</ul>
<p><img src="https://help.autodesk.com/cloudhelp/2018/CHS/Revit-API/images/GUID-FBC69AE1-EF76-4773-AC4A-7CBCC77EE924.png" alt="img"></p>
<p>图141：房间边界属性</p>
<p>WALL_ATTR_ROOM_BOUNDING内置参数通过API设置：</p>
<p>代码区域28-3：设置房间边界</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetRoomBounding</span>(<span class="params">Wall wall</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        Parameter parameter = wall.get_Parameter(BuiltInParameter.WALL_ATTR_ROOM_BOUNDING);</span><br><span class="line">        parameter.Set(<span class="number">1</span>);   <span class="comment">//set &quot;Room Bounding&quot; to true</span></span><br><span class="line">        parameter.Set(<span class="number">0</span>);   <span class="comment">//set &quot;Room Bounding&quot; to false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请注意，在下面的图片中，屋顶如何形成房间的BoundarySegment。第一张图片显示立面视图中的Level 3。将在Level 3楼层视图中创建房间。后两张图片显示了房间和房子的3D视图的边界。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/CHS/Revit-API/images/GUID-067191A0-12EA-430F-B145-6B8D5D6E596E.png" alt="img"></p>
<p>图142：在标高3视图中创建的房间</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/CHS/Revit-API/images/GUID-862FFB79-21A7-4F5A-B949-B442529EF50E.png"></p>
<p><strong>图143：</strong>屋顶形成的房间边界</p>
<p>面积边界只能是类别为面积边界（BuiltInCategory.OST_AreaSchemeLines）的ModelCurve，而显示房间的边界可以是墙和其他图元。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/CHS/Revit-API/images/GUID-8B918B3C-ED10-486C-912A-9D4A1F8CC4EA.png"></p>
<p>图144：墙端边缘</p>
<p>如果BoundarySegment对应于房间分隔和墙之间的曲线，如上图所示：</p>
<ul>
<li>Element属性返回null</li>
<li>曲线不为空。</li>
</ul>
<p><strong>边界与事务</strong></p>
<p>在使用API创建了一个元素（如墙）之后，如果调用Room.GetBoundarySegments（），墙可以更改房间边界。您必须确保数据已更新。</p>
<p>下图显示了使用Revit Platform API创建墙后房间的变化。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/CHS/Revit-API/images/GUID-5410C3CF-324E-4C38-9152-BA29AB5D6CA1.png" alt="img"></p>
<p>图145：添加的墙更改房间边界</p>
<p>要更新房间边界数据，请使用以下代码中的事务机制：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">UpdateRoomBoundary</span>(<span class="params">UIApplication application, Room room, Level level</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Document document = application.ActiveUIDocument.Document;</span><br><span class="line">            </span><br><span class="line">    <span class="comment">//Get the size before creating a wall</span></span><br><span class="line">    <span class="built_in">int</span> size = room.GetBoundarySegments(<span class="keyword">new</span> SpatialElementBoundaryOptions()).First().Count;</span><br><span class="line">    <span class="built_in">string</span> message = <span class="string">&quot;Room boundary size before wall: &quot;</span> + size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Prepare a line</span></span><br><span class="line">    XYZ startPos = <span class="keyword">new</span> XYZ(<span class="number">-10</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    XYZ endPos = <span class="keyword">new</span> XYZ(<span class="number">10</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    Line line = Line.CreateBound(startPos, endPos);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Create a new wall and enclose the creating into a single transaction</span></span><br><span class="line">    <span class="keyword">using</span> (Transaction transaction = <span class="keyword">new</span> Transaction(document, <span class="string">&quot;Create Wall&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (transaction.Start() == TransactionStatus.Started)</span><br><span class="line">        &#123;</span><br><span class="line">            Wall wall = Wall.Create(document, line, level.Id, <span class="literal">false</span>);</span><br><span class="line">            <span class="keyword">if</span> (<span class="literal">null</span> != wall)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (TransactionStatus.Committed == transaction.Commit())</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//Get the new size</span></span><br><span class="line">                    size = room.GetBoundarySegments(<span class="keyword">new</span> SpatialElementBoundaryOptions()).First().Count;</span><br><span class="line">                    message += <span class="string">&quot;\nRoom boundary size after wall: &quot;</span> + size;</span><br><span class="line">                    TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>, message);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                transaction.RollBack();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有关详细信息，请参阅事务。</p>
<p><strong>平面拓扑</strong></p>
<p>房间所在的标高平面具有由墙和房间分隔线等图元构成的拓扑。PlanTopology和PlanCircuit类用于表示标高拓扑。</p>
<ul>
<li>使用Level从Document对象获取PlanTopology对象。在每个平面视图中，每个阶段对应一个PlanTopology。</li>
<li>相同的条件适用于BoundarySegment，但房间分隔符和房间边界参数为true的元素可以是PlanCircuit中的边（边界）。</li>
</ul>
<p><img src="https://help.autodesk.com/cloudhelp/2018/CHS/Revit-API/images/GUID-E0715B88-5A70-4424-8268-E1CAD3D5EEFF.png" alt="img"></p>
<p>图146：房间和平面拓扑图</p>
<p>PlanCircuit.Sideship属性返回线路边编号，而SpatialElement.GetBoundarySegments（）返回IList&lt;IList&lt;Autodesk.Revit.DB.BoundarySegment&gt;，其Count与线路边编号不同。</p>
<ul>
<li>如果墙上有分支，则SpatialElement.GetBoundarySegments（）将底墙识别为两面墙。</li>
<li>PlanCircuit.无论分支的数量如何，Sideball总是将图片中的底墙视为一个。</li>
</ul>
<p><img src="https://help.autodesk.com/cloudhelp/2018/CHS/Revit-API/images/GUID-25504A29-2C29-409B-AFF6-916CD359E8C2.png" alt="img"></p>
<p>图147：比较房间边界与PlanCircuit</p>
<p>表57：房间边界与平面回路的比较</p>
<table>
<thead>
<tr>
<th>**Circuit **</th>
<th><strong>Circuit.SideNum</strong></th>
<th>**IList&lt;IList&lt;Autodesk.Revit.DB.BoundarySegment&gt; .Count for Room **</th>
</tr>
</thead>
<tbody><tr>
<td>Circuit 1</td>
<td>3</td>
<td>3 (Room1)</td>
</tr>
<tr>
<td>Circuit 2</td>
<td>4 +2 &#x3D; 6</td>
<td>4 +3 &#x3D; 7 (Room2)</td>
</tr>
<tr>
<td>Circuit 3</td>
<td>3 +2 &#x3D; 5</td>
<td>3 +3 &#x3D; 6 (Room3)</td>
</tr>
<tr>
<td>Circuit 4</td>
<td>3</td>
<td>3 (Room4)</td>
</tr>
<tr>
<td>Circuit 5</td>
<td>3</td>
<td>3 (Room5)</td>
</tr>
</tbody></table>
<p><strong>房间和族实例</strong></p>
<p>“门”和“窗”是与“房间”相关的特殊族实例。这里只讨论门，因为唯一的区别是窗户没有翻转把手。</p>
<p>以下特性适用于门：</p>
<ul>
<li>门元素可以在没有房间的情况下存在。</li>
<li>在API中（仅在API中），Door元素具有两个附加属性，它们引用门的两个相对侧上的区域：ToRoom和FromRoom</li>
<li>如果区域是房间，则属性的值将是房间元素。</li>
<li>如果区域不是房间，则属性将返回null。两个属性可以同时为null。</li>
<li>门打开的一侧的区域将是ToRoom。另一边的房间将是FromRoom。</li>
<li>每当相应的区域发生变化时，这两个属性都会动态更新。</li>
</ul>
<p>在下面的图片中，五扇门插入到墙中，而不翻转饰面。该表列出了每个门的FromRoom、ToRoom和Room属性。房间属性属于所有族实例。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/CHS/Revit-API/images/GUID-B05F86CE-DD91-401E-BD6C-67704F9BE55C.png" alt="img"></p>
<p>Figure 148: Door 1 </p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/CHS/Revit-API/images/GUID-4D623C2A-40AC-44D0-86E5-14D00C649014.png" alt="img"></p>
<p>Figure 149: Door 2 </p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/CHS/Revit-API/images/GUID-97032EDC-973A-4DD0-A314-3796F3E52F1E.png" alt="img"></p>
<p>Figure 150: Door 3 </p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/CHS/Revit-API/images/GUID-25B7F1B6-3F62-4607-A2DC-AA38B4CBE0D1.png" alt="img"></p>
<p>Figure 151: Door 4</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/CHS/Revit-API/images/GUID-BEB8BE84-3D6F-4E7E-A87D-0FE6C7CB6D3F.png" alt="img"></p>
<p>Figure 152: Door 5 </p>
<p><strong>表58：门属性</strong></p>
<table>
<thead>
<tr>
<th>**Door **</th>
<th><strong>FromRoom</strong></th>
<th><strong>ToRoom</strong></th>
<th><strong>Room 房间</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Door 1</td>
<td>null</td>
<td>null</td>
<td>null</td>
</tr>
<tr>
<td>Door 2</td>
<td>Room 1</td>
<td>null</td>
<td>null</td>
</tr>
<tr>
<td>Door 3</td>
<td>Room 3</td>
<td>Room 2</td>
<td>Room 2</td>
</tr>
<tr>
<td>Door 4</td>
<td>Room 4</td>
<td>null</td>
<td>null</td>
</tr>
<tr>
<td>Door 5</td>
<td>null</td>
<td>Room 6</td>
<td>Room 6</td>
</tr>
</tbody></table>
<p>所有族实例都具有“房间”属性，该属性是实例在上一个项目阶段中所在的房间。窗户和门都面对着一个房间。通过翻转门或窗的朝向或调用FamilyInstance.FlipFromToRoom（）来更改房间。对于其他类型的实例（如梁和柱），“房间”是与实例具有相同边界的房间。</p>
<p>下面的代码演示了如何从族实例中获取Room。需要检查结果是否为null。</p>
<p>代码区域28-5：从族实例获取房间</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetRoomInfo</span>(<span class="params">FamilyInstance familyInstance</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        Room room = familyInstance.Room;</span><br><span class="line">        room = familyInstance.FromRoom;  <span class="comment">//for door and window family only</span></span><br><span class="line">        room = familyInstance.ToRoom;    <span class="comment">//for door and window family only</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != room)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="comment">//use the room...</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>其他房间属性</strong></p>
<p>Room类还有其他几个属性，可用于获取有关对象的信息。房间具有以下只读尺寸属性：</p>
<ul>
<li>Area  </li>
<li>Perimeter </li>
<li>UnboundedHeight</li>
<li>Volume  </li>
<li>ClosedShell</li>
</ul>
<p>此示例显示选定房间的尺寸标注信息。请注意，必须启用体积计算设置，否则房间体积将返回为0。</p>
<p>代码区域28-6：获取房间的尺寸</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetRoomDimensions</span>(<span class="params">Document doc, Room room</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    String roominfo = <span class="string">&quot;Room dimensions:\n&quot;</span>;</span><br><span class="line">    <span class="comment">// turn on volume calculations:</span></span><br><span class="line">    <span class="keyword">using</span> (Transaction t = <span class="keyword">new</span> Transaction(doc, <span class="string">&quot;Turn on volume calculation&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        t.Start();</span><br><span class="line">        AreaVolumeSettings settings = AreaVolumeSettings.GetAreaVolumeSettings(doc);</span><br><span class="line">        settings.ComputeVolumes = <span class="literal">true</span>;</span><br><span class="line">        t.Commit();</span><br><span class="line">    &#125;</span><br><span class="line">            </span><br><span class="line">    roominfo += <span class="string">&quot;Vol: &quot;</span> + room.Volume + <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    roominfo += <span class="string">&quot;Area: &quot;</span> + room.Area + <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    roominfo += <span class="string">&quot;Perimeter: &quot;</span> + room.Perimeter + <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    roominfo += <span class="string">&quot;Unbounded height: &quot;</span> + room.UnboundedHeight + <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>,roominfo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>房间（或空间）的ClosedShell属性是由房间开放空间的边界（墙、楼板、天花板、屋顶和边界线）形成的几何图形。如果需要检查模型中的其他物理图元与房间的交点，例如，查看图元的一部分或全部是否位于房间中，则此属性非常有用。有关示例，请参见随Revit SDK提供的RoofsRooms示例应用程序，其中ClosedShell用于检查房间是否垂直无边界。</p>
<p>此外，还可以获取或设置具有以下属性的房间的基准偏移和限制偏移：</p>
<ul>
<li>BaseOffset</li>
<li>LimitOffset</li>
</ul>
<p>可以使用UpperLimit属性获取或设置定义房间上限的标高。</p>
<h2 id="注：翻译自Revit-API-Developers-Guide"><a href="#注：翻译自Revit-API-Developers-Guide" class="headerlink" title="注：翻译自Revit API Developers Guide"></a><em><strong>注：</strong></em>翻译自<a href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_html">Revit API Developers Guide</a></h2>]]></content>
      <categories>
        <category>Revit二次开发人员指南</category>
      </categories>
      <tags>
        <tag>Revit</tag>
      </tags>
  </entry>
  <entry>
    <title>24子元素</title>
    <url>/2024/12/23/%E4%BA%8C%E5%BC%80%E6%8C%87%E5%8D%97/24%E5%AD%90%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<h1 id="子元素"><a href="#子元素" class="headerlink" title="子元素"></a><a href="https://help.autodesk.com/view/RVT/2018/CHS/?guid=GUID-DD027284-D899-43FB-B33A-5917C06D0C20">子元素</a></h1><p>多个Revit图元现在可以包含称为子图元的细分。子元素提供了一种方法，使元素的各个部分的行为就像它们是真实的元素一样，而不会产生向模型中添加更多完整元素的开销。</p>
<p>许多Revit功能（例如，参数、明细表和标记）都设计用于对图元进行操作。因此，Revit代码需要将对象表示为元素，以便它们参与这些功能。这可能会导致可伸缩性问题，因为每个元素都会增加开销，并且添加许多元素可能会降低模型的性能。</p>
<p>另一种方法是使用子元素。图元可以显示其包含的一组“子图元”，指定其类别和参数等特征，并且某些Revit功能会将这些子图元视为普通图元。例如，子元素可以为主元素提供几何图形，并且可以独立于其父元素进行选择。它可能会有自己的（可设置的）类型以及分配的类别，该类别可以与其父元素不同。</p>
<p>在API中，新的Subelement类用于引用一个Element或给定Element的特定子元素。它通常与对元素或特定子元素的引用直接相关。</p>
<h2 id="注：翻译自Revit-API-Developers-Guide"><a href="#注：翻译自Revit-API-Developers-Guide" class="headerlink" title="注：翻译自Revit API Developers Guide"></a><em><strong>注：</strong></em>翻译自<a href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_html">Revit API Developers Guide</a></h2>]]></content>
      <categories>
        <category>Revit二次开发人员指南</category>
      </categories>
      <tags>
        <tag>Revit</tag>
      </tags>
  </entry>
  <entry>
    <title>23DirectShape</title>
    <url>/2024/12/24/%E4%BA%8C%E5%BC%80%E6%8C%87%E5%8D%97/23DirectShape/</url>
    <content><![CDATA[<h1 id="DirectShape"><a href="#DirectShape" class="headerlink" title="DirectShape"></a>DirectShape</h1><p>此图元类型可以在项目或族文档中存储通过导入操作或计算获得的任意几何图形。</p>
<p>DirectShape元素和相关类支持在Revit文档中存储外部创建的几何形状的功能。几何体可以包括闭合实体或网格。DirectShape主要用于从其他数据格式（如IFC或STEP）导入形状，在这些格式中，没有足够的信息来创建“真实的”Revit图元。</p>
<p>可以为DirectShape对象指定顶级模型类别，例如墙类别。子类别不能指定给DirectShape元素。IsValidCategoryId（）方法可以测试类别ID，以确保它是批准与DirectShape和Category一起使用的顶级内置类别。如果类别类型为Model，则会指示CategoryType枚举值。类别将影响该对象在Revit中的显示方式，并将为该对象授予可用参数的集合和某些有限的行为。</p>
<p><strong>DirectShape创建</strong></p>
<p>静态DirectElement（）方法将创建一个新的实例级DirectShape。它需要将DirectShape添加到其中的文档以及适当的内置类别的ID。DirectShape提供ApplicationId和ApplicationDataId字符串参数，这些参数为创建的形状的源提供上下文。</p>
<p>创建DirectShape后，可以使用重载的SetShape（）方法之一来设置该形状。该形状可以直接从ShapeBuilder对象或从GeometryObject列表中设置。如果您无论如何都要使用ShapeBuilder对象为DirectShape构造几何图形，则使用ShapeBuilder输入可能会有轻微的性能优势，因为Revit将绕过对输入几何图形的重复验证。还可以使用不同版本的DirectShape（）方法将其他几何体对象附加到DirectShape。请注意，BulldShape（）不会将传入的几何体与任何已经存在的几何体合并或连接，几何体将独立存储。</p>
<p>DirectMap接受以下几何体类型作为输入：</p>
<ul>
<li>实体（可以是封闭或开放的外壳）</li>
<li>网格</li>
<li>曲线</li>
<li>点</li>
</ul>
<p>此外，还可以指定要在DirectShape的视图特定表示中使用的几何体。该几何图形与DirectShapeTargetViewType的输入一起沿着输入。设置视图专有的形状表达时，它将仅用于该类型的视图中。目前，唯一受支持的视图专有表达用于平面视图。</p>
<p>面的示例演示如何从使用GeometryCreationUtilities类创建的球体创建简单的DirectShape。请注意在创建几何体时使用了参考框架。在使用Frame对象创建几何图形之前，最好先调用静态方法Frame.CanDefineRevitGeometry（），该方法测试提供的Frame对象是否可用于定义Revit曲线或曲面。为了满足要求，框架必须正交，并且其原点应位于Revit设计限制范围内。(When创建几何体时，使用静态XYZ也很有用。IsWithinLengthLimits（），以确保该点在Revit设计限制范围内。）</p>
<p>代码区域：创建DirectShape</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Create a DirectShape Sphere</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">CreateSphereDirectShape</span>(<span class="params">Document doc</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    List&lt;Curve&gt; profile = <span class="keyword">new</span> List&lt;Curve&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// first create sphere with 2&#x27; radius</span></span><br><span class="line">    XYZ center = XYZ.Zero;</span><br><span class="line">    <span class="built_in">double</span> radius = <span class="number">2.0</span>;    </span><br><span class="line">    XYZ profile00 = center;</span><br><span class="line">    XYZ profilePlus = center + <span class="keyword">new</span> XYZ(<span class="number">0</span>, radius, <span class="number">0</span>);</span><br><span class="line">    XYZ profileMinus = center - <span class="keyword">new</span> XYZ(<span class="number">0</span>, radius, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    profile.Add(Line.CreateBound(profilePlus, profileMinus));</span><br><span class="line">    profile.Add(Arc.Create(profileMinus, profilePlus, center + <span class="keyword">new</span> XYZ(radius, <span class="number">0</span>, <span class="number">0</span>)));</span><br><span class="line"></span><br><span class="line">    CurveLoop curveLoop = CurveLoop.Create(profile);</span><br><span class="line">    SolidOptions options = <span class="keyword">new</span> SolidOptions(ElementId.InvalidElementId, ElementId.InvalidElementId);</span><br><span class="line"></span><br><span class="line">    Frame frame = <span class="keyword">new</span> Frame(center, XYZ.BasisX, -XYZ.BasisZ, XYZ.BasisY);</span><br><span class="line">    <span class="keyword">if</span> (Frame.CanDefineRevitGeometry(frame) == <span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Solid sphere = GeometryCreationUtilities.CreateRevolvedGeometry(frame, <span class="keyword">new</span> CurveLoop[] &#123; curveLoop &#125;, <span class="number">0</span>, <span class="number">2</span> * Math.PI, options);</span><br><span class="line">        <span class="keyword">using</span> (Transaction t = <span class="keyword">new</span> Transaction(doc, <span class="string">&quot;Create sphere direct shape&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            t.Start();</span><br><span class="line">            <span class="comment">// create direct shape and assign the sphere shape</span></span><br><span class="line">            DirectShape ds = DirectShape.CreateElement(doc, <span class="keyword">new</span> ElementId(BuiltInCategory.OST_GenericModel));</span><br><span class="line"></span><br><span class="line">            ds.ApplicationId = <span class="string">&quot;Application id&quot;</span>;</span><br><span class="line">            ds.ApplicationDataId = <span class="string">&quot;Geometry object id&quot;</span>;</span><br><span class="line">            ds.SetShape(<span class="keyword">new</span> GeometryObject[] &#123; sphere &#125;);</span><br><span class="line">            t.Commit();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DirectShape的几何体也可以使用ShapeBuilder类的子类或从TessellatedShapeBuilder创建。</p>
<p><strong>ShapeBuilder</strong></p>
<p>ViewShapeBuilder和WireframeBuilder可用于创建几何体以存储在DirectShape类中。ViewShapeBuilder类生成并验证视图特定的形状表示。它仅限于平面视图的基于曲线的表达。WireframeBuilder构造由点和曲线组成的3D形状表示。这两种类型的ShapeBuilder都可以通过使用带ShapeBuilder参数的DirectShape.SetShape（）或DirectShape.SetShadShape（）重载应用于DirectShape元素。</p>
<p><strong>TessellatedShapeBuilder</strong></p>
<p>TessellatedShapeBuilder可用于创建实体、壳或多边形网格，这些网格由一组连接的平面小平面包围，通过逐个添加TessellatedFace对象创建。只有在面集处于“open”状态时，才能将面添加到构建中。使用OpenConnectedFaceSet（）方法打开面集。添加所有TessellatedFaces后，调用CloseConnectedFaceSet（）关闭面集。构建器允许多个面集的可能性-在这种情况下，第一个面集应该代表物体的外部“表面”，所有后续面集代表内部空隙。尽管输入数据中存在不一致或遗漏，构建器仍会尝试创建在Revit中有效的几何图形。</p>
<p>定义所有面并关闭面集后，调用Build（）方法从存储的面集构建指定的几何对象。可以在调用Build（）之前设置TessellatedShapeBuilder的Target、Fallback和GraphicsStyleId属性，否则将使用默认选项。Build（）的结果存储在TessellatedShapeBuilder中，可以通过调用GetBuildResult（）进行检索。TessellatedShapeBuilderResult.GetGeometricalObjects（）方法将返回一个GeometryObjects列表，该列表可与相应的DirectShape.SetShape（）或DirectShape. SethdShape（）重载一起使用，如下面的示例所示。</p>
<p>代码区域：使用TessellatedShapeBuilder创建DirectShape</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Create a pyramid-shaped DirectShape using given material for the faces</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">CreateTessellatedShape</span>(<span class="params">Document doc, ElementId materialId</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    List&lt;XYZ&gt; loopVertices = <span class="keyword">new</span> List&lt;XYZ&gt;(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    TessellatedShapeBuilder builder = <span class="keyword">new</span> TessellatedShapeBuilder();</span><br><span class="line"></span><br><span class="line">    builder.OpenConnectedFaceSet(<span class="literal">true</span>);</span><br><span class="line">    <span class="comment">// create a pyramid with a square base 4&#x27; x 4&#x27; and 5&#x27; high</span></span><br><span class="line">    <span class="built_in">double</span> length = <span class="number">4.0</span>;</span><br><span class="line">    <span class="built_in">double</span> height = <span class="number">5.0</span>;</span><br><span class="line"></span><br><span class="line">    XYZ basePt1 = XYZ.Zero;</span><br><span class="line">    XYZ basePt2 = <span class="keyword">new</span> XYZ(length, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    XYZ basePt3 = <span class="keyword">new</span> XYZ(length, length, <span class="number">0</span>);</span><br><span class="line">    XYZ basePt4 = <span class="keyword">new</span> XYZ(<span class="number">0</span>, length, <span class="number">0</span>);</span><br><span class="line">    XYZ apex = <span class="keyword">new</span> XYZ(length / <span class="number">2</span>, length / <span class="number">2</span>, height);</span><br><span class="line"></span><br><span class="line">    loopVertices.Add(basePt1);</span><br><span class="line">    loopVertices.Add(basePt2);</span><br><span class="line">    loopVertices.Add(basePt3);</span><br><span class="line">    loopVertices.Add(basePt4);</span><br><span class="line">    builder.AddFace(<span class="keyword">new</span> TessellatedFace(loopVertices, materialId));</span><br><span class="line"></span><br><span class="line">    loopVertices.Clear();</span><br><span class="line">    loopVertices.Add(basePt1);</span><br><span class="line">    loopVertices.Add(apex);</span><br><span class="line">    loopVertices.Add(basePt2);</span><br><span class="line">    builder.AddFace(<span class="keyword">new</span> TessellatedFace(loopVertices, materialId));</span><br><span class="line"></span><br><span class="line">    loopVertices.Clear();</span><br><span class="line">    loopVertices.Add(basePt2);</span><br><span class="line">    loopVertices.Add(apex);</span><br><span class="line">    loopVertices.Add(basePt3);</span><br><span class="line">    builder.AddFace(<span class="keyword">new</span> TessellatedFace(loopVertices, materialId));</span><br><span class="line"></span><br><span class="line">    loopVertices.Clear();</span><br><span class="line">    loopVertices.Add(basePt3);</span><br><span class="line">    loopVertices.Add(apex);</span><br><span class="line">    loopVertices.Add(basePt4);</span><br><span class="line">    builder.AddFace(<span class="keyword">new</span> TessellatedFace(loopVertices, materialId));</span><br><span class="line"></span><br><span class="line">    loopVertices.Clear();</span><br><span class="line">    loopVertices.Add(basePt4);</span><br><span class="line">    loopVertices.Add(apex);</span><br><span class="line">    loopVertices.Add(basePt1);</span><br><span class="line">    builder.AddFace(<span class="keyword">new</span> TessellatedFace(loopVertices, materialId));</span><br><span class="line"></span><br><span class="line">    builder.CloseConnectedFaceSet();</span><br><span class="line">    builder.Target = TessellatedShapeBuilderTarget.Solid;</span><br><span class="line">    builder.Fallback = TessellatedShapeBuilderFallback.Abort;</span><br><span class="line">    builder.Build();</span><br><span class="line"></span><br><span class="line">    TessellatedShapeBuilderResult result = builder.GetBuildResult();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> (Transaction t = <span class="keyword">new</span> Transaction(doc, <span class="string">&quot;Create tessellated direct shape&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        t.Start();</span><br><span class="line">                </span><br><span class="line">        DirectShape ds = DirectShape.CreateElement(doc, <span class="keyword">new</span> ElementId(BuiltInCategory.OST_GenericModel));</span><br><span class="line">        ds.ApplicationId = <span class="string">&quot;Application id&quot;</span>;</span><br><span class="line">        ds.ApplicationDataId = <span class="string">&quot;Geometry object id&quot;</span>;</span><br><span class="line"></span><br><span class="line">        ds.SetShape(result.GetGeometricalObjects());</span><br><span class="line">        t.Commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面的图片是运行上面的示例并指定混凝土材质ID的结果。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/CHS/Revit-API/images/GUID-94C65476-5A32-4C89-8561-4AD97C41774D.png" alt="img"></p>
<p><strong>BRepBuilder</strong></p>
<p>BRepBuilder类提供了构造Revit边界表达几何图形（实体、开放壳等）的功能。作为表面、边和边的边界环的输入的结果。如果边界表示的构建成功，则可以在接受几何图形的任何其他Revit工具中直接使用生成的几何图形对象，或者可以直接传递BRepBuilder，以通过DirectShape类的SetShape（）和RoundShape（）方法填充DirectShape。下面是一个使用SetShape（）方法将圆柱体形状分配给新DirectShape对象的示例。</p>
<p>代码区域：使用BRepBuilder创建DirectShape</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">CreateDirectShapeFromCylinder</span>(<span class="params">Document doc</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Naming convention for faces and edges: we assume that x is to the left and pointing down, y is horizontal and pointing to the right, z is up</span></span><br><span class="line">    BRepBuilder brepBuilder = <span class="keyword">new</span> BRepBuilder(BRepType.Solid);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The surfaces of the four faces.</span></span><br><span class="line">    Frame basis = <span class="keyword">new</span> Frame(<span class="keyword">new</span> XYZ(<span class="number">50</span>, <span class="number">-100</span>, <span class="number">0</span>), <span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>), <span class="keyword">new</span> XYZ(<span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">    CylindricalSurface cylSurf = CylindricalSurface.Create(basis, <span class="number">50</span>);</span><br><span class="line">    Plane top = Plane.CreateByNormalAndOrigin(<span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>), <span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>));  <span class="comment">// normal points outside the cylinder</span></span><br><span class="line">    Plane bottom = Plane.CreateByNormalAndOrigin(<span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>), <span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)); <span class="comment">// normal points inside the cylinder</span></span><br><span class="line">                                                                                              </span><br><span class="line">    <span class="comment">// Add the four faces</span></span><br><span class="line">    BRepBuilderGeometryId frontCylFaceId = brepBuilder.AddFace(BRepBuilderSurfaceGeometry.Create(cylSurf, <span class="literal">null</span>), <span class="literal">false</span>);</span><br><span class="line">    BRepBuilderGeometryId backCylFaceId = brepBuilder.AddFace(BRepBuilderSurfaceGeometry.Create(cylSurf, <span class="literal">null</span>), <span class="literal">false</span>);</span><br><span class="line">    BRepBuilderGeometryId topFaceId = brepBuilder.AddFace(BRepBuilderSurfaceGeometry.Create(top, <span class="literal">null</span>), <span class="literal">false</span>);</span><br><span class="line">    BRepBuilderGeometryId bottomFaceId = brepBuilder.AddFace(BRepBuilderSurfaceGeometry.Create(bottom, <span class="literal">null</span>), <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Geometry for the four semi-circular edges and two vertical linear edges</span></span><br><span class="line">    BRepBuilderEdgeGeometry frontEdgeBottom = BRepBuilderEdgeGeometry.Create(Arc.Create(<span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">-100</span>, <span class="number">0</span>), <span class="keyword">new</span> XYZ(<span class="number">100</span>, <span class="number">-100</span>, <span class="number">0</span>), <span class="keyword">new</span> XYZ(<span class="number">50</span>, <span class="number">-50</span>, <span class="number">0</span>)));</span><br><span class="line">    BRepBuilderEdgeGeometry backEdgeBottom = BRepBuilderEdgeGeometry.Create(Arc.Create(<span class="keyword">new</span> XYZ(<span class="number">100</span>, <span class="number">-100</span>, <span class="number">0</span>), <span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">-100</span>, <span class="number">0</span>), <span class="keyword">new</span> XYZ(<span class="number">50</span>, <span class="number">-150</span>, <span class="number">0</span>)));</span><br><span class="line"></span><br><span class="line">    BRepBuilderEdgeGeometry frontEdgeTop = BRepBuilderEdgeGeometry.Create(Arc.Create(<span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">-100</span>, <span class="number">100</span>), <span class="keyword">new</span> XYZ(<span class="number">100</span>, <span class="number">-100</span>, <span class="number">100</span>), <span class="keyword">new</span> XYZ(<span class="number">50</span>, <span class="number">-50</span>, <span class="number">100</span>)));</span><br><span class="line">    BRepBuilderEdgeGeometry backEdgeTop = BRepBuilderEdgeGeometry.Create(Arc.Create(<span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">-100</span>, <span class="number">100</span>), <span class="keyword">new</span> XYZ(<span class="number">100</span>, <span class="number">-100</span>, <span class="number">100</span>), <span class="keyword">new</span> XYZ(<span class="number">50</span>, <span class="number">-150</span>, <span class="number">100</span>)));</span><br><span class="line"></span><br><span class="line">    BRepBuilderEdgeGeometry linearEdgeFront = BRepBuilderEdgeGeometry.Create(<span class="keyword">new</span> XYZ(<span class="number">100</span>, <span class="number">-100</span>, <span class="number">0</span>), <span class="keyword">new</span> XYZ(<span class="number">100</span>, <span class="number">-100</span>, <span class="number">100</span>));</span><br><span class="line">    BRepBuilderEdgeGeometry linearEdgeBack = BRepBuilderEdgeGeometry.Create(<span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">-100</span>, <span class="number">0</span>), <span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">-100</span>, <span class="number">100</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add the six edges</span></span><br><span class="line">    BRepBuilderGeometryId frontEdgeBottomId = brepBuilder.AddEdge(frontEdgeBottom);</span><br><span class="line">    BRepBuilderGeometryId frontEdgeTopId = brepBuilder.AddEdge(frontEdgeTop);</span><br><span class="line">    BRepBuilderGeometryId linearEdgeFrontId = brepBuilder.AddEdge(linearEdgeFront);</span><br><span class="line">    BRepBuilderGeometryId linearEdgeBackId = brepBuilder.AddEdge(linearEdgeBack);</span><br><span class="line">    BRepBuilderGeometryId backEdgeBottomId = brepBuilder.AddEdge(backEdgeBottom);</span><br><span class="line">    BRepBuilderGeometryId backEdgeTopId = brepBuilder.AddEdge(backEdgeTop);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Loops of the four faces</span></span><br><span class="line">    BRepBuilderGeometryId loopId_Top = brepBuilder.AddLoop(topFaceId);</span><br><span class="line">    BRepBuilderGeometryId loopId_Bottom = brepBuilder.AddLoop(bottomFaceId);</span><br><span class="line">    BRepBuilderGeometryId loopId_Front = brepBuilder.AddLoop(frontCylFaceId);</span><br><span class="line">    BRepBuilderGeometryId loopId_Back = brepBuilder.AddLoop(backCylFaceId);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add coedges for the loop of the front face</span></span><br><span class="line">    brepBuilder.AddCoEdge(loopId_Front, linearEdgeBackId, <span class="literal">false</span>);</span><br><span class="line">    brepBuilder.AddCoEdge(loopId_Front, frontEdgeTopId, <span class="literal">false</span>);</span><br><span class="line">    brepBuilder.AddCoEdge(loopId_Front, linearEdgeFrontId, <span class="literal">true</span>);</span><br><span class="line">    brepBuilder.AddCoEdge(loopId_Front, frontEdgeBottomId, <span class="literal">true</span>);</span><br><span class="line">    brepBuilder.FinishLoop(loopId_Front);</span><br><span class="line">    brepBuilder.FinishFace(frontCylFaceId);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add coedges for the loop of the back face</span></span><br><span class="line">    brepBuilder.AddCoEdge(loopId_Back, linearEdgeBackId, <span class="literal">true</span>);</span><br><span class="line">    brepBuilder.AddCoEdge(loopId_Back, backEdgeBottomId, <span class="literal">true</span>);</span><br><span class="line">    brepBuilder.AddCoEdge(loopId_Back, linearEdgeFrontId, <span class="literal">false</span>);</span><br><span class="line">    brepBuilder.AddCoEdge(loopId_Back, backEdgeTopId, <span class="literal">true</span>);</span><br><span class="line">    brepBuilder.FinishLoop(loopId_Back);</span><br><span class="line">    brepBuilder.FinishFace(backCylFaceId);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add coedges for the loop of the top face</span></span><br><span class="line">    brepBuilder.AddCoEdge(loopId_Top, backEdgeTopId, <span class="literal">false</span>);</span><br><span class="line">    brepBuilder.AddCoEdge(loopId_Top, frontEdgeTopId, <span class="literal">true</span>);</span><br><span class="line">    brepBuilder.FinishLoop(loopId_Top);</span><br><span class="line">    brepBuilder.FinishFace(topFaceId);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add coedges for the loop of the bottom face</span></span><br><span class="line">    brepBuilder.AddCoEdge(loopId_Bottom, frontEdgeBottomId, <span class="literal">false</span>);</span><br><span class="line">    brepBuilder.AddCoEdge(loopId_Bottom, backEdgeBottomId, <span class="literal">false</span>);</span><br><span class="line">    brepBuilder.FinishLoop(loopId_Bottom);</span><br><span class="line">    brepBuilder.FinishFace(bottomFaceId);</span><br><span class="line"></span><br><span class="line">    brepBuilder.Finish();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> (Transaction tr = <span class="keyword">new</span> Transaction(doc, <span class="string">&quot;Create a DirectShape&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        tr.Start();</span><br><span class="line">        DirectShape ds = DirectShape.CreateElement(doc, <span class="keyword">new</span> ElementId(BuiltInCategory.OST_GenericModel));</span><br><span class="line">        ds.SetShape(brepBuilder);</span><br><span class="line">        tr.Commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>ShapeImporter</strong> </p>
<p>ShapeImporter工具类支持将以外部格式（如SAT和Rhino）存储的几何体转换为可用于设置DirectShape形状的GeometryObjects集合。使用ShapeImporter.Convert（）生成几何体对象（如果可能，还生成关联文档中的相应材料和图形样式）。</p>
<p>代码区域：从SAT文件创建DirectShape</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ReadSATFile</span>(<span class="params">Document revitDoc</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Allow the user to select a SAT file.</span></span><br><span class="line">    OpenFileDialog ofd = <span class="keyword">new</span> OpenFileDialog();</span><br><span class="line">    ofd.Filter = <span class="string">&quot;SAT Files (*.sat)|*.sat&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (DialogResult.OK == ofd.ShowDialog())</span><br><span class="line">    &#123;</span><br><span class="line">        ShapeImporter shapeImporter = <span class="keyword">new</span> ShapeImporter();</span><br><span class="line">        shapeImporter.InputFormat = ShapeImporterSourceFormat.SAT; </span><br><span class="line">        IList&lt;GeometryObject&gt; shapes = shapeImporter.Convert(revitDoc, ofd.FileName);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (shapes.Count != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">using</span> (Transaction tr = <span class="keyword">new</span> Transaction(revitDoc, <span class="string">&quot;Create a DirectShape&quot;</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                tr.Start();</span><br><span class="line"></span><br><span class="line">                DirectShape dsImportedSat = DirectShape.CreateElement(revitDoc, <span class="keyword">new</span> ElementId(BuiltInCategory.OST_Walls));</span><br><span class="line">                dsImportedSat.SetShape(shapes);</span><br><span class="line"></span><br><span class="line">                tr.Commit();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Options</strong> </p>
<p>DirectShapeOptions类用于控制DirectShape对象的行为。使用DirectShape.SetOptions（）设置DirectShape对象使用的选项。GetOptions（）方法将返回DirectShape对象当前使用的DirectShapeOptions。</p>
<p>默认情况下，DirectShape元素支持元素参照，包括尺寸标注、路线和面主体以及捕捉。可以使用DirectShapeOptions.ReferencingOption属性更改此默认行为。如果将其设置为NotReferenceable，则几何图形不能用于标注、捕捉、对齐或面主体。用户仍然可以选择该元素进行不引用单个几何对象的操作。</p>
<p>如果DirectShape元素属于房间边界计算的适当类别，并且关联的“房间边界”参数设置为true，则DirectShape元素还支持参与房间边界计算的功能。属性DirectShapeOptions.RoomBoundingOption标识DirectShape是否支持“房间边界”参数的选项以允许参与房间边界计算。默认值为NotApplied，但对于适用的DirectController，此值将自动更改为SetByParameter。</p>
<h2 id="注：翻译自Revit-API-Developers-Guide"><a href="#注：翻译自Revit-API-Developers-Guide" class="headerlink" title="注：翻译自Revit API Developers Guide"></a><em><strong>注：</strong></em>翻译自<a href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_html">Revit API Developers Guide</a></h2>]]></content>
      <categories>
        <category>Revit二次开发人员指南</category>
      </categories>
      <tags>
        <tag>Revit</tag>
      </tags>
  </entry>
  <entry>
    <title>22曲面</title>
    <url>/2024/12/23/%E4%BA%8C%E5%BC%80%E6%8C%87%E5%8D%97/22%E6%9B%B2%E9%9D%A2/</url>
    <content><![CDATA[<h1 id="Surfaces"><a href="#Surfaces" class="headerlink" title="Surfaces"></a><a href="https://help.autodesk.com/view/RVT/2018/CHS/?guid=GUID-064E828D-83B8-4671-9F82-C189377DDAE3">Surfaces</a></h1><p>surface类表示表面的数学表示。</p>
<p>surface类不是从GeometryObject类派生的，并且不以边或边循环为边界。Revit中的有界曲面由Face类表示。</p>
<p>Surface是更具体的曲面的基类：</p>
<ul>
<li>Plane   平面</li>
<li>CylindricalSurface   圆柱形表面</li>
<li>ConicalSurface   圆锥面</li>
<li>RuledSurface   规则曲面</li>
<li>RevolvedSurface   旋转曲面</li>
<li>HermiteSurface   Hermite曲面</li>
</ul>
<p>这些子类包含Create（）方法和只读属性，适用于构造导入几何图形。有关在几何体创建中使用曲面的示例，请参见DirectShape主题。</p>
<h2 id="注：翻译自Revit-API-Developers-Guide"><a href="#注：翻译自Revit-API-Developers-Guide" class="headerlink" title="注：翻译自Revit API Developers Guide"></a><em><strong>注：</strong></em>翻译自<a href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_html">Revit API Developers Guide</a></h2>]]></content>
      <categories>
        <category>Revit二次开发人员指南</category>
      </categories>
      <tags>
        <tag>Revit</tag>
      </tags>
  </entry>
  <entry>
    <title>21楼梯和扶手</title>
    <url>/2024/12/23/%E4%BA%8C%E5%BC%80%E6%8C%87%E5%8D%97/21%E6%A5%BC%E6%A2%AF%E5%92%8C%E6%89%B6%E6%89%8B/</url>
    <content><![CDATA[<h1 id="楼梯和扶手"><a href="#楼梯和扶手" class="headerlink" title="楼梯和扶手"></a><a href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_Revit_Geometric_Elements_Stairs_and_Railings_html">楼梯和扶手</a></h1><p>Autodesk.Revit.DB.Architecture命名空间中的Revit API中的类允许访问楼梯和相关构件（如平台和梯段）。可以使用Revit API创建或修改楼梯。Stairs类表示“由构件”创建的楼梯。不能在API中将通过草图创建的楼梯图元作为楼梯对象进行访问。静态方法Stairs.IsByComponent（）可用于确定ElementId是否表示由构件创建的楼梯。</p>
<p> 本节中的页面</p>
<ul>
<li>创建和编辑楼梯</li>
<li>扶手</li>
<li>楼梯注释</li>
<li>楼梯构件</li>
</ul>
<h2 id="创建和编辑楼梯"><a href="#创建和编辑楼梯" class="headerlink" title="创建和编辑楼梯"></a>创建和编辑楼梯</h2><p><strong>StairsEditScope</strong></p>
<p>与Revit文档中其他类型的元素一样，编辑楼梯和楼梯构件需要事务处理。但是，若要创建新构件（如梯段和平台）或创建新楼梯本身，则必须使用Autodesk.Revit.DB.StairsEditScope对象，该对象支持楼梯编辑任务。</p>
<p>StairsEditScope的作用类似于TransactionGroup。启动StairsEditScope后，可以启动事务并编辑楼梯。在StairsEditScope中创建的单个事务不会出现在撤消菜单中。在编辑模式下提交的所有事务将被合并为一个事务，该事务的名称由传递给 StairsEditScope 构造函数的参数指定。</p>
<p>StairsEditScope有两个Start方法。获取现有Stairs对象的ElementId，并为其启动楼梯编辑会话。第二个Start方法采用底部标高和顶部标高的ElementId，并在指定标高中创建具有默认楼梯类型的新空楼梯元素，然后为新楼梯启动楼梯编辑模式。</p>
<p>将梯段和平台添加到楼梯并完成编辑后，请调用 StairsEditScope.Commit() 方法结束楼梯编辑模式。</p>
<p><strong>添加梯段</strong></p>
<ul>
<li>StairsRun类有三个用于为Stairs对象创建新梯段的静态方法：<ul>
<li><strong>CreateSketchedRun</strong> - 通过提供一组边界曲线和踢面曲线来创建草图梯段。</li>
<li><strong>CreateStraightRun</strong> - 创建直线梯段。</li>
<li><strong>CreateSpiralRun</strong> - 通过提供圆心、起始角度和夹角来创建螺旋梯段。</li>
</ul>
</li>
</ul>
<p><strong>添加平台</strong></p>
<p>可以在两个梯段之间添加自动平台或草图平台。静态方法StairsLanding. Canadian AutomaticLanding（）将检查两个楼梯梯段是否满足创建自动平台的限制。静态StairsLanding. random AutomaticLanding（）方法将返回在两个楼梯梯段之间创建的所有平台的Id。</p>
<p>静态StairsLanding. RightSketchedLanding方法通过提供平台的闭合边界曲线，在两个梯段之间创建自定义平台。基本高程的双精度值是CreateSketchedLanding方法的输入参数之一。标高有以下限制：</p>
<ul>
<li>底部高程相对于楼梯的底部高程。</li>
<li>底部高程将自动舍入为踢面高度的倍数。</li>
<li>基础标高应等于或大于踢面高度的一半。</li>
</ul>
<p><strong>例子</strong></p>
<p>下面的示例将创建一个新的Stairs对象、两个梯段（一个为草图梯段，一个为直线梯段）以及它们之间的平台。</p>
<p>代码区域：创建楼梯、楼梯平台和平台</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// FailurePreprocessor class required for StairsEditScope</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">StairsFailurePreprocessor</span> : <span class="title">IFailuresPreprocessor</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> FailureProcessingResult <span class="title">PreprocessFailures</span>(<span class="params">FailuresAccessor failuresAccessor</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Use default failure processing</span></span><br><span class="line">        <span class="keyword">return</span> FailureProcessingResult.Continue; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> ElementId <span class="title">CreateStairs</span>(<span class="params">Document document, Level levelBottom, Level levelTop</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ElementId newStairsId = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> (StairsEditScope newStairsScope = <span class="keyword">new</span> StairsEditScope(document, <span class="string">&quot;New Stairs&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        newStairsId = newStairsScope.Start(levelBottom.Id, levelTop.Id);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">using</span> (Transaction stairsTrans = <span class="keyword">new</span> Transaction(document, <span class="string">&quot;Add Runs and Landings to Stairs&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            stairsTrans.Start();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Create a sketched run for the stairs</span></span><br><span class="line">            IList bdryCurves = <span class="keyword">new</span> List();</span><br><span class="line">            IList riserCurves = <span class="keyword">new</span> List();</span><br><span class="line">            IList pathCurves = <span class="keyword">new</span> List();</span><br><span class="line">            XYZ pnt1 = <span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            XYZ pnt2 = <span class="keyword">new</span> XYZ(<span class="number">15</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            XYZ pnt3 = <span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">10</span>, <span class="number">0</span>);</span><br><span class="line">            XYZ pnt4 = <span class="keyword">new</span> XYZ(<span class="number">15</span>, <span class="number">10</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// boundaries</span></span><br><span class="line">            bdryCurves.Add(Line.CreateBound(pnt1, pnt2));</span><br><span class="line">            bdryCurves.Add(Line.CreateBound(pnt3, pnt4));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// riser curves</span></span><br><span class="line">            <span class="keyword">const</span> <span class="built_in">int</span> riserNum = <span class="number">20</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> ii = <span class="number">0</span>; ii &lt;= riserNum; ii++)</span><br><span class="line">            &#123;</span><br><span class="line">                XYZ end0 = (pnt1 + pnt2)  ii / (<span class="built_in">double</span>)riserNum;</span><br><span class="line">                XYZ end1 = (pnt3 + pnt4)  ii / (<span class="built_in">double</span>)riserNum;</span><br><span class="line">                XYZ end2 = <span class="keyword">new</span> XYZ(end1.X, <span class="number">10</span>, <span class="number">0</span>);</span><br><span class="line">                riserCurves.Add(Line.CreateBound(end0, end2));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//stairs path curves</span></span><br><span class="line">            XYZ pathEnd0 = (pnt1 + pnt3) / <span class="number">2.0</span>;</span><br><span class="line">            XYZ pathEnd1 = (pnt2 + pnt4) / <span class="number">2.0</span>;</span><br><span class="line">            pathCurves.Add(Line.CreateBound(pathEnd0, pathEnd1));</span><br><span class="line"></span><br><span class="line">            StairsRun newRun1 = StairsRun.CreateSketchedRun(document, newStairsId, levelBottom.Elevation, bdryCurves, riserCurves, pathCurves);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Add a straight run</span></span><br><span class="line">            Line locationLine = Line.CreateBound(<span class="keyword">new</span> XYZ(<span class="number">20</span>, <span class="number">-5</span>, newRun1.TopElevation), <span class="keyword">new</span> XYZ(<span class="number">35</span>, <span class="number">-5</span>, newRun1.TopElevation));</span><br><span class="line">            StairsRun newRun2 = StairsRun.CreateStraightRun(document, newStairsId, locationLine, StairsRunJustification.Center);</span><br><span class="line">            newRun2.ActualRunWidth = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Add a landing between the runs</span></span><br><span class="line">            CurveLoop landingLoop = <span class="keyword">new</span> CurveLoop();</span><br><span class="line">            XYZ p1 = <span class="keyword">new</span> XYZ(<span class="number">15</span>, <span class="number">10</span>, <span class="number">0</span>); </span><br><span class="line">            XYZ p2 = <span class="keyword">new</span> XYZ(<span class="number">20</span>, <span class="number">10</span>, <span class="number">0</span>);</span><br><span class="line">            XYZ p3 = <span class="keyword">new</span> XYZ(<span class="number">20</span>, <span class="number">-10</span>, <span class="number">0</span>);</span><br><span class="line">            XYZ p4 = <span class="keyword">new</span> XYZ(<span class="number">15</span>, <span class="number">-10</span>, <span class="number">0</span>);</span><br><span class="line">            Line curve_1 = Line.CreateBound(p1, p2);</span><br><span class="line">            Line curve_2 = Line.CreateBound(p2, p3);</span><br><span class="line">            Line curve_3 = Line.CreateBound(p3, p4);</span><br><span class="line">            Line curve_4 = Line.CreateBound(p4, p1);</span><br><span class="line"></span><br><span class="line">            landingLoop.Append(curve_1);</span><br><span class="line">            landingLoop.Append(curve_2);</span><br><span class="line">            landingLoop.Append(curve_3);</span><br><span class="line">            landingLoop.Append(curve_4);</span><br><span class="line">            StairsLanding newLanding = StairsLanding.CreateSketchedLanding(document, newStairsId, landingLoop, newRun1.TopElevation);</span><br><span class="line"></span><br><span class="line">            stairsTrans.Commit();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// A failure preprocessor is to handle possible failures during the edit mode commitment process.</span></span><br><span class="line">        newStairsScope.Commit(<span class="keyword">new</span> StairsFailurePreprocessor());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> newStairsId;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的例子产生的楼梯：<img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/stairs.jpg" alt="img"></p>
<p><strong>多层楼梯</strong> </p>
<p>MultistoryStairs类允许楼梯跨越多个标高。多层楼梯元素可以包含多个楼梯，这些楼梯的范围由底部标高和顶部标高控制。 此元素将包含一个或多个Stairs元素。楼梯元素是： 复制到由共享相同标高高度的相同楼梯实例组覆盖的每个标高的参考实例， 或未连接到具有相同标高高度的组的单个Stairs实例。 默认情况下，向多层楼梯添加新标高时，新楼梯将添加到组中。对于不同标高的重复楼梯组，实例可以作为Stairs元素的子元素找到。通过修改关联的Stairs实例，可以一起编辑连接组中的楼梯。对于需要特殊设计的特定楼层，可以使用“取消锁定”方法将楼梯从组中分离出来-对取消锁定的楼梯所做的更改不会影响图元中的其他任何实例。稍后可以使用“锁定”方法将楼梯添加回组中，但是对楼梯所做的任何更改都将丢失，因为楼梯的属性将被组规范覆盖。</p>
<p>代码区域：创建多层楼梯</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// create new MultistoryStairs </span></span><br><span class="line">MultistoryStairs multistoryStairs = MultistoryStairs.Create(stairs);</span><br><span class="line"></span><br><span class="line"><span class="comment">// get all levels that can be connected to this multistoryStairs</span></span><br><span class="line">IEnumerable levelIds = <span class="keyword">new</span> FilteredElementCollector(doc).OfClass(<span class="keyword">typeof</span>(Level)).Cast().Where(q =&gt; multistoryStairs.CanConnectLevel(q.Id))</span><br><span class="line">.Select(q =&gt; q.Id);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Connect the levels to the multistoryStairs</span></span><br><span class="line"><span class="comment">// The input to ConnectLevels is a HashSet or SortedSet, so a HashSet is created from the IEnumerable returned by FilteredElementCollector</span></span><br><span class="line">multistoryStairs.ConnectLevels(<span class="keyword">new</span> HashSet(levelIds));</span><br></pre></td></tr></table></figure>

<p>当使用StairsEditScope.Start（ElementId，ElementId）方法创建新楼梯时，它们具有与其关联的默认扶手。但是，Railing.Create（）方法可用于在不带扶手的楼梯的楼梯元素的所有边上创建具有指定扶手类型的新扶手。与需要使用StairsEditScope创建梯段和平台不同，扶手创建不能在打开的楼梯编辑任务中执行。 由于无法为已具有关联扶手的楼梯创建扶手，因此下面的示例在创建新扶手之前删除与楼梯对象关联的现有扶手。</p>
<p>代码区域：创建扶手</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">CreateRailing</span>(<span class="params">Document document, Stairs stairs</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> (Transaction trans = <span class="keyword">new</span> Transaction(document, <span class="string">&quot;Create Railings&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        trans.Start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Delete existing railings</span></span><br><span class="line">        ICollection railingIds = stairs.GetAssociatedRailings();</span><br><span class="line">        <span class="keyword">foreach</span> (ElementId railingId <span class="keyword">in</span> railingIds)</span><br><span class="line">        &#123;</span><br><span class="line">            document.Delete(railingId);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Find RailingType</span></span><br><span class="line">        FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">        ICollection RailingTypeIds = collector.OfClass(<span class="keyword">typeof</span>(RailingType)).ToElementIds();</span><br><span class="line">        Railing.Create(document, stairs.Id, RailingTypeIds.First(), RailingPlacementPosition.Treads);</span><br><span class="line">        trans.Commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="扶手"><a href="#扶手" class="headerlink" title="扶手"></a>扶手</h2><p>Autodesk.Revit.DB.Architecture.Railing类表示Autodesk Revit项目中的扶手元素。尽管扶手与楼梯关联，但它们也可以与其他主体（如楼板）关联，也可以放置在空间中。扶手可以是连续的或不连续的。如果它们是不连续的，则仅提供有限的访问级别。</p>
<p>可以使用GetAssociatedRailings（）方法从Stairs类中检索与楼梯关联的扶手。只有少数属性和方法专用于栏杆扶手，例如返回顶部栏杆的ElementId的TopRail属性和指示栏杆扶手是否翻转的Flipped属性。Railing.Flip（）方法翻转扶手，而RemoveHost（）方法将删除扶手与其主体之间的关联。</p>
<p>下面的示例检索与Stairs对象关联的所有栏杆扶手，并翻转系统生成的默认栏杆扶手。</p>
<p>代码区域：使用扶手</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">FlipDefaultRailings</span>(<span class="params">Stairs stairs</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ICollection&lt;ElementId&gt; railingIds = stairs.GetAssociatedRailings();</span><br><span class="line">    Transaction trans = <span class="keyword">new</span> Transaction(stairs.Document, <span class="string">&quot;Flip Railings&quot;</span>);</span><br><span class="line">    trans.Start();</span><br><span class="line">    <span class="keyword">foreach</span> (ElementId railingId <span class="keyword">in</span> railingIds)</span><br><span class="line">    &#123;</span><br><span class="line">        Railing railing = stairs.Document.GetElement(railingId) <span class="keyword">as</span> Railing;</span><br><span class="line">        <span class="keyword">if</span> (railing.IsDefault == <span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            railing.Flip();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    trans.Commit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Railing类具有Create方法，该方法可自动在楼梯元素的所有侧面上创建具有指定扶手类型的新扶手。扶手的创建将在“创建和编辑楼梯”部分中进行演示。</p>
<p>RailingType类表示生成扶手时使用的扶手类型。它包含许多关于扶手的属性，例如主扶手和次扶手以及顶部扶手的高度、横向偏移和类型。</p>
<p> 代码区域：RailingType</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">GetRailingType</span>(<span class="params">Stairs stairs</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ICollection&lt;ElementId&gt; railingIds = stairs.GetAssociatedRailings();</span><br><span class="line">    <span class="keyword">foreach</span> (ElementId railingId <span class="keyword">in</span> railingIds)</span><br><span class="line">    &#123;</span><br><span class="line">        Railing railing = stairs.Document.GetElement(railingId) <span class="keyword">as</span> Railing;</span><br><span class="line">        RailingType railingType = stairs.Document.GetElement(railing.GetTypeId()) <span class="keyword">as</span> RailingType;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Format railing type info for display</span></span><br><span class="line">        <span class="built_in">string</span> info = <span class="string">&quot;Railing Type:  &quot;</span> + railingType.Name;</span><br><span class="line">        info += <span class="string">&quot;\nPrimary Handrail Height:  &quot;</span> + railingType.PrimaryHandrailHeight;</span><br><span class="line">        info += <span class="string">&quot;\nTop Rail Height:  &quot;</span> + railingType.TopRailHeight;</span><br><span class="line"></span><br><span class="line">        TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>, info);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="楼梯注释"><a href="#楼梯注释" class="headerlink" title="楼梯注释"></a>楼梯注释</h2><p><strong>楼梯注释</strong></p>
<p>StairsPath类可用于注释楼梯的坡度方向和行走线。静态StairsPath.Create（）方法将在楼梯必须可见的特定平面视图中为具有指定楼梯路径类型的指定楼梯创建新楼梯路径。</p>
<p>在Revit UI中编辑楼梯路径时，StairsPath类具有与“属性”窗口中可用的属性相同的属性，例如设置上下方向文字沿着或是否应显示文字的属性。此外，可以指定上下文字的偏移，也可以指定楼梯路径相对于楼梯中心线的偏移。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/CHS/Revit-API/images/GUID-98F7477B-3F67-4E52-BDC3-6B63ECA6B700.jpg" alt="img"></p>
<p>下面的示例在项目中查找StairsPathType和FloorPlan，并使用它们为给定的Stairs创建新的StairsPath。</p>
<p>代码区域：创建楼梯路径</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">CreateStairsPath</span>(<span class="params">Document document, Stairs stairs</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Transaction transNewPath = <span class="keyword">new</span> Transaction(document, <span class="string">&quot;New Stairs Path&quot;</span>);</span><br><span class="line">    transNewPath.Start();</span><br><span class="line">            </span><br><span class="line">    <span class="comment">// Find StairsPathType</span></span><br><span class="line">    FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">    ICollection&lt;ElementId&gt; stairsPathIds = collector.OfClass(<span class="keyword">typeof</span>(StairsPathType)).ToElementIdsElementId();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find a FloorPlan</span></span><br><span class="line">    ElementId planViewId = ElementId.InvalidElementId;</span><br><span class="line">    FilteredElementCollector viewCollector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">    ICollection&lt;ElementId&gt; viewIds = viewCollector.OfClass(<span class="keyword">typeof</span>(View)).ToElementIdsElementId();</span><br><span class="line">    <span class="keyword">foreach</span> (ElementId viewId <span class="keyword">in</span> viewIds)</span><br><span class="line">    &#123;</span><br><span class="line">        View view = document.GetElement(viewId) <span class="keyword">as</span> View;</span><br><span class="line">        <span class="keyword">if</span> (view.ViewType == ViewType.FloorPlan)</span><br><span class="line">        &#123;</span><br><span class="line">            planViewId = view.Id;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">            </span><br><span class="line">    LinkElementId stairsLinkId = <span class="keyword">new</span> LinkElementId(stairs.Id);</span><br><span class="line">    StairsPath.Create(stairs.Document, stairsLinkId, stairsPathIds.First(), planViewId);</span><br><span class="line">    transNewPath.Commit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>StairsPath具有StairsPathType。楼梯路径类型可从两个预定义的系统族中获得：“自动向上&#x2F;向下方向”和“固定向上方向”。可用于这两种类型的属性作为StairsPathType类中的属性提供，例如FullStepArrow和DistanceToCutMark。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/CHS/Revit-API/images/GUID-21CCA05E-3A7C-4CA3-AF96-8BBB88F775E7.jpg" alt="img"></p>
<p>CutMarkType类表示Revit UI中的剪切标记类型，它具有表示在UI中编辑剪切标记类型时可用的相同属性的属性，例如CutLineAngle和CutLineExtension。它与StairsType对象相关联，可以使用BuiltInParameter STAIRSTYPE_CUTMARK_TYPE进行检索，如下所示。</p>
<p>代码区域：获取楼梯的CutMarkType</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> CutMarkType <span class="title">GetCutMark</span>(<span class="params">Stairs stairs</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    CutMarkType cutMarkType = <span class="literal">null</span>;</span><br><span class="line">    StairsType stairsType = stairs.Document.GetElement(stairs.GetTypeId()) <span class="keyword">as</span> StairsType;</span><br><span class="line">    Parameter paramCutMark = stairsType.get_Parameter(BuiltInParameter.STAIRSTYPE_CUTMARK_TYPE);</span><br><span class="line">    <span class="keyword">if</span> (paramCutMark.StorageType == StorageType.ElementId)  <span class="comment">// should be an element id</span></span><br><span class="line">    &#123;</span><br><span class="line">        ElementId cutMarkId = paramCutMark.AsElementId();</span><br><span class="line">        cutMarkType = stairs.Document.GetElement(cutMarkId) <span class="keyword">as</span> CutMarkType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cutMarkType;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="楼梯构件"><a href="#楼梯构件" class="headerlink" title="楼梯构件"></a>楼梯构件</h2><p><strong>楼梯构件</strong></p>
<p>Stairs类表示Revit中的楼梯图元，并包含表示有关踏步、高度、楼层数以及楼梯高度、底部标高和顶部标高的信息的属性。Stairs类的方法可用于获取楼梯平台构件、楼梯梯段构件和楼梯支撑。</p>
<p>下面的示例按构件查找所有楼梯，并将有关每个楼梯的一些信息输出到TaskDialog对话框。请注意，此示例使用带有BuiltInCategory.OST_Stairs的类别过滤器，该过滤器将返回所有楼梯的ElementId，因此在从文档中检索时将每个ElementId转换为Stairs类之前，需要进行测试以查看每个ElementId是否代表Stairs By Component。</p>
<p>代码区域：获取楼梯信息</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Stairs <span class="title">GetStairInfo</span>(<span class="params">Document document</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Stairs stairs = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">    ICollection&lt;ElementId&gt; stairsIds = collector.WhereElementIsNotElementType().OfCategory(BuiltInCategory.OST_Stairs).ToElementIdsElementId();</span><br><span class="line">    <span class="keyword">foreach</span> (ElementId stairId <span class="keyword">in</span> stairsIds)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (Stairs.IsByComponent(document, stairId) == <span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            stairs = document.GetElement(stairId) <span class="keyword">as</span> Stairs;</span><br><span class="line">                   </span><br><span class="line">            <span class="comment">// Format the information</span></span><br><span class="line">            String info = <span class="string">&quot;\nNumber of stories:  &quot;</span> + stairs.NumberOfStories;</span><br><span class="line">            info += <span class="string">&quot;\nHeight of stairs:  &quot;</span> + stairs.Height;</span><br><span class="line">            info += <span class="string">&quot;\nNumber of treads:  &quot;</span> + stairs.ActualTreadsNumber;</span><br><span class="line">            info += <span class="string">&quot;\nTread depth:  &quot;</span> + stairs.ActualTreadDepth;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// Show the information to the user.</span></span><br><span class="line">            TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>, info);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> stairs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>StairsType类表示Stairs元素的类型。它包含有关楼梯的信息，例如楼梯对象中所有梯段和平台的类型、楼梯左侧、右侧和中间支撑的类型和偏移，以及与楼梯生成相关的许多其他特性，例如楼梯图元上每个踢面的最大高度。下面的示例获取Stairs元素的StairsType，并在TaskDialog中显示有关该元素的一些信息。</p>
<p>代码区域：获取楼梯类型信息</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">GetStairsType</span>(<span class="params">Stairs stairs</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    StairsType stairsType = stairs.Document.GetElement(stairs.GetTypeId()) <span class="keyword">as</span> StairsType;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Format stairs type info for display</span></span><br><span class="line">    <span class="built_in">string</span> info = <span class="string">&quot;Stairs Type:  &quot;</span> + stairsType.Name;</span><br><span class="line">    info += <span class="string">&quot;\nLeft Lateral Offset:  &quot;</span> + stairsType.LeftLateralOffset;</span><br><span class="line">    info += <span class="string">&quot;\nRight Lateral Offset:  &quot;</span> + stairsType.RightLateralOffset;</span><br><span class="line">    info += <span class="string">&quot;\nMax Riser Height:  &quot;</span> + stairsType.MaxRiserHeight;</span><br><span class="line">    info += <span class="string">&quot;\nMin Run Width:  &quot;</span> + stairsType.MinRunWidth;</span><br><span class="line"></span><br><span class="line">    TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>, info);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>梯段</strong></p>
<p>楼梯构件由梯段、平台和支撑组成。这些项中的每一项都可以从Stairs类中检索。梯段在Revit API中由StairsRun类表示。下面的示例获取Stairs对象的每个梯段，并确保它以踢面开始和结束。</p>
<p>代码区域：使用StairsRun</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">AddStartandEndRisers</span>(<span class="params">Stairs stairs</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ICollection&lt;ElementId&gt; runIds = stairs.GetStairsRuns();</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">foreach</span> (ElementId runId <span class="keyword">in</span> runIds)</span><br><span class="line">    &#123;</span><br><span class="line">        StairsRun run = stairs.Document.GetElement(runId) <span class="keyword">as</span> StairsRun;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != run)</span><br><span class="line">        &#123;</span><br><span class="line">            run.BeginsWithRiser = <span class="literal">true</span>;</span><br><span class="line">            run.EndsWithRiser = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>StairsRun类提供对梯段属性的访问，例如StairsRunStyle（直线、斜梯等），BaseElevation、TopElevation和有关高程的属性。StairsRun类中还有一些方法可用于访问梯段承载的支撑，可以是全部支撑，也可以仅是梯段边界左侧或右侧的支撑。GetStairsPath（）方法将返回表示梯段上楼梯路径的曲线，这些曲线将投影到楼梯的底部标高上。GetFootprintBoundary（）方法返回梯段的边界曲线，这些曲线也投影到楼梯的底部标高上。</p>
<p>StairsRun类有三个用于创建新梯段的静态方法。这些将在“创建和编辑楼梯”部分中介绍。</p>
<p>StairsRunType类表示StairsRun的类型。它包含有关梯段踏板和宽度的许多特性以及有关梯段的其他信息。下面的示例获取Stairs元素中第一个梯段的StairsRunType，并显示踢面和踏步厚度沿着以及类型名称。</p>
<p>代码区域：获取StairsRunType信息</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">GetRunType</span>(<span class="params">Stairs stairs</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ICollection&lt;ElementId&gt; runIds = stairs.GetStairsRuns();</span><br><span class="line"></span><br><span class="line">    ElementId firstRunId = runIds.First();</span><br><span class="line"></span><br><span class="line">    StairsRun firstRun = stairs.Document.GetElement(firstRunId) <span class="keyword">as</span> StairsRun;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> != firstRun)</span><br><span class="line">    &#123;</span><br><span class="line">        StairsRunType runType = stairs.Document.GetElement(firstRun.GetTypeId()) <span class="keyword">as</span> StairsRunType;</span><br><span class="line">        <span class="comment">// Format landing type info for display</span></span><br><span class="line">        <span class="built_in">string</span> info = <span class="string">&quot;Stairs Run Type:  &quot;</span> + runType.Name;</span><br><span class="line">        info += <span class="string">&quot;\nRiser Thickness:  &quot;</span> + runType.RiserThickness;</span><br><span class="line">        info += <span class="string">&quot;\nTread Thickness:  &quot;</span> + runType.TreadThickness;</span><br><span class="line"></span><br><span class="line">        TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>, info);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>平台</strong></p>
<p>平台由StairsLanding类表示。下面的示例查找Stairs对象的每个平台的厚度。</p>
<p>代码区域：使用楼梯平台</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">GetStairLandings</span>(<span class="params">Stairs stairs</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ICollection&lt;ElementId&gt; landingIds = stairs.GetStairsLandings();</span><br><span class="line">    <span class="built_in">string</span> info = <span class="string">&quot;Number of landings:  &quot;</span> + landingIds.Count;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> landingIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">foreach</span> (ElementId landingId <span class="keyword">in</span> landingIds)</span><br><span class="line">    &#123;</span><br><span class="line">        landingIndex++;</span><br><span class="line">        StairsLanding landing = stairs.Document.GetElement(landingId) <span class="keyword">as</span> StairsLanding;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != landing)</span><br><span class="line">        &#123;</span><br><span class="line">            info += <span class="string">&quot;\nThickness of Landing &quot;</span> + landingIndex + <span class="string">&quot;:  &quot;</span> + landing.Thickness;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>, info);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与StairsRun类似，StairsLanding具有GetStairsPath（）方法和GetFootprintBoundary（）方法，前者返回表示平台上投影到楼梯基层的楼梯路径的曲线，后者返回平台的边界曲线，也投影到楼梯基层。同样类似于StairsRun，有一种方法可以获取平台承载的所有支撑。</p>
<p>StairsLanding类有一个在两个梯段之间创建新平台的方法。它将在“创建和编辑楼梯”部分中介绍。</p>
<p>StairsLandingType类表示Revit API中的平台类型。StairsLandingType类只有两个特定于它的属性，即IsMonolithic（如果楼梯平台是整体的，则为真）和Thickness（表示楼梯平台的厚度）。</p>
<p><strong>楼梯连接</strong><br>Both StairsRun and StairsLanding have a GetConnections() method which provides information about connections among stairs components (run to run, or run to landing). The method returns a collection of StairsComponentConnection objects which have properties about each connection, including the connection type (to a landing, the start of a stairs run, or the end of a stairs run) and the Id of the connected stairs component.<br>StairsRun和StairsLanding都具有GetConnections（）方法，该方法提供有关楼梯构件之间连接的信息（梯段到梯段，或梯段到平台）。该方法返回一个StairsStringentConnection对象的集合，这些对象具有关于每个连接的属性，包括连接类型（连接平台、楼梯梯段起点或楼梯梯段终点）和连接的楼梯构件的ID。</p>
<p><strong>支撑</strong></p>
<p>Revit API不显示楼梯支撑类。获取楼梯、楼梯梯段或楼梯平台的支撑时，支撑将为常规Revit图元。下面的示例获取Stairs对象的所有支撑的名称。</p>
<p>代码区域：获取楼梯支撑</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">GetStairSupports</span>(<span class="params">Stairs stairs</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ICollection&lt;ElementId&gt; supportIds = stairs.GetStairsSupports();</span><br><span class="line">    <span class="built_in">string</span> info = <span class="string">&quot;Number of supports:  &quot;</span> + supportIds.Count;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> supportIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">foreach</span> (ElementId supportId <span class="keyword">in</span> supportIds)</span><br><span class="line">    &#123;</span><br><span class="line">        supportIndex++;</span><br><span class="line">        Element support = stairs.Document.GetElement(supportId);</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != support)</span><br><span class="line">        &#123;</span><br><span class="line">            info += <span class="string">&quot;\nName of support &quot;</span> + supportIndex + <span class="string">&quot;:  &quot;</span> + support.Name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>, info);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="注：翻译自Revit-API-Developers-Guide"><a href="#注：翻译自Revit-API-Developers-Guide" class="headerlink" title="注：翻译自Revit API Developers Guide"></a><em><strong>注：</strong></em>翻译自<a href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_html">Revit API Developers Guide</a></h2>]]></content>
      <categories>
        <category>Revit二次开发人员指南</category>
      </categories>
      <tags>
        <tag>Revit</tag>
      </tags>
  </entry>
  <entry>
    <title>20材料</title>
    <url>/2024/12/15/%E4%BA%8C%E5%BC%80%E6%8C%87%E5%8D%97/20%E6%9D%90%E6%96%99/</url>
    <content><![CDATA[<h1 id="材质"><a href="#材质" class="headerlink" title="材质"></a><a href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_Revit_Geometric_Elements_Material_html">材质</a></h1><p>在Revit Platform API中，材质数据作为图元进行存储和管理。就像在Revit UI中一样，材质可以有多个与之关联的资源，但只能使用API指定热学和结构（在Revit UI中称为物理）资源。</p>
<p>某些材质特征由材质类本身的属性（例如FillPattern、Color或Render）表示，而其他材质特征则可用作与材质关联的结构资源或热资源的属性。</p>
<p>在本章中，您将学习如何访问Material元素以及如何管理文档中的Material对象。“元素材质”提供了一个演练，演示如何获取窗材质。</p>
<p>本节中的页面</p>
<ul>
<li>一般材质信息</li>
<li>材质管理</li>
<li>元素材质</li>
<li>材质数量</li>
<li>绘制元素的表面</li>
</ul>
<h2 id="一般材质信息"><a href="#一般材质信息" class="headerlink" title="一般材质信息"></a>一般材质信息</h2><p>在开始演练之前，请通读以下部分以更好地理解Material类。</p>
<p>所有材质对象都可以使用材质类过滤器进行检索。材质对象也可在文档、类别、元素、面等中使用，并在本章的相关部分中进行讨论。无论你在哪里得到一个材质对象，它都被表示为Material类。</p>
<p><strong>属性</strong></p>
<p>材质将具有与渲染外观、结构或其他主要材质类别相关的一个或多个方面。每个方面都由Material类本身的属性或通过其结构或热资产之一表示。StructuralAsset类表示与结构分析相关的材料属性。ThermalAsset类表示与能量分析相关的材料属性。</p>
<p>代码区域19-3：获取材料属性</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ReadMaterialProps</span>(<span class="params">Document document, Material material</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ElementId strucAssetId = material.StructuralAssetId;</span><br><span class="line">    <span class="keyword">if</span> (strucAssetId != ElementId.InvalidElementId)</span><br><span class="line">    &#123;</span><br><span class="line">        PropertySetElement pse = document.GetElement(strucAssetId) asPropertySetElement;</span><br><span class="line">        <span class="keyword">if</span> (pse != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            StructuralAsset asset = pse.GetStructuralAsset();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Check the material behavior and only read if Isotropic</span></span><br><span class="line">            <span class="keyword">if</span> (asset.Behavior == StructuralBehavior.Isotropic)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// Get the class of material</span></span><br><span class="line">                StructuralAssetClass assetClass = asset.StructuralAssetClass; <span class="comment">// Get other material properties</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// Get other material properties</span></span><br><span class="line">                <span class="built_in">double</span> poisson = asset.PoissonRatio.X;</span><br><span class="line">                <span class="built_in">double</span> youngMod = asset.YoungModulus.X;</span><br><span class="line">                <span class="built_in">double</span> thermCoeff = asset.ThermalExpansionCoefficient.X;</span><br><span class="line">                <span class="built_in">double</span> unitweight = asset.Density;</span><br><span class="line">                <span class="built_in">double</span> shearMod = asset.ShearModulus.X;</span><br><span class="line">                <span class="built_in">double</span> dampingRatio = asset.DampingRatio;</span><br><span class="line">                <span class="keyword">if</span> (assetClass == StructuralAssetClass.Metal)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">double</span> dMinStress = asset.MinimumYieldStress;</span><br><span class="line">                &#125;</span><br><span class="line">                elseif (assetClass == StructuralAssetClass.Concrete)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">double</span> dConcComp = asset.ConcreteCompression;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Classification</strong> </p>
<p>与结构分析相关的材料分类（即钢、混凝土、木材）可以从与材料关联的StructuralAsset的StructuralAssetClass属性中获得。</p>
<p>注意：API不提供对混凝土材料的混凝土类型值的访问。</p>
<p>与能量分析相关的材料分类（即固体、液体、气体）可以从与材料关联的ThermalAsset的ThermalMaterialType属性中获得。</p>
<p><strong>其它性质</strong></p>
<p>材质对象属性标识特定类型的材质，包括颜色、填充图案等。</p>
<p>属性和参数</p>
<p>某些“材质”属性只能作为“参数”使用。有一些，如颜色，可作为属性或作为参数使用内置参数MATERIAL_PARAM_COLOR。</p>
<p>渲染信息</p>
<p>渲染数据的集合被组织到称为资源的对象中，这些对象是只读的。您可以从Application.Assets属性获取所有可用的与外观相关的资产。可以通过Material.AppearanceAssetId属性从材质访问外观资源。</p>
<p>下图显示了“资源浏览器”对话框的“外观库”部分，其中显示了某些渲染资源在UI中的显示方式。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/AssetBrowser.jpg"></p>
<p>图106：外观库</p>
<p>SDK附带的Materials示例应用程序显示了如何将RenderApperance属性设置为对话框中选定的材质。该对话框将填充Application.Assets中的所有Asset对象。</p>
<p>填充模式</p>
<p>文档中的所有FillPatterns都可以使用FilteredElementCollector过滤类FillPatternElement。FillPatternElement是包含FillPattern的元素，而FillPattern类提供对模式名称和组成模式的FillGrid集的访问。</p>
<p>FillPatterns有两种：Drafting和Model。在UI中，只能将“绘图”填充样式设置为Material.CutPatternId。填充图案类型通过FillPattern.Target属性公开。下面的示例显示如何更改材质FillPattern。</p>
<p>代码区域19-4：设置填充图案</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetFillPattern</span>(<span class="params">Document document, Material material</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">    ICollection fillPatternElements = collector.OfClass(<span class="keyword">typeof</span>(FillPatternElement)).ToElementIds();</span><br><span class="line">    <span class="keyword">foreach</span> (ElementId fillPatternId <span class="keyword">in</span> fillPatternElements)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// always set successfully</span></span><br><span class="line">        material.CutPatternId = fillPatternId;</span><br><span class="line">        material.SurfacePatternId = fillPatternId;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="材质管理"><a href="#材质管理" class="headerlink" title="材质管理"></a>材质管理</h2><p>您可以使用过滤来检索文档中的所有材料。文档中的每个Material对象都由唯一的名称标识。</p>
<p>以下示例说明如何使用材质名称获取材质。</p>
<p>代码区域19-5：按名称获取材质</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">FilteredElementCollector elementCollector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">elementCollector.WherePasses(<span class="keyword">new</span> ElementClassFilter(<span class="keyword">typeof</span>(Material)));</span><br><span class="line">IList materials = elementCollector.ToElements();</span><br><span class="line"></span><br><span class="line">Material floorMaterial = <span class="literal">null</span>;</span><br><span class="line"><span class="built_in">string</span> floorMaterialName = <span class="string">&quot;Default Floor&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> (Element materialElement <span class="keyword">in</span> materials)</span><br><span class="line">&#123;</span><br><span class="line">    Material material = materialElement <span class="keyword">as</span> Material;</span><br><span class="line">    <span class="keyword">if</span> (floorMaterialName == material.Name)</span><br><span class="line">    &#123;</span><br><span class="line">        floorMaterial = material;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">null</span> != floorMaterial)</span><br><span class="line">&#123;</span><br><span class="line">    TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>,<span class="string">&quot;Material found.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：要运行示例代码，请确保文档中存在材质名称。当前文档的所有材质名称都位于“管理”选项卡（“项目设置”面板  Materials）下。</p>
<p>创建材质</p>
<p>有两种方法可以在API中创建新的Material对象。</p>
<ul>
<li>复制现有材质</li>
<li>添加新材质。</li>
</ul>
<p>使用Duplicate（）方法时，返回的Material对象与原始对象的类型相同。</p>
<p>代码区域19-6：复制材料</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="built_in">bool</span> <span class="title">DuplicateMaterial</span>(<span class="params">Material material</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="built_in">bool</span> duplicated = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//try to duplicate a new instance of Material class using duplicate method</span></span><br><span class="line">        <span class="comment">//make sure the name of new material is unique in MaterailSet</span></span><br><span class="line">        <span class="built_in">string</span> newName = <span class="string">&quot;new&quot;</span> + material.Name;</span><br><span class="line">        Material myMaterial = material.Duplicate(newName);</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == myMaterial)</span><br><span class="line">        &#123;</span><br><span class="line">                TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>, <span class="string">&quot;Failed to duplicate a material!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">                duplicated = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> duplicated;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用静态方法Material.Create（）直接添加新Material。无论如何应用，都必须为材质和属于该材质的任何资产指定唯一的名称。唯一名称是“材质”对象键。</p>
<p>代码区域19-7：添加新材质</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Create the material</span></span><br><span class="line">ElementId materialId = Material.Create(document, <span class="string">&quot;My Material&quot;</span>);</span><br><span class="line">Material material = document.GetElement(materialId) <span class="keyword">as</span> Material;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Create a new property set that can be used by this material</span></span><br><span class="line">StructuralAsset strucAsset = <span class="keyword">new</span> StructuralAsset(<span class="string">&quot;My Property Set&quot;</span>, StructuralAssetClass.Concrete);</span><br><span class="line">strucAsset.Behavior = StructuralBehavior.Isotropic;</span><br><span class="line">strucAsset.Density = <span class="number">232.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Assign the property set to the material.</span></span><br><span class="line">PropertySetElement pse = PropertySetElement.Create(document, strucAsset);</span><br><span class="line">material.SetMaterialAspectByPropertySet(MaterialAspect.Structural, pse.Id);</span><br></pre></td></tr></table></figure>

<p>删除材质</p>
<p>要删除材料，用：</p>
<ul>
<li>Document.Delete()</li>
</ul>
<p>Document.Delete() 是一个泛型方法。有关详细信息，请参见编辑元素。</p>
<h2 id="元素材质"><a href="#元素材质" class="headerlink" title="元素材质"></a>元素材质</h2><p>一个元素可以有多个元素和组件。例如，FamilyInstance具有SubComponents，Wall具有CompoundStructure，其中包含多个CompoundStructureLayers。(有关“子构件”的详细信息，请参阅“族”部分，有关“复合结构”的详细信息，请参阅“墙、楼板、屋顶和洞口”。）</p>
<p>在Revit Platform API中，使用以下准则获取图元的材质：</p>
<ul>
<li>如果元素包含元素，则单独获取材料。</li>
<li>如果图元包含构件，请从参数或以特定方式获取每个构件的材质（请参见墙、楼板、屋顶和洞口中的“材质”部分）。</li>
<li>如果构件的材质返回null，则从相应的Element.Category子类别中获取物料。</li>
</ul>
<p><strong>参数中的材质</strong></p>
<p>如果Element对象有一个参数，其中的参数类型是参数类型.材料，您可以从参数中获取元素材料。例如，结构柱FamilySymbol（类别为BuiltInCategory.OST_StructuralColumns的FamilyInstance）具有“结构材质”参数。使用ElementId获取材质。下面的代码示例阐释如何获取具有一个构件的结构柱Material。</p>
<p>代码区域：从参数获取元素材质</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetMaterial</span>(<span class="params">Document document, FamilyInstance familyInstance</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">foreach</span> (Parameter parameter <span class="keyword">in</span> familyInstance.Parameters)</span><br><span class="line">    &#123;</span><br><span class="line">        Definition definition = parameter.Definition;</span><br><span class="line">        <span class="comment">// material is stored as element id</span></span><br><span class="line">        <span class="keyword">if</span> (parameter.StorageType == StorageType.ElementId)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (definition.ParameterGroup == BuiltInParameterGroup.PG_MATERIALS &amp;&amp;</span><br><span class="line">                    definition.ParameterType == ParameterType.Material)</span><br><span class="line">            &#123;</span><br><span class="line">                Autodesk.Revit.DB.Material material = <span class="literal">null</span>;</span><br><span class="line">                Autodesk.Revit.DB.ElementId materialId = parameter.AsElementId();</span><br><span class="line">                <span class="keyword">if</span> (<span class="number">-1</span> == materialId.IntegerValue)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//Invalid ElementId, assume the material is &quot;By Category&quot;</span></span><br><span class="line">                    <span class="keyword">if</span> (<span class="literal">null</span> != familyInstance.Category)</span><br><span class="line">                    &#123;</span><br><span class="line">                        material = familyInstance.Category.Material;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    material = document.GetElement(materialId) <span class="keyword">as</span> Material;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>,<span class="string">&quot;Element material: &quot;</span> + material.Name);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>如果在UI中将材质属性设置为“按类别”，则材质的ElementId为ElementId.InvalidElementId，并且不能用于检索Material对象，如示例代码中所示。尝试从类别中检索材质，如下一节所述。 其他化合物参数中包含的某些材质特性无法从API访问。例如，在下图中，对于“系统族：栏杆扶手”，“栏杆结构”参数的“栏杆类型”为“栏杆类型.无”。因此，在这种情况下，您无法获得实质性信息。<img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/ByCategory.jpg"></p>
<p>图107：扶手结构属性</p>
<p> Material和FamilyInstance 梁族、柱族和基础族有另一种使用其StructuralMaterialId属性获取其材质的方法。此属性返回一个ElementId，用于标识定义实例的结构分析属性的材质。</p>
<p>代码区域：从族实例获取图元材质</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Material <span class="title">GetFamilyInstanceMaterial</span>(<span class="params">Document document, FamilyInstance beam</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Material material = document.GetElement(beam.StructuralMaterialId) <span class="keyword">as</span> Material;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> material;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>材质和类别</strong></p>
<p>只有模型图元可以具有材质。</p>
<p>从Revit的“管理”选项卡中，单击“设置” <img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/ac.menuaro.gif" alt="img"> “对象样式”以显示“对象样式”对话框。类别列在“模型对象”（Model Objects)选项卡中的图元具有材质信息。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/ModelObjectsMaterial.jpg" alt="img"></p>
<p>图108：材质分类</p>
<p>只有模型元素可以指定“材质”属性。因此，查询与Model元素（例如，Annotations或Imported）以外的元素相对应的类别的Material将始终导致null。有关元素和类别分类的更多详细信息，请参阅元素要素。</p>
<p>如果一个元素有多个组件，则某些类别.子类别对应于这些组件。</p>
<p>在上一个“对象样式”对话框中，“窗类别”和“框架&#x2F;竖梃”子类别以及“玻璃”子类别将映射到windows元素中的构件。在下图中，似乎窗符号Glass材质参数是获取窗玻璃材质的唯一方法。但是，该值为“按类别”，相应的参数返回ElementId. InvalidElementId。</p>
<p>在这种情况下，窗户的Material不为null，它取决于Category OST_WindowsFrameMullionProjection的Material属性，该属性是窗口类别OST_Windows的子类别。如果它也返回null，则窗格的Material由父类别OST_Windows确定。有关更多详细信息，请参阅元素材质。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-4E345BF1-1837-41C7-BF9C-A89A1A76539F-low.png"></p>
<p>图109：窗户材料</p>
<p><strong>复合结构层材料</strong></p>
<p>可以从HostObjAttributes获取CompoundStructureLayer对象。有关详细信息，请参阅墙、地板、天花板、屋顶和洞口。</p>
<p><strong>电子元件材料</strong></p>
<p>下图显示了检索元素材质的工作流：</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-64D41480-87CE-454E-8B14-1EFEFEC8BF09-low.png"></p>
<p>图110：获取元素材质工作流</p>
<p>此工作流说明了以下过程：</p>
<ul>
<li>该工作流显示了如何获取属于图元的Material对象（而不是Autodesk.Revit.DB.Structure.StructuralMaterialType枚举类型）。</li>
<li>检索材质时有两种要素分类：<ul>
<li>HostObject with CompoundStructure -从CompoundStructureLayer类MaterialId属性获取Material对象。</li>
<li>其他-从参数中获取材质。</li>
</ul>
</li>
<li>当您获得空Material对象或值为ElementId.InvalidElementId的无效ElementId时，请尝试相应类别中的Material。请注意，FamilyInstance及其FamilySymbol通常具有相同的类别。</li>
<li>对Element对象了解得越多，获取材质就越容易。举例来说：<ul>
<li>如果知道元素是梁，则可以获取实例参数Structural Material</li>
<li>如果知道该元素是一个窗口，则可以将其强制转换为FamilyInstance并获取FamilySymbol。</li>
</ul>
</li>
<li>之后，您可以获得参数，如框架外部材料或框架内部材料，以获得材料对象。如果你得到null，尝试从FamilySymbol类别中获取Material对象。</li>
<li>API中并非所有元素材质都可用。</li>
</ul>
<p><strong>演练：获取窗户材质</strong></p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetMaterial</span>(<span class="params">Document document, FamilyInstance window</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    FamilySymbol windowSymbol = window.Symbol;</span><br><span class="line">    Category category = windowSymbol.Category;</span><br><span class="line">    Autodesk.Revit.DB.Material frameExteriorMaterial = <span class="literal">null</span>;</span><br><span class="line">    Autodesk.Revit.DB.Material frameInteriorMaterial = <span class="literal">null</span>;</span><br><span class="line">    Autodesk.Revit.DB.Material sashMaterial = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// Check the parameters first</span></span><br><span class="line">    <span class="keyword">foreach</span> (Parameter parameter <span class="keyword">in</span> windowSymbol.Parameters)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span> (parameter.Definition.Name)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;Frame Exterior Material&quot;</span>:</span><br><span class="line">                frameExteriorMaterial = document.GetElement(parameter.AsElementId()) <span class="keyword">as</span> Material;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;Frame Interior Material&quot;</span>:</span><br><span class="line">                frameInteriorMaterial = document.GetElement(parameter.AsElementId()) <span class="keyword">as</span> Material;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;Sash&quot;</span>:</span><br><span class="line">                sashMaterial = document.GetElement(parameter.AsElementId()) <span class="keyword">as</span> Material;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="literal">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Try category if the material is set by category</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> == frameExteriorMaterial)</span><br><span class="line">        frameExteriorMaterial = category.Material;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> == frameInteriorMaterial)</span><br><span class="line">        frameInteriorMaterial = category.Material;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> == sashMaterial)</span><br><span class="line">        sashMaterial = category.Material;</span><br><span class="line">    <span class="comment">// Show the result because the category may have a null Material,</span></span><br><span class="line">    <span class="comment">// the Material objects need to be checked.</span></span><br><span class="line">    <span class="built_in">string</span> materialsInfo = <span class="string">&quot;Frame Exterior Material: &quot;</span> + (<span class="literal">null</span> != frameExteriorMaterial ? frameExteriorMaterial.Name : <span class="string">&quot;null&quot;</span>) + <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    materialsInfo += <span class="string">&quot;Frame Interior Material: &quot;</span> + (<span class="literal">null</span> != frameInteriorMaterial ? frameInteriorMaterial.Name : <span class="string">&quot;null&quot;</span>) + <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    materialsInfo += <span class="string">&quot;Sash: &quot;</span> + (<span class="literal">null</span> != sashMaterial ? sashMaterial.Name : <span class="string">&quot;null&quot;</span>) + <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>,materialsInfo);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h2 id="材质数量"><a href="#材质数量" class="headerlink" title="材质数量"></a>材质数量</h2><p>有一些方法可以直接获取Revit为材质提取明细表计算的材质体积和面积：</p>
<ul>
<li>Element.GetMaterialIds() –获取元素中的材料列表</li>
<li>Element.GetMaterialVolume() – 获取元素中特定材料的体积</li>
<li>Element.GetMaterialArea() – 获取元素中特定材质的面积</li>
</ul>
<p>这些方法适用于其中Category. HasMaterialList属性为true的元素类别。实际上，这仅限于使用复合结构的图元（如墙、屋顶、楼板、天花板）、其他一些基本三维图元（如楼梯）以及可以将材质指定给族几何图形的三维族（如窗、门、柱、MEP设备和装置以及常规模型族）。请注意，在这些类别中，对于如何提取材料数量有进一步的限制。例如，幕墙和幕墙屋顶本身不会报告任何材质数量;这些构件使用的材质可以从组成幕墙系统的各个嵌板图元中提取。</p>
<p>请注意，在某些情况下，Revit计算的体积和面积可能是近似值。例如，对于墙内的各个层，模型中可见的体积与材质提取明细表中显示的体积之间可能会出现微小的差异。使用墙饰条工具向墙添加饰条或分隔缝时，或在某些连接条件下，往往会出现这些差异。</p>
<p>SDK示例“MaterialTools”结合了材质数量提取工具和剪切元素（洞口、窗和门）的临时抑制，以提取总材质数量和净材质数量。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/material_quantities.png"></p>
<h2 id="绘制元素的表面"><a href="#绘制元素的表面" class="headerlink" title="绘制元素的表面"></a>绘制元素的表面</h2><p>绘制工具功能可通过Revit API使用。可以使用材质绘制墙、楼板和屋顶等图元的面以更改其外观。它不会改变元素的结构。</p>
<p>与绘制元素相关的方法是Document类的一部分。Paint（）将材质应用于元素的指定面。Document.RemovePaint（）将移除应用的材质。此外，IsPainted（）和GetPaintedMaterial（）方法返回有关元素表面的信息。</p>
<p>代码区域：绘制墙面</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Paint any unpainted faces of a given wall</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PaintWallFaces</span>(<span class="params">Wall wall, ElementId matId</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Document doc = wall.Document;</span><br><span class="line">    GeometryElement geometryElement = wall.get_Geometry(<span class="keyword">new</span> Options());</span><br><span class="line">    <span class="keyword">foreach</span> (GeometryObject geometryObject <span class="keyword">in</span> geometryElement)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (geometryObject <span class="keyword">is</span> Solid)</span><br><span class="line">        &#123;</span><br><span class="line">            Solid solid = geometryObject <span class="keyword">as</span> Solid;</span><br><span class="line">            <span class="keyword">foreach</span> (Face face <span class="keyword">in</span> solid.Faces)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (doc.IsPainted(wall.Id, face) == <span class="literal">false</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    doc.Paint(wall.Id, face, matId);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="注：翻译自Revit-API-Developers-Guide"><a href="#注：翻译自Revit-API-Developers-Guide" class="headerlink" title="注：翻译自Revit API Developers Guide"></a><em><strong>注：</strong></em>翻译自<a href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_html">Revit API Developers Guide</a></h2>]]></content>
      <categories>
        <category>Revit二次开发人员指南</category>
      </categories>
      <tags>
        <tag>Revit</tag>
      </tags>
  </entry>
  <entry>
    <title>19草图</title>
    <url>/2024/12/15/%E4%BA%8C%E5%BC%80%E6%8C%87%E5%8D%97/19%E8%8D%89%E5%9B%BE/</url>
    <content><![CDATA[<h1 id="草图"><a href="#草图" class="headerlink" title="草图"></a><a href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_Revit_Geometric_Elements_Sketching_html">草图</a></h1><p>要在Revit中创建图元或编辑其轮廓，必须先创建草图对象。需要绘制草图的图元示例包括：</p>
<ul>
<li>Roofs 屋顶</li>
<li>Floors 地板</li>
<li>Stairs 楼梯</li>
<li>Railings 栏杆</li>
</ul>
<p>还需要草图来定义其他类型的几何图形，例如：</p>
<ul>
<li>Extrusions 拉伸</li>
<li>Openings 开口</li>
<li>Regions 区域</li>
</ul>
<p>在Revit Platform API中，草图函数由二维和三维草图类表示，如下所示：</p>
<ul>
<li>二维Sketch：<ul>
<li>SketchPlane 草图平面</li>
<li>Sketch 草图</li>
<li>ModelCurve 模型线</li>
<li>and more</li>
</ul>
</li>
<li>三维Sketch：<ul>
<li>GenericForm 通用形状</li>
<li>Path3D 3D路径</li>
</ul>
</li>
</ul>
<p>除了草图元素外，本章还介绍了ModelCurve。有关元素分类的详细信息，请参阅元素部分中的元素分类。</p>
<p> 本节中的页面</p>
<ul>
<li>2DSketch类</li>
<li>3DSketch</li>
<li>模型线</li>
</ul>
<h2 id="2D-Sketch类"><a href="#2D-Sketch类" class="headerlink" title="2D Sketch类"></a>2D Sketch类</h2><p>Sketch类表示用于创建3D模型的平面中的封闭曲线。关键功能由SketchPlane和CurveLoop属性表示。</p>
<p>编辑Revit文件时，无法通过迭代Document.Elements枚举来检索Sketch对象，因为所有Sketch对象都是瞬态Elements。访问族的三维建模信息时，草图对象对于形成几何图形非常重要。有关更多详细信息，请参见3D草图。</p>
<p>SketchPlane是所有2D草图类（如ModelCurve和Sketch）的基础。SketchPlane也是DetailCurve等2D注释元素的基础。ModelCurve和DetailCurve都具有SketchPlane属性，并且在相应的创建方法中需要SketchPlane。SketchPlane在Revit UI中始终不可见。</p>
<p>每个ModelCurve必须位于一个SketchPlane中。换句话说，无论您在UI中还是通过使用API绘制ModelCurve，都必须存在SketchPlane。因此，在绘制ModelCurve的二维视图中至少存在一个SketchPlane。</p>
<p>二维视图包含CeilingPlan、FloorPlan和Elevation ViewTypes。默认情况下，会自动为所有这些视图创建“草绘平面”（SketchPlane）。与二维视图相关的SketchPlane Name返回视图名称，例如Level 1或North。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-9B03E831-1E6C-4CE2-9149-3F7B309A5B5D-low.png"></p>
<p>图77：拾取平面以标识新的工作平面</p>
<p>指定新工作平面时，可以选择“拾取平面”，如上图所示。拾取平面后，选择特定图元（如墙）上的平面，如下图所示。在这种情况下，SketchPlane.Name属性返回与该元素相关的字符串。例如，在下图中，SketchPlane.Name属性返回与Wall.Name属性相同的“Generic - 8”。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-67D74CA2-D850-422F-A4FF-E762D683DFC9-low.png"></p>
<p> 图78：在墙上拾取一个平面作为工作平面</p>
<p>注意：“草绘平面”与工作平面不同，因为工作平面是可见的并且可以选择。它在当前API中没有特定的类，但由Element类表示。必须基于特定的SketchPlane定义工作平面。工作平面和SketchPlane Category属性都返回null。尽管“草绘平面”始终不可见，但始终存在与工作平面对应的“草绘平面”。工作平面用于在文本和图片中表达SketchPlane。</p>
<p>以下信息适用于SketchPlane成员：</p>
<ul>
<li>ID、UniqueId、Name和Plane属性返回值;</li>
<li>参数属性为空</li>
<li>Location属性返回Location对象</li>
<li>其他属性返回null。</li>
</ul>
<p>Plane包含SketchPlane几何信息。SketchPlane使用Plane设置平面坐标系，如下图所示：</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-415773EF-49A7-4158-B9DD-42A218063E81-low.png"></p>
<p>图79：SketchPlane和Plane坐标系</p>
<p>以下代码示例说明如何创建新的SketchPlane：</p>
<p>代码区域17-1：创建新的草绘平面</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> SketchPlane <span class="title">CreateSketchPlane</span>(<span class="params">UIApplication application</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//try to create a new sketch plane</span></span><br><span class="line">    XYZ newNormal = <span class="keyword">new</span> XYZ(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>);  <span class="comment">// the normal vector</span></span><br><span class="line">    XYZ newOrigin = <span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);  <span class="comment">// the origin point</span></span><br><span class="line">    <span class="comment">// create geometry plane</span></span><br><span class="line">    Plane geometryPlane = Plane.CreateByNormalAndOrigin(newNormal, newOrigin);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create sketch plane</span></span><br><span class="line">    SketchPlane sketchPlane = SketchPlane.Create(application.ActiveUIDocument.Document,geometryPlane);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sketchPlane;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3D-Sketch"><a href="#3D-Sketch" class="headerlink" title="3D Sketch"></a>3D Sketch</h2><p>三维草图用于编辑族或创建三维对象。在Revit Platform API中，可以使用以下类完成三维草图。</p>
<ul>
<li>Extrusion </li>
<li>Revolution </li>
<li>Blend </li>
<li>Sweep</li>
</ul>
<p>换句话说，有四个操作可以将2D模型转换为3D模型。有关在2D中绘制草图的详细信息，请参见2D草图类。</p>
<p><strong>Extrusion</strong> </p>
<p>Revit使用拉伸定义族的三维几何图形。通过在平面上定义二维草图来创建拉伸;然后Revit在起点和终点之间拉伸草图。</p>
<p>查询“拉伸形状”对象，以查找要在族建模和体量中使用的常规形状。Extrusion类具有以下属性：</p>
<p>表40：拉伸属性</p>
<table>
<thead>
<tr>
<th>**Property **</th>
<th>**Description **</th>
</tr>
</thead>
<tbody><tr>
<td>ExtrusionStart</td>
<td>返回拉伸起点。这是一个双类型。</td>
</tr>
<tr>
<td>ExtrusionEnd</td>
<td>返回拉伸终点。这是一个双类型。</td>
</tr>
<tr>
<td>Sketch</td>
<td>返回拉伸草图。它包含一个草图平面和一些曲线。</td>
</tr>
</tbody></table>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-8F322D1A-5035-4E9E-88F6-2AFAD258E59E-low.png"></p>
<p>图81：拉伸结果</p>
<p><strong>Revolution</strong> </p>
<p>“旋转”命令可创建绕轴旋转的几何图形。可以使用“旋转”命令在家具、圆屋顶或柱上创建门把手或其他把手。</p>
<p>查询“旋转形式”对象，以获得要在族建模和体量中使用的常规形式。Revolution类具有以下属性：</p>
<p>表41：Revolution属性</p>
<table>
<thead>
<tr>
<th>**Property **</th>
<th>**Description **</th>
</tr>
</thead>
<tbody><tr>
<td>Axis</td>
<td>返回轴。它是一个ModelLine对象。</td>
</tr>
<tr>
<td>EndAngle</td>
<td>返回结束角度。这是一个double类型。</td>
</tr>
<tr>
<td>Sketch</td>
<td>返回拉伸草图。它包含一个SketchPlane和一些曲线。</td>
</tr>
</tbody></table>
<p>EndAngle与Revit UI中的相同参数一致。下图说明了Revolution对应参数、草图和结果。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-2CF60823-4258-4838-ADA8-61F52C4B3515-low.png"></p>
<p>图82：对应参数</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-10A03254-96BC-4023-99C5-B22AF43A0702-low.png"></p>
<p>图83：旋转草图</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-803C819E-E85C-462B-BF33-CC49E9FC3C86-low.png"></p>
<p>图84：旋转结果</p>
<p>Note: 注意事项：</p>
<ul>
<li>无法使用Revit Platform API访问“起始角度”。</li>
<li>如果“结束角度”为正，则“旋转”方向为顺时针。如果为负，则旋转方向为逆时针</li>
</ul>
<h2 id="Blend"><a href="#Blend" class="headerlink" title="Blend"></a>Blend</h2><p>“融合”命令将两个轮廓融合在一起。例如，如果绘制了一个大矩形，并在其上绘制了一个小矩形，则Revit会将这两个形状融合在一起。</p>
<p>查询“融合形式”对象以获得要在族建模和体量中使用的常规形式。Blend类具有以下属性：</p>
<p>表42：Blend属性</p>
<table>
<thead>
<tr>
<th>**Property **</th>
<th>**Description **</th>
</tr>
</thead>
<tbody><tr>
<td>BottomSketch</td>
<td>返回底部草图。它是一个Sketch对象。</td>
</tr>
<tr>
<td>TopSketch</td>
<td>返回顶部草图融合。它是一个Sketch对象。</td>
</tr>
<tr>
<td>FirstEnd</td>
<td>返回第一个端点。这是一个double类型。</td>
</tr>
<tr>
<td>SecondEnd</td>
<td>返回第二个终点。这是一个double类型。</td>
</tr>
</tbody></table>
<p>FirstEnd和SecondEnd属性值与Revit UI中的相同参数一致。下图说明了“融合”对应的参数、草图和结果。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-BF73A304-626D-43C2-9A53-8C396270369F-low.png"></p>
<p>图85：UI中的融合参数</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-14B5134B-B412-429C-8CBF-A542C16659C0-low.png"></p>
<p>图86：融合顶部草图和底部草图</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-F637CA72-BA0E-4917-B24D-93947FD69E22-low.png"></p>
<p> 图87：融合结果</p>
<h2 id="Sweep"><a href="#Sweep" class="headerlink" title="Sweep"></a>Sweep</h2><p>“放样”命令可沿创建的二维路径或选定的三维路径沿着放样一个轮廓。路径可以是开环或闭环，但必须穿过轮廓平面。</p>
<p>查询“放样形状”对象，以获得用于族建模和体量的常规形状。Sweep类具有以下属性：</p>
<p>表43：Sweep 属性</p>
<table>
<thead>
<tr>
<th><strong>Property</strong></th>
<th>**Description **</th>
</tr>
</thead>
<tbody><tr>
<td>Path3d</td>
<td>返回三维路径草图。它是一个Path3D对象。</td>
</tr>
<tr>
<td>PathSketch</td>
<td>返回平面路径草图。它是一个Sketch对象。</td>
</tr>
<tr>
<td>ProfileSketch</td>
<td>返回轮廓草图。它是一个Sketch对象。</td>
</tr>
<tr>
<td>EnableTrajSegmentation</td>
<td>返回轨迹分段状态。它是一个布尔值。</td>
</tr>
<tr>
<td>MaxSegmentAngle</td>
<td>返回最大线段角度。这是一个double类型。</td>
</tr>
</tbody></table>
<p>创建2D路径与其他形状类似。通过拾取创建的3D曲线来获取3D路径。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-C9B66D17-E7EF-4CE4-B186-E1862B49461D-low.png"></p>
<p>图88：选择Sweep 3D路径</p>
<p>注意：以下信息适用于放样：</p>
<ul>
<li>仅当使用“拾取路径”获取3D路径时，Path3d特性才可用。</li>
<li>无论路径是三维还是二维，PathSketch都可用。<img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-4E2B269D-16CC-417E-A4BF-EBAD946C73DC-low.png" alt="img"><br>图89：扫描轮廓草图</li>
</ul>
<p>注意：轮廓草图垂直于路径。</p>
<p>分段放样对于创建机械风管弯头非常有用。通过设置两个放样参数并绘制带有圆弧的路径来创建分段放样。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-B63CD7A5-25B1-440A-A31B-AB6FADF08169-low.png"></p>
<p>图90：UI中的相应分段设置</p>
<p>注意：以下信息适用于分段放样：</p>
<ul>
<li>这些参数仅影响路径中的弧。</li>
<li>放样的最小分段数为两个。</li>
<li>通过清除“轨迹分段”（Trajectory Segmentation）复选框，将分段放样更改为非分段放样。EnableTrajSegmentation属性返回false。</li>
<li>如果EnableTrajSegmentation属性为false，则MaxSegmentAngle的值为默认360°。<img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-2AACA3CE-F284-4412-9887-B84FB87CC6BA-low.png" alt="img"></li>
</ul>
<p>图91：放样结果</p>
<h2 id="模型线"><a href="#模型线" class="headerlink" title="模型线"></a>模型线</h2><p>ModelCurve表示项目中的模型线。它存在于三维空间中，在所有视图中可见。</p>
<p>以下图片说明了四个ModelCurve派生类：<br><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-1CE68863-4E07-4852-A896-5ACE5235B7AE-low.png" alt="img"> 图92：ModelLine和ModelArc<br><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-E914167B-553C-4B5B-A87E-1AAB487A12B5-low.png" alt="img"> 图93：ModelEllipse和ModelNurbSpline</p>
<p><strong>创建模型线</strong></p>
<p>创建模型曲线的关键是创建曲线所在的几何、曲线和草图平面。根据您输入的Geometry.Curve类型，返回的相应ModelCurve可以向下转换为正确的类型。</p>
<p>以下示例说明如何创建新的模型曲线（ModelLine和ModelArc）：</p>
<p>代码区域17-2：创建新的模型曲线</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// get handle to application from document</span></span><br><span class="line">Autodesk.Revit.ApplicationServices.Application application = document.Application;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a geometry line in Revit application</span></span><br><span class="line">XYZ startPoint = <span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">XYZ endPoint = <span class="keyword">new</span> XYZ(<span class="number">10</span>, <span class="number">10</span>, <span class="number">0</span>);</span><br><span class="line">Line geomLine = Line.CreateBound(startPoint, endPoint);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a geometry arc in Revit application</span></span><br><span class="line">XYZ end0 = <span class="keyword">new</span> XYZ(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">XYZ end1 = <span class="keyword">new</span> XYZ(<span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line">XYZ pointOnCurve = <span class="keyword">new</span> XYZ(<span class="number">10</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">Arc geomArc = Arc.Create(end0, end1, pointOnCurve);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a geometry plane in Revit application</span></span><br><span class="line">XYZ origin = <span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">XYZ normal = <span class="keyword">new</span> XYZ(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">Plane geomPlane = Plane.CreateByNormalAndOrigin(normal, origin);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a sketch plane in current document</span></span><br><span class="line">SketchPlane sketch = SketchPlane.Create(document, geomPlane);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a ModelLine element using the created geometry line and sketch plane</span></span><br><span class="line">ModelLine line = document.Create.NewModelCurve(geomLine, sketch) <span class="keyword">as</span> ModelLine;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a ModelArc element using the created geometry arc and sketch plane</span></span><br><span class="line">ModelArc arc = document.Create.NewModelCurve(geomArc, sketch) <span class="keyword">as</span> ModelArc;</span><br></pre></td></tr></table></figure>

<p><strong>Members</strong> </p>
<p>GeometryCurve </p>
<p>GeometryCurve属性用于获取或设置模型曲线的几何曲线。除了ModelHermiteSpline，你可以从四个ModelCurves中得到不同的几何曲线;</p>
<ul>
<li>Line </li>
<li>Arc </li>
<li>Ellipse </li>
<li>Nurbspline</li>
</ul>
<p>下面的代码示例说明如何从ModelCurve获取特定Curve。</p>
<p>代码区域17-3：从ModelCurve获取特定曲线</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//get the geometry modelCurve of the model modelCurve</span></span><br><span class="line">Autodesk.Revit.DB.Curve geoCurve = modelCurve.GeometryCurve;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (geoCurve <span class="keyword">is</span> Autodesk.Revit.DB.Line)</span><br><span class="line">&#123;</span><br><span class="line">        Line geoLine = geoCurve <span class="keyword">as</span> Line;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>GeometryCurve属性返回值是一个常规的Geometry.Curve对象，因此，必须使用As运算符来转换对象类型。</p>
<p>注意：以下信息适用于GeometryCurve：</p>
<ul>
<li>在Revit中，无法创建Hermite曲线，但可以从其他软件（如AutoCAD）导入该曲线。Curve是唯一表示Hermite曲线的几何类。</li>
<li>SetPlaneAndCurve（）方法以及Curve和SketchPlane属性设置器用于不同的情况。<ul>
<li>当新曲线位于同一个SketchPlane中，或者新SketchPlane与旧SketchPlane位于同一个平面上时，请使用Curve或SketchPlane属性设置器。</li>
<li>如果新的Curve不在同一个SketchPlane中，或者新的SketchPlane与旧的SketchPlane不在同一个平面上，则必须使用SetPlaneAndCurve（）同时更改Curve值和SketchPlane值，以避免内部数据不一致。</li>
</ul>
</li>
</ul>
<p>线样式</p>
<p>线型由GraphicsStyle类表示。ModelCurve的所有线条样式都可以从GetLineStyleIds（）方法中获得，该方法返回一组GraphicsStyle元素的ElementIds。</p>
<h2 id="注：翻译自Revit-API-Developers-Guide"><a href="#注：翻译自Revit-API-Developers-Guide" class="headerlink" title="注：翻译自Revit API Developers Guide"></a><em><strong>注：</strong></em>翻译自<a href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_html">Revit API Developers Guide</a></h2>]]></content>
      <categories>
        <category>Revit二次开发人员指南</category>
      </categories>
      <tags>
        <tag>Revit</tag>
      </tags>
  </entry>
  <entry>
    <title>18几何</title>
    <url>/2024/12/14/%E4%BA%8C%E5%BC%80%E6%8C%87%E5%8D%97/18%E5%87%A0%E4%BD%95/</url>
    <content><![CDATA[<h1 id="几何"><a href="#几何" class="headerlink" title="几何"></a><a href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_Revit_Geometric_Elements_Geometry_html">几何</a></h1><p>Autodesk.Revit.DB 命名空间包含许多与几何和图形相关类型相关的类，用于描述 API 中的图形表示。几何相关的类包括：</p>
<ul>
<li>GeometryObject class - 包含从几何对象类派生的类。</li>
<li>Geometry Helper Classes - 包含从 APIObject 类派生出的类和值类型</li>
<li>Geometry Utility Classes - 包含创建非元素几何体和查找实体交点的类</li>
<li>Collection Classes - 包括从 IEnumerable 或 IEnumerator 接口派生的类。</li>
</ul>
<p>在这一节中，您将学习如何使用各种图形相关类型，如何从元素中检索几何数据，如何变换元素，以及更多内容。</p>
<p><strong>本节页面</strong></p>
<ul>
<li>从墙壁中检索几何数据</li>
<li>GeometryObject类</li>
<li>几何辅助类</li>
<li>集合类</li>
<li>从梁中检索几何数据</li>
<li>固体挤压分析</li>
<li>通过光线投影寻找几何图形</li>
<li>几何工具类</li>
<li>房间与空间几何</li>
</ul>
<h2 id="示例：从墙壁中检索几何数据"><a href="#示例：从墙壁中检索几何数据" class="headerlink" title="示例：从墙壁中检索几何数据"></a>示例：从墙壁中检索几何数据</h2><p>本教程演示了如何从墙壁获取几何数据。以下信息被涵盖：</p>
<ul>
<li>获取墙体几何边缘。</li>
<li>获取墙体几何面。</li>
</ul>
<p>注意：在本例中，由于未考虑实例，从元素中检索几何数据受到限制。例如，包含在墙中的放样在示例代码中不可用。本指南的目标是让您对如何检索几何数据有一个基本了解，但并不涵盖所有情况。有关从元素中检索几何数据的更多信息，请参阅示例：从梁中检索几何数据。</p>
<p>代码区域20-1：创建 Geometry.Options</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Autodesk.Revit.DB.Options geomOption = application.Create.NewGeometryOptions();</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">null</span> != geomOption)</span><br><span class="line">&#123;</span><br><span class="line">        geomOption.ComputeReferences = <span class="literal">true</span>;</span><br><span class="line">        geomOption.DetailLevel = Autodesk Autodesk.Revit.DB.DetailLevels.Fine;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Either the DetailLevel or the View can be set, but not both</span></span><br><span class="line">        <span class="comment">//geomOption.View = commandData.Application.ActiveUIDocument.Document.ActiveView;</span></span><br><span class="line"></span><br><span class="line">        TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>, <span class="string">&quot;Geometry Option created successfully.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：有关详细信息，请参阅几何辅助类。</p>
<p>检索面和边</p>
<p> 墙几何图形是由面和边组成的实体。完成以下步骤以获取面和边：</p>
<p>1.使用Wall类的Geometry属性创建一个Geometry.Element实例。此实例包含“对象”属性中的所有几何体对象，如实体、直线等。</p>
<p>2.迭代Object属性以获取几何体实体实例，该实例包含“面”和“边”属性中的所有几何体面和边。</p>
<p>3.迭代“面”属性以获取所有几何体面。</p>
<p>4.迭代Edges属性以获取所有几何体边。 </p>
<p>示例代码如下：</p>
<p>代码区域20-2：检索面和边</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">GetFacesAndEdges</span>(<span class="params">Wall wall</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        String faceInfo = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">        Autodesk.Revit.DB.Options opt = <span class="keyword">new</span> Options();</span><br><span class="line">        Autodesk.Revit.DB.GeometryElement geomElem = wall.get_Geometry(opt);</span><br><span class="line">        <span class="keyword">foreach</span> (GeometryObject geomObj <span class="keyword">in</span> geomElem)</span><br><span class="line">        &#123;</span><br><span class="line">                Solid geomSolid = geomObj <span class="keyword">as</span> Solid;</span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">null</span> != geomSolid)</span><br><span class="line">                &#123;</span><br><span class="line">                        <span class="built_in">int</span> faces = <span class="number">0</span>;</span><br><span class="line">                        <span class="built_in">double</span> totalArea = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">foreach</span> (Face geomFace <span class="keyword">in</span> geomSolid.Faces)</span><br><span class="line">                        &#123;</span><br><span class="line">                                faces++;</span><br><span class="line">                                faceInfo += <span class="string">&quot;Face &quot;</span> + faces + <span class="string">&quot; area: &quot;</span> + geomFace.Area.ToString() + <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">                                totalArea += geomFace.Area;</span><br><span class="line">                        &#125;</span><br><span class="line">                        faceInfo += <span class="string">&quot;Number of faces: &quot;</span> + faces + <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">                        faceInfo += <span class="string">&quot;Total area: &quot;</span> + totalArea.ToString() + <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">                        <span class="keyword">foreach</span> (Edge geomEdge <span class="keyword">in</span> geomSolid.Edges)</span><br><span class="line">                        &#123;</span><br><span class="line">                                <span class="comment">// get wall&#x27;s geometry edges</span></span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>, faceInfo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="GeometryObject类"><a href="#GeometryObject类" class="headerlink" title="GeometryObject类"></a>GeometryObject类</h2><p>索引属性Element.Geometry[]可用于提取任何模型元素（3D元素）的几何图形。这既适用于系统族实例（如墙、楼板和屋顶），也适用于许多类别的族实例（如门、窗、家具或体量）。</p>
<p>提取的几何图形将作为Autodesk. Revit. DB. GeometryElement返回给您。可以使用GetEnumerator（）方法遍历该元素的几何成员。</p>
<p>通常，在提取的几何图形的顶层返回的对象将是以下对象之一：</p>
<ul>
<li>Solids, Faces and Edges-由面和边组成的边界表示</li>
<li>Meshes-三角形的3D阵列</li>
<li>Curves-有界3D曲线</li>
<li>Points – 给定3D位置处的可见基准点</li>
<li>PolyLines – 由3D点定义的一系列线段</li>
<li>GeometryInstances-位于元素内的几何元素的实例</li>
</ul>
<p>该图说明了通过几何体提取找到的对象的层次结构。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/geometry_hierarchy.png"></p>
<p>本节中的页面</p>
<ul>
<li>Curves </li>
<li>GeometryInstances </li>
<li>Meshes </li>
<li>Points </li>
<li>PolyLines </li>
<li>Solids, Faces and Edges</li>
</ul>
<h3 id="Curves"><a href="#Curves" class="headerlink" title="Curves"></a>Curves</h3><p>曲线表示Revit模型中的二维或三维路径。曲线可以表示元素几何形状的整个范围（例如CurveElements），也可以显示为元素几何形状的一部分（例如墙或风管的中心线）。曲线和曲线集合在API的许多元素创建方法中用作输入。</p>
<p>本节中的页面</p>
<ul>
<li>曲线分析</li>
<li>曲线工作</li>
<li>曲线集合</li>
<li>曲线创建</li>
<li>曲线参数化</li>
<li>曲线类型</li>
<li>曲线类型的数学表示</li>
</ul>
<h4 id="曲线分析"><a href="#曲线分析" class="headerlink" title="曲线分析"></a>曲线分析</h4><p>有几种曲线方法是适用于几何分析的工具。</p>
<p>在某些情况下，这些API所做的事情比您通过快速查看其名称所期望的要多。</p>
<p><strong>Intersect()</strong></p>
<p>“相交”方法允许您比较两条曲线，以找出它们的不同之处或相似之处。它可以以您可能期望的方式使用，以获得两条曲线彼此相交的点，但它也可以用于识别：</p>
<ul>
<li>Collinear lines 共线的线</li>
<li>Overlapping lines 重叠线</li>
<li>Identical curves 相同曲线</li>
<li>Totally distinct curves with no intersections 完全不同的曲线，没有交叉点</li>
</ul>
<p>返回值标识这些不同的结果，输出IntersectionSetResult包含有关交点的信息。</p>
<p><strong>Project()</strong> </p>
<p>Project方法将点投影到曲线上，并返回有关曲线上最近点、其参数以及与投影点的距离的信息。</p>
<p><strong>Tessellate()</strong></p>
<p>这会将曲线分割为一系列线性段，精确度在默认公差范围内。对于Curve.Tessellate（），公差略大于1&#x2F;16”。此近似公差是Revit内部使用的公差，足以满足显示目的。</p>
<p>请注意，只有直线可以被分割成只有两个细分点的输出;非线性曲线将总是输出两个以上的点，即使曲线具有极大的半径，在数学上可能等同于直线。</p>
<h4 id="曲线工作"><a href="#曲线工作" class="headerlink" title="曲线工作"></a>曲线工作</h4><p>Curve类提供了使用曲线的有用方法。</p>
<p>除了对分析有用的方法外，Curve类还提供了用于修改曲线或获取有关曲线的基本信息的属性和方法。</p>
<p><strong>改变界限</strong></p>
<p>MakeBound（）方法可用于更改曲线的边界或为先前未绑定的曲线创建边界。MakeUnbound（）将使曲线未绑定。对于这两种方法，如果曲线标记为只读（因为它是直接从Revit图元或集合&#x2F;聚合对象中提取的），则调用此方法会导致对象更改为包含原始曲线的断开连接的副本。修改不会影响原始曲线或提供原始曲线的对象。</p>
<p><strong>图形样式</strong></p>
<p>Curve从GeometryObject继承GraphicsStyleId只读属性，GeometryObject提供指定给Curve的GraphicsStyle的ElementId。方法Curve.SetGraphicsStyleId（）可用于设置Curve的GraphicsStyle Id。Revit API中的许多方法将不使用与此曲线关联的图形样式。例如，用作图元草图一部分的曲线将不会读取此属性。新创建的曲线元素也不会使用此值，因为它们从其关联类别继承图形特性。</p>
<p><strong>曲线长度</strong></p>
<p>曲线有两个与长度相关的属性。Length属性将返回曲线的精确长度。我使用解析或数值积分计算曲线的长度。对于直线和圆弧没有性能影响。对于更快的近似，ApproximateLength属性可以快速估计曲线的长度，但在某些情况下可能会偏离2倍。此计算对于直线和圆弧是精确的。</p>
<h4 id="曲线集合"><a href="#曲线集合" class="headerlink" title="曲线集合"></a>曲线集合</h4><p>Revit API使用不同类型的曲线集合作为输入。</p>
<p>注意：较新的API方法使用Curves的.NET集合代替CurveArray和CurveArrArray。</p>
<p><strong>CurveLoop</strong></p>
<p>curveloop表示端到端连接的特定曲线链。它可以表示一个闭环或一个开环。curveloop的成员可以直接迭代，因为该类实现了IEnumerable。迭代提供了直接包含在循环中的曲线的副本；曲线的修改不会影响loop中包含的曲线。可以使用以下方法创建CurveLoops：</p>
<ul>
<li>CurveLoop.Create（）-从曲线列表创建新的CurveLoop。</li>
<li>CurveLoop.CreateViaCopy() - 创建新的CurveLoop作为现有CurveLoop的副本。</li>
<li>CurveLoop. ViaThumb（Curve，double，XYZ）-通过相对于给定平面加厚输入曲线来创建新的闭合CurveLoop。</li>
<li>CurveLoop. curveViaThrottle（CurveLoop，double，XYZ）-通过相对于给定平面加厚输入开放曲线循环来创建新的闭合曲线循环。</li>
<li>CurveLoop.CreateViaTransform() - 创建一个新的CurveLoop作为输入CurveLoop的转换副本。请注意，重载ViaThursday（）方法的thickness参数必须导致曲线超过Revit的短曲线容差（Application.ShortCurveTolerance），否则将引发异常。</li>
</ul>
<p>CurveLoop.Transform（） 的执行方式与 CreateViaTransform（） 类似，但它会变换 CurveLoop 中包含的曲线，而不是创建变换后的副本。</p>
<p><strong>CurveArray</strong></p>
<p>此集合类表示曲线的任意集合。使用其构造函数创建它。</p>
<p><strong>CurveArrArray</strong></p>
<p>此集合类是 CurveArray 的集合。当使用 this 时，此数组的子元素的组织对 this 传递给的方法有意义;例如，在 NewExtrusion（） 中，多个 CurveArrays 应该表示不同的闭合循环。</p>
<h4 id="曲线创建"><a href="#曲线创建" class="headerlink" title="曲线创建"></a>曲线创建</h4><p>通常需要将曲线作为 Revit API 方法的输入。可以通过多种方式创建它们。</p>
<p>曲线具有许多派生类型，这些类型具有用于创建曲线的静态方法。基类 Curve 还具有从现有曲线创建新曲线的方法。</p>
<p>曲线创建方法会阻止创建短于 Revit 容差的曲线。此容差通过 Application.ShortCurveTolerance 属性公开。</p>
<p><strong>Curve</strong> </p>
<p>Curve 类具有多种从现有曲线创建新曲线的方法。</p>
<ul>
<li>Clone（） - 创建此曲线的副本。</li>
<li>CreateOffset（） - 从该曲线创建一个新的曲线偏移。</li>
<li>CreateReversed（） - 创建一条与现有曲线方向相反的新曲线</li>
<li>Curve.CreateTransformed（） - 创建曲线的新实例作为该曲线的变换。</li>
</ul>
<p><strong>Line</strong></p>
<p>有两种静态方法可用于创建新 Line。</p>
<ul>
<li>CreateBound() - 在两点之间创建新的边界线性曲线。</li>
<li>CreateUnbound() - 在给定原点和方向的情况下创建新的未绑定线性曲线。</li>
</ul>
<p>Code Region：创建unbound 的线性曲线</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// define start point and direction for unbound line</span></span><br><span class="line">XYZ startPoint = <span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">XYZ directionPt = <span class="keyword">new</span> XYZ(<span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// create line</span></span><br><span class="line">Line line = Line.CreateUnbound(startPoint, directionPt);</span><br></pre></td></tr></table></figure>

<p><strong>Arc</strong> </p>
<p>重载的静态 Create（） 方法允许通过以下三种方式之一创建 Arc：</p>
<ul>
<li><p>基于 3 点</p>
</li>
<li><p>代码区域：创建具有 3 个点的圆弧</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Create a new arc using two ends and a point on the curve</span></span><br><span class="line">XYZ end0 = <span class="keyword">new</span> XYZ(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);    <span class="comment">// start point of the arc</span></span><br><span class="line">XYZ end1 = <span class="keyword">new</span> XYZ(<span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>); <span class="comment">// end point of the arc</span></span><br><span class="line">XYZ pointOnCurve = <span class="keyword">new</span> XYZ(<span class="number">10</span>, <span class="number">0</span>, <span class="number">0</span>);   <span class="comment">// point along arc</span></span><br><span class="line"></span><br><span class="line">Arc arc = Arc.Create(end0, end1, pointOnCurve);</span><br></pre></td></tr></table></figure>
</li>
<li><p>基于平面、半径和角度</p>
</li>
<li><p>代码区域：使用平面创建圆弧</p>
</li>
<li><pre><code class="c#">Arc CreateArcByGivingPlane(Autodesk.Revit.ApplicationServices.Application application, Plane plane)
&#123;
    // Create an arc which is placed on the plane and whose center is the plane&#39;s origin
    double radius = 10;
    double startAngle = 0;      // The unit is radian
    double endAngle = 2 * Math.PI;        // this arc will be a circle
    return Arc.Create(plane, radius, startAngle, endAngle);
&#125;
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">- based on center, radius, angles and two axes</span><br><span class="line">  基于圆心、半径、角度和两个轴</span><br><span class="line"></span><br><span class="line">  代码区域：使用轴创建圆弧</span><br><span class="line"></span><br><span class="line">  ```c#</span><br><span class="line">  // Create a new arc defined by its center, radios, angles and 2 axes</span><br><span class="line">  double radius = 10;</span><br><span class="line">  double startAngle = 0;      // In radian</span><br><span class="line">  double endAngle = Math.PI;        // In radian</span><br><span class="line">  XYZ center = new XYZ(5, 0, 0);</span><br><span class="line">  XYZ xAxis = new XYZ(1, 0, 0);   // The x axis to define the arc plane. Must be normalized</span><br><span class="line">  XYZ yAxis = new XYZ(0, 1, 0);   // The y axis to define the arc plane. Must be normalized</span><br><span class="line">  </span><br><span class="line">  Arc arc = Arc.Create(center, radius, startAngle, endAngle, xAxis, yAxis);</span><br></pre></td></tr></table></figure>

注意，对于后两个选项，如果角度范围等于或大于 2 * PI，则曲线将自动转换为无界圆。
</code></pre>
</li>
</ul>
<p><strong>Ellipse</strong> </p>
<p>静态 CreateCurve（） 方法创建一个椭圆，给定中心、椭圆的 x 向量和 y 向量半径、x 轴和 y 轴以定义椭圆的平面以及开始和结束参数。如果 x 半径和 y 半径几乎相等，它将返回一个圆弧，否则将返回一个椭圆。</p>
<p><strong>Cylindrical Helix</strong></p>
<p>CylindricalHelix 的静态 Create（） 方法从轴的基点、半径、x 向量、z 向量、螺距、起始角度（用于指定螺旋线的起点）和结束角度（用于指定螺旋线的终点）创建一个新的 CylindricalHelix。z 向量是轴方向，应垂直于 x 向量。正螺距产生右旋螺旋，而负螺距产生左旋螺旋。</p>
<p><strong>NURBS</strong> </p>
<p>NurbSpline 类表示 NURBS 或非均匀有理 B 样条曲线。重载的静态 CreateCurve（） 方法提供了多种创建 NURBS 曲线的方法。第一种方法是使用 Revit 在用户界面中绘制样条曲线时使用的相同计算。它需要一个控制点和权重的列表来创建新的 NurbSpline。样条的结和阶数是根据给定的控制点和权重计算的。</p>
<p>第二个选项还需要控制点和权重列表，还需要结列表以及 NurbSpline 的阶数。度数必须为 1 或更大。必须至少有 degree+1 个控制点。结的大小必须等于 degree、control points 数组的大小和 1 之和。第一度 + 1 节应该相同，最后一度 + 1 节也应相同。序列中间的结必须是非递减的。</p>
<p>第三个选项只需要控制点和权重。必须至少有 2 个控制点，并且权重的数量必须等于控制点的数量。所有权重的值都必须为正。</p>
<p>在所有情况下，创建的曲线可以是 NURBSpline 或更简单的曲线，例如直线或圆弧。这与 Revit 的期望一致，即在 Revit 图元中应使用尽可能简单的曲线表示。</p>
<p><strong>Hermite Spline</strong></p>
<p>重载的静态 HermiteSpline.Create（） 方法提供了两个用于创建 Hermite 样条的选项。最简单的方法是创建端点处具有默认切线的 Hermite 样条，并且只需要一个控制点列表和一个指示 Hermite 样条是否为周期性的标志。第二个选项将创建在其端点处具有指定切线的 Hermite 样条曲线。它有一个附加的 HermiteSplineTangents 对象参数，用于指定曲线起点和&#x2F;或终点的切线。</p>
<h4 id="曲线参数化"><a href="#曲线参数化" class="headerlink" title="曲线参数化"></a>曲线参数化</h4><p>Revit API 中的曲线可以描述为输入参数“u”的数学函数，其中曲线在 XYZ 空间中任何给定点的位置是“u”的函数。</p>
<p>曲线可以是绑定的，也可以是未绑定的。未绑定曲线没有端点，表示无限抽象（未绑定的直线）或循环曲线（圆或椭圆）。</p>
<p>在 Revit 中，参数“u”可以用两种方式表示：</p>
<ul>
<li>一个 ‘normalized’ 参数。参数的起始值为 0.0，结束值为 1.0。对于某些曲线类型，这使得沿曲线范围的曲线计算非常容易，例如，直线的中点位于参数 0.5 处。（请注意，对于更复杂的曲线方程式（如 Splines），不能总是做出此假设）。</li>
<li>一个 ‘raw’ 参数。参数的 start 和 end 值可以是任何值。对于给定的曲线，最小和最大原始参数的值可以通过 Curve.GetEndParameter（int） 获取。原始参数非常有用，因为它们的单位与 Revit 默认单位（英尺）相同。因此，要从起点沿曲线获得 5 英尺的位置，您可以在起点处获取 raw 参数，并在其上添加 5。原始参数也是计算未绑定曲线的唯一方法。</li>
</ul>
<p>方法 Curve.ComputeNormalizedParameter（） 和 Curve.ComputeRawParameter（） 会自动在两种参数类型之间缩放。方法 Curve.IsInside（） 计算原始参数，以查看它是否位于曲线的边界内。</p>
<p>您可以使用参数来计算曲线在任何给定位置的各种属性：</p>
<ul>
<li>给定曲线的 XYZ 位置。这是从 Curve.Evaluate（） 返回的。可以提供 raw 或 normalized 参数。如果您还调用 ComputeDerivatives（），则这也是 .Origin 属性。</li>
<li>给定曲线的第一个导数&#x2F;切线向量。这是 .Curve.ComputeDerivatives（） 返回的 Transform 的 BasisX 属性。</li>
<li>给定曲线的第二个导数&#x2F;法向量。这是 .BasisY 属性。</li>
<li>给定曲线的<em>次法向量</em>，定义为切线向量和法向量的叉积。这是 .Curve.ComputeDerivatives（） 返回的 Transform 的 BasisZ 属性。</li>
</ul>
<p>返回的所有向量都是非规格化的（但可以使用XYZ.Normalize（）规格化Revit API中的任何向量）。请注意，当曲线是直线时，将不会为法线和副法线向量设置值。可以使用切向量计算给定平面中直线的法向量。</p>
<p>API示例“DirectionCalculation”使用墙位置曲线的切线向量来查找朝南的外墙：</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/directioncalculation_sample.png"></p>
<p>寻找并突出显示朝南的外墙</p>
<h4 id="曲线类型"><a href="#曲线类型" class="headerlink" title="曲线类型"></a>曲线类型</h4><p>Revit使用各种曲线类型来表示文档中的曲线几何图形。</p>
<table>
<thead>
<tr>
<th><strong>Curve type 曲线类型</strong></th>
<th>Revit API类**</th>
<th><strong>Definition 定义</strong></th>
<th><strong>Notes 注意</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Bound line</td>
<td>Line</td>
<td>由端点定义的线段。</td>
<td>从Curve.GetEndpoint（）获取端点</td>
</tr>
<tr>
<td>Unbound line</td>
<td>Line</td>
<td>由位置和方向定义的无限线</td>
<td>使用Curve.IsBound标识这些。在原始参数&#x3D; 0处计算点和切向量，以找到直线方程的输入参数。</td>
</tr>
<tr>
<td>Arc</td>
<td>Arc</td>
<td>一个有界的圆弧</td>
<td>开始和结束在一定的角度。这些角度可以通过弧的每一端的原始参数值获得。</td>
</tr>
<tr>
<td>Circle</td>
<td>Arc</td>
<td>一个没有束缚的圆圈</td>
<td>使用Curve.IsBound标识。使用原始参数进行评价（从0到2π）</td>
</tr>
<tr>
<td>Cylindrical helix</td>
<td>CylindricalHelix</td>
<td>绕在圆柱体上的螺旋线，与圆柱体的轴线成恒定的角度</td>
<td>仅在楼梯和扶手中的特定应用中使用，在访问其他Revit图元和几何图形的曲线时不应使用或遇到。</td>
</tr>
<tr>
<td>Elliptical arc</td>
<td>Ellipse</td>
<td>一个约束椭圆段</td>
<td></td>
</tr>
<tr>
<td>Ellipse</td>
<td>Ellipse</td>
<td>无约束椭圆</td>
<td>使用Curve.IsBound标识。使用原始参数进行评价（从0到2π）</td>
</tr>
<tr>
<td>NURBS</td>
<td>NurbSpline</td>
<td>非均匀有理B样条曲线</td>
<td>用于在各种Revit工具中绘制的样条曲线，以及导入的几何图形</td>
</tr>
<tr>
<td>Hermite</td>
<td>HermiteSpline</td>
<td>一组点之间的样条插值</td>
<td>用于“逐点曲线”和软风管&#x2F;管道等工具，以及导入的几何图形</td>
</tr>
</tbody></table>
<p>所有Revit曲线类型的数学表示可以在曲线类型的数学表示找到。</p>
<h4 id="曲线类型的数学表示"><a href="#曲线类型的数学表示" class="headerlink" title="曲线类型的数学表示"></a>曲线类型的数学表示</h4><p>本节介绍Revit几何图形中遇到的曲线类型、其属性及其数学表示。</p>
<p><strong>Bound lines</strong></p>
<p>Bound lines由其端点定义。在Revit API中，从曲线-标高 GetEndPoint（）方法获取线的端点。</p>
<p>Bound lines上的点根据归一化参数“u”和Bound lines上点的方程为：</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/curve_bound_line.png"></p>
<p><strong>Unbound lines</strong></p>
<p>Unbound lines在Revit API中进行了专门处理。不能使用大多数曲线属性，但是，当提供原始参数时，Evaluate（）和ComputeDerivatives（）可用于获取曲线沿着的位置。</p>
<p>根据原始参数“u”以及线原点和归一化方向向量，未绑定线的点的方程为：</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/curve_unbound_line.png"></p>
<p><strong>Arcs and Circles</strong></p>
<p>圆弧和圆在Revit API中由Arc类表示。它们是根据半径、圆心和垂直于弧平面的矢量定义的，这些参数可以在Revit API中作为属性直接从Arc类访问。</p>
<p>圆的IsBound属性设置为true。这意味着它们只能通过使用原始参数（范围从0到2π）来计算，并且圆上的点的原始参数方程为：</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/curve_arcs.png"></p>
<p>其中假设圆位于XY平面内。</p>
<p>弧的开始和结束都有一定的角度。这些角度可以通过弧的每一端处的原始参数值来获得，并且这些值之间的角度值可以插入到与上述相同的等式中。</p>
<p><strong>圆柱螺旋</strong></p>
<p>圆柱螺旋线在Revit API中由ExtradricalHashion类表示。它们是根据螺旋缠绕的圆柱体的轴的基点、半径、x和y矢量、螺距以及起始角和结束角来定义的。</p>
<p><strong>椭圆和椭圆弧</strong></p>
<p>椭圆和椭圆弧段在Revit API中由Ellipse类表示。与圆弧和圆类似，它们在给定平面中根据其X和Y半径、中心和垂直于椭圆平面的向量来定义。</p>
<p>完整椭圆的IsBound属性设置为true。与圆类似，它们可以通过0和2π之间的原始参数进行评估：</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/curve_ellipse.png"></p>
<p><strong>NurbSpline</strong></p>
<p>NURBS用于用户绘制为曲线或3D对象草图的一部分的样条线段。它们还用于表示某些类型的导入几何数据。</p>
<p>NurbSpline的数据包括：</p>
<ul>
<li>长度为n+1的控制点数组</li>
<li>weights数组，长度也是n+1</li>
<li>曲线阶数，其值等于曲线阶数（k）的小一</li>
<li>长度为n + k +1的节点向量</li>
</ul>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/curve_nurb_spline.png"></p>
<p>Revit的草图绘制工具中使用的NurbSplines可以使用算法单独从控制点和阶数生成。可以在外部复制Revit算法执行的计算，请参见下面的示例：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">NurbSplinespline = curve.GeometryCurve <span class="keyword">as</span> NurbSpline;</span><br><span class="line">DoubleArrayknots = spline.Knots;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Convert to generic collection</span></span><br><span class="line">List knotList = <span class="keyword">new</span> List();</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; knots.Size; i++)</span><br><span class="line">&#123;</span><br><span class="line">    knotList.Add(knots.get_Item(i));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Preparation - get distance between each control point</span></span><br><span class="line">IList controlPoints = spline.CtrlPoints;</span><br><span class="line"><span class="built_in">int</span> numControlPoints = controlPoints.Count;</span><br><span class="line"><span class="built_in">double</span>[] chordLengths = <span class="keyword">new</span> <span class="built_in">double</span>[numControlPoints - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> iControlPoint = <span class="number">1</span>; iControlPoint &lt; numControlPoints; ++iControlPoint)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">double</span> chordLength = </span><br><span class="line">       controlPoints[iControlPoint].DistanceTo(controlPoints[iControlPoint - <span class="number">1</span>]);</span><br><span class="line">    chordLengths[iControlPoint - <span class="number">1</span>] = chordLength;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> degree = spline.Degree;</span><br><span class="line"><span class="built_in">int</span> order = degree + <span class="number">1</span>;</span><br><span class="line"><span class="built_in">int</span> numKnots = numControlPoints + order;</span><br><span class="line"><span class="built_in">double</span>[] computedKnots = <span class="keyword">new</span> <span class="built_in">double</span>[numKnots];</span><br><span class="line"><span class="built_in">int</span> iKnot = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Start knot with multiplicity degree + 1.</span></span><br><span class="line"><span class="built_in">double</span> startKnot = <span class="number">0.0</span>;</span><br><span class="line"><span class="built_in">double</span> knot = startKnot;</span><br><span class="line"><span class="keyword">for</span>(iKnot = <span class="number">0</span>; iKnot &lt; order; ++iKnot)</span><br><span class="line">&#123;</span><br><span class="line">    computedKnots[iKnot] = knot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Interior knots based on chord lengths</span></span><br><span class="line"><span class="built_in">double</span> prevKnot = knot;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="comment">/*blank*/</span>; iKnot &lt;= numControlPoints; ++iKnot) </span><br><span class="line">    <span class="comment">// Last loop computes end knot but does not set interior knot.</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">double</span> knotIncrement = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> jj = iKnot - order; jj &lt; iKnot - <span class="number">1</span>; ++jj)</span><br><span class="line">    &#123;</span><br><span class="line">        knotIncrement += chordLengths[jj];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    knotIncrement /= degree;</span><br><span class="line">    knot = prevKnot + knotIncrement;</span><br><span class="line">    <span class="keyword">if</span> (iKnot &lt; numControlPoints)</span><br><span class="line">        computedKnots[iKnot] = knot;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">break</span>;   <span class="comment">// Leave &quot;knot&quot; set to the end knot; do not increment &quot;ii&quot;.</span></span><br><span class="line"></span><br><span class="line">    prevKnot = knot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// End knot with multiplicity degree + 1.</span></span><br><span class="line"><span class="keyword">for</span>(<span class="comment">/*blank*/</span>; iKnot &lt; numKnots; ++iKnot)</span><br><span class="line">&#123;</span><br><span class="line">    computedKnots[iKnot] = knot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>HermiteSpline</strong></p>
<p>Hermite样条用于在一组控制点之间插值的曲线，如MEP中的逐点曲线和软风管和管道。它们还用于表示某些类型的导入几何数据。在Revit API中，HermiteSpline类提供了通过“控制点”、“切线”和“参数”属性访问点阵列、切线向量和参数的功能。</p>
<p>Hermite样条中两个节点之间的曲线方程为：</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/curve_hermite_1.png"></p>
<p>其中，Pk和Pk+1表示每个节点处的点，Mk和Mk+1表示切向量，并且uk和uk+1表示节点处的参数，并且基函数为：</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/curve_hermite_2.png"></p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/curve_hermite5.png"></p>
<h3 id="GeometryInstances"><a href="#GeometryInstances" class="headerlink" title="GeometryInstances"></a>GeometryInstances</h3><p>GeometryInstance表示Revit以默认配置存储的一组几何图形，然后根据图元的属性将其转换到正确的位置。最常见的遇到几何图形的情况是在族实例中。Revit使用几何图形库，允许它存储给定族的几何图形的单个副本，并在多个实例中重复使用该副本。</p>
<p>请注意，并非所有族实例都将包括几何图形。当Revit需要为给定实例制作族几何图形的唯一副本时（由于局部连接、交点以及与实例放置相关的其他因素的影响），不会遇到GeometryInstance;相反，实体几何图形将位于层次的顶层。</p>
<p>GeometryInstance提供了通过GetSymbolGeometry（）和GetInstanceGeometry（）方法读取其几何体的能力。这些方法返回另一个Autodesk.Revit.DB.GeometryElement，可以像第一级返回一样对其进行分析。</p>
<p>GetSymbolGeometry（）返回在族的坐标系中表示的几何图形。例如，当您需要“通用”表格的图片而不考虑项目中的方向和放置位置时，请使用此选项。这也是唯一一个将实际的Revit几何图形对象返回给您而不是复制的重载。这一点很重要，因为使用此几何图形作为输入来创建其他图元的操作（例如，标注尺寸或放置基于面的族）需要参照原始几何图形。</p>
<p>GetInstanceGeometry（）返回在放置实例的项目的坐标系中表示的几何图形。例如，当需要项目中实例的特定几何图形的图片时（例如，确保桌子与房间的墙壁平行放置），请使用此选项。这始终会返回图元几何图形的副本，因此，虽然它适用于实施导出器或几何分析工具，但不适合用于创建引用此几何图形的其他Revit图元。</p>
<p>GetInstanceGeometry（）和GetSymbolGeometry（）也有重载，它们可以通过任意坐标系变换几何体。这些方法始终返回类似于GetInstanceGeometry（）的副本。</p>
<p>GeometryInstance还存储了从符号坐标空间到实例坐标的变换。此转换可作为Transform属性访问。它也是通过GetInstanceGeometry（）提取几何体副本时使用的变换。有关更多详细信息，请参见几何辅助类。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/instances_transformed.png"></p>
<p>2个使用不同变换放置的族实例-将从两个族实例中获取相同的几何图形</p>
<p>对于某些族，可以嵌套多层。如果您遇到嵌套实例，则可能会以与第一级实例类似的方式对其进行解析。</p>
<p>给出了两个示例来解释如何解析实例的几何形状。</p>
<p>在此示例中，从GeometryInstance方法GetInstanceGeometry（）提取曲线。</p>
<p>代码区域：从实例获取曲线</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetAndTransformCurve</span>(<span class="params">Autodesk.Revit.ApplicationServices.Application app,</span></span></span><br><span class="line"><span class="params"><span class="function">            Autodesk.Revit.DB.Element element, Options geoOptions</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// Get geometry element of the selected element</span></span><br><span class="line">   Autodesk.Revit.DB.GeometryElement geoElement = element.get_Geometry(geoOptions);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Get geometry object</span></span><br><span class="line">   <span class="keyword">foreach</span> (GeometryObject geoObject <span class="keyword">in</span> geoElement)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="comment">// Get the geometry instance which contains the geometry information</span></span><br><span class="line">      Autodesk.Revit.DB.GeometryInstance instance =</span><br><span class="line">             geoObject <span class="keyword">as</span> Autodesk.Revit.DB.GeometryInstance;</span><br><span class="line">      <span class="keyword">if</span> (<span class="literal">null</span> != instance)</span><br><span class="line">      &#123;</span><br><span class="line">         GeometryElement instanceGeometryElement = instance.GetInstanceGeometry();</span><br><span class="line">         <span class="keyword">foreach</span> (GeometryObject o <span class="keyword">in</span> instanceGeometryElement)</span><br><span class="line">         &#123;</span><br><span class="line">            <span class="comment">// Try to find curves</span></span><br><span class="line">            Curve curve = o <span class="keyword">as</span> Curve;</span><br><span class="line">            <span class="keyword">if</span> (curve != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">               <span class="comment">// The curve is already transformed into the project coordinate system</span></span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在此示例中，使用GetSymbolGeometry（）从实例中获取实体。然后使用GeometryInstance.Transform将组成点变换到项目坐标系中。</p>
<p>代码区域：从实例获取可靠信息</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">GetAndTransformSolidInfo</span>(<span class="params">Application application, Element element, Options geoOptions</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">// Get geometry element of the selected element</span></span><br><span class="line">        Autodesk.Revit.DB.GeometryElement geoElement = element.get_Geometry(geoOptions);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Get geometry object</span></span><br><span class="line">        <span class="keyword">foreach</span> (GeometryObject geoObject <span class="keyword">in</span> geoElement)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="comment">// Get the geometry instance which contains the geometry information</span></span><br><span class="line">                Autodesk.Revit.DB.GeometryInstance instance =</span><br><span class="line">      geoObject <span class="keyword">as</span> Autodesk.Revit.DB.GeometryInstance;</span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">null</span> != instance)</span><br><span class="line">                &#123;</span><br><span class="line">                    GeometryElement instanceGeometryElement = instance.GetSymbolGeometry();</span><br><span class="line">                    <span class="keyword">foreach</span> (GeometryObject instObj <span class="keyword">in</span> instanceGeometryElement)</span><br><span class="line">                        &#123;</span><br><span class="line">                                Solid solid = instObj <span class="keyword">as</span> Solid;</span><br><span class="line">                                <span class="keyword">if</span> (<span class="literal">null</span> == solid || <span class="number">0</span> == solid.Faces.Size || <span class="number">0</span> == solid.Edges.Size)</span><br><span class="line">                                &#123;</span><br><span class="line">                                        <span class="keyword">continue</span>;</span><br><span class="line">                                &#125;</span><br><span class="line"></span><br><span class="line">                                Transform instTransform = instance.Transform;</span><br><span class="line">                                <span class="comment">// Get the faces and edges from solid, and transform the formed points</span></span><br><span class="line">                                <span class="keyword">foreach</span> (Face face <span class="keyword">in</span> solid.Faces)</span><br><span class="line">                                &#123;</span><br><span class="line">                                        Mesh mesh = face.Triangulate();</span><br><span class="line">                                        <span class="keyword">foreach</span> (XYZ ii <span class="keyword">in</span> mesh.Vertices)</span><br><span class="line">                                        &#123;</span><br><span class="line">                                                XYZ point = ii;</span><br><span class="line">                                                XYZ transformedPoint = instTransform.OfPoint(point);</span><br><span class="line">                                        &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">foreach</span> (Edge edge <span class="keyword">in</span> solid.Edges)</span><br><span class="line">                                &#123;</span><br><span class="line">                                        <span class="keyword">foreach</span> (XYZ ii <span class="keyword">in</span> edge.Tessellate())</span><br><span class="line">                                        &#123;</span><br><span class="line">                                                XYZ point = ii;</span><br><span class="line">                                                XYZ transformedPoint = instTransform.OfPoint(point);</span><br><span class="line">                                        &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：有关检索到的族实例几何图形的详细信息，请参见示例：从梁中检索几何图形数据。</p>
<h3 id="网格"><a href="#网格" class="headerlink" title="网格"></a>网格</h3><p>网格是三角形边界的集合，它们共同形成3D形状。如果Revit图元是通过某些导入操作创建的，并且还用于某些本机Revit图元（如TopographySurface），则通常会在Revit图元几何图形中遇到网格。还可以通过调用任意给定Revit面的Face.Triangulate（）来获取网格。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/mesh.png"></p>
<p>表示圆环面的网格</p>
<p>以下代码示例说明了如何将Revit面的几何体作为网格获取：</p>
<p>代码区域：提取几何体的网格</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">GetTrianglesFromFace</span>(<span class="params">Face face</span>)</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Get mesh</span></span><br><span class="line"></span><br><span class="line">        Mesh mesh = face.Triangulate();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; mesh.NumTriangles; i++)</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">               MeshTriangle triangle = mesh.get_Triangle(i);</span><br><span class="line"></span><br><span class="line">               XYZ vertex1 = triangle.get_Vertex(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">               XYZ vertex2 = triangle.get_Vertex(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">               XYZ vertex3 = triangle.get_Vertex(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：用于Revit显示目的的近似公差在构造网格时由Triangulate（）方法（上面使用的）的无参数重载使用。Triangulate（）的重载接受一个double，允许将细节级别设置在0（粗糙）和1（精细）之间。</p>
<h3 id="点"><a href="#点" class="headerlink" title="点"></a>点</h3><p>点表示3D空间中的可见坐标。</p>
<p>点通常出现在体量族图元（如ReferencePoint）中。Point类提供对其坐标的读访问，并能够获取对该点的引用，以用作其他函数的输入。</p>
<p><strong>点创建</strong></p>
<p>有两种方法可以创建点：</p>
<ul>
<li>Create(XYZ) - 在给定坐标处创建一个点。</li>
<li>Create(XYZ, ElementId) - 在给定坐标处创建一个Point，并根据GraphicsStyle元素（由ElementId指定）为其指定颜色。</li>
</ul>
<h3 id="PolyLine"><a href="#PolyLine" class="headerlink" title="PolyLine"></a>PolyLine</h3><p>PolyLine是由一组坐标点定义的线段的集合。这些通常在导入的几何体中遇到。PolyLine类提供了读取坐标的能力：</p>
<ul>
<li>PolyLine.NumberOfCoordinates – 在坐标系中的点数</li>
<li>PolyLine.GetCoordinate() – 通过索引获取坐标</li>
<li>PolyLine.GetCoordinates() – 获取对象中所有坐标的集合</li>
<li>PolyLine.Evaluate() – 给定一个规格化参数（从0到1），沿整个PolyLine范围沿着计算XYZ点</li>
</ul>
<h3 id="实体、面和边"><a href="#实体、面和边" class="headerlink" title="实体、面和边"></a>实体、面和边</h3><p>实体是一个Revit API对象，表示面和边的集合。通常，在Revit中，这些集合是完全封闭的体积，但也可能遇到壳或部分有界体积。请注意，有时Revit几何图形将包含未使用的实体，这些实体包含零个边和面。选中“边”和面成员以过滤掉这些实体。</p>
<p>Revit API提供了读取面和边的集合以及计算实体的表面积、体积和质心的功能。</p>
<p>本节中的页面</p>
<ul>
<li>边和面参数化</li>
<li>面</li>
<li>面分析</li>
<li>面分割</li>
<li>面类型</li>
<li>面类型的数学表示</li>
<li>实体分析</li>
<li>实体和面的创建</li>
</ul>
<h5 id="边和面参数化"><a href="#边和面参数化" class="headerlink" title="边和面参数化"></a>边和面参数化</h5><p>边是给定面的边界曲线。</p>
<p>使用EdgeLoops属性迭代面的边。每个循环表示面上的一个闭合边界。边始终参数化为0到1。可以使用Edge.AsCurve（）和Edge.AsCurveFollowingFace（）函数提取边缘的Curve表示。</p>
<p>边通常通过计算两个面的相交来定义。但Revit在绘制图形时不会重新计算此交点。因此，边存储一个点列表-直边的端点和曲边的细分列表。这些点是两个面上的参数坐标。这些点可以通过TessellateOnFace（）方法获得。</p>
<p>剖面产生“切割边缘”。这些是人工边-不表示模型级几何体的一部分，因此不提供参照。</p>
<p><strong>边的方向</strong></p>
<p>方向通常在第一个面上为顺时针方向（第一个面表示Revit已为特定边标识的任意面）。但是，由于两个不同的面在一个特定的边相交，并且无论您关注的是哪个面，该边都具有相同的参数化方向，因此有时需要确定特定面上的边的方向。</p>
<p>下图说明了这是如何工作的。对于面0，所有边都是顺时针参数化的（？？？）。对于面1，与面0共享的边不会重新参数化;因此，相对于面1，该边具有相反的方向，并且某些边在两条边的参数均为0（或1）的地方相交。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/face_edge_direction.png"></p>
<p>边参数化</p>
<p>API示例“PanelEdgeLengthAngle”显示了如何识别给定面的反转边。它使用边端点处的切向量来计算相邻边之间的角度，并检测是否在每个交点处翻转切向量以计算适当的角度。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/paneledgelengthangle_sample.png"></p>
<p>PanelEdgeLengthAngle结果</p>
<h5 id="面"><a href="#面" class="headerlink" title="面"></a>面</h5><p>可以将Revit API中的面描述为两个输入参数“u”和“v”的数学函数，其中面在XYZ空间中任意给定点处的位置是参数的函数。</p>
<p>U和V方向是根据给定面的形状自动确定的。恒定U或V的线可以表示为面上的网格线，如下例所示：</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/face_params.png"></p>
<p>圆柱面上的U和V网格线</p>
<p>可以使用UV参数来评估任意给定位置处的面的各种属性：</p>
<ul>
<li>参数是否在面的边界内，使用Face.IsInside（）</li>
<li>指定UV参数值处给定面的XYZ位置。这是从Face.Evaluate（）返回的。如果您还在调用ComputeDerivatives（），则这也是该方法返回的Transform的.Origin属性。</li>
<li>给定面在U方向上的切向量。这是Face.ComputeDerivatives（）返回的Transform的.BasisX属性</li>
<li>给定面在V方向上的切向量。这是Face.ComputeDerivatives（）返回的Transform的.BasisY属性。</li>
<li>给定面部的法向量。这是Face.ComputeDerivatives（）返回的Transform的.BasisZ属性。</li>
<li>关于U的二阶导数。这是Face.ComputeSecondDerivatives（）返回的FaceSecondDerivatives的. UUD派生属性。</li>
<li>相对于V的二阶导数。这是Face.ComputeSecondDerivatives（）返回的FaceSecondDerivatives的.VVDerivative。</li>
<li>给定面的混合导数。这是Face.ComputeSecondDerivatives（）返回的FaceSecondDerivatives的.MixedDerivative。</li>
</ul>
<p>返回的所有向量都是非单位化的。</p>
<h5 id="面分析"><a href="#面分析" class="headerlink" title="面分析"></a>面分析</h5><p>有几种面方法是适用于几何分析的工具。</p>
<p><strong>Intersect()</strong></p>
<p>“相交”方法计算面与曲线之间的相交。它可用于识别：</p>
<ul>
<li>两个对象之间的交点</li>
<li>如果有一条边靠近该位置，则为距离交点最近的边</li>
<li>与面完全重合的曲线</li>
<li>不相交的曲线和面</li>
</ul>
<p><strong>Project()</strong> </p>
<p>Project方法将点投影到输入面上，并返回有关投影点、到面的距离以及到投影点的最近边的信息。</p>
<p><strong>Triangulate()</strong></p>
<p>Triangulate方法获得一个近似于面的三角形网格。此方法有两个重载。无参数方法与Curve.Tessellate（）类似，因为网格的点在Revit使用的输入公差范围内（略大于1&#x2F;16”）是精确的。第二个Triangulate方法接受一个细节级别作为参数，范围从0（粗略）到1（精细）。</p>
<h5 id="面分割"><a href="#面分割" class="headerlink" title="面分割"></a>面分割</h5><p>可以通过“分割面”命令将面分割为面域。Face.HasRegions属性将报告面是否包含使用Split Face命令创建的区域，而Face.GetRegions（）方法将返回一个面列表，一个面用于承载Split Face的对象的主面（如地板的墙壁），一个面用于每个Split Face区域。</p>
<p>FaceSplitter类表示拆分面的元素。FaceSplitter.SplitElementId属性提供其面被此元素分割的元素的ID。FaceSplitter类可用于按类型过滤和查找这些面，如下所示。</p>
<p>代码区域：查找面分割元素</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Autodesk.Revit.DB.Options opt = app.Create.NewGeometryOptions();</span><br><span class="line">opt.ComputeReferences = <span class="literal">true</span>;</span><br><span class="line">opt.IncludeNonVisibleObjects = <span class="literal">true</span>;</span><br><span class="line">FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(doc);</span><br><span class="line">ICollection splitElements = collector.OfClass(<span class="keyword">typeof</span>(FaceSplitter)).Cast().ToList();</span><br><span class="line"><span class="keyword">foreach</span>(FaceSplitter faceSplitter <span class="keyword">in</span> splitElements)</span><br><span class="line">&#123;</span><br><span class="line">    Element splitElement = doc.GetElement(faceSplitter.SplitElementId);</span><br><span class="line">    Autodesk.Revit.DB.GeometryElement geomElem = faceSplitter.get_Geometry(opt);</span><br><span class="line">    <span class="keyword">foreach</span> (GeometryObject geomObj <span class="keyword">in</span> geomElem)</span><br><span class="line">    &#123;</span><br><span class="line">        Line line = geomObj <span class="keyword">as</span> Line;</span><br><span class="line">        <span class="keyword">if</span> (line != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            XYZ end1 = line.GetEndPoint(<span class="number">0</span>);</span><br><span class="line">            XYZ end2 = line.GetEndPoint(<span class="number">1</span>);</span><br><span class="line">            <span class="built_in">double</span> length = line.ApproximateLength;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="面类型"><a href="#面类型" class="headerlink" title="面类型"></a>面类型</h5><p>Revit使用各种曲线类型来表示文档中的面几何图形。其中包括：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>**Face type **</td>
<td><strong>Revit API Class</strong></td>
<td>**Definition **</td>
<td><strong>Notes 注意</strong></td>
</tr>
<tr>
<td>Plane</td>
<td>PlanarFace</td>
<td>由原点与U和V的单位向量定义的平面。</td>
<td></td>
</tr>
<tr>
<td>Cylinder</td>
<td>CylindricalFace</td>
<td>通过沿着轴拉伸圆定义的面。</td>
<td>Radius提供“半径向量”-圆的单位向量乘以半径值。</td>
</tr>
<tr>
<td>Cone</td>
<td>ConicalFace</td>
<td>一条线绕一个轴旋转而定义的面。</td>
<td>Radius提供“半径向量”-圆的单位向量乘以半径值。</td>
</tr>
<tr>
<td>Revolved face</td>
<td>RevolvedFace</td>
<td>由任意曲线绕轴旋转定义的面。</td>
<td>Radius提供旋转平面的单位矢量，不涉及“半径”。</td>
</tr>
<tr>
<td>Ruled surface</td>
<td>RuledFace</td>
<td>通过放样两条轮廓曲线或一条轮廓曲线和一个点之间的直线而定义的面。</td>
<td>曲线和点都可以作为属性获得。</td>
</tr>
<tr>
<td>Hermite face</td>
<td>HermiteFace</td>
<td>由点之间的Hermite插值定义的面。</td>
<td></td>
</tr>
</tbody></table>
<p>所有Revit面类型的数学表示可以在其中找到：面类型的数学表示。</p>
<h5 id="面类型的数学表示"><a href="#面类型的数学表示" class="headerlink" title="面类型的数学表示"></a>面类型的数学表示</h5><p>本节介绍Revit几何图形中遇到的面类型、其属性及其数学表示。</p>
<p><strong>PlanarFace</strong></p>
<p>由原点与U和V的单位向量定义的平面。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/face_planar.png"></p>
<p><strong>CylindricalFace</strong> </p>
<p>通过沿轴沿着拉伸圆而定义的面。Revit API提供以下属性：</p>
<ul>
<li>面的原点。</li>
<li>拉伸轴。</li>
<li>在X和Y中的“径向矢量”。这些向量是圆的单位向量乘以圆的半径。注意，单位向量可以表示右手或左手控制。</li>
</ul>
<p>此面的参数方程为：</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/face_cylinder.png" alt="img"></p>
<p><strong>ConicalFace</strong> </p>
<p>由一条线绕一个轴旋转而定义的面。Revit API提供以下属性：</p>
<ul>
<li>面的原点。</li>
<li>圆锥体的轴。</li>
<li>在X和Y中的“径向矢量”。这些矢量是单位矢量乘以旋转形成的圆的半径。注意，单位向量可以表示右手或左手控制。</li>
<li>The half angle of the face.<br>面的半个角。</li>
</ul>
<p>此面的参数方程为：</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/face_cone.png" alt="img"></p>
<p><strong>RevolvedFace</strong></p>
<p>由任意曲线绕轴旋转定义的面。Revit API提供以下属性：</p>
<ul>
<li>面的原点</li>
<li>面的轴线</li>
<li>轮廓曲线</li>
<li>旋转曲线的单位向量（姑且地称为“半径”）</li>
</ul>
<p>此面的参数方程为：</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/face_revolved.png" alt="img"></p>
<p><strong>RuledFace</strong> </p>
<p>RuledFace 是通过放样两条轮廓曲线之间或曲线与点之间的直线而创建的。Revit API提供曲线和点作为属性。</p>
<p>该曲面的参数方程为：</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/face_ruled1.png" alt="img"> 如果两条曲线都有效。如果其中一条曲线被替换为一个点，则方程简化为以下之一：</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/face_ruled2.png" alt="img"> <img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/face_ruled3.png" alt="img"> 没有曲线和两个点的RuledFace是不会被返回。</p>
<p><strong>HermiteFace</strong></p>
<p>立方Hermite样条曲线面。Revit API提供：</p>
<ul>
<li>样条插值点的u和v参数数组</li>
<li>每个节点上的3D点的数组（数组按u递增，然后v递增的方式组织）</li>
<li>每个节点的切向量数组</li>
<li>每个节点处的扭曲向量数组</li>
</ul>
<p>在节点（u1，v1）和（u2，v2）之间，该曲面的参数表示为：</p>
<p>其中 <img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/face_hermite2.png" alt="img"> ， <img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/face_hermite3.png" alt="img"> ，<strong>MH</strong>是Hermite矩阵：</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/face_hermite4.png" alt="img"><br>并且B是从插值点处的面属性获得的系数矩阵：</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/face_hermite5.png" alt="img"></p>
<h5 id="实体分析"><a href="#实体分析" class="headerlink" title="实体分析"></a>实体分析</h5><p><strong>实体与曲线的交线</strong></p>
<p>方法Solid.IntersectWithCurve（）计算闭合体积实体和曲线之间的交点。SolidCurveIntersectionOptions类可以指定IntersectWithCurve（）方法的结果是否将包括实体体积内部或外部的曲线段。实体内的曲线段将包括与实体的面重合的曲线段。曲线段和曲线段的参数都可以在结果中使用。</p>
<p>以下示例使用IntersectWithCurve（）方法计算柱内钢筋的长度。</p>
<p>代码区域：查找实体和曲线之间的交点</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">FindColumnRebarIntersections</span>(<span class="params">Document document, FamilyInstance column</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// We will be computing the total length of the rebar inside the column</span></span><br><span class="line">    <span class="built_in">double</span> totalRebarLengthInColumn = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find rebar hosted by this column</span></span><br><span class="line">    RebarHostData rebarHostData = RebarHostData.GetRebarHostData(column);</span><br><span class="line">    <span class="keyword">if</span> (rebarHostData == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    IList rebars = rebarHostData.GetRebarsInHost();</span><br><span class="line">    <span class="keyword">if</span> (rebars.Count == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Retrieve geometry of the column</span></span><br><span class="line">    Options geomOptions = <span class="keyword">new</span> Options();</span><br><span class="line">    geomOptions.ComputeReferences = <span class="literal">true</span>;</span><br><span class="line">    geomOptions.DetailLevel = ViewDetailLevel.Fine;</span><br><span class="line">    GeometryElement elemGeometry = column.get_Geometry(geomOptions);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Examine all geometry primitives of the column</span></span><br><span class="line">    <span class="keyword">foreach</span> (GeometryObject elemPrimitive <span class="keyword">in</span> elemGeometry)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Skip objects that are not geometry instances</span></span><br><span class="line">        GeometryInstance gInstance = elemPrimitive <span class="keyword">as</span> GeometryInstance;</span><br><span class="line">        <span class="keyword">if</span> (gInstance == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Retrieve geometry of each found geometry instance</span></span><br><span class="line">        GeometryElement instGeometry = gInstance.GetInstanceGeometry();</span><br><span class="line">        <span class="keyword">foreach</span> (GeometryObject instPrimitive <span class="keyword">in</span> instGeometry)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Skip non-solid sobject</span></span><br><span class="line">            Solid solid = instPrimitive <span class="keyword">as</span> Solid;</span><br><span class="line">            <span class="keyword">if</span> (solid == <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            SolidCurveIntersectionOptions intersectOptions = <span class="keyword">new</span> SolidCurveIntersectionOptions();</span><br><span class="line">            <span class="keyword">foreach</span> (Rebar rebar <span class="keyword">in</span> rebars)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// Get the centerlines for the rebar to find their intersection with the column</span></span><br><span class="line">                <span class="built_in">bool</span> selfIntersection = <span class="literal">false</span>;</span><br><span class="line">                <span class="built_in">bool</span> suppresHooks = <span class="literal">false</span>;</span><br><span class="line">                <span class="built_in">bool</span> suppresBends = <span class="literal">false</span>;</span><br><span class="line">                IList curves = rebar.GetCenterlineCurves(selfIntersection, suppresHooks, suppresBends, MultiplanarOption.IncludeOnlyPlanarCurves, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Examine every segment of every curve of the centerline</span></span><br><span class="line">                <span class="keyword">foreach</span> (Curve curve <span class="keyword">in</span> curves)</span><br><span class="line">                &#123;</span><br><span class="line">                    SolidCurveIntersection intersection = solid.IntersectWithCurve(curve, intersectOptions);</span><br><span class="line">                    <span class="keyword">for</span> (<span class="built_in">int</span> segment = <span class="number">0</span>; segment &lt;= intersection.SegmentCount - <span class="number">1</span>; segment++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">// Calculate length of the rebar that is inside the column</span></span><br><span class="line">                        Curve curveInside = intersection.GetCurveSegment(segment);</span><br><span class="line">                        <span class="built_in">double</span> rebarLengthInColumn = curveInside.Length;</span><br><span class="line">                        totalRebarLengthInColumn = totalRebarLengthInColumn + rebarLengthInColumn;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="实体和面的创建"><a href="#实体和面的创建" class="headerlink" title="实体和面的创建"></a>实体和面的创建</h5><p>实体和面有时用作其他实用程序的输入。Revit API提供了几个例程，可用于从头开始创建此类几何图形或从其他输入中导出此类几何图形。</p>
<p><strong>Transformed geometry</strong></p>
<p>方法</p>
<ul>
<li>GeometryElement.GetTransformed()</li>
</ul>
<p>返回应用了变换的输入几何图元的副本。由于此几何图形是副本，因此其成员不能用作其他Revit图元的输入参照，但可用于几何分析和提取。</p>
<p><strong>Geometry creation utilities</strong></p>
<p>GeometryCreationUtilities类是一个允许构造基本实体形状的实用程序类：</p>
<ul>
<li>Extrusion 拉伸</li>
<li>Loft</li>
<li>Revolution 旋转</li>
<li>Sweep 放样</li>
<li>Blend 融合</li>
<li>SweptBlend 放样融合</li>
</ul>
<p>生成的几何图形不会作为任何元素的一部分添加到文档中。然而，创建的Solid可用作其他API函数的输入，包括：</p>
<ul>
<li>作为分析可视化框架（SpatialFieldManager.AddSpatialFieldPrimitive（））中方法的输入面-这允许用户相对于文档中的其他元素可视化创建的形状</li>
<li>作为通过相交查找3D元素的输入实体</li>
<li>作为布尔运算的一个或多个输入</li>
<li>作为几何计算的一部分（例如，使用Face.Project（）、Face.Intersect（）或其他面、实体和边几何方法）</li>
</ul>
<p>下面的示例使用GeometryCreationUtilities类基于位置和高度创建圆柱形。例如，这可以用于在墙端点周围创建体积，以便查找与墙端点非常接近的其他墙：</p>
<p>代码区域：创建圆柱体</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Build cylinder centered at wall end point, extending 3&#x27; in diameter</span></span><br><span class="line">CurveLoop cylinderLoop = <span class="keyword">new</span> CurveLoop();</span><br><span class="line">XYZ arcCenter = <span class="keyword">new</span> XYZ(endPoint.X, endPoint.Y, elevation);</span><br><span class="line">Application application = wall.Document.Application;</span><br><span class="line">Arc firstArc = Arc.Create(arcCenter, <span class="number">1.5</span>, <span class="number">0</span>, Math.PI, XYZ.BasisX, XYZ.BasisY);</span><br><span class="line">Arc secondArc = Arc.Create(arcCenter, <span class="number">1.5</span>, Math.PI, <span class="number">2</span> * Math.PI, XYZ.BasisX, XYZ.BasisY);</span><br><span class="line"></span><br><span class="line">cylinderLoop.Append(firstArc);</span><br><span class="line">cylinderLoop.Append(secondArc);</span><br><span class="line"></span><br><span class="line">List singleLoop = <span class="keyword">new</span> List();</span><br><span class="line">singleLoop.Add(cylinderLoop);</span><br><span class="line"></span><br><span class="line">Solid proximityCylinder = GeometryCreationUtilities.CreateExtrusionGeometry(singleLoop, XYZ.BasisZ, height);</span><br></pre></td></tr></table></figure>

<p><strong>Boolean operations</strong> </p>
<p>BooleanOperationsUtils类提供用于组合一对实心几何体对象的方法。</p>
<p>ExecuteBooleanOperation（）方法获取输入实体的副本，并生成新实体作为结果。它的第一个参数可以是任何实体，可以直接从Revit图元获得，也可以通过其他操作（如GeometryCreationUtils）创建。</p>
<p>方法ExecuteBooleanOperationModifyingOriginalSolid（）直接对第一个输入实体执行布尔运算。第一个输入必须是不是直接从Revit图元获得的实体。属性GeometryObject.IsElementGeometry可以标识实体是否适合作为此方法的输入。</p>
<p>这两种方法的选项包括操作类型：并集、差集或交集。下面的示例演示如何获取两个实体的交点，然后查找体积。</p>
<p>代码区域：实体相交的体积</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ComputeIntersectionVolume</span>(<span class="params">Solid solidA, Solid solidB</span>)</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    Solid intersection = BooleanOperationsUtils.ExecuteBooleanOperation(solidA, solidB, BooleanOperationsType.Intersect);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">double</span> volumeOfIntersection = intersection.Volume;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法CutWithHalfSpace（）和CutWithHalfSpaceModifyingOriginalSolid（）生成一个实体，该实体是输入Solid与给定Plane正侧的半空间的交点。平面的正侧是平面。法线指向的一侧。第一种方法使用结果创建新实体，而第二种方法修改现有实体（必须是由应用程序创建的实体，而不是从Revit图元获得的实体）。</p>
<h2 id="Geometry-Helper-类"><a href="#Geometry-Helper-类" class="headerlink" title="Geometry Helper 类"></a>Geometry Helper 类</h2><p>API中有几个Geometry Helper类。Helper类用于描述某些元素的几何信息，例如使用BoundingBoxXYZ类为视图定义CropBox。</p>
<ul>
<li>BoundingBoxXYZ - 用于定义三维视图截面区域等情况的三维矩形框。</li>
<li>Transform - 变换仿射3D空间。</li>
<li>Reference -Revit模型中几何对象的稳定参照，在创建尺寸标注等图元时使用。</li>
<li>Plane - 几何中的平面。</li>
<li>Options - 用于分析几何图形的用户首选项。</li>
<li>XYZ - 表示3D空间中坐标的对象。</li>
<li>UV - 表示2D空间中坐标的对象。</li>
<li>BoundingBoxUV - 平行于坐标轴的2D矩形。</li>
</ul>
<h3 id="Transform"><a href="#Transform" class="headerlink" title="Transform"></a>Transform</h3><p>在Revit应用程序中，变换仅限于3x4变换（矩阵），即相对于模型空间的其余部分和其他对象变换对象在模型空间中的位置。变换是根据模型空间中的位置和方向构建的。三个方向矢量（BasisX、BasisY和BasisZ属性）和原点提供所有变换信息。由四个值形成的矩阵如下：</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-362AC8B3-CB53-4DB6-8606-5D90F2C8BFC4-low.png"></p>
<p>将变换应用于点如下：</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-5ABFA7C5-22F5-4A86-9878-CB0812834EB8-low.png"></p>
<p>Transform Of Point方法实现了前面的函数。</p>
<p>下面几节将介绍Geometry.Transform类的属性和方法。</p>
<h4 id="Identity"><a href="#Identity" class="headerlink" title="Identity"></a>Identity</h4><p>转换Identity </p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-4AD4178C-E897-44E0-93CD-AA8C1FD39AC4-low.png">CreateReflection()</p>
<p>反射指定的平面。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-DCA42587-9FD4-4AE3-95A8-1D45ED472D14-low.png">图112：墙反射关系</p>
<p>如上图所示，参照平面镜像了一面墙。CreateReflection（）方法需要参考平面的几何平面信息。</p>
<p>代码区域20-8：使用反射属性</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Transform <span class="title">Reflect</span>(<span class="params">ReferencePlane refPlane</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Transform mirTrans = Transform.CreateReflection(refPlane.GetPlane());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mirTrans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="CreateRotation-and-CreateRotationAtPoint"><a href="#CreateRotation-and-CreateRotationAtPoint" class="headerlink" title="CreateRotation() and CreateRotationAtPoint()"></a>CreateRotation() and CreateRotationAtPoint()</h4><p>围绕位于（0，0，0）或指定点的指定轴旋转指定角度。</p>
<h4 id="CreateTranslation"><a href="#CreateTranslation" class="headerlink" title="CreateTranslation()"></a>CreateTranslation()</h4><p>按指定的向量平移。给定一个矢量XYZ数据，如下创建一个变换：<img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-4E661E3C-0609-44C0-A7D5-52E993FEA94C-low.png"></p>
<h4 id="Determinant"><a href="#Determinant" class="headerlink" title="Determinant"></a>Determinant</h4><p>变换行列式</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-4570D0C0-0834-4A9E-AB7C-751F771AAE5B-low.png"></p>
<h4 id="HasReflection"><a href="#HasReflection" class="headerlink" title="HasReflection"></a>HasReflection</h4><p>这是一个布尔值，指示变换是否产生反射。</p>
<h4 id="Scale"><a href="#Scale" class="headerlink" title="Scale"></a>Scale</h4><p>表示变换比例的值。</p>
<h4 id="Inverse"><a href="#Inverse" class="headerlink" title="Inverse"></a>Inverse</h4><p>逆变换。如果存在变换矩阵B使得A<em>B &#x3D; B</em> A &#x3D; I（单位元），则变换矩阵A是可逆的。</p>
<h4 id="IsIdentity"><a href="#IsIdentity" class="headerlink" title="IsIdentity"></a>IsIdentity</h4><p>指示此转换是否为标识的布尔值。</p>
<h4 id="IsTranslation"><a href="#IsTranslation" class="headerlink" title="IsTranslation"></a>IsTranslation</h4><p>布尔值，指示此转变是否是转换。</p>
<h4 id="Multiply"><a href="#Multiply" class="headerlink" title="Multiply"></a>Multiply</h4><p>将转换乘以指定的变换并返回结果。</p>
<p>Operator*-将两个指定的转换相乘。</p>
<h4 id="ScaleBasis"><a href="#ScaleBasis" class="headerlink" title="ScaleBasis"></a>ScaleBasis</h4><p>缩放基向量并返回结果。</p>
<h4 id="ScaleBasisAndOrigin"><a href="#ScaleBasisAndOrigin" class="headerlink" title="ScaleBasisAndOrigin"></a>ScaleBasisAndOrigin</h4><p>缩放基向量，变换原点返回结果。</p>
<h4 id="OfPoint"><a href="#OfPoint" class="headerlink" title="OfPoint"></a>OfPoint</h4><p>将transformation到指定点。使用Origin属性。</p>
<h4 id="OfVector"><a href="#OfVector" class="headerlink" title="OfVector"></a>OfVector</h4><p>将transform转换为向量。不使用Origin属性。</p>
<h4 id="AlmostEqual"><a href="#AlmostEqual" class="headerlink" title="AlmostEqual"></a>AlmostEqual</h4><p>比较两个转换。AlmostEqual与Revit核心代码中的计算机制和精度一致。此外，在Transform类中没有实现Equal和&#x3D;&#x3D;运算符。</p>
<p>API提供了几种完成几何变换的快捷方式。几个几何体类中的Transformed属性用于执行此工作，如下表所示。</p>
<p>表48：Transformed 方法</p>
<table>
<thead>
<tr>
<th><strong>Class Name 类名</strong></th>
<th><strong>Function Description 功能描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Curve.get_Transformed(Transform transform)</td>
<td>将指定的变换转换为曲线</td>
</tr>
<tr>
<td>GeometryElement.GetTransformed(Transform transform)</td>
<td>转换原始元素中几何图形的副本。</td>
</tr>
<tr>
<td>Profile.get_Transformed(Transform transform)</td>
<td>转换轮廓并返回结果。</td>
</tr>
<tr>
<td>Mesh.get_Transformed(Transform transform) M</td>
<td>转换网格并返回结果。</td>
</tr>
</tbody></table>
<p>注意：transformed方法克隆自身，然后返回转换后的克隆结果。 除了这些方法之外，Instance类（它是族实例、链接实例和导入的CAD内容等图元的父类）还有两个方法，可以为给定的Instance提供变换。GetTransform（）方法根据实例的放置方式获得实例的基本变换，而GetTotalTransform（）方法提供使用真北变换修改的变换，例如导入实例。</p>
<p><strong>Reference</strong> </p>
<p>Reference 在元素创建中非常有用。 创建尺寸需要参照。 参考以灵活的方式标识几何表示树内的路径。 树用于查看特定的几何表达创建。API基于不同的Pick指针类型公开四种类型的引用。它们以不同的方式从API中检索：</p>
<ul>
<li>对于点-Curve.GetEndPointReference方法</li>
<li>对于曲线（直线、圆弧等）- Curve.Reference属性</li>
<li>对于面-face.Reference属性</li>
<li>对于剪切边-Edge.Reference property</li>
</ul>
<p>不能任意使用不同的参考类型。举例来说： NewLineBoundaryConditions（）方法需要Line的引用。 NewAreaBoundaryConditions（）方法需要面的引用。 NewPointBoundaryConditions（）方法需要Point的引用。 Reference. ConvertToStableRepresentation（）方法可用于将对几何体对象（例如面、边或曲线）的引用另存为字符串，然后在同一Revit任务中（甚至在存在同一文档的不同任务中）使用ParseFromStableRepresentation（）方法以字符串作为输入来获取相同的引用。</p>
<p> Options Geometry 通常从索引属性Element.Geometry中提取。梁、柱或支撑的原始几何图形在实例通过连接、剪切、复制、拉伸或其他后处理进行修改之前，可以使用FamilyInstance. GetOriginalGeometry（）方法提取。Element. Geometry和FamilyInstance. GetOriginalGeometry（）都接受必须提供的options 类。</p>
<p>options 类根据其属性自定义接收的输出类型： </p>
<ul>
<li>ComputeReferences -指示检索几何信息时是否计算几何参照。默认值为false，因此如果此属性未设置为true，则引用将不可访问。 </li>
<li>IncludeNonVisibleObjects -指示还返回在默认视图中不可见的几何对象。 </li>
<li><em>View</em> -从特定视图获取几何信息。请注意，如果指定了视图，则将使用此视图的详细程度来代替“DetailLevel”。 </li>
<li>DetailLevel -指示首选详细程度。默认值为“中”。</li>
</ul>
<p> ComputeReferences  如果将此属性设置为false，则API不计算几何参照。从几何体树检索的所有引用属性都不返回任何内容。有关引用的更多详细信息，请参阅“引用”部分。与FamilyInstance.GetOriginalGeometry（）一起使用时，此选项不能设置为true。 </p>
<p>IncludeNonVisibleObjects 大多数不可见几何图形是用户在编辑元素时看到的构造和条件几何图形（即，窗族实例的中心平面）。此属性的默认值为false。但是，某些条件可见几何图形表示真实对象（例如Revit中风管周围的隔热层），因此应将其提取。 </p>
<p>View 如果用户将“视图”特性设置为其他视图，则检索到的几何图形信息可能会有所不同。有关详细信息，请查看以下示例： 1. 在Revit中，在三维视图中绘制楼梯，然后在三维视图中选择“裁剪区域”、“裁剪区域可见”和“剖面框”属性。在“裁剪区域”中，修改三维视图中的剖面框以显示楼梯的一部分。如果使用API获取楼梯的几何图形信息，并将三维视图设置为Options.View属性，则只能检索楼梯几何图形的一部分。下图显示了Revit应用程序中的楼梯（左图）和使用API绘制的楼梯（右图）。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-F6123E3E-4B46-4502-915A-5FC399B34045-low.png"></p>
<p>图113：不同的剖面框显示不同的几何图形 </p>
<p>在Revit中绘制楼梯，然后绘制剖面，如左图所示。如果使用API获取此楼梯的信息，并将此剖面视图设置为Options.View属性，则只能检索楼梯几何图形的一部分。使用API绘制的楼梯如右图所示。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-1095389D-A7C6-4AB8-A6C6-FC8CC3C05EAB-low.png"></p>
<p>图114：检索几何剖面图 </p>
<p>DetailLevel API在Geometry.Options.DetailLevels中定义了三个枚举。这三个枚举对应于Revit应用程序中的三个详细程度，如下所示。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-81B8A84A-2F7B-4019-8CC8-4DA11B7A176A-low.png"></p>
<p>图115：三个细节层次</p>
<p>据DetailLevel特性中的不同设置检索不同的几何体信息。例如，在Revit应用程序中绘制梁，然后使用API从梁中获取几何图形进行绘制。以下图片显示了绘制结果：</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-B1C82974-A3D1-4893-9DF9-E9396C7D6352-low.png"></p>
<p>图116：梁的几何详图</p>
<p>BoundingBoxXYZ BoundingBoxXYZ定义了一个3D矩形框，它需要与任何坐标轴平行。与Instance类类似，BoundingBoxXYZ将数据存储在局部坐标空间中。它具有一个Transform属性，可将数据从框局部坐标空间转换到模型空间。换句话说，要获取模型空间中的长方体边界（与Revit中的长方体边界相同），请使用Transform属性变换每个数据成员。以下各节说明如何使用BoundingBoxXYZ。 #定义视图边界 BoundingBoxXYZ可用于通过View.CropBox属性定义视图边界。下图使用剖面视图显示了如何在Revit应用程序中使用BoundingBoxXYZ。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-C517106E-BC7F-4E89-90C4-7FFF1D6B3FD2-low.png"></p>
<p>图117：截面视图中的BoundingBoxXYZ </p>
<p>前面图片中的虚线显示了作为CropBox特性（BoundingBoxXYZ实例）显示的横断面图边界。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-22E284B3-C514-4EB4-B322-91454006173E-low.png"></p>
<p>图118：创建的截面视图 </p>
<p>上一张图片显示了相应的横断面图。视图边界外的墙将不显示。 </p>
<p>定义截面框 BoundingBoxXYZ还用于为从View3D.GetSectionBox（）方法检索的三维视图定义剖面框。在“特性”对话框中选择“剖面框”特性。剖面框如下图所示：</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-1EA1F70A-FFC5-4C58-9446-48E73E9C5606-low.png"></p>
<p>图119：三维视图剖面框#其他用途在元素的几何图形周围定义一个框。（Element.BoundingBox属性）。</p>
<p>以这种方式检索的BoundingBoxXYZ实例平行于坐标轴。在ViewSection. ViewDetail（）方法中使用。下表标识了此类的主要用途。表49：BoundingBoxXYZ属性</p>
<table>
<thead>
<tr>
<th>**Property Name **</th>
<th><strong>Usage 使用</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Max&#x2F;Min</td>
<td>最大&#x2F;最小坐标。这两个属性定义了一个平行于任何坐标轴的三维长方体。Transform属性提供了一个可以将长方体变换到适当位置的变换矩阵。</td>
</tr>
<tr>
<td>Transform</td>
<td>从长方体坐标空间转换到模型空间。</td>
</tr>
<tr>
<td>Enabled</td>
<td>指示是否打开边界框。</td>
</tr>
<tr>
<td>MaxEnabled&#x2F; MinEnabled</td>
<td>如果裁剪视图处于打开状态，<em><strong>MaxEnabled</strong></em>属性和<em><strong>MinEnabled</strong></em>属性都返回true。<img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-7050609C-8AAF-40C4-A9A8-F8920B6AD022-low.png" alt="img">如果裁剪视图处于关闭状态，<em><strong>MaxEnabled</strong></em>属性和<em><strong>MinEnabled</strong></em>属性都返回false。* 定义给定维度的最大&#x2F;最小界限是否处于活动状态。如果Enable属性为false，这两个属性也应该返回false。  此属性指示视图的裁剪框面是否可用于裁剪元素的视图。 <em>如果从View3D.GetSectionBox（)方法检索BoundingBoxXYZ，则返回值取决于是否在“三维视图属性”对话框中选择了“剖面框”属性。如果是，则所有Enabled属性都返回true。</em> 如果从Element.BoundingBox属性检索BoundingBoxXYZ，则所有Enabled属性都为true。</td>
</tr>
<tr>
<td>Bounds</td>
<td>Max&#x2F;Min属性的界限。</td>
</tr>
<tr>
<td>BoundEnabled</td>
<td>MaxEnabled&#x2F;MinEnabled属性的界限。</td>
</tr>
</tbody></table>
<p>下面的代码示例阐释如何旋转BoundingBoxXYZ以修改三维视图剖面框。</p>
<p>代码区域20-9：旋转BoundingBoxXYZ</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">RotateBoundingBox</span>(<span class="params">View3D view3d</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!view3d.IsSectionBoxActive)</span><br><span class="line">    &#123;</span><br><span class="line">        TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>,<span class="string">&quot;The section box for View3D isn&#x27;t active.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    BoundingBoxXYZ box = view3d.GetSectionBox();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create a rotation transform to apply to the section box </span></span><br><span class="line">    XYZ origin = <span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    XYZ axis = <span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Rotate 30 degrees</span></span><br><span class="line">    Transform rotate = Transform.CreateRotationAtPoint(axis, Math.PI/<span class="number">6.0</span>, origin);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Transform the View3D&#x27;s section box with the rotation transform</span></span><br><span class="line">    box.Transform = box.Transform.Multiply(rotate);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set the section box back to the view (requires an open transaction)</span></span><br><span class="line">    view3d.SetSectionBox(box);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="BoundingBoxUV"><a href="#BoundingBoxUV" class="headerlink" title="BoundingBoxUV"></a>BoundingBoxUV</h3><p>BoundingBoxUV是一个值类，它定义了一个平行于坐标轴的2D矩形。它支持最小和最大数据成员。它们一起定义BoundingBoxUV的边界。BoundingBoxUV从View.Outline属性中检索，该属性是图纸空间视图中的边界视图。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-3CDBA6D9-E139-482E-816C-640D56DE5E63-low.png"></p>
<p>图120：视图轮廓</p>
<p>两个点定义BoundingBoxUV。</p>
<ul>
<li><p>Min point - 左下角端点。</p>
</li>
<li><p>Max point - 右上端点。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-71827A01-D568-4770-9457-A279F252DBFD-low.png"></p>
</li>
</ul>
<p>图121：BoundingBoxUV最大值和最小值</p>
<p>注意：BoundingBoxUV不能像下图那样呈现倾斜矩形</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-1A52815E-11F5-4305-B68E-B0A63A06718D-low.png"></p>
<p>图122：倾斜矩形</p>
<h2 id="集合类"><a href="#集合类" class="headerlink" title="集合类"></a>集合类</h2><p>Revit API中的专用几何图形集合类。</p>
<p>API根据集合类包含的项提供以下集合类：</p>
<p>表50：几何集合类</p>
<table>
<thead>
<tr>
<th>**Class&#x2F;Type **</th>
<th>对应的集合类**</th>
<th>对应的迭代器**</th>
</tr>
</thead>
<tbody><tr>
<td>Edge</td>
<td>EdgeArray, EdgeArrayArray</td>
<td>EdgeArrayIterator, EdgeArrayArrayIterator</td>
</tr>
<tr>
<td>Face</td>
<td>FaceArray</td>
<td>FaceArrayIterator</td>
</tr>
<tr>
<td>Reference</td>
<td>ReferenceArray</td>
<td>ReferenceArrayIterator</td>
</tr>
<tr>
<td>Double value</td>
<td>DoubleArray</td>
<td>DoubleArrayIterator</td>
</tr>
</tbody></table>
<p>所有这些类都使用非常相似的方法和属性来完成类似的工作。有关更多详细信息，请参阅集合。</p>
<h2 id="示例：从梁中检索几何图形数据"><a href="#示例：从梁中检索几何图形数据" class="headerlink" title="示例：从梁中检索几何图形数据"></a>示例：从梁中检索几何图形数据</h2><p>本节说明如何从梁获取实体和曲线。可以以类似的方式检索柱和支撑几何数据。GeometryElement可以包含所需的几何体作为Solid或GeometryInstance，具体取决于梁是连接的还是独立的，本代码涵盖了这两种情况。</p>
<p>注意：如果要获取梁和支撑驱动曲线，请调用LocationCurve可用的FamilyInstance Location属性。</p>
<p>示例代码如下所示：</p>
<p>代码区域20-10：从梁获取实体和曲线</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetCurvesFromABeam</span>(<span class="params">Autodesk.Revit.DB.FamilyInstance beam,</span></span></span><br><span class="line"><span class="params"><span class="function">                                Autodesk.Revit.DB.Options options</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Autodesk.Revit.DB.GeometryElement geomElem = beam.get_Geometry(options);</span><br><span class="line"></span><br><span class="line">    Autodesk.Revit.DB.CurveArray curves = <span class="keyword">new</span> CurveArray();</span><br><span class="line">    System.Collections.Generic.List&lt;Autodesk.Revit.DB.Solid&gt; solids = <span class="keyword">new</span> System.Collections.Generic.List&lt;Autodesk.Revit.DB.Solid&gt;(); </span><br><span class="line"></span><br><span class="line">    <span class="comment">//Find all solids and insert them into solid array</span></span><br><span class="line">    AddCurvesAndSolids(geomElem, <span class="keyword">ref</span> curves, <span class="keyword">ref</span> solids);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">AddCurvesAndSolids</span>(<span class="params">Autodesk.Revit.DB.GeometryElement geomElem,</span></span></span><br><span class="line"><span class="params"><span class="function">                                <span class="keyword">ref</span> Autodesk.Revit.DB.CurveArray curves,</span></span></span><br><span class="line"><span class="params"><span class="function">                                <span class="keyword">ref</span> System.Collections.Generic.List&lt;Autodesk.Revit.DB.Solid&gt; solids</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">foreach</span> (Autodesk.Revit.DB.GeometryObject geomObj <span class="keyword">in</span> geomElem)</span><br><span class="line">    &#123;</span><br><span class="line">        Autodesk.Revit.DB.Curve curve = geomObj <span class="keyword">as</span> Autodesk.Revit.DB.Curve;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != curve)</span><br><span class="line">        &#123;</span><br><span class="line">            curves.Append(curve);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Autodesk.Revit.DB.Solid solid = geomObj <span class="keyword">as</span> Autodesk.Revit.DB.Solid;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != solid)</span><br><span class="line">        &#123;</span><br><span class="line">            solids.Add(solid);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//If this GeometryObject is Instance, call AddCurvesAndSolids</span></span><br><span class="line">        Autodesk.Revit.DB.GeometryInstance geomInst = geomObj <span class="keyword">as</span> Autodesk.Revit.DB.GeometryInstance;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != geomInst)</span><br><span class="line">        &#123;</span><br><span class="line">            Autodesk.Revit.DB.GeometryElement transformedGeomElem</span><br><span class="line">                = geomInst.GetInstanceGeometry(geomInst.Transform);</span><br><span class="line">            AddCurvesAndSolids(transformedGeomElem, <span class="keyword">ref</span> curves, <span class="keyword">ref</span> solids);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的示例使用FamilyInstance.Geometry属性访问梁的真实几何图形。若要在通过连接、剪切、复制、拉伸或其他后期处理修改族实例之前获取其原始几何图形，请使用FamilyInstance.GetOriginalGeometry（）方法。</p>
<p>注意：有关如何检索Geometry.Options类型对象的详细信息，请参阅Geometry Helper Classes。</p>
<h2 id="实体的拉伸分析"><a href="#实体的拉伸分析" class="headerlink" title="实体的拉伸分析"></a>实体的拉伸分析</h2><p>实用程序类ExtrusionAnalyzer允许您尝试将给定的几何图形“拟合”到拉伸轮廓的形状中。这个类的实例是一次性使用类，应该提供一个立体几何、一个平面和一个方向。初始化ExtrusionAnalyzer后，可以通过以下成员访问结果：</p>
<ul>
<li>GetExtrusionBase（）方法返回与输入平面对齐的拉伸实体的计算基础轮廓。</li>
<li>CalculateFaceAlignment（）方法可用于标识原始几何体中与计算拉伸的面对齐或不对齐的所有面。例如，这对于确定墙的顶部是否有倾斜连接（如果与屋顶有连接，则会出现这种情况）非常有用。如果某个面未对齐，则会将某些内容连接到影响该面的几何体。</li>
<li>若要确定生成非对齐面的元素，请将面传递给Element.GetGeneratingElementIds（）。有关此实用程序的更多详细信息，请参阅以下部分。</li>
</ul>
<p>ExtrusionAnalyzer实用程序最适用于至少有点“类似于拉伸”的几何体，例如，可能会或可能不会受到端点连接、楼板连接、屋顶连接、由门窗切割的洞口或其他修改影响的墙几何体。对于特定的形状和方向组合，分析器可能很少无法确定作为挤出基础的连贯面-在这些情况下将引发InvalidOperationException。</p>
<p>在此示例中，拉伸分析器用于计算并绘制由输入实体和太阳方向形成的阴影的轮廓。</p>
<p>代码区域：使用拉伸分析器计算并绘制阴影轮廓。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> </span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> Draw the shadow of the indicated solid with the sun direction specified.</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> </span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> The shadow will be outlined with model curves added to the document.</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> A transaction must be open in the document.</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> The document.</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> The target solid.</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> The target level where to measure and draw the shadow.</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> The direction from the sun (or light source).</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> The curves created for the shadow.</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> Thrown by ExtrusionAnalyzer when the geometry and </span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> direction combined do not permit a successful analysis.</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ICollection <span class="title">DrawShadow</span>(<span class="params">Document document, Solid solid, Level targetLevel, XYZ sunDirection</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Create target plane from level.    Plane plane = Plane.CreateByNormalAndOrigin(XYZ.BasisZ, new XYZ(0, 0, targetLevel.ProjectElevation));</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create extrusion analyzer.</span></span><br><span class="line">    ExtrusionAnalyzer analyzer = ExtrusionAnalyzer.Create(solid, plane, sunDirection);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get the resulting face at the base of the calculated extrusion.</span></span><br><span class="line">    Face result = analyzer.GetExtrusionBase();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Convert edges of the face to curves.</span></span><br><span class="line">    CurveArray curves = document.Application.Create.NewCurveArray();</span><br><span class="line">    <span class="keyword">foreach</span> (EdgeArray edgeLoop <span class="keyword">in</span> result.EdgeLoops)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">foreach</span> (Edge edge <span class="keyword">in</span> edgeLoop)</span><br><span class="line">        &#123;</span><br><span class="line">            curves.Append(edge.AsCurve());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get the model curve factory object.</span></span><br><span class="line">    Autodesk.Revit.Creation.ItemFactoryBase itemFactory;</span><br><span class="line">    <span class="keyword">if</span> (document.IsFamilyDocument)</span><br><span class="line">        itemFactory = document.FamilyCreate;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        itemFactory = document.Create;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add a sketch plane for the curves.    CurveLoop loop = new CurveLoop();</span></span><br><span class="line">    <span class="keyword">foreach</span> (Curve currentCurve <span class="keyword">in</span> curves)</span><br><span class="line">    &#123;</span><br><span class="line">        loop.Append(currentCurve);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SketchPlane sketchPlane = SketchPlane.Create(document, loop.GetPlane());</span><br><span class="line">    document.Regenerate();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add the shadow curves</span></span><br><span class="line">    ModelCurveArray curveElements = itemFactory.NewModelCurveArray(curves, sketchPlane);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Return the ids of the curves created</span></span><br><span class="line">    List curveElementIds = <span class="keyword">new</span> List();</span><br><span class="line">    <span class="keyword">foreach</span> (ModelCurve curveElement <span class="keyword">in</span> curveElements)</span><br><span class="line">    &#123;</span><br><span class="line">        curveElementIds.Add(curveElement.Id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> curveElementIds;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的实用程序可用于计算给定质量相对于视图当前日光和阴影设置的阴影：</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/shadowcalculator.png"></p>
<h2 id="通过光线投影查找几何图形"><a href="#通过光线投影查找几何图形" class="headerlink" title="通过光线投影查找几何图形"></a>通过光线投影查找几何图形</h2><p>ReferenceIntersector类可用于查找与给定射线相交的元素。</p>
<p><strong>ReferenceIntersector</strong> </p>
<p>此类允许应用程序使用Revit的拾取工具来查找图元和几何图形。这个类使用从指定方向的点发出的射线来查找射线击中的几何体。</p>
<p>该类仅与3D几何体相交，并且在创建时需要3D视图。可以使用已被剖面框剪切的三维视图，或设置了视图专有几何图元和图形选项的三维视图。输入视图上的可见性设置将确定是否返回特定图元（例如，此工具永远不会返回隐藏图元，几何图形位于视图剖面框之外的图元也不会返回）。</p>
<p>ReferenceIntersector类支持基于元素或引用类型过滤输出。输出可以根据使用的构造函数进行自定义，或者在调用方法执行光线投影之前使用类的方法和属性进行自定义。</p>
<p>有4个构造函数。</p>
<table>
<thead>
<tr>
<th><strong>Name 名称</strong></th>
<th><strong>Description 描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>ReferenceIntersector(View3D)</td>
<td>构造一个ReferenceIntersector，它被设置为返回所有元素的交集，并表示所有引用目标类型。</td>
</tr>
<tr>
<td>ReferenceIntersector(ElementFilter, FindReferenceTarget, View3D)</td>
<td>构造一个ReferenceIntersector，将其设置为返回通过过滤器的任何元素的交集。</td>
</tr>
<tr>
<td>ReferenceIntersector(ElementId, FindReferenceTarget, View3D)</td>
<td>构造一个ReferenceIntersector，它被设置为仅返回来自单个目标元素的交集。</td>
</tr>
<tr>
<td>ReferenceIntersector(ICollection, FindReferenceTarget, View3D)</td>
<td>构造一个ReferenceIntersector，它被设置为返回一组目标元素中任何一个的交集。</td>
</tr>
</tbody></table>
<p>FindReferenceTarget枚举包括以下选项：元素、网格、边、曲线、面或全部。 </p>
<p>查找元素 </p>
<p>有两种方法可以投影光线，这两种方法都将光线的原点及其方向作为输入。仅返回光线前面的元素的引用。Find（）方法返回与ReferenceIntersector的条件匹配的ReferenceWithContext对象的集合。该对象包含光线参照，它可以是与光线相交的元素和几何参照。返回的某些图元参照将具有一个相应的几何对象，该对象也是矩形的（例如，穿过墙中洞口的光线将与墙和洞口图元相交）。如果只对真正的物理交点感兴趣，则应用程序应丢弃其Reference类型为Element的所有引用。 FindNearest（）方法的行为与Find（）方法类似，但仅返回距离光线原点最近的对象引用。 返回的ReferenceWithContext包含一个接近度参数。这是光线原点与交点之间的距离。应用程序可以使用此距离来排除距离原点太远的项目，以进行特定的几何分析。应用程序还可以使用此距离来处理一些有趣的问题，包括分析模型的几何图形。</p>
<p>注意：这些方法不会返回与不在激活设计选项中的图元的交点。</p>
<p>链接文件中的元素</p>
<p> FindReferencesInRevitLinks属性提供了一个选项，用于返回在Revit链接中遇到的图元结果。如果设置为false，ReferenceIntersector将找不到对Revit链接中任何图元的参照，并且返回的所有参照将仅指向主体文档中的图元。如果设置为true，则结果可能包括对主体中元素的引用和对链接实例中元素的引用。 如果在ReferenceIntersector中设置了目标ElementId的列表，则仅当ElementId与ReferenceRevitLinkInstance的ID匹配时，才会返回引用。如果有匹配，链接中的任何相交元素都将被返回（它们的id将不会与目标id列表进行比较）。 如果应用了ElementFilter，则将根据存储的ElementFilter计算链接中的元素。请注意，如果应用的过滤器是几何过滤器（如BoundingBox过滤器或ElementIntersects过滤器），则结果可能与预期不同。这是因为将针对链接模型坐标中的链接图元计算过滤器，而链接模型坐标可能与图元在主体模型中显示的坐标不匹配。此外，在实例化期间接受Document和&#x2F;或ElementId作为输入的ElementFilters将无法正确传递链接中出现的元素，因为过滤器将无法将链接元素与过滤器的标准相匹配。 ###查找元素附近的元素 此工具的一个主要用途是查找与其他元素非常接近的元素。这允许应用程序将该工具用作其“眼睛”，并确定尚未具有内置关系的元素之间的关系。 例如，光线跟踪功能可用于查找嵌入墙中的柱。由于柱和墙不直接保持关系，因此此类允许我们通过跟踪墙范围外的光线并查找与柱的交点来查找潜在的候选对象。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/find_refs_1.png"></p>
<p>示例：查找嵌入墙中的柱</p>
<p><strong>测量距离</strong> </p>
<p>这个类也可以用来测量从天窗到最近楼层的垂直距离。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/DistanceToFloor.jpg"></p>
<p>示例：使用ReferenceIntersector.FindNearest（）进行测量</p>
<p>代码区域：使用光线投影测量距离</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">RayProjection</span> : <span class="title">IExternalCommand</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">Execute</span>(<span class="params">ExternalCommandData revit, <span class="keyword">ref</span> <span class="built_in">string</span> message, ElementSet elements</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Document doc = revit.Application.ActiveUIDocument.Document;</span><br><span class="line"></span><br><span class="line">        ICollection selectedIds = revit.Application.ActiveUIDocument.Selection.GetElementIds();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If skylight is selected, process it.</span></span><br><span class="line">        FamilyInstance skylight = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (selectedIds.Count == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">foreach</span> (ElementId id <span class="keyword">in</span> selectedIds)</span><br><span class="line">            &#123;</span><br><span class="line">                Element e = doc.GetElement(id);</span><br><span class="line">                <span class="keyword">if</span> (e <span class="keyword">is</span> FamilyInstance)</span><br><span class="line">                &#123;</span><br><span class="line">                    FamilyInstance instance = e <span class="keyword">as</span> FamilyInstance;</span><br><span class="line">                    <span class="built_in">bool</span> isWindow = (instance.Category.Id.IntegerValue == (<span class="built_in">int</span>)BuiltInCategory.OST_Windows);</span><br><span class="line">                    <span class="built_in">bool</span> isHostedByRoof = (instance.Host.Category.Id.IntegerValue == (<span class="built_in">int</span>)BuiltInCategory.OST_Roofs);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (isWindow &amp;&amp; isHostedByRoof)</span><br><span class="line">                    &#123;</span><br><span class="line">                        skylight = instance;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (skylight == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            message = <span class="string">&quot;Please select one skylight.&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span> Result.Cancelled;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Calculate the height</span></span><br><span class="line">        Line line = CalculateLineAboveFloor(doc, skylight);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create a model curve to show the distance</span></span><br><span class="line">        Plane plane = Plane.CreateByNormalAndOrigin(<span class="keyword">new</span> XYZ(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>), line.GetEndPoint(<span class="number">0</span>));</span><br><span class="line">        SketchPlane sketchPlane = SketchPlane.Create(doc, plane);</span><br><span class="line"></span><br><span class="line">        ModelCurve curve = doc.Create.NewModelCurve(line, sketchPlane);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Show a message with the length value</span></span><br><span class="line">        TaskDialog.Show(<span class="string">&quot;Distance&quot;</span>, <span class="string">&quot;Distance to floor: &quot;</span> + String.Format(<span class="string">&quot;&#123;0:f2&#125;&quot;</span>, line.Length));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Result.Succeeded;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> </span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> Determines the line segment that connects the skylight to the nearest floor.</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> </span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> The line segment.</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Line <span class="title">CalculateLineAboveFloor</span>(<span class="params">Document doc, FamilyInstance skylight</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Find a 3D view to use for the ReferenceIntersector constructor</span></span><br><span class="line">        FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(doc);</span><br><span class="line">        Func&lt;View3D, <span class="built_in">bool</span>&gt; isNotTemplate = v3 =&gt; !(v3.IsTemplate);</span><br><span class="line">        View3D view3D = collector.OfClass(<span class="keyword">typeof</span>(View3D)).Cast().First(isNotTemplate);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Use the center of the skylight bounding box as the start point.</span></span><br><span class="line">        BoundingBoxXYZ box = skylight.get_BoundingBox(view3D);</span><br><span class="line">        XYZ center = box.Min.Add(box.Max).Multiply(<span class="number">0.5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Project in the negative Z direction down to the floor.</span></span><br><span class="line">        XYZ rayDirection = <span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">        ElementClassFilter filter = <span class="keyword">new</span> ElementClassFilter(<span class="keyword">typeof</span>(Floor));</span><br><span class="line"></span><br><span class="line">        ReferenceIntersector refIntersector = <span class="keyword">new</span> ReferenceIntersector(filter, FindReferenceTarget.Face, view3D);</span><br><span class="line">        ReferenceWithContext referenceWithContext = refIntersector.FindNearest(center, rayDirection);</span><br><span class="line"></span><br><span class="line">        Reference reference = referenceWithContext.GetReference();</span><br><span class="line">        XYZ intersection = reference.GlobalPoint;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create line segment from the start point and intersection point.</span></span><br><span class="line">        Line result = Line.CreateBound(center, intersection);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>射线反弹&#x2F;分析</strong></p>
<p>ReferenceIntersector.Find（）返回的参照包括几何上的交点。知道了面上的交点、面的材质和光线方向，应用程序就可以分析建筑物内的反射和折射。下图演示了如何使用交点来反射由模型图元遮挡的光线;添加了模型曲线来表示每条光线的路径。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/find_refs_3.png"></p>
<p>示例：从曲面反弹的射线</p>
<p><strong>查找交点&#x2F;碰撞</strong></p>
<p>ReferenceIntersector类的另一个用途是检测与给定梁或管道的中心线相交&#x2F;干涉的交点（如梁或管道）。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/find_refs_4.png"></p>
<p>示例：在干涉周围重新布线元素</p>
<h2 id="几何工具类"><a href="#几何工具类" class="headerlink" title="几何工具类"></a>几何工具类</h2><p>有许多工具类可用于处理几何体对象。</p>
<p><strong>HostObjectUtils</strong></p>
<p>HostObjectUtils类提供方法作为定位复合HostObjects的某些面的快捷方式。这些实用程序检索用作对象的CompoundStructure的边界的面：</p>
<ul>
<li>HostObjectUtils.GetSideFaces() – 适用于墙壁和FaceWalls;您可以获得外部或内部饰面。</li>
<li>HostObjectUtils.GetTopFaces() and HostObjectUtils.GetBottomFaces() – 适用于屋顶、楼板和天花板。</li>
</ul>
<p><strong>SolidUtils</strong></p>
<p>SolidUtils类包含对实体执行操作的方法。</p>
<ul>
<li>SolidUtils.Clone() - 创建一个新的Solid，它是输入Solid的副本</li>
<li>SolidUtils.SplitVolumes() - 使用一个包含不相交的封闭体积的实体，并返回新创建的代表每个体积的实体对象。如果不需要分割，则返回输入实体。</li>
<li>SolidUtils.TessellateSolidOrShell() - 对给定的输入实体（可以是一个或多个完全闭合的体积，也可以是一个开放的壳）进行三角测量。返回一个TriangulatedSolidOrShell对象，该对象允许访问存储的实体的三角化边界组件或壳的三角化连接组件。</li>
<li>SolidUtils.CreateTransformed() - 创建一个新的实体，它是输入实体的变换。</li>
</ul>
<p><strong>JoinGeometryUtils</strong></p>
<p>JoinGeometryUtils类包含用于连接和取消连接元素以及管理元素连接顺序的方法。这些实用程序不适用于族文档。</p>
<ul>
<li>JoinGeometryUtils.AreElementsJoined() - 确定是否连接两个元素</li>
<li>JoinGeometryUtils.GetJoinedElements() - 返回连接到给定元素的所有元素</li>
<li>JoinGeometryUtils.JoinGeometry() - 在共享公共面的两个元素之间创建连接。将删除连接图元之间的可见边。然后，连接的元素共享相同的线宽和填充图案。</li>
<li>JoinGeometryUtils.UnjoinGeometry() - 删除两个连接元素之间的连接</li>
<li>JoinGeometryUtils.SwitchJoinOrder() - 反转两个元素连接的顺序。切割元件变成被切割元件，反之亦然。</li>
<li>JoinGeometryUtils . IsCuttingElementInJoin() - 确定两个连接的元素中的第一个元素是否剪切第二个元素，反之亦然。</li>
</ul>
<p><strong>FacetingUtils</strong></p>
<p>此类用于将三角形结构转换为其中某些三角形已合并为四边形的结构。</p>
<ul>
<li>FacetingUtils.ConvertTrianglesToQuads() - 此方法以TriangulationInterface（从TriangulatedSolidOrShell构造）作为输入，并返回表示原始三角化对象的三角形和四边形的集合。</li>
</ul>
<h2 id="房间和空间几何"><a href="#房间和空间几何" class="headerlink" title="房间和空间几何"></a>房间和空间几何</h2><p>通过Revit API可以访问空间图元（房间和空间）的三维几何图形。</p>
<p>SpatialElementGeometryCalculator类可用于计算空间元素的几何形状并获取几何形状与元素边界元素之间的关系。可以为此实用程序提供2个选项：</p>
<ul>
<li>SpatialElementBoundaryLocation – 是否使用详细面或边界元素中心线进行计算</li>
<li>StoredFreeBoundaryFaces – 是否在结果中包括不直接映射到边界元素的面。</li>
</ul>
<p>计算几何体的结果包含在SpatialElementGeometryResults类中。从SpatialElementGeometryResults类中，可以获得：</p>
<ul>
<li>表示几何的实体体积（GetGeometry（）方法）</li>
<li>边界面信息（一个集合SpatialElementBoundarySubfaces）</li>
</ul>
<p>每个子面提供：</p>
<ul>
<li>空间元素的表面</li>
<li>边界元素的匹配面</li>
<li>子面（由该特定边界元素限定的空间元素面部分）</li>
<li>底面类型（底部、顶部或侧面）</li>
</ul>
<p>关于使用此实用程序的一些注意事项：</p>
<ul>
<li>计算器为已处理的几何体维护一个内部缓存。如果要计算同一项目中多个图元的几何图形，则应使用此类的单个实例。请注意，当对文档进行任何更改时，将清除该高速缓存。</li>
<li>楼板几乎从不作为边界元素包含在内。Revit使用房间的二维轮廓来形成底面，而不将其与楼板几何图形相匹配。</li>
<li>由墙剪切特征（例如门和窗）创建的洞口不包括在返回的面中。</li>
<li>几何图形计算与Revit提供的功能相匹配。在某些情况下，如果Revit假设如何计算房间和空间边界的体积，则这些假设将显示在实用程序的输出中。</li>
</ul>
<p>以下示例计算房间的几何图形并查找其边界面</p>
<p>代码区域：使用SpatialElementGeometryCalculator的面部区域</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SpatialElementGeometryCalculator calculator = new SpatialElementGeometryCalculator(doc);</span><br><span class="line"></span><br><span class="line"><span class="comment">// compute the room geometry</span></span><br><span class="line">SpatialElementGeometryResults results = calculator.CalculateSpatialElementGeometry(room);</span><br><span class="line"></span><br><span class="line"><span class="comment">// get the solid representing the room&#x27;s geometry</span></span><br><span class="line">Solid roomSolid = results.GetGeometry(); </span><br><span class="line"></span><br><span class="line">foreach (Face face in roomSolid.Faces)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">double</span> faceArea = face.Area;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get the sub-faces for the face of the room</span></span><br><span class="line">    IList subfaceList = results.GetBoundaryFaceInfo(face);</span><br><span class="line">    foreach (SpatialElementBoundarySubface subface in subfaceList)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (subfaceList.Count &gt; <span class="number">1</span>) <span class="comment">// there are multiple sub-faces that define the face</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// get the area of each sub-face</span></span><br><span class="line">            <span class="type">double</span> subfaceArea = subface.GetSubface().Area;</span><br><span class="line">            <span class="comment">// sub-faces exist in situations such as when a room-bounding wall has been</span></span><br><span class="line">            <span class="comment">// horizontally split and the faces of each split wall combine to create the </span></span><br><span class="line">            <span class="comment">// entire face of the room</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面的示例计算房间的几何图形，并查找属于定义房间的图元的面的材质。</p>
<p>代码区域：使用SpatialElementGeometryCalculator的面材质</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">MaterialFromFace</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="built_in">string</span> s = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    Document doc = <span class="keyword">this</span>.Document;</span><br><span class="line">        UIDocument uidoc = <span class="keyword">new</span> UIDocument(doc);</span><br><span class="line">        Room room = doc.GetElement(uidoc.Selection.PickObject(ObjectType.Element).ElementId) <span class="keyword">as</span> Room;</span><br><span class="line"></span><br><span class="line">        SpatialElementBoundaryOptions  spatialElementBoundaryOptions = <span class="keyword">new</span> SpatialElementBoundaryOptions();</span><br><span class="line">        spatialElementBoundaryOptions.SpatialElementBoundaryLocation = SpatialElementBoundaryLocation.Finish;</span><br><span class="line">        SpatialElementGeometryCalculator calculator = <span class="keyword">new</span> SpatialElementGeometryCalculator(doc, spatialElementBoundaryOptions);</span><br><span class="line">        SpatialElementGeometryResults results = calculator.CalculateSpatialElementGeometry(room);</span><br><span class="line">        Solid roomSolid = results.GetGeometry(); </span><br><span class="line"></span><br><span class="line">        <span class="keyword">foreach</span> (Face roomSolidFace <span class="keyword">in</span> roomSolid.Faces)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">foreach</span> (SpatialElementBoundarySubface subface <span class="keyword">in</span> results.GetBoundaryFaceInfo(roomSolidFace))</span><br><span class="line">            &#123;</span><br><span class="line">                Face boundingElementface = subface.GetBoundingElementFace();</span><br><span class="line">                ElementId id = boundingElementface.MaterialElementId;</span><br><span class="line">                s +=  doc.GetElement(id).Name + <span class="string">&quot;, id = &quot;</span> + id.IntegerValue.ToString() + <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    TaskDialog.Show(<span class="string">&quot;revit&quot;</span>,s);&#125;</span><br></pre></td></tr></table></figure>

<h2 id="注：翻译自Revit-API-Developers-Guide"><a href="#注：翻译自Revit-API-Developers-Guide" class="headerlink" title="注：翻译自Revit API Developers Guide"></a><em><strong>注：</strong></em>翻译自<a href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_html">Revit API Developers Guide</a></h2>]]></content>
      <categories>
        <category>Revit二次开发人员指南</category>
      </categories>
      <tags>
        <tag>Revit</tag>
      </tags>
  </entry>
  <entry>
    <title>17注释元素</title>
    <url>/2024/12/10/%E4%BA%8C%E5%BC%80%E6%8C%87%E5%8D%97/17%E6%B3%A8%E9%87%8A%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<h1 id="注释元素"><a href="#注释元素" class="headerlink" title="注释元素"></a><a href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_Revit_Geometric_Elements_Annotation_Elements_html">注释元素</a></h1><p>本节介绍Revit注释元素，例如尺寸标注、文字注释、注释记号、标记和符号。</p>
<p>请注意：</p>
<ul>
<li>尺寸标注是视图专有的图元，用于显示项目中的尺寸和距离。</li>
<li>为详图创建详图曲线。它们仅在绘制它们的视图中可见。它们通常绘制在模型视图上。</li>
<li>标签是用于标识图形中图元的注释。与标签关联的特性可以显示在明细表中。</li>
<li>AnnotationSymbol在加载到项目中时具有多个引线选项。</li>
</ul>
<p>有关Revit Element分类的详细信息，请参见元素要点。</p>
<h2 id="尺寸标注和约束"><a href="#尺寸标注和约束" class="headerlink" title="尺寸标注和约束"></a>尺寸标注和约束</h2><p>永久性尺寸标注和尺寸标注相关约束。</p>
<p>Dimension类表示永久性尺寸标注和与尺寸标注相关的约束元素。在UI中编辑元素时创建的临时尺寸标注不可访问。高程点和高程点坐标由SpotDimension类表示。</p>
<p>下面的代码示例在结尾处说明了如何区分永久性尺寸标注和约束元素。</p>
<p>代码区域16-1：区分永久性尺寸标注和约束</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetInfo_Dimension</span>(<span class="params">Dimension dimension</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> message = <span class="string">&quot;Dimension : &quot;</span>;</span><br><span class="line">    <span class="comment">// Get Dimension name</span></span><br><span class="line">    message += <span class="string">&quot;\nDimension name is : &quot;</span> + dimension.Name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get Dimension Curve</span></span><br><span class="line">    Autodesk.Revit.DB.Curve curve = dimension.Curve;</span><br><span class="line">    <span class="keyword">if</span> (curve != <span class="literal">null</span> &amp;&amp; curve.IsBound)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Get curve start point</span></span><br><span class="line">        message += <span class="string">&quot;\nCurve start point:(&quot;</span> + curve.GetEndPoint(<span class="number">0</span>).X + <span class="string">&quot;, &quot;</span></span><br><span class="line">                + curve.GetEndPoint(<span class="number">0</span>).Y + <span class="string">&quot;, &quot;</span> + curve.GetEndPoint(<span class="number">0</span>).Z + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">        <span class="comment">// Get curve end point</span></span><br><span class="line">        message += <span class="string">&quot;; Curve end point:(&quot;</span> + curve.GetEndPoint(<span class="number">1</span>).X + <span class="string">&quot;, &quot;</span></span><br><span class="line">                + curve.GetEndPoint(<span class="number">1</span>).Y + <span class="string">&quot;, &quot;</span> + curve.GetEndPoint(<span class="number">1</span>).Z + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get Dimension type name</span></span><br><span class="line">    message += <span class="string">&quot;\nDimension type name is : &quot;</span> + dimension.DimensionType.Name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get Dimension view name</span></span><br><span class="line">    message += <span class="string">&quot;\nDimension view name is : &quot;</span> + dimension.View.Name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get Dimension reference count</span></span><br><span class="line">    message += <span class="string">&quot;\nDimension references count is &quot;</span> + dimension.References.Size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((<span class="built_in">int</span>)BuiltInCategory.OST_Dimensions == dimension.Category.Id.IntegerValue)</span><br><span class="line">    &#123;</span><br><span class="line">        message += <span class="string">&quot;\nDimension is a permanent dimension.&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((<span class="built_in">int</span>)BuiltInCategory.OST_Constraints == dimension.Category.Id.IntegerValue)</span><br><span class="line">    &#123;</span><br><span class="line">        message += <span class="string">&quot;\nDimension is a constraint element.&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>,message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="尺寸标注"><a href="#尺寸标注" class="headerlink" title="尺寸标注"></a>尺寸标注</h3><p>有五种永久尺寸标注：</p>
<ul>
<li>Linear dimension 线性尺寸标注</li>
<li>Radial dimension 半径尺寸标注</li>
<li>Diameter Dimension 直径尺寸标注</li>
<li>Angular dimension 角度尺寸标注</li>
<li>Arc length dimension 弧长尺寸标注</li>
</ul>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/Dims.png"></p>
<p>图66：永久尺寸标注</p>
<p>所有永久性尺寸标注的BuiltInCategory为OST_Dimensions。没有一种使用API区分四个维度的简单方法。</p>
<p>除半径尺寸标注和直径尺寸标注外，每个尺寸标注都有一条尺寸线。尺寸线可从始终未绑定的Dimension.Curve属性中获得。换句话说，尺寸线没有起点或终点。基于上一张图片：</p>
<ul>
<li>将为线性标注返回Line对象。</li>
<li>将为半径标注或角度标注返回弧对象。</li>
<li>径向尺寸标注返回空。</li>
<li>直径尺寸标注返回空。</li>
</ul>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-4C8DCD73-DFD8-4185-A1EA-2C890D176FBF-low.png"></p>
<p>图67：尺寸参考</p>
<p>如上图所示，通过选择几何参照来创建尺寸。几何参照在API中表示为Reference类。以下尺寸参照可从“参照”（References）属性中获得。有关参考的更多信息，请参见几何部分中的几何辅助程序类。</p>
<ul>
<li>半径和直径尺寸标注-返回曲线的一个参考对象</li>
<li>角度和弧长尺寸标注-返回两个参照对象。</li>
<li>线性尺寸标注-返回两个或多个参照对象。在下图中，线性标注有五个Reference对象。</li>
</ul>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-A976B817-2D4B-471B-BF79-27E9262A8A85-low.png"></p>
<p>图68：线性尺寸参考</p>
<p>与其他注释元素一样，尺寸标注也是视图专有的。它们仅显示在添加它们的视图中。Dimension.View属性返回特定的视图。</p>
<h3 id="约束元素"><a href="#约束元素" class="headerlink" title="约束元素"></a>约束元素</h3><p>具有类别约束的标注对象（BuitInCategory.OST_Constraints）表示两种与标注相关的约束：</p>
<ul>
<li>Linear and radial dimension constraints<br>线性和半径尺寸标注约束</li>
<li>Equality constraints 等式约束</li>
</ul>
<p>在下图中，两种锁定约束分别对应于线性标注和半径标注。在应用程序中，它们显示为带有绿色虚线的挂锁。(绿色虚线可从“尺Dimension.Curve”属性中获得。）线性标注约束和半径标注约束都从Dimension.References属性返回两个Reference对象。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-370D4754-3BC7-4A6C-8531-41B7A5B424D9-low.png"></p>
<p>图69：线性和半径尺寸约束</p>
<p>约束图元不是视图专有的，可以显示在不同的视图中。因此，View属性总是返回null。在下图中，上一图中的约束元素在3D视图中也可见。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-8365F25E-7304-413D-BABE-1C495BD8ADAD-low.png"></p>
<p>图70：3D视图中的线性和半径尺寸约束</p>
<p>虽然等分约束基于尺寸标注，但它们也由Dimension类表示。在API中，没有使用类别或类型区分线性标注约束和等式约束的直接方法。相等约束返回三个或更多引用，而线性尺寸约束返回两个或更多引用。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-FB6F70CD-8913-4C3A-A036-2108550BA25C-low.png"></p>
<p>图71：等分约束</p>
<p>注意：并非所有约束元素都由Dimension类表示，但都属于约束（OST_Constraints）类别，如对齐约束。</p>
<h3 id="高程点标注"><a href="#高程点标注" class="headerlink" title="高程点标注"></a>高程点标注</h3><p>高程点坐标和高程点由SpotDimension类表示，并按类别区分。与永久性尺寸标注一样，高程点尺寸标注也是视图专有的。下表列出了每个高程点标注的类型和类别：</p>
<p>表35：点尺寸类型和类别</p>
<table>
<thead>
<tr>
<th><strong>Type 类型</strong></th>
<th><strong>Category 类别</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Spot Coordinates 高程点坐标</td>
<td>OST_SpotCoordinates</td>
</tr>
<tr>
<td>Spot Elevations 高程点</td>
<td>OST_SpotElevations</td>
</tr>
</tbody></table>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-BDB09C60-D4AC-4F6A-8100-6BA2FA165228-low.png"></p>
<p>图72：SpotCoordinates和SpotElevations</p>
<p>可以将SpotDimension Location向下转换为LocationPoint，以便可以从LocationPoint.Point属性中获得点尺寸所指向的点坐标。SpotDimensions没有尺寸曲线，因此其Curve属性始终返回null。SpotDimension References属性返回一个Reference，表示高程点标注引用的点或边。* 若要控制文本和标记显示样式，请修改SpotDimension和SpotExpressionType参数。</p>
<p>对比下表对比了API中不同类型的维度和约束：</p>
<p>表36：Dimension类别对比</p>
<table>
<thead>
<tr>
<th>Dimension or Constraint</th>
<th>Dimension or Constraint</th>
<th>API Class</th>
<th>BuiltInCategory</th>
<th>Curve</th>
<th>Geometry Helper Classes</th>
<th>View</th>
<th>Location</th>
</tr>
</thead>
<tbody><tr>
<td>Permanent Dimension</td>
<td>linear dimension</td>
<td>Dimension</td>
<td>OST_Dimensions</td>
<td>A Line</td>
<td>&#x3D;2</td>
<td>Specific view</td>
<td>null</td>
</tr>
<tr>
<td>Permanent Dimension</td>
<td>radial dimension</td>
<td>Dimension</td>
<td>OST_Dimensions</td>
<td>Null</td>
<td>1</td>
<td>Specific view</td>
<td>null</td>
</tr>
<tr>
<td>Permanent Dimension</td>
<td>diameter dimension</td>
<td>Dimension</td>
<td>OST_Dimensions</td>
<td>Null</td>
<td>1</td>
<td>Specific view</td>
<td>null</td>
</tr>
<tr>
<td>Permanent Dimension</td>
<td>angular dimension</td>
<td>Dimension</td>
<td>OST_Dimensions</td>
<td>An Arc</td>
<td>2</td>
<td>Specific view</td>
<td>null</td>
</tr>
<tr>
<td>Permanent Dimension</td>
<td>arc length dimension</td>
<td>Dimension</td>
<td>OST_Dimensions</td>
<td>An Arc</td>
<td>2</td>
<td>Specific view</td>
<td>null</td>
</tr>
<tr>
<td>Dimension Constraint</td>
<td>linear dimension constraint</td>
<td>Dimension</td>
<td>OST_Constraints</td>
<td>An Arc</td>
<td>2</td>
<td></td>
<td>null</td>
</tr>
<tr>
<td>Dimension Constraint</td>
<td>angular dimension</td>
<td>Dimension</td>
<td>OST_Constraints</td>
<td>An Arc</td>
<td>2</td>
<td></td>
<td>null</td>
</tr>
<tr>
<td>Equality Constraint</td>
<td>Equality Constraint</td>
<td>Dimension</td>
<td>OST_Constraints</td>
<td>A Line</td>
<td>&#x3D;3</td>
<td></td>
<td>null</td>
</tr>
</tbody></table>
<h3 id="创建和删除"><a href="#创建和删除" class="headerlink" title="创建和删除"></a>创建和删除</h3><p>NewDimension（）方法在Creation.Document类中可用。此方法只能创建线性标注。</p>
<p>代码区域16-2：NewDimension（）</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Dimension <span class="title">NewDimension</span> (<span class="params">View view, Line line, ReferenceArray references</span>)</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Dimension <span class="title">NewDimension</span> (<span class="params">View view, Line line, ReferenceArray references, </span></span></span><br><span class="line"><span class="params"><span class="function">DimensionType dimensionType</span>)</span></span><br></pre></td></tr></table></figure>

<p>使用NewDimension（）方法输入参数，可以定义可见的View、尺寸线和References（两个或多个）。但是，没有简单的方法将线性标注类型与其他类型区分开来。很少使用带有ExcisionType参数的重载NewDimension（）方法。 下面的代码演示如何使用NewDimension（）方法复制标注。</p>
<p>代码区域16-3：使用NewDimension（）复制标注</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DuplicateDimension</span>(<span class="params">Document document, Dimension dimension</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        Line line = dimension.Curve <span class="keyword">as</span> Line;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != line)</span><br><span class="line">        &#123;</span><br><span class="line">                Autodesk.Revit.DB.View view = dimension.View;</span><br><span class="line">                ReferenceArray references = dimension.References;</span><br><span class="line">                Dimension newDimension = document.Create.NewDimension(view, line, references);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>尽管只创建了线性标注，但您可以使用Document.Delete（）方法删除由Dimension和SpotDimension表示的所有标注和约束。 </p>
<p>标注文本操作 Dimension和ExpressionSegment类提供了类似的属性和方法，用于查询和调整文本相对于尺寸曲线的位置。 Dimension.Origin返回尺寸曲线中点的XYZ值，而ExpressionSegment.Origin将返回组成线段的直线的中点。 通过调用IsTextPositionAdjustable（）方法确定标注或标注段的文本位置是否可调，该方法将指示是否可以设置文本和引线位置。 使用属性TextPosition和LeaderEndPosition查询或修改文本或引线（标注或标注段）的位置。 通过调用ResetTextPosition（）方法将文本重置为其在尺寸上的默认位置。</p>
<p>注意：TextPosition和LeaderEndPosition不一定适用于所有标注（例如，标注样式为纵坐标时，使用相等约束的高程点标注、多段标注）。如果这些值不适用，它们将返回NULL，并且不允许设置值。</p>
<p>代码区域：重新定位标注文字</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Moves all of the text in this dimension one unit in the Y direction</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">DimensionTextReposition</span>(<span class="params">Dimension dimToModify</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">bool</span> modified = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (dimToModify == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check to see if we have a non-multisegment dimension and if text position is adjustable</span></span><br><span class="line">    <span class="keyword">if</span> (dimToModify.NumberOfSegments == <span class="number">0</span> &amp;&amp; dimToModify.IsTextPositionAdjustable())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Get the current text XYZ position</span></span><br><span class="line">        XYZ currentTextPosition = dimToModify.TextPosition;</span><br><span class="line">        <span class="comment">// Calculate a new XYZ position by transforming the current text position</span></span><br><span class="line">        XYZ newTextPosition = Transform.CreateTranslation(<span class="keyword">new</span> XYZ(<span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>)).OfPoint(currentTextPosition);</span><br><span class="line">        <span class="comment">// Set the new text position</span></span><br><span class="line">        dimToModify.TextPosition = newTextPosition;</span><br><span class="line"></span><br><span class="line">        modified = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (dimToModify.NumberOfSegments &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">foreach</span> (DimensionSegment currentSegment <span class="keyword">in</span> dimToModify.Segments)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (currentSegment != <span class="literal">null</span> &amp;&amp; currentSegment.IsTextPositionAdjustable())</span><br><span class="line">            &#123;</span><br><span class="line">                modified = <span class="literal">true</span>;</span><br><span class="line">                <span class="comment">// Get the current text XYZ position</span></span><br><span class="line">                XYZ currentTextPosition = currentSegment.TextPosition;</span><br><span class="line">                <span class="comment">// Calculate a new XYZ position by transforming the current text position</span></span><br><span class="line">                XYZ newTextPosition = Transform.CreateTranslation(<span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>)).OfPoint(currentTextPosition);</span><br><span class="line">                <span class="comment">// Set the new text position for the segment&#x27;s text</span></span><br><span class="line">                currentSegment.TextPosition = newTextPosition;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> modified;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="详图线"><a href="#详图线" class="headerlink" title="详图线"></a>详图线</h2><p>详图线是一种重要的详图构件，通常用于详图或绘图视图中。可以在DetailCurve类及其派生类中访问详图曲线。</p>
<p>DetailCurve与其他注释元素一样，是视图专有的。但是，没有DetailCurve.View属性。创建详图曲线时，必须将详图曲线与模型曲线视图进行比较。</p>
<p>代码区域16-4：NewDetailCurve（）和NewModelCurve（）</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> DetailCurve <span class="title">NewDetailCurve</span> (<span class="params">View, Curve, SketchPlane</span>)</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ModelCurve <span class="title">NewModelCurve</span> (<span class="params">Curve, SketchPlane</span>)</span></span><br></pre></td></tr></table></figure>

<p>通常，只有二维视图（如平面视图和立面视图）是可接受的，否则将引发异常。</p>
<p>除了与视图相关的功能外，DetailCurve与ModelCurve非常相似。有关ModelCurve属性和用法的详细信息，请参见“草图”部分中的ModelCurve。</p>
<h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><p>标签是用于标识图形元素的注释。API公开IndependentTag和RoomTag类，以涵盖Revit应用程序中使用的大多数标签。有关RoomTag的更多详细信息，请参阅房间。</p>
<p>注意：IndependentTag类表示Revit中的标签图元和其他特定标记，如注释标签、梁系统标签、电子电路符号等。在Revit内部代码中，特定标记具有从IndependentTag派生的相应类。因此，特定功能不会由API公开，并且无法使用IndependentTag.xml创建。它们可按以下类别加以区分：</p>
<p>表37：标签名称和类别</p>
<table>
<thead>
<tr>
<th><strong>Tag Name 标记名称</strong></th>
<th><strong>BuiltInCategory</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Keynote Tag</td>
<td>OST_KeynoteTags</td>
</tr>
<tr>
<td>Beam System Tag</td>
<td>OST_BeamSystemTags</td>
</tr>
<tr>
<td>Electronic Circuit Tag</td>
<td>OST_ElectricalCircuitTags</td>
</tr>
<tr>
<td>Span Direction Tag</td>
<td>OST_SpanDirectionSymbol</td>
</tr>
<tr>
<td>Path Reinforcement Span Tag</td>
<td>OST_PathReinSpanSymbol</td>
</tr>
<tr>
<td>Rebar System Span Tag</td>
<td>OST_IOSRebarSystemSpanSymbolCtrl</td>
</tr>
</tbody></table>
<p>族库中的每个类别都有一个预先制作的标记。某些标记会随默认的Revit应用程序样板自动加载，而其他标记则会手动加载。如果主体元素是使用“按类别”选项创建的，则IndependentTag对象将根据主体元素返回不同的类别。例如，Wall和Floor IndependentTag分别是OST_WallTags和OST_FloorTags。</p>
<p>如果标记是使用“Multi-Category ”或“Material”样式创建的，则它们的类别分别为OST_MultiCategoryTags和OST_MaterialTags。</p>
<p>请注意IndependentTag.Create只在2D视图或锁定的3D视图中工作，否则将引发异常。下面的代码是创建IndependentTag的示例。当标高视图为活动视图时运行该命令。</p>
<p>注意：您无法直接更改IndependentTag中显示的文本。您需要修改用于在要标记的图元的族类型中填充标记文字的参数。在下面的示例中，该参数为“Type Mark”，但可以在Revit UI的族编辑器中更改此设置。</p>
<p>代码区域16-5：创建IndependentTag</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> IndependentTag <span class="title">CreateIndependentTag</span>(<span class="params">Autodesk.Revit.DB.Document document, Reference reference</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// make sure active view is not a 3D view</span></span><br><span class="line">    Autodesk.Revit.DB.View view = document.ActiveView;</span><br><span class="line">    <span class="keyword">if</span> (view <span class="keyword">is</span> View3D)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// define tag mode and tag orientation for new tag</span></span><br><span class="line">    TagMode tagMode = TagMode.TM_ADDBY_CATEGORY;</span><br><span class="line">    TagOrientation tagorn = TagOrientation.Horizontal;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add the tag to the middle of the wall</span></span><br><span class="line">    Wall wall = document.GetElement(reference) <span class="keyword">as</span> Wall;</span><br><span class="line">    <span class="keyword">if</span> (wall == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    LocationCurve wallLoc = wall.Location <span class="keyword">as</span> LocationCurve;</span><br><span class="line">    XYZ wallStart = wallLoc.Curve.GetEndPoint(<span class="number">0</span>);</span><br><span class="line">    XYZ wallEnd = wallLoc.Curve.GetEndPoint(<span class="number">1</span>);</span><br><span class="line">    XYZ wallMid = wallLoc.Curve.Evaluate(<span class="number">0.5</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    IndependentTag newTag = IndependentTag.Create(document, view.Id, reference, <span class="literal">true</span>, tagMode, tagorn, wallMid);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> == newTag)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Create IndependentTag Failed.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// newTag.TagText is read-only, so we change the Type Mark type parameter to </span></span><br><span class="line">    <span class="comment">// set the tag text.  The label parameter for the tag family determines</span></span><br><span class="line">    <span class="comment">// what type parameter is used for the tag text.</span></span><br><span class="line"></span><br><span class="line">    WallType type = wall.WallType;</span><br><span class="line"></span><br><span class="line">    Parameter foundParameter = type.LookupParameter(<span class="string">&quot;Type Mark&quot;</span>);</span><br><span class="line">    <span class="built_in">bool</span> result = foundParameter.Set(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set leader mode free</span></span><br><span class="line">    <span class="comment">// otherwise leader end point move with elbow point</span></span><br><span class="line"></span><br><span class="line">    newTag.LeaderEndCondition = LeaderEndCondition.Free;</span><br><span class="line">    XYZ elbowPnt = wallMid + <span class="keyword">new</span> XYZ(<span class="number">5.0</span>, <span class="number">5.0</span>, <span class="number">0.0</span>);</span><br><span class="line">    newTag.LeaderElbow = elbowPnt;</span><br><span class="line">    XYZ headerPnt = wallMid + <span class="keyword">new</span> XYZ(<span class="number">10.0</span>, <span class="number">10.0</span>, <span class="number">0.0</span>);</span><br><span class="line">    newTag.TagHeadPosition = headerPnt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> newTag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-6FE76534-FEA8-4573-A2D7-747AB527B335-low.png"></p>
<p>图74：使用示例代码创建IndependentTag</p>
<h2 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h2><p>可以从TextNote类访问文本和关联的引线。注意TextNote可以包含纯文本或格式化文本。重载的TextNote.Create（）方法提供了用于创建展开和换行文本注释元素的选项。文本内容区域的宽度可以在创建时指定，但受基于文本及其类型的属性的最小和最大宽度的限制。从TextElement继承的重载方法GetMinimumAllowedWidth（）和GetMaximumAllowedWidth（）返回特定TextNote或给定文档和文本类型ID的约束。</p>
<p>下面的示例在用户指定的点处使用给定的宽度和TextNoteOptions创建一个新的TextNote。</p>
<p>代码区域：创建文本注释</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TextNote <span class="title">AddNewTextNote</span>(<span class="params">UIDocument uiDoc</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Document doc = uiDoc.Document;</span><br><span class="line">    XYZ textLoc = uiDoc.Selection.PickPoint(<span class="string">&quot;Pick a point for sample text.&quot;</span>);</span><br><span class="line">    ElementId defaultTextTypeId = doc.GetDefaultElementTypeId(ElementTypeGroup.TextNoteType);</span><br><span class="line">    <span class="built_in">double</span> noteWidth = <span class="number">.2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// make sure note width works for the text type</span></span><br><span class="line">    <span class="built_in">double</span> minWidth = TextNote.GetMinimumAllowedWidth(doc, defaultTextTypeId);</span><br><span class="line">    <span class="built_in">double</span> maxWidth = TextNote.GetMaximumAllowedWidth(doc, defaultTextTypeId);</span><br><span class="line">    <span class="keyword">if</span> (noteWidth &lt; minWidth)</span><br><span class="line">    &#123;</span><br><span class="line">        noteWidth = minWidth;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (noteWidth &gt; maxWidth)</span><br><span class="line">    &#123;</span><br><span class="line">        noteWidth = maxWidth;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TextNoteOptions opts = <span class="keyword">new</span> TextNoteOptions(defaultTextTypeId);</span><br><span class="line">    opts.HorizontalAlignment = HorizontalTextAlignment.Left;</span><br><span class="line">    opts.Rotation = Math.PI / <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    TextNote textNote = TextNote.Create(doc, doc.ActiveView.Id, textLoc, noteWidth, <span class="string">&quot;New sample text&quot;</span>, opts);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> textNote;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>无论TextNote具有纯文本还是格式化文本，始终可以从TextNote.Text属性检索未格式化的文本。</p>
<p>格式化文本 当第一次创建时，TextNote将具有纯文本。使用TextNote. GetNotedText（）方法获取TextNote的NotedText对象。类可以用于对文本应用各种格式，如粗体、下划线、上标或全部大写。在使用修改后的TextText调用SetSetNotedText（）之前，TextNote不会更新。 可以使用TextRange全部或部分地格式化已删除文本中的文本。TextRange基于TextedText对象中的文本指定起始索引和长度。当格式化方法（如SetItalicStatus（）或SetAllCapsStatus（））的重载使用TextRange时，将只修改该范围内的字符。TextRange可以使用其构造函数显式定义，也可以使用FormattedText.Find（）方法检索以获取给定搜索字符串的范围。Find（）方法指定搜索的开始索引，以及是否匹配搜索字符串的大小写或是否进行全词搜索。如果在搜索字符串中找不到文本，或者如果给定的起始索引超出了整个文本的长度，则将返回一个空的TextRange。在使用返回的范围设置文本格式之前，请确保该范围不为空，以避免异常。 下面的示例演示如何设置TextNote中的文本格式并将其设置回TextNote。它使用Find（）方法对文本中的特定单词加粗体和下划线。</p>
<p>代码区域：设置TextNote中的文本格式</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">FormatText</span>(<span class="params">TextNote textNote</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// TextNote created with &quot;New sample text&quot;</span></span><br><span class="line">    FormattedText formatText = textNote.GetFormattedText();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// italicize &quot;New&quot;</span></span><br><span class="line">    TextRange range = <span class="keyword">new</span> TextRange(<span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">    formatText.SetItalicStatus(range, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// make &quot;sample&quot; bold</span></span><br><span class="line">    range = formatText.Find(<span class="string">&quot;sample&quot;</span>, <span class="number">0</span>, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">if</span> (range.Length &gt; <span class="number">0</span>)</span><br><span class="line">        formatText.SetBoldStatus(range, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// make &quot;text&quot; underlined</span></span><br><span class="line">    range = formatText.Find(<span class="string">&quot;text&quot;</span>, <span class="number">0</span>, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">if</span> (range.Length &gt; <span class="number">0</span>)</span><br><span class="line">        formatText.SetUnderlineStatus(range, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// make all text uppercase</span></span><br><span class="line">    formatText.SetAllCapsStatus(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    textNote.SetFormattedText(formatText);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以将新文本添加到已添加文本对象中的现有文本中。如果使用了具有TextRange参数的重载，SetPlainText（）方法将替换某些现有文本，否则将替换整个文本。若要插入文本而不替换现有文本，请使用Length为0的TextRange。新文本将插入到TextRange.Start属性指定的索引处。请注意，插入文本时，它可能会选择相邻文本的格式，类似于将未格式化的文本粘贴到Word文档中将导致文本具有插入点的当前格式。如果格式设置已经应用于整个multitedText，如上面示例中的SetAllCapsStatus（true）调用，则该格式设置将应用于插入的任何新文本。 在下面的示例中，通过首先查找当前文本的结尾并将其设置为要添加的范围的开始，新文本将被追加到现有文本的结尾。它还演示了如何创建一个列表（可以是项目符号，编号或字母）。请注意，它还为新文本的范围调用GetAllCapsStatus（），并在状态不是“大写状态.无”（其他选项是“全部”和“混合”）时关闭大写。</p>
<p>代码区域：插入新文本</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AppendText</span>(<span class="params">TextNote textNote</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    FormattedText formatText = textNote.GetFormattedText();</span><br><span class="line"></span><br><span class="line">    TextRange range = formatText.AsTextRange();</span><br><span class="line"></span><br><span class="line">    range.Start = range.End - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// set Length to 0 to insert</span></span><br><span class="line">    range.Length = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">string</span> someNewText = <span class="string">&quot;\rThis is a new paragraph\vThis is a new line without a paragraph break\r&quot;</span>;</span><br><span class="line">    formatText.SetPlainText(range, someNewText);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get range for entire text</span></span><br><span class="line">    range = formatText.AsTextRange();</span><br><span class="line">    range.Start = range.End - <span class="number">1</span>;</span><br><span class="line">    range.Length = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">string</span> someListText = <span class="string">&quot;\rBulleted List item 1\rItem 2\vSecond line for Item 2\rThird bullet point&quot;</span>;</span><br><span class="line">    formatText.SetPlainText(range, someListText);</span><br><span class="line">    range.Start++;</span><br><span class="line">    range.Length = someListText.Length;</span><br><span class="line">    formatText.SetListType(range, ListType.Bullet);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (formatText.GetAllCapsStatus(range) != FormatStatus.None)</span><br><span class="line">    &#123;</span><br><span class="line">        formatText.SetAllCapsStatus(range, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    textNote.SetFormattedText(formatText);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码显示了如何使用\r创建换行符，使用\v创建不打断段落的垂直制表符。在项目符号列表的文本中，“\v”用于创建两行项目符号。仅在使用“\r”时才插入新项目符号。 </p>
<p>文本编辑器 TextEditorOptions类可用于控制Revit中文本编辑器的外观和功能。这些设置保存在Revit.ini文件中，不与文档绑定。</p>
<p>代码区域：设置文本编辑器选项</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetEditorOptions</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    TextEditorOptions editorOptions = TextEditorOptions.GetTextEditorOptions();</span><br><span class="line">    editorOptions.ShowBorder = <span class="literal">false</span>;</span><br><span class="line">    editorOptions.ShowOpaqueBackground = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="引线"><a href="#引线" class="headerlink" title="引线"></a>引线</h3><p>Revit支持两种引线：直线引线和圆弧引线。可以使用AddLeader（）方法将引线添加到TextNote，并使用TextNoteLeaderType枚举类型指定引线类型：</p>
<p>表39：引线类型</p>
<table>
<thead>
<tr>
<th><strong>Function 功能</strong></th>
<th><strong>Member Name 成员名称</strong></th>
</tr>
</thead>
<tbody><tr>
<td><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-0A443B27-ACDB-401E-8486-62165414529F-low.png" alt="img"> -添加右弧引线</td>
<td>TNLT_ARC_R</td>
</tr>
<tr>
<td><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-EE3246C4-B4F8-443D-9958-66CE5E62BB12-low.png" alt="img"> -添加左弧引线</td>
<td>TNLT_ARC_L</td>
</tr>
<tr>
<td><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-0D7DA193-EC77-4E99-A864-CA1E69BB3A62-low.png" alt="img"> -添加右引线。</td>
<td>TNLT_STRAIGHT_R</td>
</tr>
<tr>
<td><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-60BA1957-992C-468D-8459-7A26E418BF57-low.png" alt="img"> -添加左引线。</td>
<td>TNLT_STRAIGHT_L</td>
</tr>
</tbody></table>
<p>注意：直线引线和圆弧引线不能同时添加到文本类型。</p>
<p>TextNote.LeaderCount属性返回引线数，GetLeaders（）方法返回当前附加到文本组件的所有引线。LeaderLeftAttachment和LeaderRightAttachment指示引线在TextNote的相应侧上的附着位置。LeaderAttachment的选项有TopLine、MidPoint和BottomLine。使用RemoveLeaders（）方法从TextNote中删除所有引线。</p>
<h2 id="注释符号"><a href="#注释符号" class="headerlink" title="注释符号"></a>注释符号</h2><p>注释符号是应用于族的符号，用于在项目中唯一标识该族。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-75864163-28D5-496D-9077-98DFECA07E75-low.png"></p>
<p>图76：带有两条引线的注释符号</p>
<h3 id="创建和删除-1"><a href="#创建和删除-1" class="headerlink" title="创建和删除"></a>创建和删除</h3><p>可以使用Creation.Document.NewFamilyInstance（）方法的以下重载创建注释符号：</p>
<p>代码区域16-6：创建新注释符号</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> FamilyInstance NewFamilyInstance <span class="title">Method</span> (<span class="params">XYZ origin, FamilySymbol symbol, View specView</span>)</span></span><br></pre></td></tr></table></figure>

<p>可以使用Document.Delete（）方法删除注释符号。 </p>
<p>添加和删除Leader 使用addLeader（）和removeLeader（）方法添加和删除引线。</p>
<p>代码区域16-7：使用addLeader（）和removeLeader（）</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddAndRemoveLeaders</span>(<span class="params">AnnotationSymbol symbol</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// check if there are any leaders currently attached, and remove them</span></span><br><span class="line">    IList leaders = symbol.GetLeaders();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (leaders != <span class="literal">null</span> &amp;&amp; leaders.Count &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = leaders.Count; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            symbol.removeLeader();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// add one new leader instead</span></span><br><span class="line">    symbol.addLeader();&#125;</span><br></pre></td></tr></table></figure>

<h2 id="注：翻译自Revit-API-Developers-Guide"><a href="#注：翻译自Revit-API-Developers-Guide" class="headerlink" title="注：翻译自Revit API Developers Guide"></a><em><strong>注：</strong></em>翻译自<a href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_html">Revit API Developers Guide</a></h2>]]></content>
      <categories>
        <category>Revit二次开发人员指南</category>
      </categories>
      <tags>
        <tag>Revit</tag>
      </tags>
  </entry>
  <entry>
    <title>16基准和信息元素</title>
    <url>/2024/12/06/%E4%BA%8C%E5%BC%80%E6%8C%87%E5%8D%97/16%E5%9F%BA%E5%87%86%E5%92%8C%E4%BF%A1%E6%81%AF%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<h1 id="基准和信息元素"><a href="#基准和信息元素" class="headerlink" title="基准和信息元素"></a><a href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_Revit_Geometric_Elements_Datum_and_Information_Elements_html">基准和信息元素</a></h1><p>本章介绍Revit中的基准元素和信息元素。</p>
<ul>
<li>基准元素包括标高、轴网和模型线。</li>
<li>信息元素包括阶段、设计选项和EnergyDataSettings。</li>
</ul>
<p>有关Revit图元分类的详细信息，请参见图元要素。</p>
<p>注：如果您需要更多信息，请参阅相关章节：</p>
<ul>
<li>有关荷载基础、荷载工况、荷载组合、荷载性质和荷载用途，请参阅结构工程</li>
<li>对于模型曲线，请参阅草图</li>
<li>对于材质和填充图案，请参阅材质</li>
<li>有关能量数据设置，请参阅能量数据</li>
</ul>
<p>本节中的页面</p>
<ul>
<li>Levels 标高</li>
<li>Grids 轴网</li>
<li>Phase 阶段</li>
<li>Design Options 设计选项</li>
</ul>
<h2 id="标高"><a href="#标高" class="headerlink" title="标高"></a>标高</h2><p>标高是一个有限的水平面，用作以标高为主体的图元（如墙、屋顶、楼板和天花板）的参照。</p>
<p>在Revit Platform API中，Level类派生自DatumPlane类，而DatumPlane类派生自Element类。继承的Name属性用于检索Revit UI中标高编号旁边的用户可见标高名称。若要检索项目中的所有标高，请将ElementClassFilter与Level类一起使用。</p>
<h3 id="高程"><a href="#高程" class="headerlink" title="高程"></a>高程</h3><p>Level类具有以下属性：</p>
<ul>
<li>“高程”特性用于检索或更改高于或低于地平面的高程。</li>
<li>ProjectElevation属性用于检索相对于项目原点的高程，而不考虑高程基准参数值。</li>
<li>“高程基准”值是一个标高类型参数。<ul>
<li>它的内置参数是LEVEL_RELATIVE_BASE_TYPE。</li>
<li>它的类型是整型</li>
<li>0对应于项目，1对应于共享。</li>
</ul>
</li>
</ul>
<p>下面的代码示例阐释如何使用Level类筛选器检索项目中的所有标高。</p>
<p>代码区域15-1：检索所有标高</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Getinfo_Level</span>(<span class="params">Document document</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        StringBuilder levelInformation = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="built_in">int</span> levelNumber = <span class="number">0</span>;</span><br><span class="line">        FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">        ICollection collection = collector.OfClass(<span class="keyword">typeof</span>(Level)).ToElements();</span><br><span class="line">        <span class="keyword">foreach</span> (Element e <span class="keyword">in</span> collection)</span><br><span class="line">        &#123;</span><br><span class="line">                Level level = e <span class="keyword">as</span> Level;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">null</span> != level)</span><br><span class="line">                &#123;</span><br><span class="line">                        <span class="comment">// keep track of number of levels</span></span><br><span class="line">                        levelNumber++;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//get the name of the level</span></span><br><span class="line">                        levelInformation.Append(<span class="string">&quot;\nLevel Name: &quot;</span> + level.Name);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//get the elevation of the level</span></span><br><span class="line">                        levelInformation.Append(<span class="string">&quot;\n\tElevation: &quot;</span> + level.Elevation);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// get the project elevation of the level</span></span><br><span class="line">                        levelInformation.Append(<span class="string">&quot;\n\tProject Elevation: &quot;</span> + level.ProjectElevation);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//number of total levels in current document</span></span><br><span class="line">        levelInformation.Append(<span class="string">&quot;\n\n There are &quot;</span> + levelNumber + <span class="string">&quot; levels in the document!&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//show the level information in the messagebox</span></span><br><span class="line">        TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>,levelInformation.ToString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="创造标高"><a href="#创造标高" class="headerlink" title="创造标高"></a>创造标高</h3><p>使用“标高”命令，可以定义建筑内的垂直高度或楼层，还可以为每个现有楼层或其他建筑参照创建标高。必须在剖面视图或立面视图中添加标高。此外，还可以使用Revit平台API创建新标高。</p>
<p>下面的代码示例阐释如何创建新标高。</p>
<p>代码区域15-2：创建新标高</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function">Level <span class="title">CreateLevel</span>(<span class="params">Autodesk.Revit.DB.Document document</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// The elevation to apply to the new level</span></span><br><span class="line">    <span class="built_in">double</span> elevation = <span class="number">20.0</span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Begin to create a level</span></span><br><span class="line">    Level level = Level.Create(document, elevation);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> == level)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Create a new level failed.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Change the level name</span></span><br><span class="line">    level.Name = <span class="string">&quot;New level&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> level;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：创建新标高后，Revit不会为此标高创建关联的平面视图。如果有必要，您可以自己创建。有关如何创建平面视图的详细信息，请参见平面视图。</p>
<h2 id="轴网"><a href="#轴网" class="headerlink" title="轴网"></a>轴网</h2><p>Grid类表示Autodesk Revit中的一条轴网线。</p>
<p>网格由Grid类表示，Grid类派生自DatumPlane类，DatumPlane类派生自Element类。它包含所有网格属性和方法。继承的Name属性用于检索网格线的内容。</p>
<h3 id="曲线"><a href="#曲线" class="headerlink" title="曲线"></a>曲线</h3><p>Grid类Curve属性获取表示网格线几何图形的对象。</p>
<ul>
<li>如果IsCurved属性返回true，则Curve属性将是Arc类对象。</li>
<li>如果IsCurved属性返回false，则Curve属性将是Line类对象。</li>
</ul>
<p>有关详细信息，请参考几何图形。</p>
<p>下面的代码是一个使用Grid类的简单示例。调用命令后，结果将显示在消息框中。</p>
<p>代码区域15-3：使用Grid类</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetInfo_Grid</span>(<span class="params">Grid grid</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> message = <span class="string">&quot;Grid : &quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Show IsCurved property</span></span><br><span class="line">    message += <span class="string">&quot;\nIf grid is Arc : &quot;</span> + grid.IsCurved;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Show Curve information</span></span><br><span class="line">    Autodesk.Revit.DB.Curve curve = grid.Curve;</span><br><span class="line">    <span class="keyword">if</span> (grid.IsCurved)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// if the curve is an arc, give center and radius information</span></span><br><span class="line">        Autodesk.Revit.DB.Arc arc = curve <span class="keyword">as</span> Autodesk.Revit.DB.Arc;</span><br><span class="line">        message += <span class="string">&quot;\nArc&#x27;s radius: &quot;</span> + arc.Radius;</span><br><span class="line">        message += <span class="string">&quot;\nArc&#x27;s center:  (&quot;</span> + XYZToString(arc.Center);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// if the curve is a line, give length information</span></span><br><span class="line">        Autodesk.Revit.DB.Line line = curve <span class="keyword">as</span> Autodesk.Revit.DB.Line;</span><br><span class="line">        message += <span class="string">&quot;\nLine&#x27;s Length: &quot;</span> + line.Length;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Get curve start point</span></span><br><span class="line">    message += <span class="string">&quot;\nStart point: &quot;</span> + XYZToString(curve.GetEndPoint(<span class="number">0</span>));</span><br><span class="line">    <span class="comment">// Get curve end point</span></span><br><span class="line">    message += <span class="string">&quot;; End point: &quot;</span> + XYZToString(curve.GetEndPoint(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>,message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// output the point&#x27;s three coordinates</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">XYZToString</span>(<span class="params">XYZ point</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;(&quot;</span> + point.X + <span class="string">&quot;, &quot;</span> + point.Y + <span class="string">&quot;, &quot;</span> + point.Z + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="创建轴网"><a href="#创建轴网" class="headerlink" title="创建轴网"></a>创建轴网</h3><p>Grid类中有两个重载的Create（）方法可用于在Revit Platform API中创建新的轴网。使用以下方法和不同的参数，可以创建曲线或直线格线：</p>
<p>代码区域15-4：Grid.Create（）</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Grid <span class="title">Create</span>(<span class="params"> Document document, Arc arc </span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Grid <span class="title">Create</span>(<span class="params"> Document document, Line line </span>)</span>;</span><br></pre></td></tr></table></figure>

<p>注意：用于创建网格的弧或线必须位于水平面内。</p>
<p>下面的代码示例演示如何创建带有直线或圆弧的新轴网。</p>
<p>代码区域15-5：使用直线或圆弧创建网格</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateGrid</span>(<span class="params">Autodesk.Revit.DB.Document document</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Create the geometry line which the grid locates</span></span><br><span class="line">    XYZ start = <span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    XYZ end = <span class="keyword">new</span> XYZ(<span class="number">30</span>, <span class="number">30</span>, <span class="number">0</span>);</span><br><span class="line">    Line geomLine = Line.CreateBound(start, end);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create a grid using the geometry line</span></span><br><span class="line">    Grid lineGrid = Grid.Create(document, geomLine);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> == lineGrid)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Create a new straight grid failed.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Modify the name of the created grid</span></span><br><span class="line">    lineGrid.Name = <span class="string">&quot;New Name1&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create the geometry arc which the grid locates</span></span><br><span class="line">    XYZ end0 = <span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    XYZ end1 = <span class="keyword">new</span> XYZ(<span class="number">10</span>, <span class="number">40</span>, <span class="number">0</span>);</span><br><span class="line">    XYZ pointOnCurve = <span class="keyword">new</span> XYZ(<span class="number">5</span>, <span class="number">7</span>, <span class="number">0</span>);</span><br><span class="line">    Arc geomArc = Arc.Create(end0, end1, pointOnCurve);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create a grid using the geometry arc</span></span><br><span class="line">    Grid arcGrid = Grid.Create(document, geomArc);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> == arcGrid)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Create a new curved grid failed.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Modify the name of the created grid</span></span><br><span class="line">    arcGrid.Name = <span class="string">&quot;New Name2&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：在Revit中，创建轴网时，轴网将自动按数字或字母顺序命名。</p>
<h2 id="阶段"><a href="#阶段" class="headerlink" title="阶段"></a>阶段</h2><p>一些建筑项目，如翻新，分阶段进行。阶段具有以下特征：</p>
<ul>
<li>阶段表示项目生命周期中的不同时间段。</li>
<li>建筑物内图元的寿命由阶段控制。</li>
<li>每个元素都有一个构造阶段，但只有具有有限寿命的元素才有一个破坏阶段。</li>
</ul>
<p>项目中的所有阶段都可以从Document对象中检索。Phase对象包含三个有用的信息：Name、ID和UniqueId。其余属性始终返回null或空集合。</p>
<p>添加到项目中的每个新建模构件都具有“创建的阶段ID”和“拆除的阶段ID”特性。Element.AllowPhases（）方法指示是否可以修改其阶段ID属性。</p>
<p>“创建的阶段ID”特性具有以下特征：</p>
<ul>
<li>它标识添加组件的阶段。</li>
<li>默认值为与当前视图“阶段”值相同的ID。</li>
<li>通过选择与下拉列表相对应的新值来更改“创建的阶段ID”参数。</li>
</ul>
<p>已拆除阶段ID属性具有以下特征：</p>
<ul>
<li>它标识在哪个阶段拆除构件。</li>
<li>默认值为无。</li>
<li>使用拆除工具拆除构件会将特性更新为拆除图元所在视图中的当前阶段ID值。</li>
<li>可以通过将“已拆除的阶段ID”特性设置为其他值来拆除构件。</li>
<li>如果使用Revit Platform API删除某个阶段，则当前阶段中的所有建模构件仍然存在。这些元件的“创建的阶段ID”参数值将更改为“特性”对话框下拉列表中的下一项。 <img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-3840696A-98D6-4898-8004-EFB85A3247E1-low.png" alt="img"></li>
</ul>
<p>图65：阶段创建的组件参数值</p>
<p>下面的代码示例显示当前文档中支持的所有阶段。阶段名称显示在消息框中。</p>
<p>代码区域15-6：展示所有支持的阶段</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Getinfo_Phase</span>(<span class="params">Document doc</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">// Get the phase array which contains all the phases.</span></span><br><span class="line">        PhaseArray phases = doc.Phases;</span><br><span class="line">        <span class="comment">// Format the string which identifies all supported phases in the current document.</span></span><br><span class="line">        String prompt = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> != phases.Size)</span><br><span class="line">        &#123;</span><br><span class="line">                prompt = <span class="string">&quot;All the phases in current document list as follow:&quot;</span>;</span><br><span class="line">                <span class="keyword">foreach</span> (Phase ii <span class="keyword">in</span> phases)</span><br><span class="line">                &#123;</span><br><span class="line">                        prompt += <span class="string">&quot;\n\t&quot;</span> + ii.Name;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">                prompt = <span class="string">&quot;There are no phases in current document.&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Give the user the information.</span></span><br><span class="line">        TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>,prompt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="设计选项"><a href="#设计选项" class="headerlink" title="设计选项"></a>设计选项</h2><p>设计选项提供了一种在项目中探索备选设计的方法。</p>
<p>设计选项提供了适应项目范围变化或开发供审查的替代设计的灵活性。您可以开始使用主项目模型，然后沿着向客户展示的方式开发变体。大多数图元都可以添加到设计选项中。不能添加到设计选项中的图元被视为主模型的一部分，并且没有设计备选方案。</p>
<p>设计选项的主要用途是作为元素类的属性。请参阅以下示例。</p>
<p>代码区域15-7：使用设计选项</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Getinfo_DesignOption</span>(<span class="params">Document document</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Get the selected Elements in the Active Document</span></span><br><span class="line">    UIDocument uidoc = <span class="keyword">new</span> UIDocument(document);</span><br><span class="line">    ICollection selectedIds = uidoc.Selection.GetElementIds();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">foreach</span> (ElementId id <span class="keyword">in</span> selectedIds)</span><br><span class="line">    &#123;</span><br><span class="line">        Element element = document.GetElement(id);</span><br><span class="line">        <span class="comment">//Use the DesignOption property of Element</span></span><br><span class="line">        <span class="keyword">if</span> (element.DesignOption != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>,element.DesignOption.Name.ToString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下规则适用于设计选项</p>
<ul>
<li>如果元素位于主模型中，则DesignOption属性的值为null。否则，将返回在Revit UI中创建的名称。</li>
<li>ActiveDocument中只能存在一个活动DesignOption元素。<ul>
<li>主选项被视为默认的活动DesignOption。例如，一个设计选项集名为“墙”，该设计选项集中有两个设计选项，分别名为“砖墙”和“玻璃墙”。如果“砖墙”是主选项，则元素迭代器只检索此选项和属于它的元素。“玻璃墙”不活跃。</li>
</ul>
</li>
</ul>
<h2 id="注：翻译自Revit-API-Developers-Guide"><a href="#注：翻译自Revit-API-Developers-Guide" class="headerlink" title="注：翻译自Revit API Developers Guide"></a><em><strong>注：</strong></em>翻译自<a href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_html">Revit API Developers Guide</a></h2>]]></content>
      <categories>
        <category>Revit二次开发人员指南</category>
      </categories>
      <tags>
        <tag>Revit</tag>
      </tags>
  </entry>
  <entry>
    <title>15概念设计</title>
    <url>/2024/12/05/%E4%BA%8C%E5%BC%80%E6%8C%87%E5%8D%97/15%E6%A6%82%E5%BF%B5%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<h1 id="概念设计"><a href="#概念设计" class="headerlink" title="概念设计"></a><a href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_Revit_Geometric_Elements_Conceptual_Design_html">概念设计</a></h1><p>本章讨论用于在族文档中创建复杂几何图形的Revit API的概念设计功能。通过添加新对象（点和通过这些点的样条曲线）来支持形状制作。可以分割、填充图案和嵌板化生成的曲面，以创建具有持久参数关系的可构建形状。</p>
<p>本节中的页面</p>
<ul>
<li>点和曲线对象</li>
<li>形状</li>
<li>曲面的几何化</li>
<li>自适应构件</li>
<li>创建.addin清单文件</li>
</ul>
<h2 id="点和曲线对象"><a href="#点和曲线对象" class="headerlink" title="点和曲线对象"></a>点和曲线对象</h2><p>参照点是在概念设计环境的XYZ工作空间中指定位置的元素。可以创建参照点来设计和打印直线、样条曲线和形状。可以将ReferencePoint添加到ReferencePointArray，然后用于创建CurveByPoints，而CurveByPoints又可用于创建形状。</p>
<p>下面的示例演示如何创建CurveByPoints对象。请参见下一节中的“创建放样形状”示例，了解如何从多个CurveByPoints对象创建形状。</p>
<p>代码区域14-1：创建新的CurveByPoints</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//体量中创建</span></span><br><span class="line">ReferencePointArray rpa = <span class="keyword">new</span> ReferencePointArray();</span><br><span class="line"></span><br><span class="line">XYZ xyz = document.Application.Create.NewXYZ(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">ReferencePoint rp = document.FamilyCreate.NewReferencePoint(xyz);</span><br><span class="line">rpa.Append(rp);</span><br><span class="line"></span><br><span class="line">xyz = document.Application.Create.NewXYZ(<span class="number">0</span>, <span class="number">30</span>, <span class="number">10</span>);</span><br><span class="line">rp = document.FamilyCreate.NewReferencePoint(xyz);</span><br><span class="line">rpa.Append(rp);</span><br><span class="line"></span><br><span class="line">xyz = document.Application.Create.NewXYZ(<span class="number">0</span>, <span class="number">60</span>, <span class="number">0</span>);</span><br><span class="line">rp = document.FamilyCreate.NewReferencePoint(xyz);</span><br><span class="line">rpa.Append(rp);</span><br><span class="line"></span><br><span class="line">xyz = document.Application.Create.NewXYZ(<span class="number">0</span>, <span class="number">100</span>, <span class="number">30</span>);</span><br><span class="line">rp = document.FamilyCreate.NewReferencePoint(xyz);</span><br><span class="line">rpa.Append(rp);</span><br><span class="line"></span><br><span class="line">xyz = document.Application.Create.NewXYZ(<span class="number">0</span>, <span class="number">150</span>, <span class="number">0</span>);</span><br><span class="line">rp = document.FamilyCreate.NewReferencePoint(xyz);</span><br><span class="line">rpa.Append(rp);</span><br><span class="line"></span><br><span class="line">CurveByPoints curve = document.FamilyCreate.NewCurveByPoints(rpa);</span><br></pre></td></tr></table></figure>

<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-91A84A22-3B88-45F4-B7CE-8D75F685A95A-low.png"></p>
<p>图54：CurveByPoints曲线</p>
<p>参照点可以基于XYZ坐标创建，如上例所示，也可以相对于其他几何图元创建，以便当参照几何图元更改时，这些点会移动。这些点使用PointElementReference类的子类创建。这些子类是：</p>
<ul>
<li>PointOnEdge</li>
<li>PointOnEdgeEdgeIntersection</li>
<li>PointOnEdgeFaceIntersection</li>
<li>PointOnFace</li>
<li>PointOnPlane</li>
</ul>
<p>例如，上一个示例中的最后两行代码在CurveByPoints的中间创建了一个参考点。</p>
<p>可以使用模型线或参照线创建形状。模型线在创建过程中由形状“使用”，不再作为单独的图元存在。另一方面，参照线在形状创建后仍然存在，如果移动它们，可能会改变形状。虽然API没有ReferenceLine类，但可以使用ModelCurve.ChangeToReferenceLine（）方法将模型线更改为参考线。</p>
<p>代码区域14-2：使用参照线创建形状</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//demo失败（报错，无效操作）</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> FormArray <span class="title">CreateRevolveForm</span>(<span class="params">Document document</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    FormArray revolveForms = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create one profile</span></span><br><span class="line">    ReferenceArray ref_ar = <span class="keyword">new</span> ReferenceArray();</span><br><span class="line"></span><br><span class="line">    XYZ ptA = <span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">    XYZ ptB = <span class="keyword">new</span> XYZ(<span class="number">100</span>, <span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">    Line line = Line.CreateBound(ptA, ptB);</span><br><span class="line">    ModelCurve modelcurve = MakeLine(document, ptA, ptB);</span><br><span class="line">    ref_ar.Append(modelcurve.GeometryCurve.Reference);</span><br><span class="line"></span><br><span class="line">    ptA = <span class="keyword">new</span> XYZ(<span class="number">100</span>, <span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">    ptB = <span class="keyword">new</span> XYZ(<span class="number">100</span>, <span class="number">100</span>, <span class="number">10</span>);</span><br><span class="line">    modelcurve = MakeLine(document, ptA, ptB);</span><br><span class="line">    ref_ar.Append(modelcurve.GeometryCurve.Reference);</span><br><span class="line"></span><br><span class="line">    ptA = <span class="keyword">new</span> XYZ(<span class="number">100</span>, <span class="number">100</span>, <span class="number">10</span>);</span><br><span class="line">    ptB = <span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">    modelcurve = MakeLine(document, ptA, ptB);</span><br><span class="line">    ref_ar.Append(modelcurve.GeometryCurve.Reference);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create axis for revolve form</span></span><br><span class="line">    ptA = <span class="keyword">new</span> XYZ(<span class="number">-5</span>, <span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">    ptB = <span class="keyword">new</span> XYZ(<span class="number">-5</span>, <span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line">    ModelCurve axis = MakeLine(document, ptA, ptB);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// make axis a Reference Line</span></span><br><span class="line">    axis.ChangeToReferenceLine();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Typically this operation produces only a single form, </span></span><br><span class="line">    <span class="comment">// but some combinations of arguments will create multiple froms from a single profile.</span></span><br><span class="line">    revolveForms = document.FamilyCreate.NewRevolveForms(<span class="literal">true</span>, ref_ar, axis.GeometryCurve.Reference, <span class="number">0</span>, Math.PI / <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> revolveForms;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelCurve <span class="title">MakeLine</span>(<span class="params">Document doc, XYZ ptA, XYZ ptB</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Autodesk.Revit.ApplicationServices.Application app = doc.Application;</span><br><span class="line">    <span class="comment">// Create plane by the points</span></span><br><span class="line">    Line line = Line.CreateBound(ptA, ptB);</span><br><span class="line">    XYZ norm = ptA.CrossProduct(ptB);</span><br><span class="line">    <span class="keyword">if</span> (norm.IsZeroLength()) norm = XYZ.BasisZ;</span><br><span class="line">    Plane plane = Plane.CreateByNormalAndOrigin(norm, ptB);</span><br><span class="line">    SketchPlane skplane = SketchPlane.Create(doc, plane);</span><br><span class="line">    <span class="comment">// Create line here</span></span><br><span class="line">    ModelCurve modelcurve = doc.FamilyCreate.NewModelCurve(line, skplane);</span><br><span class="line">    <span class="keyword">return</span> modelcurve;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-F5F29826-D2EA-4007-8C3F-8F30975261C4-low.png"></p>
<p>图55：生成的Revolve表单</p>
<h2 id="形状"><a href="#形状" class="headerlink" title="形状"></a>形状</h2><h3 id="创建形状"><a href="#创建形状" class="headerlink" title="创建形状"></a>创建形状</h3><p>与族创建类似，概念设计环境提供了创建新形状的功能。可以创建以下类型的形状：拉伸、旋转、放样、放样融合、放样和曲面形状。体量族不使用族创建中使用的“混合”、“拉伸”、“旋转”、“放样”和“放样融合”类，而是将“形状”类用于所有类型的形状。</p>
<p>拉伸形状是从平面的闭合曲线回路创建的。旋转形状是根据轮廓和与轮廓在同一平面上的直线创建的，轮廓是围绕其旋转形状以创建三维形状的轴。放样形状是从沿沿着平面路径放样的二维轮廓创建的。放样融合是从多个轮廓创建的，每个轮廓都是平面的，沿沿着单个曲线放样。放样形状由位于不同平面上的两个或多个截面轮廓创建。单个曲面形状是从轮廓创建的，类似于拉伸，但不指定高度。</p>
<p>下面的示例创建一个简单的拉伸形状。请注意，由于用于创建形状的ModelCurves不会转换为参照线，因此它们将由生成的形状使用。</p>
<p>代码区域14-3：创建拉伸形状</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Form <span class="title">CreateExtrusionForm</span>(<span class="params">Autodesk.Revit.DB.Document document</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Form extrusionForm = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create one profile</span></span><br><span class="line">    ReferenceArray ref_ar = <span class="keyword">new</span> ReferenceArray();</span><br><span class="line"></span><br><span class="line">    XYZ ptA = <span class="keyword">new</span> XYZ(<span class="number">10</span>, <span class="number">10</span>, <span class="number">0</span>);</span><br><span class="line">    XYZ ptB = <span class="keyword">new</span> XYZ(<span class="number">90</span>, <span class="number">10</span>, <span class="number">0</span>);</span><br><span class="line">    ModelCurve modelcurve = MakeLine(document, ptA, ptB);</span><br><span class="line">    ref_ar.Append(modelcurve.GeometryCurve.Reference);</span><br><span class="line"></span><br><span class="line">    ptA = <span class="keyword">new</span> XYZ(<span class="number">90</span>, <span class="number">10</span>, <span class="number">0</span>);</span><br><span class="line">    ptB = <span class="keyword">new</span> XYZ(<span class="number">10</span>, <span class="number">90</span>, <span class="number">0</span>);</span><br><span class="line">    modelcurve = MakeLine(document, ptA, ptB);</span><br><span class="line">    ref_ar.Append(modelcurve.GeometryCurve.Reference);</span><br><span class="line"></span><br><span class="line">    ptA = <span class="keyword">new</span> XYZ(<span class="number">10</span>, <span class="number">90</span>, <span class="number">0</span>);</span><br><span class="line">    ptB = <span class="keyword">new</span> XYZ(<span class="number">10</span>, <span class="number">10</span>, <span class="number">0</span>);</span><br><span class="line">    modelcurve = MakeLine(document, ptA, ptB);</span><br><span class="line">    ref_ar.Append(modelcurve.GeometryCurve.Reference);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The extrusion form direction</span></span><br><span class="line">    XYZ direction = <span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">0</span>, <span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">    extrusionForm = document.FamilyCreate.NewExtrusionForm(<span class="literal">true</span>, ref_ar, direction);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> profileCount = extrusionForm.ProfileCount;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> extrusionForm;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelCurve <span class="title">MakeLine</span>(<span class="params">Document doc, XYZ ptA, XYZ ptB</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Autodesk.Revit.ApplicationServices.Application app = doc.Application;</span><br><span class="line">    <span class="comment">// Create plane by the points</span></span><br><span class="line">    Line line = Line.CreateBound(ptA, ptB);</span><br><span class="line">    XYZ norm = ptA.CrossProduct(ptB);</span><br><span class="line">    <span class="keyword">if</span> (norm.IsZeroLength()) norm = XYZ.BasisZ;</span><br><span class="line">    Plane plane = Plane.CreateByNormalAndOrigin(norm, ptB);</span><br><span class="line">    SketchPlane skplane = SketchPlane.Create(doc, plane);</span><br><span class="line">    <span class="comment">// Create line here</span></span><br><span class="line">    ModelCurve modelcurve = doc.FamilyCreate.NewModelCurve(line, skplane);</span><br><span class="line">    <span class="keyword">return</span> modelcurve;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-ACA912B3-A871-4886-8600-A95C293FB2D5-low.png"></p>
<p>图56：所得拉伸形状</p>
<p>下面的示例显示如何使用一系列CurveByPoints对象创建放样形状。</p>
<p>代码区域14-4：创建放样形状</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Form <span class="title">CreateLoftForm</span>(<span class="params">Autodesk.Revit.Document document</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        Form loftForm = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        ReferencePointArray rpa = <span class="keyword">new</span> ReferencePointArray();</span><br><span class="line">        ReferenceArrayArray ref_ar_ar = <span class="keyword">new</span> ReferenceArrayArray();</span><br><span class="line">        ReferenceArray ref_ar = <span class="keyword">new</span> ReferenceArray();</span><br><span class="line">        ReferencePoint rp = <span class="literal">null</span>;</span><br><span class="line">        XYZ xyz = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// make first profile curve for loft</span></span><br><span class="line">        xyz = document.Application.Create.NewXYZ(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        rp = document.FamilyCreate.NewReferencePoint(xyz);</span><br><span class="line">        rpa.Append(rp);</span><br><span class="line"></span><br><span class="line">        xyz = document.Application.Create.NewXYZ(<span class="number">0</span>, <span class="number">50</span>, <span class="number">10</span>);</span><br><span class="line">        rp = document.FamilyCreate.NewReferencePoint(xyz);</span><br><span class="line">        rpa.Append(rp);</span><br><span class="line"></span><br><span class="line">        xyz = document.Application.Create.NewXYZ(<span class="number">0</span>, <span class="number">100</span>, <span class="number">0</span>);</span><br><span class="line">        rp = document.FamilyCreate.NewReferencePoint(xyz);</span><br><span class="line">        rpa.Append(rp);</span><br><span class="line"></span><br><span class="line">        CurveByPoints cbp = document.FamilyCreate.NewCurveByPoints(rpa);</span><br><span class="line">        ref_ar.Append(cbp.GeometryCurve.Reference);</span><br><span class="line">        ref_ar_ar.Append(ref_ar);</span><br><span class="line">        rpa.Clear();</span><br><span class="line">        ref_ar = <span class="keyword">new</span> ReferenceArray();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// make second profile curve for loft</span></span><br><span class="line">        xyz = document.Application.Create.NewXYZ(<span class="number">50</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        rp = document.FamilyCreate.NewReferencePoint(xyz);</span><br><span class="line">        rpa.Append(rp);</span><br><span class="line"></span><br><span class="line">        xyz = document.Application.Create.NewXYZ(<span class="number">50</span>, <span class="number">50</span>, <span class="number">30</span>);</span><br><span class="line">        rp = document.FamilyCreate.NewReferencePoint(xyz);</span><br><span class="line">        rpa.Append(rp);</span><br><span class="line"></span><br><span class="line">        xyz = document.Application.Create.NewXYZ(<span class="number">50</span>, <span class="number">100</span>, <span class="number">0</span>);</span><br><span class="line">        rp = document.FamilyCreate.NewReferencePoint(xyz);</span><br><span class="line">        rpa.Append(rp);</span><br><span class="line"></span><br><span class="line">        cbp = document.FamilyCreate.NewCurveByPoints(rpa);</span><br><span class="line">        ref_ar.Append(cbp.GeometryCurve.Reference);</span><br><span class="line">        ref_ar_ar.Append(ref_ar);</span><br><span class="line">        rpa.Clear();</span><br><span class="line">        ref_ar = <span class="keyword">new</span> ReferenceArray();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// make third profile curve for loft</span></span><br><span class="line">        xyz = document.Application.Create.NewXYZ(<span class="number">75</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        rp = document.FamilyCreate.NewReferencePoint(xyz);</span><br><span class="line">        rpa.Append(rp);</span><br><span class="line"></span><br><span class="line">        xyz = document.Application.Create.NewXYZ(<span class="number">75</span>, <span class="number">50</span>, <span class="number">5</span>);</span><br><span class="line">        rp = document.FamilyCreate.NewReferencePoint(xyz);</span><br><span class="line">        rpa.Append(rp);</span><br><span class="line"></span><br><span class="line">        xyz = document.Application.Create.NewXYZ(<span class="number">75</span>, <span class="number">100</span>, <span class="number">0</span>);</span><br><span class="line">        rp = document.FamilyCreate.NewReferencePoint(xyz);</span><br><span class="line">        rpa.Append(rp);</span><br><span class="line"></span><br><span class="line">        cbp = document.FamilyCreate.NewCurveByPoints(rpa);</span><br><span class="line">        ref_ar.Append(cbp.GeometryCurve.Reference);</span><br><span class="line">        ref_ar_ar.Append(ref_ar);</span><br><span class="line"></span><br><span class="line">        loftForm = document.FamilyCreate.NewLoftForm(<span class="literal">true</span>, ref_ar_ar);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> loftForm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-8F7F53FC-51B6-4547-86C4-709C11B72FCA-low.png"></p>
<p>图57：生成的放样形状</p>
<h3 id="形状修改"><a href="#形状修改" class="headerlink" title="形状修改"></a>形状修改</h3><p>一旦创建，可以通过改变形状的子元素（即面、边、曲线或顶点）或整个轮廓来修改形状。修改表单的方法包括：</p>
<ul>
<li>AddEdge</li>
<li>AddProfile</li>
<li>DeleteProfile</li>
<li>DeleteSubElement</li>
<li>MoveProfile </li>
<li>MoveSubElement </li>
<li>RotateProfile</li>
<li>RotateSubElement</li>
<li>ScaleSubElement</li>
</ul>
<p>此外，可以通过添加边或轮廓来修改形状，然后可以使用上面列出的方法进行修改。</p>
<p>下面的示例将给定形状的第一条轮廓曲线移动指定的偏移量。相应的图显示了将此代码应用于上一个示例中的放样形式的结果。</p>
<p>代码区域14-5：移动轮廓</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">MoveForm</span>(<span class="params">Form form</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="built_in">int</span> profileCount = form.ProfileCount;</span><br><span class="line">        <span class="keyword">if</span> (form.ProfileCount &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">int</span> profileIndex = <span class="number">0</span>;   <span class="comment">// modify the first form only</span></span><br><span class="line">                <span class="keyword">if</span> (form.CanManipulateProfile(profileIndex))</span><br><span class="line">                &#123;</span><br><span class="line">                XYZ offset = <span class="keyword">new</span> XYZ(<span class="number">-25</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">                form.MoveProfile(profileIndex, offset);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-BCA27D2B-71B9-40CE-A94E-2858C22B8A08-low.png"></p>
<p>图58：修改后的放样形式</p>
<p>下一个示例演示如何移动给定形状的单个顶点。相应的图演示了此代码对前面的拉伸形状示例的影响</p>
<p>代码区域14-6：移动子元素</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">MoveSubElement</span>(<span class="params">Form form</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">if</span> (form.ProfileCount &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">int</span> profileIndex = <span class="number">0</span>;   <span class="comment">// get first profile</span></span><br><span class="line">                ReferenceArray ra = form.get_CurveLoopReferencesOnProfile(profileIndex, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">foreach</span> (Reference r <span class="keyword">in</span> ra)</span><br><span class="line">                &#123;</span><br><span class="line">                        ReferenceArray ra2 = form.GetControlPoints(r);</span><br><span class="line">                        <span class="keyword">foreach</span> (Reference r2 <span class="keyword">in</span> ra2)</span><br><span class="line">                        &#123;</span><br><span class="line">                                Point vertex = document.GetElement(r2).GetGeometryObjectFromReference(r2) <span class="keyword">as</span> Point;</span><br><span class="line"></span><br><span class="line">                                XYZ offset = <span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">15</span>, <span class="number">0</span>);</span><br><span class="line">                                form.MoveSubElement(r2, offset);</span><br><span class="line">                                <span class="keyword">break</span>;  <span class="comment">// just move the first point</span></span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>图59：修改拉伸的形状</p>
<h2 id="表面的几何化"><a href="#表面的几何化" class="headerlink" title="表面的几何化"></a>表面的几何化</h2><h3 id="分割表面"><a href="#分割表面" class="headerlink" title="分割表面"></a>分割表面</h3><p>形状的面可以用UV网格划分。可以使用DividedSurface.GetReferencesWithDividedSurface（）和DividedSurface.GetDividedSurfaceForReference（）方法（如后续示例所示）访问分割曲面的数据，也可以在形状上创建新的分割曲面，如下所示。</p>
<p>代码区域14-7：划分表面</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DivideSurface</span>(<span class="params">Document document, Form form</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Autodesk.Revit.ApplicationServices.Application application = document.Application;</span><br><span class="line">    Options opt = application.Create.NewGeometryOptions();</span><br><span class="line">    opt.ComputeReferences = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    Autodesk.Revit.DB.GeometryElement geomElem = form.get_Geometry(opt);</span><br><span class="line">    <span class="keyword">foreach</span> (GeometryObject geomObj <span class="keyword">in</span> geomElem)</span><br><span class="line">    &#123;</span><br><span class="line">        Solid solid = geomObj <span class="keyword">as</span> Solid;</span><br><span class="line">        <span class="keyword">foreach</span> (Face face <span class="keyword">in</span> solid.Faces)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (face.Reference != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                DividedSurface ds = DividedSurface.Create(document,face.Reference);</span><br><span class="line">                <span class="comment">// create a divided surface with fixed number of U and V grid lines</span></span><br><span class="line">                SpacingRule srU = ds.USpacingRule;</span><br><span class="line">                srU.SetLayoutFixedNumber(<span class="number">16</span>, SpacingRuleJustification.Center, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">                SpacingRule srV = ds.VSpacingRule;</span><br><span class="line">                srV.SetLayoutFixedNumber(<span class="number">24</span>, SpacingRuleJustification.Center, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">break</span>;  <span class="comment">// just divide one face of form</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-68B498E3-3756-47BF-8392-1F12F2F8D4ED-low.png"></p>
<p>图60：由UV网格划分的形状面</p>
<p>通过指定DividedSurface的USpacing和VSpacing属性，可以为U和V网格线定义SpacingRule，方法是指定固定的网格数（如上例所示）、网格之间的固定距离或网格之间的最小或最大间距。每个间距规则都需要其他信息，例如对正和网格旋转。</p>
<p>图案化表面</p>
<p>可以对分割的曲面进行阵列。任何内置平铺填充图案都可以应用于分割表面。平铺图案是指定给DividedSurface的ElementType。平铺图案根据UV栅格布局应用于曲面，因此更改DividedSurface的USpacing和VSpacing属性将影响图案化曲面的显示方式。</p>
<p>下面的示例演示如何使用OctagonRotate图案覆盖分割曲面。相应的图显示了将其应用于上一示例中的分割曲面时的外观。注意这个例子还演示了如何在窗体上获取DividedSurface。</p>
<p>代码区域14-8：图案化表面</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TileSurface</span>(<span class="params">Document document, Form form</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// cover surface with OctagonRotate tile pattern</span></span><br><span class="line">    TilePatterns tilePatterns = document.Settings.TilePatterns;</span><br><span class="line">    <span class="keyword">foreach</span> (Reference r <span class="keyword">in</span> DividedSurface.GetReferencesWithDividedSurfaces(form))</span><br><span class="line">    &#123;</span><br><span class="line">        DividedSurface ds = DividedSurface.GetDividedSurfaceForReference(document, r);</span><br><span class="line">        ds.ChangeTypeId(tilePatterns.GetTilePattern(TilePatternsBuiltIn.OctagonRotate).Id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>图61：应用于分割表面的平铺图案</p>
<p>除了将内置的平铺填充图案应用于分割表面之外，还可以使用“基于幕墙嵌板填充图案的.rft”样板创建自己的体量嵌板族。然后，可以使用DividedSurface.ChangeTypeId（）方法将这些嵌板族载入体量族并应用于分割曲面。</p>
<p>“族”的下列属性特定于幕墙嵌板族：</p>
<ul>
<li>IsCurtainPanelFamily</li>
<li>CurtainPanelHorizontalSpacing -分隔网格的水平间距</li>
<li>CurtainPanelVerticalSpacing -分隔网格的垂直间距</li>
<li>CurtainPanelTilePattern -平铺图案的选择</li>
</ul>
<p>下面的示例演示如何编辑体量嵌板族，然后将其应用于概念体量文档中的形状。若要运行此示例，请首先使用“Curtain Panel Pattern Based.rft”样板创建一个新的族文档。</p>
<p>代码区域14-9：编辑幕墙嵌板族</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Family family = document.OwnerFamily;</span><br><span class="line"><span class="keyword">if</span> (family.IsCurtainPanelFamily == <span class="literal">true</span> &amp;&amp;</span><br><span class="line">    family.CurtainPanelTilePattern == TilePatternsBuiltIn.Rectangle)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// first change spacing of grids in family document</span></span><br><span class="line">    family.CurtainPanelHorizontalSpacing = <span class="number">20</span>;</span><br><span class="line">    family.CurtainPanelVerticalSpacing = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create new points and lines on grid</span></span><br><span class="line">    Autodesk.Revit.ApplicationServices.Application app = document.Application;</span><br><span class="line">    FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">    ICollection collection = collector.OfClass(<span class="keyword">typeof</span>(ReferencePoint)).ToElements();</span><br><span class="line">    <span class="built_in">int</span> ctr = <span class="number">0</span>;</span><br><span class="line">    ReferencePoint rp0 = <span class="literal">null</span>, rp1 = <span class="literal">null</span>, rp2 = <span class="literal">null</span>, rp3 = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">foreach</span> (Autodesk.Revit.DB.Element e <span class="keyword">in</span> collection)</span><br><span class="line">    &#123;</span><br><span class="line">        ReferencePoint rp = e <span class="keyword">as</span> ReferencePoint;</span><br><span class="line">        <span class="keyword">switch</span> (ctr)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                rp0 = rp;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                rp1 = rp;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                rp2 = rp;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                rp3 = rp;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ctr++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ReferencePointArray rpAr = <span class="keyword">new</span> ReferencePointArray();</span><br><span class="line">    rpAr.Append(rp0);</span><br><span class="line">    rpAr.Append(rp2);</span><br><span class="line">    CurveByPoints curve1 = document.FamilyCreate.NewCurveByPoints(rpAr);</span><br><span class="line">    PointLocationOnCurve pointLocationOnCurve25 = <span class="keyword">new</span> PointLocationOnCurve(PointOnCurveMeasurementType.NormalizedCurveParameter, <span class="number">0.25</span>, PointOnCurveMeasureFrom.Beginning);</span><br><span class="line">    PointOnEdge poeA = app.Create.NewPointOnEdge(curve1.GeometryCurve.Reference, pointLocationOnCurve25);</span><br><span class="line">    ReferencePoint rpA = document.FamilyCreate.NewReferencePoint(poeA);</span><br><span class="line">    PointLocationOnCurve pointLocationOnCurve75 = <span class="keyword">new</span> PointLocationOnCurve(PointOnCurveMeasurementType.NormalizedCurveParameter, <span class="number">0.75</span>, PointOnCurveMeasureFrom.Beginning);</span><br><span class="line">    PointOnEdge poeB = app.Create.NewPointOnEdge(curve1.GeometryCurve.Reference, pointLocationOnCurve75);</span><br><span class="line">    ReferencePoint rpB = document.FamilyCreate.NewReferencePoint(poeB);</span><br><span class="line"></span><br><span class="line">    rpAr.Clear();</span><br><span class="line">    rpAr.Append(rp1);</span><br><span class="line">    rpAr.Append(rp3);</span><br><span class="line">    CurveByPoints curve2 = document.FamilyCreate.NewCurveByPoints(rpAr);</span><br><span class="line">    PointOnEdge poeC = app.Create.NewPointOnEdge(curve2.GeometryCurve.Reference, pointLocationOnCurve25);</span><br><span class="line">    ReferencePoint rpC = document.FamilyCreate.NewReferencePoint(poeC);</span><br><span class="line">    PointOnEdge poeD = app.Create.NewPointOnEdge(curve2.GeometryCurve.Reference, pointLocationOnCurve75);</span><br><span class="line">    ReferencePoint rpD = document.FamilyCreate.NewReferencePoint(poeD);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Please open a curtain family document before calling this command.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-8EECE3F0-4C1F-4B31-9133-D3D64676E7FE-low.png"></p>
<p>图62：幕墙嵌板族</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-263500A5-C732-4E47-B9AA-D878AF9E9729-low.png"></p>
<p>图63：指定给分割表面的幕墙嵌板</p>
<h2 id="自适应构件"><a href="#自适应构件" class="headerlink" title="自适应构件"></a>自适应构件</h2><p>自适应组件旨在处理组件需要灵活地适应许多独特的上下文条件的情况。例如，自适应构件可用于通过排列符合用户定义约束的多个构件生成的重复系统中。</p>
<p>下面的代码显示如何将自适应构件族的实例创建到体量族中，并以数学方式设置每个点的位置。</p>
<p>代码区域：创建自适应构件族的实例</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">CreateAdaptiveComponentInstance</span>(<span class="params">Document document, FamilySymbol symbol</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Create a new instance of an adaptive component family</span></span><br><span class="line">            FamilyInstance instance = AdaptiveComponentInstanceUtils.CreateAdaptiveComponentInstance(document, symbol);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Get the placement points of this instance</span></span><br><span class="line">            <span class="keyword">var</span> placePointIds = <span class="keyword">new</span> List&lt;ElementId&gt;();</span><br><span class="line">            placePointIds = AdaptiveComponentInstanceUtils.GetInstancePlacementPointElementRefIds(instance).ToList();</span><br><span class="line">            <span class="built_in">double</span> x = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Set the position of each placement point</span></span><br><span class="line">            <span class="keyword">foreach</span> (ElementId id <span class="keyword">in</span> placePointIds)</span><br><span class="line">            &#123;</span><br><span class="line">                ReferencePoint point = document.GetElement(id) <span class="keyword">as</span> ReferencePoint;</span><br><span class="line">                point.Position = <span class="keyword">new</span> Autodesk.Revit.DB.XYZ(<span class="number">10</span>*x, <span class="number">10</span>*Math.Cos(x), <span class="number">0</span>);</span><br><span class="line">                x += Math.PI / <span class="number">6</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>若要批处理创建自适应组件，可以使用FamilyInstanceCreationData构造函数的重载，该构造函数接受两个参数-FamilySymbol和要初始化自适应实例的XYZ自适应点列表。结合使用Autodesk. Rev. Creation. ItemFactoryBase. NewFamilyInstances 2（）方法（该方法采用FamilyInstanceCreationData对象列表），可以一次添加多个自适应构件。这可能比逐个放置单个自适应组件更有效。</p>
<h2 id="创建-addin清单文件"><a href="#创建-addin清单文件" class="headerlink" title="创建.addin清单文件"></a>创建.addin清单文件</h2><p>HelloWorld.dll文件出现在项目输出目录中。如果要在Revit中调用应用程序，请创建清单文件以将其注册到Revit中。</p>
<p>创建清单文件</p>
<ol>
<li><p>在记事本中创建一个新的文本文件。</p>
</li>
<li><p>增加以下案文：</p>
<p>代码区域30-10：为外部命令创建.addin清单文件</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span> standalone=<span class="string">&quot;no&quot;</span>?&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    HelloWorld</span><br><span class="line">    HelloWorld.HelloWorld</span><br><span class="line">    HelloWorld</span><br><span class="line">    Show Hello World.</span><br><span class="line">    AlwaysVisible</span><br><span class="line">    C:\Samples\HelloWorld\HelloWorld\bin\Debug\HelloWorld.dll</span><br><span class="line">    <span class="number">239B</span>D853<span class="number">-36E4</span><span class="number">-461f</span><span class="number">-9171</span>-C5ACEDA4E723</span><br><span class="line">    ADSK</span><br><span class="line">    Autodesk, Inc, www.autodesk.com</span><br></pre></td></tr></table></figure></li>
</ol>
<p>注意：FullClassName包括在项目属性的“应用程序”选项卡上找到的根命名空间。</p>
<p>将文件保存为HelloWorld.addin并将其放在以下位置：</p>
<ul>
<li>C:\ProgramData\Autodesk\Revit\Addins\2018\</li>
</ul>
<p>有关使用清单文件的更多详细信息，请参阅加载项集成。</p>
<h2 id="注：翻译自Revit-API-Developers-Guide"><a href="#注：翻译自Revit-API-Developers-Guide" class="headerlink" title="注：翻译自Revit API Developers Guide"></a><em><strong>注：</strong></em>翻译自<a href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_html">Revit API Developers Guide</a></h2>]]></content>
      <categories>
        <category>Revit二次开发人员指南</category>
      </categories>
      <tags>
        <tag>Revit</tag>
      </tags>
  </entry>
  <entry>
    <title>14族文档</title>
    <url>/2024/11/29/%E4%BA%8C%E5%BC%80%E6%8C%87%E5%8D%97/14%E6%97%8F%E6%96%87%E6%A1%A3/</url>
    <content><![CDATA[<h1 id="族文档"><a href="#族文档" class="headerlink" title="族文档"></a><a href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_Revit_Geometric_Elements_Family_Documents_html">族文档</a></h1><p>本节讨论族以及如何：</p>
<ul>
<li>创建和修改族文档</li>
<li>访问族类型和参数</li>
</ul>
<p>本节中的页面</p>
<ul>
<li>关于族文档</li>
<li>在族中创建图元</li>
<li>族元素的可见性</li>
<li>管理族类型和参数</li>
</ul>
<h2 id="关于族文档"><a href="#关于族文档" class="headerlink" title="关于族文档"></a>关于族文档</h2><h3 id="族"><a href="#族" class="headerlink" title="族"></a>族</h3><p>族对象表示整个Revit族。族文档是表示族的文档(rfa)而不是Revit项目。</p>
<p>使用Revit API的族创建功能，可以创建和编辑族及其类型。当您有来自外部系统的现有数据并希望将其转换为Revit族库时，此功能特别有用。</p>
<p>对系统族编辑的API访问不可用。</p>
<h3 id="类别"><a href="#类别" class="headerlink" title="类别"></a>类别</h3><p>如前一节所述，Family.FamilyCategory属性指示族的类别，如柱、家具、结构框架或窗。</p>
<p>以下代码可用于确定打开的Revit族文档中族的类别。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> categoryName = familyDoc.OwnerFamily.FamilyCategory.Name;</span><br></pre></td></tr></table></figure>

<p>还可以设置FamilyCategory，以允许更改正在编辑的族的类别。</p>
<p> <strong>参数设置</strong> 可以从族文档的OwnerFamily属性访问族参数，如下例所示。</p>
<p>代码区域13-2：打开的Revit族文档的类别</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// get the owner family of the family document.</span></span><br><span class="line">Family family = familyDoc.OwnerFamily; </span><br><span class="line">Parameter param = family.get_Parameter(BuiltInParameter.FAMILY_WORK_PLANE_BASED);</span><br><span class="line"><span class="comment">// this param is a Yes/No parameter in UI, but an integer value in API</span></span><br><span class="line"><span class="comment">// 1 for true and 0 for false</span></span><br><span class="line"><span class="built_in">int</span> isTrue = param.AsInteger(); </span><br><span class="line"><span class="comment">// param.Set(1); // set value to true.</span></span><br></pre></td></tr></table></figure>

<h3 id="创建族文档"><a href="#创建族文档" class="headerlink" title="创建族文档"></a>创建族文档</h3><p>如果文档是族文档（由IsFamilyDocument属性确定），则可以通过Document类修改Revit族文档并访问族类型和参数。若要在处理Project文档时编辑现有族，请使用Document类中提供的EditFamily（）函数，然后在编辑完成后使用LoadFamily（）将族重新加载回所有者文档。要创建新的族文档，请使用Application.NewFamilyDocument（）：</p>
<p>代码区域13-3：创建新的族文档</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// create a new family document using Generic Model.rft template</span></span><br><span class="line"><span class="built_in">string</span> templateFileName = <span class="string">@&quot;C:\Documents and Settings\All Users\Application Data\Autodesk\RST 2011\Imperial Templates\Generic Model.rft&quot;</span>;</span><br><span class="line"></span><br><span class="line">Document familyDocument = application.NewFamilyDocument(templateFileName);</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">null</span> == familyDocument)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Cannot open family document&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="嵌套族符号"><a href="#嵌套族符号" class="headerlink" title="嵌套族符号"></a>嵌套族符号</h3><p>可以过滤FamilySymbols的族文档，以将所有FamilySymbols加载到族中。在此代码示例中，列出了给定FamilyInstance的族中的所有嵌套FamilySymbol。</p>
<p>代码区域13-4：在族中获取嵌套的族符号</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetLoadedSymbols</span>(<span class="params">Autodesk.Revit.DB.Document document, FamilyInstance familyInstance</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != familyInstance.Symbol)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="comment">// Get family associated with this</span></span><br><span class="line">                Family family = familyInstance.Symbol.Family;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Get Family document for family</span></span><br><span class="line">                Document familyDoc = document.EditFamily(family);</span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">null</span> != familyDoc &amp;&amp; familyDoc.IsFamilyDocument == <span class="literal">true</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                        String loadedFamilies = <span class="string">&quot;FamilySymbols in &quot;</span> + family.Name + <span class="string">&quot;:\n&quot;</span>;</span><br><span class="line">                        FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">                        ICollection collection = </span><br><span class="line">                                collector.OfClass(<span class="keyword">typeof</span>(FamilySymbol)).ToElements();</span><br><span class="line">                        <span class="keyword">foreach</span> (Element e <span class="keyword">in</span> collection)</span><br><span class="line">                        &#123;</span><br><span class="line">                                FamilySymbol fs = e <span class="keyword">as</span> FamilySymbol;</span><br><span class="line">                                loadedFamilies += <span class="string">&quot;\t&quot;</span> + fs.Name + <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>,loadedFamilies);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="在族中创建元素"><a href="#在族中创建元素" class="headerlink" title="在族中创建元素"></a>在族中创建元素</h2><p>FamilyItemFactory类提供了在族文档中创建图元的功能。可以通过Document.FamilyCreate属性访问它。FamilyItemFactory派生自ItemFactoryBase类，该类是一个实用的用于在Revit项目文档和族文档中创建元素。</p>
<p> 本节中的页面</p>
<ul>
<li>创建表单元素</li>
<li>创建注释</li>
</ul>
<h3 id="创建形状元素"><a href="#创建形状元素" class="headerlink" title="创建形状元素"></a>创建形状元素</h3><p>FamilyItemFactory类提供了在族中创建形状图元的功能，例如拉伸、旋转、放样和融合。有关这些3D草图表格的更多信息，请参见3D草图部分。</p>
<p>下面的示例演示如何创建新的Extrusion元素。它将创建一个简单的矩形截面轮廓，然后将新创建的“拉伸”移动到新位置。</p>
<p>代码区域：创建新拉伸</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Extrusion <span class="title">CreateExtrusion</span>(<span class="params">Autodesk.Revit.DB.Document document, SketchPlane sketchPlane</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Extrusion rectExtrusion = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// make sure we have a family document</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">true</span> == document.IsFamilyDocument)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// define the profile for the extrusion</span></span><br><span class="line">        CurveArrArray curveArrArray = <span class="keyword">new</span> CurveArrArray();</span><br><span class="line">        CurveArray curveArray1 = <span class="keyword">new</span> CurveArray();</span><br><span class="line">        CurveArray curveArray2 = <span class="keyword">new</span> CurveArray();</span><br><span class="line">        CurveArray curveArray3 = <span class="keyword">new</span> CurveArray();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// create a rectangular profile</span></span><br><span class="line">        XYZ p0 = XYZ.Zero;</span><br><span class="line">        XYZ p1 = <span class="keyword">new</span> XYZ(<span class="number">10</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        XYZ p2 = <span class="keyword">new</span> XYZ(<span class="number">10</span>, <span class="number">10</span>, <span class="number">0</span>);</span><br><span class="line">        XYZ p3 = <span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">10</span>, <span class="number">0</span>);</span><br><span class="line">        Line line1 = Line.CreateBound(p0, p1);</span><br><span class="line">        Line line2 = Line.CreateBound(p1, p2);</span><br><span class="line">        Line line3 = Line.CreateBound(p2, p3);</span><br><span class="line">        Line line4 = Line.CreateBound(p3, p0);</span><br><span class="line">        curveArray1.Append(line1);</span><br><span class="line">        curveArray1.Append(line2);</span><br><span class="line">        curveArray1.Append(line3);</span><br><span class="line">        curveArray1.Append(line4);</span><br><span class="line"></span><br><span class="line">        curveArrArray.Append(curveArray1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// create solid rectangular extrusion</span></span><br><span class="line">        rectExtrusion = document.FamilyCreate.NewExtrusion(<span class="literal">true</span>, curveArrArray, sketchPlane, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != rectExtrusion)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// move extrusion to proper place</span></span><br><span class="line">            XYZ transPoint1 = <span class="keyword">new</span> XYZ(<span class="number">-16</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            ElementTransformUtils.MoveElement(document, rectExtrusion.Id, transPoint1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Create new Extrusion failed.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Please open a Family document before invoking this command.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rectExtrusion;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下示例显示了如何从族文档中的实心卵形轮廓创建新放样。</p>
<p>代码区域：创建新放样</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Sweep <span class="title">CreateSweep</span>(<span class="params">Autodesk.Revit.DB.Document document, SketchPlane sketchPlane</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Sweep sweep = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// make sure we have a family document</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">true</span> == document.IsFamilyDocument)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Define a profile for the sweep</span></span><br><span class="line">        CurveArrArray arrarr = <span class="keyword">new</span> CurveArrArray();</span><br><span class="line">        CurveArray arr = <span class="keyword">new</span> CurveArray();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create an ovoid profile</span></span><br><span class="line">        XYZ pnt1 = <span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        XYZ pnt2 = <span class="keyword">new</span> XYZ(<span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        XYZ pnt3 = <span class="keyword">new</span> XYZ(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        arr.Append(Arc.Create(pnt2, <span class="number">1.0</span>d, <span class="number">0.0</span>d, <span class="number">180.0</span>d, XYZ.BasisX, XYZ.BasisY));</span><br><span class="line">        arr.Append(Arc.Create(pnt1, pnt3, pnt2));</span><br><span class="line">        arrarr.Append(arr);</span><br><span class="line">        SweepProfile profile = document.Application.Create.NewCurveLoopsProfile(arrarr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create a path for the sweep</span></span><br><span class="line">        XYZ pnt4 = <span class="keyword">new</span> XYZ(<span class="number">10</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        XYZ pnt5 = <span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">10</span>, <span class="number">0</span>);</span><br><span class="line">        Curve curve = Line.CreateBound(pnt4, pnt5);</span><br><span class="line"></span><br><span class="line">        CurveArray curves = <span class="keyword">new</span> CurveArray();</span><br><span class="line">        curves.Append(curve);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// create a solid ovoid sweep</span></span><br><span class="line">        sweep = document.FamilyCreate.NewSweep(<span class="literal">true</span>, curves, sketchPlane, profile, <span class="number">0</span>, ProfilePlaneLocation.Start);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != sweep)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// move to proper place</span></span><br><span class="line">            XYZ transPoint1 = <span class="keyword">new</span> XYZ(<span class="number">11</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            ElementTransformUtils.MoveElement(document, sweep.Id, transPoint1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Failed to create a new Sweep.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Please open a Family document before invoking this command.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sweep;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-169B9078-7508-4982-B10D-333FF97CA345-low.png"></p>
<p>图50：由上一个示例创建的卵形扫描</p>
<p> FreeFormElement类允许创建从输入实体轮廓创建的非参数化几何体。FreeFormElement可以与其他可组合元素一起参与连接和空切割。元素的平面可以在面法线方向上以交互方式和编程方式偏移。</p>
<p>将子类别转换为形状 在族中创建新形状后，可能需要修改形状的子类别。例如，您可能有一个门族，并且希望创建多个门的子类别，并将不同的子类别指定给族中的不同门类型。 下面的示例演示如何创建新的子类别，为其指定材质，然后将该子类别指定给窗体。</p>
<p>代码区域：指定子类别</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AssignSubCategory</span>(<span class="params">Document document, GenericForm extrusion</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// create a new subcategory</span></span><br><span class="line">    Category cat = document.OwnerFamily.FamilyCategory;</span><br><span class="line">    Category subCat = document.Settings.Categories.NewSubcategory(cat, <span class="string">&quot;NewSubCat&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create a new material and assign it to the subcategory</span></span><br><span class="line">    ElementId materialId = Material.Create(document, <span class="string">&quot;Wood Material&quot;</span>);</span><br><span class="line">    subCat.Material = document.GetElement(materialId) <span class="keyword">as</span> Material;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// assign the subcategory to the element</span></span><br><span class="line">    extrusion.Subcategory = subCat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="创建注释"><a href="#创建注释" class="headerlink" title="创建注释"></a>创建注释</h3><p>还可以在族中创建新注释（例如尺寸标注和ModelText和TextNote对象）以及曲线注释元素（例如SymbolicCurve、ModelCurve和DetailCurve）。有关注释元素的详细信息，请参见注释元素。</p>
<p>此外，还可以添加新路线，并参照确定路线方向的视图和两个几何图形参照。</p>
<p>以下示例演示如何创建新的弧长标注。</p>
<p>代码区域：创建标注</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Dimension <span class="title">CreateArcDimension</span>(<span class="params">Document document, SketchPlane sketchPlane</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Autodesk.Revit.Creation.Application appCreate = document.Application.Create;</span><br><span class="line">    Line gLine1 = Line.CreateBound(<span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>), <span class="keyword">new</span> XYZ(<span class="number">2</span>, <span class="number">2</span>, <span class="number">0</span>));</span><br><span class="line">    Line gLine2 = Line.CreateBound(<span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>), <span class="keyword">new</span> XYZ(<span class="number">2</span>, <span class="number">4</span>, <span class="number">0</span>));</span><br><span class="line">    Arc arctoDim = Arc.Create(<span class="keyword">new</span> XYZ(<span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>), <span class="keyword">new</span> XYZ(<span class="number">-1</span>, <span class="number">2</span>, <span class="number">0</span>), <span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>));</span><br><span class="line">    Arc arcofDim = Arc.Create(<span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>), <span class="keyword">new</span> XYZ(<span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>), <span class="keyword">new</span> XYZ(<span class="number">0.8</span>, <span class="number">2.8</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    Autodesk.Revit.Creation.FamilyItemFactory creationFamily = document.FamilyCreate;</span><br><span class="line">    ModelCurve modelCurve1 = creationFamily.NewModelCurve(gLine1, sketchPlane);</span><br><span class="line">    ModelCurve modelCurve2 = creationFamily.NewModelCurve(gLine2, sketchPlane);</span><br><span class="line">    ModelCurve modelCurve3 = creationFamily.NewModelCurve(arctoDim, sketchPlane);</span><br><span class="line">    <span class="comment">//get their reference</span></span><br><span class="line">    Reference ref1 = modelCurve1.GeometryCurve.Reference;</span><br><span class="line">    Reference ref2 = modelCurve2.GeometryCurve.Reference;</span><br><span class="line">    Reference arcRef = modelCurve3.GeometryCurve.Reference;</span><br><span class="line"></span><br><span class="line">    Dimension newArcDim = creationFamily.NewArcLengthDimension(document.ActiveView, arcofDim, arcRef, ref1, ref2);</span><br><span class="line">    <span class="keyword">if</span> (newArcDim == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Failed to create new arc length dimension.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> newArcDim;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-813DEE5B-AD67-4892-934A-EF192F72A5BB-low.png"></p>
<p>图51：产生的弧长尺寸</p>
<p>某些类型的尺寸标注可以使用FamilyParameter进行标记。如果尝试获取或设置Label属性，则无法标记的尺寸标注将引发Autodesk.Revit. Revit.InvalidOperationException。在下面的示例中，在两条线之间创建了一个新的线性尺寸标注，并将其标记为“width”。</p>
<p>代码区域：标注尺寸</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Dimension <span class="title">CreateLinearDimension</span>(<span class="params">Document document</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// first create two lines</span></span><br><span class="line">    XYZ pt1 = <span class="keyword">new</span> XYZ(<span class="number">5</span>, <span class="number">5</span>, <span class="number">0</span>);</span><br><span class="line">    XYZ pt2 = <span class="keyword">new</span> XYZ(<span class="number">5</span>, <span class="number">10</span>, <span class="number">0</span>);</span><br><span class="line">    Line line = Line.CreateBound(pt1, pt2);</span><br><span class="line">    Plane plane = Plane.CreateByNormalAndOrigin(pt1.CrossProduct(pt2), pt2);</span><br><span class="line">    SketchPlane skplane = SketchPlane.Create (document, plane);</span><br><span class="line">    ModelCurve modelcurve1 = document.FamilyCreate.NewModelCurve(line, skplane);</span><br><span class="line"></span><br><span class="line">    pt1 = <span class="keyword">new</span> XYZ(<span class="number">10</span>, <span class="number">5</span>, <span class="number">0</span>);</span><br><span class="line">    pt2 = <span class="keyword">new</span> XYZ(<span class="number">10</span>, <span class="number">10</span>, <span class="number">0</span>);</span><br><span class="line">    line = Line.CreateBound(pt1, pt2);</span><br><span class="line">    plane = Plane.CreateByNormalAndOrigin(pt1.CrossProduct(pt2), pt2);</span><br><span class="line">    skplane = SketchPlane.Create (document, plane);</span><br><span class="line">    ModelCurve modelcurve2 = document.FamilyCreate.NewModelCurve(line, skplane);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// now create a linear dimension between them</span></span><br><span class="line">    ReferenceArray ra = <span class="keyword">new</span> ReferenceArray();</span><br><span class="line">    ra.Append(modelcurve1.GeometryCurve.Reference);</span><br><span class="line">    ra.Append(modelcurve2.GeometryCurve.Reference);</span><br><span class="line"></span><br><span class="line">    pt1 = <span class="keyword">new</span> XYZ(<span class="number">5</span>, <span class="number">10</span>, <span class="number">0</span>);</span><br><span class="line">    pt2 = <span class="keyword">new</span> XYZ(<span class="number">10</span>, <span class="number">10</span>, <span class="number">0</span>);</span><br><span class="line">    line = Line.CreateBound(pt1, pt2);</span><br><span class="line"></span><br><span class="line">    Dimension dim = document.FamilyCreate.NewLinearDimension(document.ActiveView, line, ra);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create a label for the dimension called &quot;width&quot;</span></span><br><span class="line">    FamilyParameter param = document.FamilyManager.AddParameter(<span class="string">&quot;width&quot;</span>, </span><br><span class="line">        BuiltInParameterGroup.PG_CONSTRAINTS, </span><br><span class="line">        ParameterType.Length, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    dim.FamilyLabel = param;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dim;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-802D577E-3791-4286-A288-0B7858C6459C-low.png"></p>
<p>图52：标记的线性尺寸</p>
<h2 id="族元素的可见性"><a href="#族元素的可见性" class="headerlink" title="族元素的可见性"></a>族元素的可见性</h2><p>FamilyElementVisibility类可用于控制族图元在项目文档中的可见性。例如，如果有门族，则可能只希望门开启方向在放置门的项目文档的平面视图中可见，而在三维视图中不可见。通过设置门开启方向的可见性，您可以控制其可见性。FamilyElementVisibility适用于以下具有SetVisibility（）函数的族图元类：</p>
<ul>
<li>GenericForm</li>
<li>SymbolicCurve</li>
<li>ModelText </li>
<li>CurveByPoints</li>
<li>ModelCurve </li>
<li>ReferencePoint </li>
<li>ImportInstance</li>
</ul>
<p>在下面的示例中，生成的族文档将显示文本“Hello World”，其下有一条线。当族载入到Revit项目文档中并放置实例时，在平面视图中，只有该线可见。在3D视图中，将同时显示线条和文本，除非将“详细程度”设置为“粗”，在这种情况下，线条将消失。</p>
<p>代码区域13-10：设置族图元可见性</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">CreateAndSetVisibility</span>(<span class="params">Autodesk.Revit.DB.Document familyDocument, SketchPlane sketchPlane</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// create a new ModelCurve in the family document</span></span><br><span class="line">    XYZ p0 = <span class="keyword">new</span> XYZ(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    XYZ p1 = <span class="keyword">new</span> XYZ(<span class="number">5</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    Line line1 = Line.CreateBound(p0, p1);</span><br><span class="line"></span><br><span class="line">    ModelCurve modelCurve1 = familyDocument.FamilyCreate.NewModelCurve(line1, sketchPlane);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create a new ModelText along ModelCurve line</span></span><br><span class="line">    ModelText text = familyDocument.FamilyCreate.NewModelText(<span class="string">&quot;Hello World&quot;</span>, <span class="literal">null</span>, sketchPlane, p0, HorizontalAlign.Center, <span class="number">0.1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set visibility for text</span></span><br><span class="line">    FamilyElementVisibility textVisibility = <span class="keyword">new</span> FamilyElementVisibility(FamilyElementVisibilityType.Model);</span><br><span class="line">    textVisibility.IsShownInTopBottom = <span class="literal">false</span>;</span><br><span class="line">    text.SetVisibility(textVisibility);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set visibility for line</span></span><br><span class="line">    FamilyElementVisibility curveVisibility = <span class="keyword">new</span> FamilyElementVisibility(FamilyElementVisibilityType.Model);</span><br><span class="line">    curveVisibility.IsShownInCoarse = <span class="literal">false</span>;</span><br><span class="line">    modelCurve1.SetVisibility(curveVisibility);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="管理族类型和参数"><a href="#管理族类型和参数" class="headerlink" title="管理族类型和参数"></a>管理族类型和参数</h2><p>族文档提供对FamilyManager属性的访问。FamilyManager类提供对族类型和参数的访问。使用此类，可以添加和删除类型、添加和删除族参数和共享参数、设置不同族类型中的参数值以及定义公式来驱动参数值。</p>
<p><strong>在族中获取种类</strong></p>
<p>FamilyManager可用于遍历族中的种类，如下例所示。</p>
<p>代码区域13-11：获取族中的种类</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetFamilyTypesInFamily</span>(<span class="params">Document familyDoc</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (familyDoc.IsFamilyDocument)</span><br><span class="line">    &#123;</span><br><span class="line">        FamilyManager familyManager = familyDoc.FamilyManager;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// get types in family</span></span><br><span class="line">        <span class="built_in">string</span> types = <span class="string">&quot;Family Types: &quot;</span>;</span><br><span class="line">        FamilyTypeSet familyTypes = familyManager.Types;</span><br><span class="line">        FamilyTypeSetIterator familyTypesItor = familyTypes.ForwardIterator();</span><br><span class="line">        familyTypesItor.Reset();</span><br><span class="line">        <span class="keyword">while</span> (familyTypesItor.MoveNext())</span><br><span class="line">        &#123;</span><br><span class="line">            FamilyType familyType = familyTypesItor.Current <span class="keyword">as</span> FamilyType;</span><br><span class="line">            types += <span class="string">&quot;\n&quot;</span> + familyType.Name;</span><br><span class="line">        &#125;</span><br><span class="line">        TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>,types);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-60AB2EDC-BC4E-4E08-8922-38ECF4B7F991-low.png"></p>
<p>图53：混凝土矩形柱族中的族种类</p>
<p><strong>编辑族种类</strong></p>
<p>FamilyManager提供了遍历族中现有种类以及添加和修改种类及其参数的功能。</p>
<p>下面的示例演示如何添加新种类（familysymbol），设置其参数，然后将新种类分配给FamilyInstance。种类编辑是通过使用Set（）函数在当前种类上完成的。当前种类可从CurrentType属性获得。CurrentType属性可用于在编辑之前设置当前种类，或使用NewType（）函数创建新种类并将其设置为当前种类以进行编辑。</p>
<p>请注意，一旦创建并修改了新种类，就会使用Document.LoadFamily（）将族重新载入到Revit项目中，以使新种类可用。</p>
<p>代码区域13-12：编辑族类型</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">EditFamilyTypes</span>(<span class="params">Document document, FamilyInstance familyInstance</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// example works best when familyInstance is a rectangular concrete element</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((<span class="literal">null</span> == document) || (<span class="literal">null</span> == familyInstance.Symbol))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;   <span class="comment">// invalid arguments</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get family associated with this</span></span><br><span class="line">    Family family = familyInstance.Symbol.Family;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> == family)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;    <span class="comment">// could not get the family</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get Family document for family</span></span><br><span class="line">    Document familyDoc = document.EditFamily(family);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> == familyDoc)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;    <span class="comment">// could not open a family for edit</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    FamilyManager familyManager = familyDoc.FamilyManager;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> == familyManager)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;  <span class="comment">// cuould not get a family manager</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start transaction for the family document</span></span><br><span class="line">    <span class="keyword">using</span> (Transaction newFamilyTypeTransaction = <span class="keyword">new</span> Transaction(familyDoc, <span class="string">&quot;Add Type to Family&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> changesMade = <span class="number">0</span>;</span><br><span class="line">        newFamilyTypeTransaction.Start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// add a new type and edit its parameters</span></span><br><span class="line">        FamilyType newFamilyType = familyManager.NewType(<span class="string">&quot;2X2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (newFamilyType != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// look for &#x27;b&#x27; and &#x27;h&#x27; parameters and set them to 2 feet</span></span><br><span class="line">            FamilyParameter familyParam = familyManager.get_Parameter(<span class="string">&quot;宽度&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (<span class="literal">null</span> != familyParam)</span><br><span class="line">            &#123;</span><br><span class="line">                familyManager.Set(familyParam, <span class="number">2.0</span>);</span><br><span class="line">                changesMade += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            familyParam = familyManager.get_Parameter(<span class="string">&quot;高度&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (<span class="literal">null</span> != familyParam)</span><br><span class="line">            &#123;</span><br><span class="line">                familyManager.Set(familyParam, <span class="number">2.0</span>);</span><br><span class="line">                changesMade += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">2</span> == changesMade)   <span class="comment">// set both paramaters?</span></span><br><span class="line">        &#123;</span><br><span class="line">            newFamilyTypeTransaction.Commit();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>   <span class="comment">// could not make the change -&gt; should roll back </span></span><br><span class="line">        &#123;</span><br><span class="line">            newFamilyTypeTransaction.RollBack();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// if could not make the change or could not commit it, we return</span></span><br><span class="line">        <span class="keyword">if</span> (newFamilyTypeTransaction.GetStatus() != TransactionStatus.Committed)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// now update the Revit project with Family which has a new type</span></span><br><span class="line">    LoadOpts loadOptions = <span class="keyword">new</span> LoadOpts();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This overload is necessary for reloading an edited family</span></span><br><span class="line">    <span class="comment">// back into the source document from which it was extracted</span></span><br><span class="line">    family = familyDoc.LoadFamily(document, loadOptions);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> != family)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// find the new type and assign it to FamilyInstance</span></span><br><span class="line">        ISet familySymbolIds = family.GetFamilySymbolIds();</span><br><span class="line">        <span class="keyword">foreach</span> (ElementId id <span class="keyword">in</span> familySymbolIds)</span><br><span class="line">        &#123;</span><br><span class="line">            FamilySymbol familySymbol = family.Document.GetElement(id) <span class="keyword">as</span> FamilySymbol;</span><br><span class="line">            <span class="keyword">if</span> ((<span class="literal">null</span> != familySymbol) &amp;&amp; familySymbol.Name == <span class="string">&quot;2X2&quot;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">using</span> (Transaction changeSymbol = <span class="keyword">new</span> Transaction(document, <span class="string">&quot;Change Symbol Assignment&quot;</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                    changeSymbol.Start();</span><br><span class="line">                    familyInstance.Symbol = familySymbol;</span><br><span class="line">                    changeSymbol.Commit();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">LoadOpts</span> : <span class="title">IFamilyLoadOptions</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">OnFamilyFound</span>(<span class="params"><span class="built_in">bool</span> familyInUse, <span class="keyword">out</span> <span class="built_in">bool</span> overwriteParameterValues</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        overwriteParameterValues = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">OnSharedFamilyFound</span>(<span class="params">Family sharedFamily, <span class="built_in">bool</span> familyInUse, <span class="keyword">out</span> FamilySource source, <span class="keyword">out</span> <span class="built_in">bool</span> overwriteParameterValues</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        source = FamilySource.Family;</span><br><span class="line">        overwriteParameterValues = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>FamilyManager类提供对所有族参数的访问。这包括族内置参数、类别内置参数和与族类型关联的共享参数。有两种方法可以获取族参数：</p>
<ul>
<li>Parameters property - 获取族中的所有参数</li>
<li>GetParameters（）-按族中所有参数在Revit UI中出现的顺序获取这些参数使用GetParameters（）方法时，Revit UI顺序首先按组确定，然后按各个参数的顺序确定。</li>
</ul>
<p>可以从给定族的API（不支持重新排序参数的钢筋形状族除外）重新排序（在其组内）族参数。这允许参数以最符合逻辑的顺序呈现给用户。排序仅影响同一参数组中的可见参数。属于不同组的参数将保持分离，并且组的顺序不会受到影响。</p>
<p>对参数重新排序的最简单方法是使用FamilyManager.SortParameters（）方法，该方法接受一个指示所需排序顺序的参数。下面的示例按升序对参数进行排序。</p>
<p>代码区域：对族参数排序</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">DisplayParametersInAscendingOrder</span>(<span class="params">Document familyDoc</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    FamilyManager familyManager = familyDoc.FamilyManager;</span><br><span class="line">    familyManager.SortParameters(ParametersOrder.Ascending);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：排序是一次性操作。当添加新参数时，它们不会自动排序。若要对参数的排序方式进行更多控制，请使用FamilyManager.ReorderParameters（）方法，该方法以新顺序接受族参数列表。此列表必须包含GetParameters（）方法返回的所有参数，包括任何不可见的参数，否则将引发异常。</p>
<h2 id="注：翻译自Revit-API-Developers-Guide"><a href="#注：翻译自Revit-API-Developers-Guide" class="headerlink" title="注：翻译自Revit API Developers Guide"></a><em><strong>注：</strong></em>翻译自<a href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_html">Revit API Developers Guide</a></h2>]]></content>
      <categories>
        <category>Revit二次开发人员指南</category>
      </categories>
      <tags>
        <tag>Revit</tag>
      </tags>
  </entry>
  <entry>
    <title>13族实例</title>
    <url>/2024/11/23/%E4%BA%8C%E5%BC%80%E6%8C%87%E5%8D%97/13%E6%97%8F%E5%AE%9E%E4%BE%8B/</url>
    <content><![CDATA[<h1 id="族实例"><a href="#族实例" class="headerlink" title="族实例"></a><a href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_Revit_Geometric_Elements_Family_Instances_html">族实例</a></h1><p>在本节中，您将了解以下内容：</p>
<ul>
<li>族与族实例的关系</li>
<li>族和族实例特征</li>
<li>如何载入或创建族和族实例特征</li>
<li>族实例与族符号的关系</li>
</ul>
<p> 本节中的页面</p>
<ul>
<li>Identifying Elements 识别元素</li>
<li>FamilyInstances 族实例</li>
<li>Code Samples 代码示例</li>
<li>FamilySymbol 族符号</li>
<li>Family 族</li>
</ul>
<h2 id="识别元素"><a href="#识别元素" class="headerlink" title="识别元素"></a>识别元素</h2><p>在Revit中，判断元素是否为FamilyInstance的最简单方法是使用属性对话框。</p>
<ul>
<li>如果族名称以“系统族”开头，并且禁用了“载入”按钮，则该族属于“系统族”。</li>
</ul>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-96BC987E-5C38-45EF-9621-2D6EF89989B1-low.png"></p>
<p>图41：系统族</p>
<ul>
<li>属于构件族的常规FamilyInstance不以System Family开头。</li>
<li>例如，在下图中，桌子家具的族名为Desk。此外，还启用了“加载”按钮。</li>
</ul>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-67F1CF63-64EF-40E4-BF92-284873CDDB31-low.png"></p>
<p>图42：组件族</p>
<p>有一些例外，例如：体量和内建成员。“族”和“类型”字段为空。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-A2B06CEE-7E4A-494B-8DE8-7131068F182B-low.png"></p>
<p>图43：体量或内建构件示例</p>
<p>Revit Platform API中的族由三个对象表示：</p>
<ul>
<li>Family </li>
<li>FamilySymbol</li>
<li>FamilyInstance</li>
</ul>
<p>每件对象在族结构中都起着重要的作用。</p>
<p>“族”对象表示整个族，例如单平面门。例如，“单面齐平门族”对应于“单面齐平.rfa”文件。Family对象包含多个FamilySymbols，用于获取所有族符号，以便于将实例从一个符号切换到另一个符号。</p>
<p>FamilySymbol对象表示与Revit UI中的“类型”（例如34”×80”）相对应的一组特定族设置。</p>
<p>FamilyInstance对象表示Revit项目中的实际Type（FamilySymbol）实例。例如，在下图中，FamilyInstance是项目中的一扇门。</p>
<ul>
<li>每个FamilyInstance都有一个FamilySymbol。门是一个34”×80”的实例。</li>
<li>每个FamilySymbol都属于一个Family。34”×80”符号属于单齐平系列。</li>
<li>每个族都包含一个或多个族符号。单齐平系列包含34”×80”符号、34”×84”符号、36”×84”等。</li>
</ul>
<p>注意：虽然大多数组件元素都是通过API类FamilySymbol和FamilyInstance公开的，但也有一些是用特定的API类包装的。例如，AnnotationSymbolType包装FamilySymbol，AnnotationSymbol包装FamilyInstance。</p>
<h2 id="族实例-1"><a href="#族实例-1" class="headerlink" title="族实例"></a>族实例</h2><p>FamilyInstance对象包括梁、支撑、柱、家具、体量等。FamilyInstance对象提供了更详细的属性，以便可以更改项目中的族实例类型和外观。</p>
<h3 id="位置相关属性"><a href="#位置相关属性" class="headerlink" title="位置相关属性"></a>位置相关属性</h3><p>与位置相关的属性显示FamilyInstance对象的物理和几何特征，如方向、旋转和位置。</p>
<h4 id="Orientation-朝向"><a href="#Orientation-朝向" class="headerlink" title="Orientation 朝向"></a>Orientation 朝向</h4><p>对于某些FamilyInstance对象，可以更改面方向或手方向。例如，门可以面向房间或墙壁的外部或内部，并且可以将把手放置在左侧或右侧。下表比较了门、窗和桌子族实例。</p>
<p>表29：比较族实例</p>
<table>
<thead>
<tr>
<th><strong>Boolean Property 布尔属性</strong></th>
<th><strong>Door 门</strong></th>
<th>**Window (Fixed: 36”w × 72”h) **</th>
<th><strong>Desk 书桌</strong></th>
</tr>
</thead>
<tbody><tr>
<td>CanFlipFacing</td>
<td>True</td>
<td>True</td>
<td>False</td>
</tr>
<tr>
<td>CanFlipHand</td>
<td>True</td>
<td>False</td>
<td>False</td>
</tr>
</tbody></table>
<p>如果CanFlipFacing或CanFlipHand为true，则可以分别调用flipFacing（）或flipHand（）方法。这些方法可以分别改变面向方向或手方向。否则，这些方法不执行任何操作并返回False。修改方向时，请记住某些类型的窗可以同时修改手方向和面方向，例如带Trim的3x3平开窗族。门有四种不同的朝向和手方向组合。请参见下图中的组合，下表中列出了相应的布尔值。 </p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-AC8B1DB7-860B-46D3-A0BD-DBF120980580-low.png"></p>
<p>图44：具有不同面方向和手方向的门</p>
<p>表30：相同类型的不同饰面</p>
<table>
<thead>
<tr>
<th><strong>Boolean Property 布尔属性</strong></th>
<th>**Door 1 **</th>
<th>**Door 2 **</th>
<th>**Door 3 **</th>
<th>**Door 4 **</th>
</tr>
</thead>
<tbody><tr>
<td>FacingFlipped</td>
<td>False</td>
<td>True</td>
<td>False</td>
<td>True</td>
</tr>
<tr>
<td>HandFlipped</td>
<td>False</td>
<td>True</td>
<td>True</td>
<td>False</td>
</tr>
</tbody></table>
<h4 id="Orientation-Work-Plane-方位-工作平面"><a href="#Orientation-Work-Plane-方位-工作平面" class="headerlink" title="Orientation - Work Plane 方位-工作平面"></a>Orientation - Work Plane 方位-工作平面</h4><p>也可以更改FamilyInstance的工作平面方向。如果CanFlipWorkPlane为true，则可以设置IsWorkPlaneFlipped属性。尝试为不允许翻转工作平面的FamilyInstance设置此属性将导致异常。</p>
<h4 id="Rotation-Mirrored-旋转-镜像"><a href="#Rotation-Mirrored-旋转-镜像" class="headerlink" title="Rotation - Mirrored 旋转-镜像"></a>Rotation - Mirrored 旋转-镜像</h4><p>镜像属性指示FamilyInstance对象是否已镜像。</p>
<p>表31：门镜像属性</p>
<table>
<thead>
<tr>
<th><strong>Boolean Property 布尔属性</strong></th>
<th>**Door 1 **</th>
<th>**Door 2 **</th>
<th>**Door 3 **</th>
<th>**Door 4 **</th>
</tr>
</thead>
<tbody><tr>
<td>Mirrored</td>
<td>False</td>
<td>False</td>
<td>True</td>
<td>True</td>
</tr>
</tbody></table>
<p>在前面的门示例中，Door 1和Door 2的Mirror属性为False，而Door 3和Door 4的Mirror属性均为True。这是因为在Revit项目中创建门时，默认结果为“门1”或“门2”。要创建类似“门3”或“门4”的门，必须分别翻转“门1”和“门2”的方向。翻转操作类似于镜像变换，这就是为什么“门3”和“门4”镜像属性为True。 有关在Revit中使用Mirror（）方法的详细信息，请参阅“编辑图元”一章。 #### Rotation - CanRotate和rotate（） 族实例布尔CanRotate属性用于测试族实例是否可以旋转180度。这取决于实例所属的族。例如，在下面的图片中，Window 1（Casement 3×3 with Trim：36”×72”）和Door 1（Double-Glass 2：72”×82”）的CanRotate属性为true，而Window 2（Fixed：36“w × 72“h）的CanRotate属性为false。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-8E93FD79-81F8-4B3D-B09F-9C9A4A1A556C-low.png"></p>
<p><strong>图45：旋转后的变化</strong> </p>
<p>如果CanRotate为true，则可以调用族实例rotate（）方法，该方法将族实例翻转180度。否则，该方法不执行任何操作并返回False。上图还显示了执行rotate（）方法后的Window 1和Door 1状态。 回想一下本文档前面的旋转图元部分，可以使用ElementTransformUtils.RotateElement（）和ElementTransformUtils.RotateElements（）将族实例（和其他图元）旋转用户指定的角度。</p>
<p><strong>位置</strong> Location属性确定实例在项目中的物理位置。实例可以具有点位置或线位置。 以下特征适用于位置： </p>
<p><em>点位置是LocationPoint类对象-基础、门或桌子都有点位置</em> </p>
<p>线位置是LocationCurve类对象-梁具有线位置。 * 它们都是Location类的子类。 有关位置的详细信息，请参阅编辑元素。</p>
<p>Host和HostFace Host和HostFace都是FamilyInstance属性。 </p>
<p><strong>Host</strong> FamilyInstance对象有一个返回其宿主元素的Host属性。 某些FamilyInstance对象没有宿主元素，如Tables和其他家具，因此Host属性不返回任何内容，因为没有创建主体元素。但是，其他对象（如门和窗）必须具有宿主图元。在这种情况下，Host属性返回窗或门所在的墙元素。请参见下图。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-837ECA51-19DE-4B19-A304-A5C26F24EBD0-low.png"></p>
<p>图46：以墙为主体的门和窗 </p>
<p><strong>HostFace</strong> HostFace属性获取对族实例的宿主面的参照，或者如果实例放置在工作平面上，则获取对工作平面下面的几何图形面的参照。如果工作平面未参照其他几何图形，或者实例未以面或工作平面为宿主，则此属性将返回空参照。</p>
<p> <strong>子组件和超级组件</strong> FamilyInstance. GetSubmenentIds（）方法返回加载到该族中的族实例的ElementIds。将“Table-Dining Round w Chairs.rfa”的实例放置在项目中时，GetSubmenuentIds（）方法将返回椅子集的ElementIds。 SuperComponent属性返回族实例的父构件。在“Table-Dining Round w Chairs. rfa”中，每个嵌套椅子的族实例超级组件都是“Table-Dining Round w Chairs. rfa”的实例。</p>
<p>代码区域12-1：从FamilyInstance获取子组件和超级组件</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetSubAndSuperComponents</span>(<span class="params">FamilyInstance familyInstance</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ICollection subElemSet = familyInstance.GetSubComponentIds();</span><br><span class="line">    <span class="keyword">if</span> (subElemSet != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> subElems = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">foreach</span> (Autodesk.Revit.DB.ElementId ee <span class="keyword">in</span> subElemSet)</span><br><span class="line">        &#123;</span><br><span class="line">            FamilyInstance f = familyInstance.Document.GetElement(ee) <span class="keyword">as</span> FamilyInstance;</span><br><span class="line">            subElems = subElems + f.Name + <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>,<span class="string">&quot;Subcomponent count = &quot;</span> + subElemSet.Count + <span class="string">&quot;\n&quot;</span> + subElems);</span><br><span class="line">    &#125;</span><br><span class="line">    FamilyInstance super = familyInstance.SuperComponent <span class="keyword">as</span> FamilyInstance;</span><br><span class="line">    <span class="keyword">if</span> (super != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>,<span class="string">&quot;SUPER component: &quot;</span> + super.Name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="几何"><a href="#几何" class="headerlink" title="几何"></a>几何</h3><p>有时，FamilyInstance对象的几何图形会通过连接、剪切、顶盖、延伸或其他在Revit中进行的后期处理进行修改。FamilyInstance.HasModifiedGeometry（）方法标识此FamilyInstance的几何图形是否已从自动生成的默认值修改。GetOriginalGeometry（）方法将返回实例的原始几何体，该几何体在可能发生任何修改之前。若要获取实例的当前几何体，请使用从Element类继承的Geometry属性。</p>
<h3 id="空间元素计算点"><a href="#空间元素计算点" class="headerlink" title="空间元素计算点"></a>空间元素计算点</h3><p>FamilyInstance具有多个成员，用于直接从族实例中阅读有关空间计算点的信息。HasSpatialElementCalculationPoint属性标识此实例是否有一个SpatialElementCalculationPoint用作Revit的搜索点，以标识实例是否位于房间或空间内。如果为true，GetSpatialElementCalculationPoint（）方法将返回此实例的计算点的位置作为XYZ点。</p>
<p>HasSpatialElementFromToCalculationPoints属性标识此实例是否具有一对SpatialElementCalculationPoints，它们用作Revit的搜索点，以标识实例是否位于最多两个房间或空间之间。对于连接两个房间或空间（如门或窗）的族实例，这些点确定哪个房间或空间被视为“从”，哪个被视为“到”。当此属性为true时，GetSpatialElementFromToCalculationPoints（）方法将此实例的计算点的位置作为XYZ点的列表返回。</p>
<h3 id="其它属性"><a href="#其它属性" class="headerlink" title="其它属性"></a>其它属性</h3><p>本部分中的属性特定于Revit的建筑和结构工程功能。它们在各自的章节中都有详细介绍。</p>
<h4 id="房间信息"><a href="#房间信息" class="headerlink" title="房间信息"></a>房间信息</h4><p>FamilyInstance属性包括Room、FromRoom和ToRoom。有关房间的详细信息，请参阅建筑。</p>
<h4 id="空间信息"><a href="#空间信息" class="headerlink" title="空间信息"></a>空间信息</h4><p>FamilyInstance有一个Space属性，用于标识MEP中保存实例的空间。</p>
<h4 id="结构分析模型"><a href="#结构分析模型" class="headerlink" title="结构分析模型"></a>结构分析模型</h4><p>GetAnalyticalModel（）方法检索族实例结构分析模型。</p>
<p>有关分析模型的详细信息，请参阅结构工程。</p>
<h3 id="创建FamilyInstance对象"><a href="#创建FamilyInstance对象" class="headerlink" title="创建FamilyInstance对象"></a>创建FamilyInstance对象</h3><p>通常，FamilyInstance对象是使用Autodesk.Revit.Creation.Document的12种重载方法之一NewFamilyInstance（）创建的。选择使用哪个重载不仅取决于实例的类别，还取决于放置的其他特征，例如是否应将其作为主体、相对于参照标高放置或直接放置在特定面上。详细信息包含在下面的表32 -使用NewFamilyInstance（）创建实例的选项中。</p>
<p>某些FamilyInstance对象需要创建多个位置。在这些情况下，使用此对象提供的更详细的创建方法更合适（请参见表33 -使用其他方法创建实例的选项）。如果未创建实例，则会引发异常。在调用该方法之前，必须将使用的类型&#x2F;符号加载到项目中。</p>
<p>检查NewFamilyInstance（）的所有重载以确保输入FamilySymbol处于活动状态（FamilySymbol.IsActive）。如果输入FamilySymbol处于非活动状态，则该方法将抛出ArgumentException。文档中未使用的符号可能会被停用，以节省内存和再生时间。当符号处于非活动状态时，其几何图形为空，无法访问。为了访问文档中未激活的符号的几何图形，应首先通过调用FamilySymbol.Activate（）来激活该符号。</p>
<p>表32 -使用NewFamilyInstance（）创建实例的选项</p>
<table>
<thead>
<tr>
<th align="left">Category 类别</th>
<th align="left">NewFamilyInstance() parameters NewFamilyInstance（）参数</th>
<th align="left">Comments注解</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Air Terminals Boundary Conditions Casework Communication Devices Data Devices Electrical Equipment Electrical Fixtures Entourage Fire Alarm Devices Furniture Furniture Systems Generic Models Lighting Devices Lighting Fixtures Mass Mechanical Equipment Nurse Call Devices Parking Planting Plumbing Fixtures Security Devices Site Specialty Equipment Sprinklers Structural Connections Structural Foundations Structural Stiffeners Telephone Devices</td>
<td align="left">XYZ, FamilySymbol, StructuralType</td>
<td align="left">在任意位置创建实例，而不参照标高或宿主元素。</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">XYZ, FamilySymbol, Element, StructuralType</td>
<td align="left">如果要在墙壁、地板或天花板上承载</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">XYZ, FamilySymbol, XYZ, Element, StructuralType</td>
<td align="left">如果要以墙、楼板或天花板为主体，并且需要以非默认方向，</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">XYZ, FamilySymbol, Element, Level, StructuralType</td>
<td align="left">如果要以墙、楼板或天花板为宿主并与参照标高关联，</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">XYZ, FamilySymbol, Level, StructuralType</td>
<td align="left">如果要将其关联到参考标高</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">Face, XYZ, XYZ, FamilySymbol XYZ，</td>
<td align="left">如果它是基于面的并且需要以非默认方向，</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">Reference, XYZ, XYZ, FamilySymbol</td>
<td align="left">如果它是基于面的，并且需要以非默认方向，则接受对面的引用，而不是对Face</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">Face, Line, FamilySymbol</td>
<td align="left">如果它是基于面和线的</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">Reference, Line, FamilySymbol</td>
<td align="left">如果它是基于面和线的，但接受对面的引用，而不是面</td>
</tr>
<tr>
<td align="left">Columns Structural Columns</td>
<td align="left">XYZ, FamilySymbol, Level, StructuralType</td>
<td align="left">创建柱，使其底部位于参照标高上。柱将延伸到模型中的下一个可用标高，或者如果参照标高之上没有合适的标高，则将延伸默认柱高。</td>
</tr>
<tr>
<td align="left">Doors Windows</td>
<td align="left">XYZ, FamilySymbol, Element, StructuralType</td>
<td align="left">门和窗必须以墙为宿主。如果可以使用默认方向放置它们，请使用此方法。</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">XYZ, FamilySymbol, XYZ, Element, StructuralType</td>
<td align="left">如果创建的实例需要以非默认方向</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">XYZ, FamilySymbol, Element, Level, StructuralType</td>
<td align="left">如果实例需要关联到参照标高</td>
</tr>
<tr>
<td align="left">Structural Framing (Beams, Braces)</td>
<td align="left">Curve, FamilySymbol, Level, StructuralType</td>
<td align="left">根据其曲线创建基于标高的支撑或梁。这是创建梁和支撑的推荐方法</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">XYZ, FamilySymbol, StructuralType</td>
<td align="left">在任意位置创建实例</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">XYZ, FamilySymbol, Element, Level, StructuralType</td>
<td align="left">如果它位于图元（地板等）上，并与参考标高相关联</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">XYZ, FamilySymbol, Level, StructuralType</td>
<td align="left">如果它与参考标高相关联，</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">XYZ, FamilySymbol, Element, StructuralType</td>
<td align="left">如果它位于图元（地板等）上</td>
</tr>
<tr>
<td align="left">Detail Component</td>
<td align="left">Line, FamilySymbol, View</td>
<td align="left">仅限于基于二维族线的详图符号</td>
</tr>
<tr>
<td align="left">Generic Annotations</td>
<td align="left">XYZ, FamilySymbol, View</td>
<td align="left">仅显示为二维族符号</td>
</tr>
</tbody></table>
<p>结构实例在创建后长度为零。通过使用LocationCurve.Curve属性设置其曲线（FamilyInstance.Location为LocationCurve）来扩展它。</p>
<p>通过使用Document.NewFamilyList（）一次创建多个族实例，可以简化代码并提高性能。此方法有一个参数，该参数是描述要创建的族实例的FamilyInstanceCreationData对象的列表。</p>
<p>代码区域12-2：批量创建族实例</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function">ICollection <span class="title">BatchCreateColumns</span>(<span class="params">Autodesk.Revit.DB.Document document, Level level</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        List fiCreationDatas = <span class="keyword">new</span> List();</span><br><span class="line"></span><br><span class="line">        ICollection elementSet = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Try to get a FamilySymbol</span></span><br><span class="line">        FamilySymbol familySymbol = <span class="literal">null</span>;</span><br><span class="line">        FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">        ICollection collection = collector.OfClass(<span class="keyword">typeof</span>(FamilySymbol)).ToElements();</span><br><span class="line">        <span class="keyword">foreach</span> (Element e <span class="keyword">in</span> collection)</span><br><span class="line">        &#123;</span><br><span class="line">                familySymbol = e <span class="keyword">as</span> FamilySymbol;</span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">null</span> != familySymbol.Category)</span><br><span class="line">                &#123;</span><br><span class="line">                        <span class="keyword">if</span> (<span class="string">&quot;Structural Columns&quot;</span> == familySymbol.Category.Name)</span><br><span class="line">                        &#123;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != familySymbol)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="comment">//Create 10 FamilyInstanceCreationData items for batch creation </span></span><br><span class="line">                <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt; <span class="number">11</span>; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                        XYZ location = <span class="keyword">new</span> XYZ(i * <span class="number">10</span>, <span class="number">100</span>, <span class="number">0</span>);</span><br><span class="line">                        FamilyInstanceCreationData fiCreationData = <span class="keyword">new</span> FamilyInstanceCreationData(location, familySymbol, level, </span><br><span class="line">                                        StructuralType.Column);</span><br><span class="line">                        <span class="keyword">if</span> (<span class="literal">null</span> != fiCreationData)</span><br><span class="line">                        &#123;</span><br><span class="line">                                fiCreationDatas.Add(fiCreationData);</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (fiCreationDatas.Count &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                        <span class="comment">// Create Columns</span></span><br><span class="line">            elementSet = document.Create.NewFamilyInstances2(fiCreationDatas);</span><br><span class="line">        &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Batch creation failed.&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;No column types found.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> elementSet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>某些族类型的实例最好通过Autodesk.Revit.Creation.Document.NewFamilyInstance（）以外的方法创建。这些列于下表。</p>
<p>表33 -使用其他方法创建实例的选项</p>
<table>
<thead>
<tr>
<th><strong>Category 类别</strong></th>
<th><strong>Creation method 创建方法</strong></th>
<th><strong>Comments</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Air Terminal Tags Area Load Tags Area Tags Casework Tags Ceiling Tags Communication Device Tags Curtain Panel Tags Data Device Tags Detail Item Tags Door Tags Duct Accessory Tags Duct Fitting Tags Duct Tags Electrical Equipment Tags Electrical Fixture Tags Fire Alarm Device Tags Flex Duct Tags Flex Pipe Tags Floor Tags Furniture System Tags Furniture Tags Generic Model Tags Internal Area Load Tags Internal Line Load Tags Internal Point Load Tags Keynote Tags Lighting Device Tags Lighting Fixture Tags Line Load Tags Mass Floor Tags Mass Tags Mechanical Equipment Tags Nurse Call Device Tags Parking Tags Pipe Accessory Tags Pipe Fitting Tags Pipe Tags Planting Tags Plumbing Fixture Tags Point Load Tags Property Line Segment Tags Property Tags Railing Tags Revision Cloud Tags Roof Tags Room Tags Security Device Tags Site Tags Space Tags Specialty Equipment Tags Spinkler Tags Stair Tags Structural Area Reinforcement Tags Structural Beam System Tags Structural Column Tags Structural Connection Tags Structural Foundation Tags Structural Framing Tags Structural Path Reinforcement Tags Structural Rebar Tags Structural Stiffener Tags Structural Truss Tags Telephone Device Tags Wall Tags Window Tags Wire Tag Zone Tags on Tags Structural Foundation Tags Structural Framing Tags Structural Path Reinforcement Tags Structural Rebar Tags Structural Truss Tags Telephone Device Tags Wall Tags Window Tags Wire Tag Zone</td>
<td>IndependentTag.Create(Document, ElementId, Reference, Boolean, TagMode, TagOrientation, XYZ)</td>
<td>TagMode should be TM_ADDBY_CATEGORY and there should be a related tag loaded when try to create a tag，otherwise exception will be thrown（当尝试创建一个标记时，应该有一个相关的标签载入家庭）</td>
</tr>
<tr>
<td>Material Tags</td>
<td>IndependentTag.Create(Document, ElementId, Reference, Boolean, TagMode, TagOrientation, XYZ)</td>
<td>TagMode应为TM_ADDBY_MATERIAL，并且应加载材质标签族，否则将引发异常</td>
</tr>
<tr>
<td>Multi-Category Tags</td>
<td>IndependentTag.Create(Document, ElementId, Reference, Boolean, TagMode, TagOrientation, XYZ)</td>
<td>TagMode应为TM_ADDBY_MULTICATEGORY，并且应加载多类别标记族，否则将抛出异常</td>
</tr>
<tr>
<td>Title Blocks</td>
<td>ViewSheet.Create(Document, ElementId)</td>
<td>标题栏将添加到新创建的图纸中。</td>
</tr>
</tbody></table>
<p>使用Document.LoadFamily（）或Document.LoadFamilySymbol（）方法加载族和族符号。某些族（如梁）具有多个端点，插入方式与插入单个点实例的方式相同。插入线性族实例后，可以使用Element.Location属性更改其端点。有关详细信息，请参阅代码示例。</p>
<h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p>用于使用Family Data的代码示例。</p>
<p>有关使用Family Object的详细信息，请查看以下代码示例。请注意，在NewFamilyInstance（）方法中，需要StructuralType参数来指定要创建的族实例的类型。以下是一些示例：</p>
<p>表34：NewFamilyInstance（）方法中StructuralType参数的值</p>
<table>
<thead>
<tr>
<th><strong>Type of Family Instance 族实例的类型</strong></th>
<th><strong>Value of StructuralType StructuralType的值</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Doors, tables, etc. 门、桌子等</td>
<td>NonStructural 非结构</td>
</tr>
<tr>
<td>Beams 梁</td>
<td>Beam 梁</td>
</tr>
<tr>
<td>Braces 支撑</td>
<td>Brace 支撑</td>
</tr>
<tr>
<td>Columns 柱</td>
<td>Column 柱</td>
</tr>
<tr>
<td>Footings 基础</td>
<td>Footing 基础</td>
</tr>
</tbody></table>
<h3 id="创建桌"><a href="#创建桌" class="headerlink" title="创建桌"></a>创建桌</h3><p>以下函数演示了如何将表族加载到Revit项目中，以及如何从该族中的所有符号创建实例。</p>
<p>如果指定的族以前已加载，则LoadFamily（）方法返回false。因此，在以下情况下，在调用此函数之前，不加载族Table-Dining Round w Chairs.rfa。在本例中，默认情况下，桌是在标高1创建的。</p>
<p>代码区域12-3：创建桌</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateTables</span>(<span class="params">Autodesk.Revit.DB.Document document</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    String fileName = <span class="string">@&quot;C:\ProgramData\Autodesk\RVT 2014\Libraries\US Imperial\Furniture\Tables\Table-Dining Round w Chairs.rfa&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// try to load family</span></span><br><span class="line">    Family family = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (!document.LoadFamily(fileName, <span class="keyword">out</span> family))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Unable to load &quot;</span> + fileName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Loop through table symbols and add a new table for each</span></span><br><span class="line">    ISet familySymbolIds = family.GetFamilySymbolIds();</span><br><span class="line">    <span class="built_in">double</span> x = <span class="number">0.0</span>, y = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">foreach</span> (ElementId id <span class="keyword">in</span> familySymbolIds)</span><br><span class="line">    &#123;</span><br><span class="line">        FamilySymbol symbol = family.Document.GetElement(id) <span class="keyword">as</span> FamilySymbol;</span><br><span class="line">        symbol.Activate();</span><br><span class="line">        XYZ location = <span class="keyword">new</span> XYZ(x, y, <span class="number">10.0</span>);</span><br><span class="line"></span><br><span class="line">        FamilyInstance instance = document.Create.NewFamilyInstance(location, symbol, StructuralType.NonStructural);</span><br><span class="line">        x += <span class="number">10.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>加载桌族并放置每个FamilySymbol的一个实例的结果：</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-5FE17FC0-A248-47AE-A08A-1BBA3156193B-low.png"></p>
<p>图47：在Revit项目中加载族并创建表格 </p>
<h3 id="创建Beam"><a href="#创建Beam" class="headerlink" title="创建Beam"></a>创建Beam</h3><p> 在此示例中，加载的是族符号而不是族，因为加载单个FamilySymbol比加载包含许多FamilySymbol的族要快。</p>
<p>代码区域12-4：创建梁</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function">FamilyInstance <span class="title">CreateBeam</span>(<span class="params">Autodesk.Revit.DB.Document document, View view</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get the given view&#x27;s level for beam creation</span></span><br><span class="line">    Level level = document.GetElement(view.LevelId) <span class="keyword">as</span> Level;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get a family symbol</span></span><br><span class="line">    FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">    collector.OfClass(<span class="keyword">typeof</span>(FamilySymbol)).OfCategory(BuiltInCategory.OST_StructuralFraming);</span><br><span class="line"></span><br><span class="line">    FamilySymbol gotSymbol = collector.FirstElement() <span class="keyword">as</span> FamilySymbol;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create new beam 10&#x27; long starting at origin</span></span><br><span class="line">    XYZ startPoint = <span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    XYZ endPoint = <span class="keyword">new</span> Autodesk.Revit.DB.XYZ(<span class="number">10</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    Autodesk.Revit.DB.Curve beamLine = Line.CreateBound(startPoint, endPoint);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create a new beam</span></span><br><span class="line">    FamilyInstance instance = document.Create.NewFamilyInstance(beamLine, gotSymbol,</span><br><span class="line">                                                                level, StructuralType.Beam);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="创建门"><a href="#创建门" class="headerlink" title="创建门"></a>创建门</h3><p>创建一个长约180’的长墙，并在运行此示例之前选择它。宿主对象必须支持插入实例;否则NewFamilyInstance（）方法将失败。如果没有为必须在宿主中创建的实例提供宿主元素，或者无法将实例插入到指定的宿主元素中，则方法NewFamilyInstance（）不执行任何操作。</p>
<p>代码区域12-5：创建门</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateDoorsInWall</span>(<span class="params">Autodesk.Revit.DB.Document document, Wall wall</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// get wall&#x27;s level for door creation</span></span><br><span class="line">    Level level = document.GetElement(wall.LevelId) <span class="keyword">as</span> Level;</span><br><span class="line"></span><br><span class="line">    FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">    ICollection collection = collector.OfClass(<span class="keyword">typeof</span>(FamilySymbol))</span><br><span class="line">                                                .OfCategory(BuiltInCategory.OST_Doors)</span><br><span class="line">                                                .ToElements();</span><br><span class="line">    IEnumerator symbolItor = collection.GetEnumerator();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">double</span> x = <span class="number">0</span>, y = <span class="number">0</span>, z = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (symbolItor.MoveNext())</span><br><span class="line">    &#123;</span><br><span class="line">        FamilySymbol symbol = symbolItor.Current <span class="keyword">as</span> FamilySymbol;</span><br><span class="line">        symbol.Activate();</span><br><span class="line">        XYZ location = <span class="keyword">new</span> XYZ(x, y, z);</span><br><span class="line">        FamilyInstance instance = document.Create.NewFamilyInstance(location, symbol, wall, level, StructuralType.NonStructural);</span><br><span class="line">        x += <span class="number">10</span>;</span><br><span class="line">        y += <span class="number">10</span>;</span><br><span class="line">        z += <span class="number">1.5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下图显示了在Revit中执行上述代码的结果。请注意，如果指定的位置不在指定的标高上，NewFamilyInstance（）方法将使用位置标高而不是标高。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-3175405A-CD58-4A39-8DC8-696E76652DBB-low.png"></p>
<p>图48：将门插入墙壁</p>
<h3 id="使用参考方向创建族实例"><a href="#使用参考方向创建族实例" class="headerlink" title="使用参考方向创建族实例"></a>使用参考方向创建族实例</h3><p>使用参照方向可在特定方向上插入项目。</p>
<p>代码区域12-6：使用参考方向创建族实例</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Get a floor to place the beds</span></span><br><span class="line">FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">Floor floor = collector.OfClass(<span class="keyword">typeof</span>(Floor)).FirstElement() <span class="keyword">as</span> Floor;</span><br><span class="line"><span class="keyword">if</span> (floor != <span class="literal">null</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Find a Bed-Box family</span></span><br><span class="line">    Family family = <span class="literal">null</span>;</span><br><span class="line">    FilteredElementCollector famCollector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">    famCollector.OfClass(<span class="keyword">typeof</span>(Family));</span><br><span class="line">    ICollection collection = famCollector.ToElements();</span><br><span class="line">    <span class="keyword">foreach</span> (Element element <span class="keyword">in</span> collection)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (element.Name.CompareTo(<span class="string">&quot;双人床 - 箱式&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            family = element <span class="keyword">as</span> Family;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (family != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Enumerate the beds in the Bed-Box family</span></span><br><span class="line">        FilteredElementCollector fsCollector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">        ICollection fsCollection = fsCollector.WherePasses(<span class="keyword">new</span> FamilySymbolFilter(family.Id)).ToElements();</span><br><span class="line">        IEnumerator symbolItor = fsCollection.GetEnumerator();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (symbolItor.MoveNext())</span><br><span class="line">        &#123;</span><br><span class="line">            FamilySymbol symbol = symbolItor.Current <span class="keyword">as</span> FamilySymbol;</span><br><span class="line">            symbol.Activate();</span><br><span class="line">            XYZ location = <span class="keyword">new</span> XYZ(x, y, <span class="number">0</span>);</span><br><span class="line">            XYZ direction = <span class="keyword">new</span> XYZ();</span><br><span class="line">            <span class="keyword">switch</span> (i % <span class="number">3</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                    direction = <span class="keyword">new</span> XYZ(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                    direction = <span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                    direction = <span class="keyword">new</span> XYZ(<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            FamilyInstance instance = document.Create.NewFamilyInstance(location, symbol, direction, floor, StructuralType.NonStructural);</span><br><span class="line">            x += <span class="number">10</span>;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上一个代码的结果显示在下图中：</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-86B0A1C3-988D-4C4B-BA8E-3C8C9BDEAAE0-low.png"></p>
<p>图49：使用不同的参照方向创建族实例</p>
<h2 id="族符号"><a href="#族符号" class="headerlink" title="族符号"></a>族符号</h2><p>FamilySymbol类表示族中的单个类型。</p>
<p>每个族可以包含一个或多个族符号。每个FamilyInstance都有一个关联的FamilySymbol，可以从其Symbol属性访问。</p>
<h3 id="热属性"><a href="#热属性" class="headerlink" title="热属性"></a>热属性</h3><p>某些类型的族（门、窗和幕墙嵌板）包含下面窗的“类型属性”窗口中所示的热属性。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/FamilyThermalProperties2-76173.jpg"></p>
<p>FamilySymbol的热属性由FamilyThermalProperties类表示，并使用FamilySymbol.GetThermalProperties（）方法检索。可以使用SetThermalProperties（）设置FamilySymbol的FamilyThermalProperties。FamilyThermalProperties类本身的属性是只读的。</p>
<p>计算值的单位如下表所示。</p>
<table>
<thead>
<tr>
<th><strong>Property 属性</strong></th>
<th><strong>Unit 单位</strong></th>
</tr>
</thead>
<tbody><tr>
<td>HeatTransferCoefficient 传热系数</td>
<td>watts per meter-squared kelvin (W&#x2F;(m^2<em>K)</em></td>
</tr>
<tr>
<td>ThermalResistance 热阻</td>
<td>meter-squared kelvin per watt ((m^2K)&#x2F;Watt)</td>
</tr>
</tbody></table>
<p>AnalyticConstructionTypeId属性是构造gbXML类型，并返回与Constructions.xml中constructionType节点的“id”属性对应的值。静态FamilyThermalProperties.Find（）方法将通过Constructions.xml中constructionType节点的“id”属性查找FamilyThermalProperties。</p>
<p> #FamilyType参数 </p>
<p>FamilySymbol的某些参数可以是FamilyType参数。对于这些参数，可以使用Family.GetFamilyTypeParameterValues（）方法获取参数的所有适用值。返回的值是与给定参数的定义所指定的类别相匹配的所有族类型的ElementId。这些元素属于类ElementType或NestedFamilyTypeReference。第二种变体适用于嵌套在族中的类型，因此无法以其他方式访问。NestedFamilyTypeReference元素仅存储有关嵌套FamilyType的基本信息，例如Type的名称、Family的名称和Category。这些元素非常低级，因此被标准元素过滤器绕过，因此获取它们的主要方法是通过Family.GetFamilyTypeParameterValues（）方法。 以下示例演示如何获取FamilySymbol的FamilyType参数的所有族类型参数值。然后将参数的值更改为另一个值。此更改将影响使用加载的FamilySymbol的所有FamilySymbol。</p>
<p>代码区域：获取嵌套的FamilyTypes</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetNestedFamilyTypes</span>(<span class="params">FamilyInstance instance</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// find one FamilyType parameter and all values applicable to it</span></span><br><span class="line"></span><br><span class="line">    Parameter aTypeParam = <span class="literal">null</span>;</span><br><span class="line">    ISet values = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    Family family = instance.Symbol.Family;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">foreach</span> (Parameter param <span class="keyword">in</span> instance.Symbol.Parameters)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (param.Definition.ParameterType == ParameterType.FamilyType)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            aTypeParam = param;</span><br><span class="line"></span><br><span class="line">            values = family.GetFamilyTypeParameterValues(param.Id);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (aTypeParam == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        TaskDialog.Show(<span class="string">&quot;Warning&quot;</span>, <span class="string">&quot;The selected family has no FamilyType parameter defined.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (values == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        TaskDialog.Show(<span class="string">&quot;Error&quot;</span>, <span class="string">&quot;A FamilyType parameter does not have any applicable values!?&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        ElementId newValue = values.Last();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (newValue != aTypeParam.AsElementId())</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">using</span> (Transaction trans = <span class="keyword">new</span> Transaction(instance.Document, <span class="string">&quot;Setting parameter value&quot;</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                trans.Start();</span><br><span class="line">                aTypeParam.Set(newValue);</span><br><span class="line">                trans.Commit();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="族"><a href="#族" class="headerlink" title="族"></a>族</h2><p>“族”类表示整个Revit族。它包含FamilySymbols使用的FamilySymbols。</p>
<h3 id="载入族"><a href="#载入族" class="headerlink" title="载入族"></a>载入族</h3><p>Document类包含LoadFamily（）和LoadFamilySymbol（）方法。</p>
<ul>
<li>LoadFamily（）将整个族及其所有类型或符号加载到项目中。</li>
<li>LoadFamilySymbol（）仅将指定的族符号从族文件载入到项目中。</li>
</ul>
<p><strong>注意：</strong>要提高应用程序的性能并减少内存使用，请尽可能加载特定的FamilySymbol，而不是整个Family对象。</p>
<ul>
<li>使用Options.Application对象GetLibraryPaths（）方法检索族文件路径。</li>
<li>Options.Application对象是使用Application对象的Options属性检索的。</li>
<li>在LoadFamilySymbol（）中，输入参数Name与FamilySymbol对象Name属性返回的字符串值相同。</li>
</ul>
<p>有关详细信息，请参阅代码示例。</p>
<p>类别</p>
<p>FamilyCategory属性指示族的类别，例如柱、家具、结构框架或窗。</p>
]]></content>
      <categories>
        <category>Revit二次开发人员指南</category>
      </categories>
      <tags>
        <tag>Revit</tag>
      </tags>
  </entry>
  <entry>
    <title>12墙、楼板、天花板、屋顶和洞口</title>
    <url>/2024/11/21/%E4%BA%8C%E5%BC%80%E6%8C%87%E5%8D%97/12%E5%A2%99%E3%80%81%E6%A5%BC%E6%9D%BF%E3%80%81%E5%A4%A9%E8%8A%B1%E6%9D%BF%E3%80%81%E5%B1%8B%E9%A1%B6%E5%92%8C%E6%B4%9E%E5%8F%A3/</url>
    <content><![CDATA[<h1 id="墙、楼板、天花板、屋顶和洞口"><a href="#墙、楼板、天花板、屋顶和洞口" class="headerlink" title="墙、楼板、天花板、屋顶和洞口"></a><a href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_Revit_Geometric_Elements_Walls_Floors_Ceilings_Roofs_and_Openings_html">墙、楼板、天花板、屋顶和洞口</a></h1><p>元素和表示内置位置构造的相应ElementType。</p>
<p>以下部分介绍与内置位置构造（如墙、楼板、天花板、屋顶和洞口）相关的类及其相应的属性。</p>
<p>本节中的页面</p>
<ul>
<li>墙</li>
<li>楼板、天花板和基础</li>
<li>屋顶</li>
<li>幕墙</li>
<li>其他元素</li>
<li>复合结构</li>
<li>洞口</li>
<li>热属性</li>
</ul>
<h2 id="墙"><a href="#墙" class="headerlink" title="墙"></a>墙</h2><p>WallType.Kind枚举表示四种墙：</p>
<ul>
<li>Stacked 叠层墙</li>
<li>Curtain 幕墙</li>
<li>Basic 基本</li>
<li>Unknown 未知</li>
</ul>
<p>Wall和WallType类与基本墙类型一起使用，同时为叠层墙和幕墙提供有限的功能。有时您需要检查墙以确定墙类型。例如，不能使用API从叠层墙获取子墙。WallKind是只读的，由系统系列设置。</p>
<p>Wall.Flipped属性和Wall.flip（）方法可以访问和控制墙的方向。在下面的示例中，将在调用flip（）方法之前和之后比较Wall。</p>
<ul>
<li>之前的Orientation属性为（0.0，1.0，0.0）。</li>
<li>翻转调用后的Orientation属性为（0.0，-1.0，0.0）。</li>
<li>“墙定位线（WALL_KEY_REF_PARAM）”参数为3，表示下表中的“饰面：内部”。</li>
<li>以该线为参照，墙将被移动，但“位置”不会更改。</li>
</ul>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-4BFD801E-18BC-4021-8371-C29AF13CF7EE-low.png"></p>
<p><strong>图33：原始墙</strong></p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-85CF3DAD-C029-41C5-ACC6-1FEC8CA304E4-low.png"></p>
<p><strong>图34：翻转后的墙</strong></p>
<p><strong>表24：墙位置线</strong></p>
<table>
<thead>
<tr>
<th><strong>Location Line Value 定位线值</strong></th>
<th><strong>Description 描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>墙中心线</td>
</tr>
<tr>
<td>1</td>
<td>核心层中心线</td>
</tr>
<tr>
<td>2</td>
<td>表面：外部</td>
</tr>
<tr>
<td>3</td>
<td>表面：内部</td>
</tr>
<tr>
<td>4</td>
<td>核心面：外部</td>
</tr>
<tr>
<td>5</td>
<td>核心面：内部</td>
</tr>
</tbody></table>
<p>Wall类中有五个静态覆盖方法可用于创建Wall：</p>
<p>表25：Create（）重载</p>
<table>
<thead>
<tr>
<th><strong>Name 名称</strong></th>
<th><strong>Description 描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Create(Document, Curve, WallType, Level, Double, Double, Boolean, Boolean)</td>
<td>使用指定的墙类型、高度和偏移在项目中创建新的矩形轮廓墙。</td>
</tr>
<tr>
<td>Create(Document, IList Curve , Boolean)</td>
<td>使用默认墙样式在项目中创建非矩形轮廓墙。</td>
</tr>
<tr>
<td>Create(Document, Curve, ElementId, Boolean)</td>
<td>使用默认墙样式在项目中由ElementId指定的标高上创建新的矩形轮廓墙。</td>
</tr>
<tr>
<td>Create(Document, IList Curve , ElementId, ElementId, Boolean)</td>
<td>使用指定的墙类型在项目中创建非矩形轮廓墙。</td>
</tr>
<tr>
<td>Create(Document, IList Curve , ElementId, ElementId, Boolean, XYZ)</td>
<td>使用指定的墙类型和法向量在项目中创建非矩形轮廓墙。</td>
</tr>
</tbody></table>
<p>WallType墙功能（WALL_ATTR_EXTERIOR）参数会影响创建的墙实例“房间边界和结构用途”参数。WALL_ATTR_EXTERIOR值是一个整数：</p>
<p><strong>表26：墙功能</strong></p>
<table>
<thead>
<tr>
<th><strong>Wall Function 墙功能</strong></th>
<th><strong>Interior 内部</strong></th>
<th><strong>Exterior 外部</strong></th>
<th><strong>Foundation 基础墙</strong></th>
<th><strong>Retaining 挡土墙</strong></th>
<th><strong>Soffit 檐底板</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Value 值</td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
</tr>
</tbody></table>
<p>以下规则适用于由API创建的墙：</p>
<ul>
<li>如果输入结构参数为true或Wall Function（WALL_ATTR_EXTERIOR）参数为Foundation，则Wall StructuralUsage参数为Bearing;否则为NonBearing。</li>
<li>如果墙功能（WALL_ATTR_EXTERIOR）参数为“Retaining”，则创建的墙房间边界（WALL_ATTR_ROOM_BOUNDING）参数为false。</li>
</ul>
<p>有关与结构相关的函数（如AnalyticalModel属性）的详细信息，请参见结构工程。</p>
<h2 id="楼板、天花板和基础"><a href="#楼板、天花板和基础" class="headerlink" title="楼板、天花板和基础"></a>楼板、天花板和基础</h2><p>与楼板、天花板和基础关联的类。</p>
<p>楼板、天花板和基础相关的API项目包括：</p>
<p>表28：API中的地板、天花板和基础</p>
<table>
<thead>
<tr>
<th><strong>Object 对象</strong></th>
<th><strong>Element Type 元素类型</strong></th>
<th><strong>ElementType Type ElementType类型</strong></th>
<th><strong>Element Creation 元素创建</strong></th>
<th><strong>Other 其他</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Floor</td>
<td>Floor</td>
<td>FloorType</td>
<td>NewFloor()&#x2F;NewSlab()</td>
<td>FloorType.IsFoundationSlab &#x3D; false</td>
</tr>
<tr>
<td>Slab</td>
<td>Floor</td>
<td>FloorType</td>
<td>NewSlab()</td>
<td>FloorType.IsFoundationSlab &#x3D; false</td>
</tr>
<tr>
<td>Ceiling</td>
<td>Ceiling</td>
<td>CeilingType</td>
<td>No</td>
<td>Category &#x3D; OST_Ceilings</td>
</tr>
<tr>
<td>Wall Foundation</td>
<td>WallFoundation</td>
<td>WallFoundationType</td>
<td>No</td>
<td>Category &#x3D; OST_StructuralFoundation</td>
</tr>
<tr>
<td>Isolated Foundation</td>
<td>FamilyInstance</td>
<td>FamilySymbol</td>
<td>NewFamilyInstance()</td>
<td>Category &#x3D; OST_StructuralFoundation</td>
</tr>
<tr>
<td>Foundation Slab</td>
<td>Floor</td>
<td>FloorType</td>
<td>NewFloor()</td>
<td>Category &#x3D; OST_StructuralFoundation FloorType.IsFoundationSlab &#x3D; true</td>
</tr>
</tbody></table>
<p>注意：Floor和Ceiling派生自CeilingAndFloor类。以下规则适用于Floor：</p>
<ul>
<li>从基础设计栏创建的元素具有相同的类别OST_StructuralFoundation，但对应于不同的类。</li>
<li>FloorType IsFoundationSlab属性将FloorType类别设置为OST_StructuralFoundation或不设置。</li>
</ul>
<p>检索FloorType以使用NewFloor创建楼板或基础底板时，请使用以下方法：</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-26C2760B-04F0-4690-AF22-6EB1A0CDD933-low.png"></p>
<p>图35：创建基础和楼板</p>
<p>当前，API不提供对Floor类中的地板坡度箭头的访问。但是，在使用Revit的结构功能时，可以使用NewSlab（）创建斜板：</p>
<p>代码区域11-1：NewSlab（）</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Floor <span class="title">NewSlab</span>(<span class="params">CurveArray profile, Level level, Line slopedArrow, <span class="built_in">double</span> slope,<span class="built_in">bool</span> isStructural</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>使用slopedArrow参数创建坡度箭头。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-5589AB8C-03FB-4FE6-BB20-065A37058854-low.png"></p>
<p>图36：NewSlab中的slopedArrow参数</p>
<p>NewSlab（）中斜率参数的单位是rise&#x2F;run。</p>
<p>Floor.FloorType属性是使用Floor.GetTypeId（）方法的替代方法。有关与结构相关的成员（如GetSpanDirectionSymbolIds（）方法和SpanDirectionAngle属性）的详细信息，请参见结构工程部分。</p>
<p>在Revit中编辑独立基础时，可以执行以下操作：</p>
<ul>
<li>您可以选取宿主，例如楼板。但是，FamilyInstance对象Host属性始终返回null。</li>
<li>删除宿主楼板时，基础不会随之删除。</li>
<li>Foundation 宿主可通过Host（MANANCE_FREE_HOST_PARAM）参数访问。</li>
<li>使用另一个相关的“偏移”（Offset_FREE_HOST_OFFSET_PARAM）参数控制宿主元素的基础偏移。</li>
</ul>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-6FECE5EE-DCFE-42E5-B3F8-868B44E774D5-low.png"></p>
<p>图37：为FoundationSlab（FamilyInstance）选择宿主</p>
<p>条形基础由API中的WallFoundation类表示。API提供对WallFoundation和WallFoundationType的有限访问，但使用GetAnalyticalModel（）方法时除外（请参阅“结构工程”部分中的分析模型）。例如，附着的墙不能用于Revit的建筑功能。使用Revit的结构功能，可以使用AnalyticalModel类中的GetAnalyticalModelSupports（）方法显示Wall类和WallFoundation类之间的关系。有关详细信息，请参见“结构工程”部分中的分析模型。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-03EA5485-1F1B-429D-8917-02B86A50E627-low.png"></p>
<h3 id="修改板"><a href="#修改板" class="headerlink" title="修改板"></a>修改板</h3><p>您可以使用SlabShapeEditor类修改基于板的元素的形式。此类允许您：</p>
<ul>
<li>操作选定的基于板的元素上的一个或多个点或边</li>
<li>在元素上添加点以更改元素的几何图形</li>
<li>添加线性边并将板的现有面拆分为更小的子面域</li>
<li>删除形状修改器并将图元几何图形重置回未修改的形状。</li>
</ul>
<p>下面是将选定的已修改地板恢复为其原始形状的示例：</p>
<p>代码区域11-2：恢复板的形状</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ResetSlabShapes</span>(<span class="params">Autodesk.Revit.DB.Document document</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        UIDocument uidoc = <span class="keyword">new</span> UIDocument(document);</span><br><span class="line">        Selection choices = uidoc.Selection;</span><br><span class="line">        ElementSet collection = choices.Elements;</span><br><span class="line">        <span class="keyword">foreach</span> (Autodesk.Revit.DB.Element elem <span class="keyword">in</span> collection)</span><br><span class="line">        &#123;</span><br><span class="line">                Floor floor = elem <span class="keyword">as</span> Floor;</span><br><span class="line">                <span class="keyword">if</span> (floor != <span class="literal">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                        SlabShapeEditor slabShapeEditor = floor.SlabShapeEditor;</span><br><span class="line">                        slabShapeEditor.ResetSlabShape();</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有关使用SlabShapeEditor和相关类的详细示例，请参见Revit SDK中包含的SlabShapeEditing示例应用程序。</p>
<h2 id="屋顶"><a href="#屋顶" class="headerlink" title="屋顶"></a>屋顶</h2><p>Revit API中屋顶的表示。</p>
<p>Revit Platform API中的屋顶均派生自RoofBase对象。有两个类：</p>
<ul>
<li>FootPrintRoof -表示由建筑物迹线区构成的屋顶</li>
<li>ExtrusionRoof -表示由拉伸轮廓制成的屋顶</li>
</ul>
<p>两者都有一个RoofType属性，用于获取或设置屋顶的类型。此示例说明如何基于某些选定的墙创建迹线屋顶：</p>
<p>代码区域11-3：创建迹线屋顶</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Before invoking this sample, select some walls to add a roof over.</span></span><br><span class="line"><span class="comment">// Make sure there is a level named &quot;Roof&quot; in the document.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// find the Roof level</span></span><br><span class="line">FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">collector.OfClass(<span class="keyword">typeof</span>(Level));</span><br><span class="line"><span class="keyword">var</span> elements = <span class="keyword">from</span> element <span class="keyword">in</span> collector <span class="keyword">where</span> element.Name == <span class="string">&quot;Roof&quot;</span> <span class="keyword">select</span> element;</span><br><span class="line">Level level = elements.Cast().ElementAt(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">collector.OfClass(<span class="keyword">typeof</span>(RoofType));</span><br><span class="line">RoofType roofType = collector.FirstElement() <span class="keyword">as</span> RoofType; </span><br><span class="line"></span><br><span class="line"><span class="comment">// Get the handle of the application</span></span><br><span class="line">Autodesk.Revit.ApplicationServices.Application application = document.Application;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Define the footprint for the roof based on user selection</span></span><br><span class="line">CurveArray footprint = application.Create.NewCurveArray();</span><br><span class="line">UIDocument uidoc = <span class="keyword">new</span> UIDocument(document);</span><br><span class="line">ICollection selectedIds = uidoc.Selection.GetElementIds();</span><br><span class="line"><span class="keyword">if</span> (selectedIds.Count != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">foreach</span> (ElementId id <span class="keyword">in</span> selectedIds)</span><br><span class="line">    &#123;</span><br><span class="line">        Element element = document.GetElement(id);</span><br><span class="line">        Wall wall = element <span class="keyword">as</span> Wall;</span><br><span class="line">        <span class="keyword">if</span> (wall != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            LocationCurve wallCurve = wall.Location <span class="keyword">as</span> LocationCurve;</span><br><span class="line">            footprint.Append(wallCurve.Curve);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ModelCurve modelCurve = element <span class="keyword">as</span> ModelCurve;</span><br><span class="line">        <span class="keyword">if</span> (modelCurve != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            footprint.Append(modelCurve.GeometryCurve);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;You should select a curve loop, or a wall loop, or loops combination \nof walls and curves to create a footprint roof.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ModelCurveArray footPrintToModelCurveMapping = <span class="keyword">new</span> ModelCurveArray();</span><br><span class="line">FootPrintRoof footprintRoof = document.Create.NewFootPrintRoof(footprint, level, roofType, <span class="keyword">out</span> footPrintToModelCurveMapping);</span><br><span class="line">ModelCurveArrayIterator iterator = footPrintToModelCurveMapping.ForwardIterator();</span><br><span class="line">iterator.Reset();</span><br><span class="line"><span class="keyword">while</span> (iterator.MoveNext())</span><br><span class="line">&#123;</span><br><span class="line">    ModelCurve modelCurve = iterator.Current <span class="keyword">as</span> ModelCurve;</span><br><span class="line">    footprintRoof.set_DefinesSlope(modelCurve, <span class="literal">true</span>);</span><br><span class="line">    footprintRoof.set_SlopeAngle(modelCurve, <span class="number">0.5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有关如何创建ExtrusionRoof的示例，请参见Revit API SDK附带的NewRoof示例应用程序。</p>
<p>天沟、筋膜檐沟和封檐带图元派生自表示屋顶的HostedSweep类。可以通过API创建、删除或修改它们。若要创建这些元素，请使用Document.Create.NewFascia（）或Document.Create.NewGutter（）重写之一。有关如何创建新檐沟和封檐带的示例，请参见SDK示例中包含的NewHostedSweep应用程序。下面是一个代码片段，显示了您可以修改gutter元素的属性。</p>
<p>代码区域11-4：修改天沟</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ModifyGutter</span>(<span class="params">Autodesk.Revit.DB.Document document</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        UIDocument uidoc = <span class="keyword">new</span> UIDocument(document);</span><br><span class="line">        ElementSet collection = uidoc.Selection.Elements;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">foreach</span> (Autodesk.Revit.DB.Element elem <span class="keyword">in</span> collection)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">if</span> (elem <span class="keyword">is</span> Gutter)</span><br><span class="line">                &#123;</span><br><span class="line">                        Gutter gutter = elem <span class="keyword">as</span> Gutter;</span><br><span class="line">                        <span class="comment">// convert degrees to rads:</span></span><br><span class="line">                        gutter.Angle = <span class="number">45.00</span> * Math.PI / <span class="number">180</span>;</span><br><span class="line">                        TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>,<span class="string">&quot;Changed gutter angle&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="幕墙"><a href="#幕墙" class="headerlink" title="幕墙"></a>幕墙</h2><p>幕墙、幕墙系统和幕墙屋顶是CurtainGrid对象的主体图元。幕墙只能有一个CurtainGrid，而幕墙系统和幕墙屋顶可以包含一个或多个CurtainGrid。有关如何创建CurtainSystem的示例，请参见Revit SDK附带的CurtainSystem示例应用程序。有关创建幕墙并使用网格线填充幕墙的示例，请参见CurtainWallGrid示例应用程序。</p>
<h2 id="其他元素"><a href="#其他元素" class="headerlink" title="其他元素"></a>其他元素</h2><p>有些元素不是HostObject（也没有特定的类），但它们是可以承载其他对象的特殊情况。例如，ramp及其关联的元素类型在API中没有特定的类，而是在OST_Ramp类别中表示为Element和ElementType。</p>
<h2 id="复合结构"><a href="#复合结构" class="headerlink" title="复合结构"></a>复合结构</h2><p>描述墙、楼板、屋顶或天花板的内部结构。</p>
<p>墙、楼板、天花板和屋顶都是API类HostObject的子对象。HostObject（及其相关类型类HostObjAttributes）提供对CompoundStructure的只读访问。复合结构由有序层的集合组成，对于墙来说，从外部到内部，或者对于地板，屋顶或天花板来说，从顶部到底部。这些层的属性决定了相关墙、楼板、屋顶或天花板的整体结构的厚度、材质和功能。</p>
<p>层可以通过GetLayers（）方法访问，并使用SetLayers（）完全替换。</p>
<p>通常，这些层是平行的，并以固定的层宽度延伸整个主体对象。然而，对于墙，结构也可以是“垂直复合”的，其中层在距墙的顶部和底部的指定垂直距离处变化。使用CompoundStructure.IsVerticallyCompound来标识它们。对于垂直复合结构，该结构通过矩形描述垂直截面，该矩形被划分为多边形区域，多边形区域的边都是垂直或水平段。映射将这些区域中的每一个与CompoundStructure中的层的索引相关联，该层的索引确定该区域的属性。</p>
<p>可以使用复合结构来找到不同层边界的几何位置。方法CompoundStructure.GetOffsetForLocationLine（）提供从中心定位线到任何定位线选项（芯体中心线、任一侧的饰面面或芯体侧）的偏移。</p>
<p>有了到定位线的偏移，您可以从已知位置开始，使用CompoundStructure.GetLayerWidth（）获取每个边界层的宽度，从而获取每个层边界的位置。</p>
<p>使用CompoundStructure的一些注意事项：</p>
<ul>
<li>元素的总宽度是每个CompoundStructureLayer的宽度之和。您无法直接更改元素的总宽度，但可以通过更改CompoundStructureLayer宽度来更改它。指定的可变长度层的索引（如果已分配）可以从CompoundStructure.VariableLayerIndex获得。</li>
<li>必须将CompoundStructure设置回HostObjAttributes实例（使用HostObjAttributes.SetCompoundStructure（）方法），以便存储任何更改。</li>
<li>对HostObjAttributes的更改会影响当前文档中的每个实例。如果需要新的层组合，则需要创建新的HostObjAttributes（使用ElementType.Duplicate（））并将新的CompoundStructure分配给它。</li>
<li>CompoundStructureLayer DeckProfileId和DeckEmbeddingType属性仅适用于Revit结构要素中的Slab。有关详细信息，请参阅结构工程。</li>
</ul>
<h3 id="材质"><a href="#材质" class="headerlink" title="材质"></a>材质</h3><p>HostObjAttributes中的每个CompoundStructureLayer通常与某种类型的材质一起显示。如果CompoundStructureLayer.MaterialId返回-1，则表示该Material与Category相关。有关详细信息，请参阅材料。获取CompoundStructureLayer材质的示例代码如下：</p>
<p>代码区域11-5：获取CompoundStructureLayer材质</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetWallLayerMaterial</span>(<span class="params">Autodesk.Revit.DB.Document document, Wall wall</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">// get WallType of wall</span></span><br><span class="line">        WallType aWallType = wall.WallType;</span><br><span class="line">        <span class="comment">// Only Basic Wall has compoundStructure</span></span><br><span class="line">        <span class="keyword">if</span> (WallKind.Basic == aWallType.Kind)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Get CompoundStructure</span></span><br><span class="line">                CompoundStructure comStruct = aWallType.GetCompoundStructure();</span><br><span class="line">                Categories allCategories = document.Settings.Categories;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Get the category OST_Walls default Material; </span></span><br><span class="line">                <span class="comment">// use if that layer&#x27;s default Material is </span></span><br><span class="line">                Category wallCategory = allCategories.get_Item(BuiltInCategory.OST_Walls);</span><br><span class="line">                Autodesk.Revit.DB.Material wallMaterial = wallCategory.Material;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">foreach</span> (CompoundStructureLayer structLayer <span class="keyword">in</span> comStruct.GetLayers())</span><br><span class="line">                &#123;</span><br><span class="line">                        Autodesk.Revit.DB.Material layerMaterial = </span><br><span class="line">                                document.GetElement(structLayer.MaterialId) <span class="keyword">as</span> Material;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// If CompoundStructureLayer&#x27;s Material is specified, use default</span></span><br><span class="line">                        <span class="comment">// Material of its Category</span></span><br><span class="line">                        <span class="keyword">if</span> (<span class="literal">null</span> == layerMaterial)</span><br><span class="line">                        &#123;</span><br><span class="line">                                <span class="keyword">switch</span> (structLayer.Function)</span><br><span class="line">                                &#123;</span><br><span class="line">                                        <span class="keyword">case</span> MaterialFunctionAssignment.Finish1:</span><br><span class="line">                                                layerMaterial =</span><br><span class="line">                                                        allCategories.get_Item(BuiltInCategory.OST_WallsFinish1).Material;</span><br><span class="line">                                                <span class="keyword">break</span>;</span><br><span class="line">                                        <span class="keyword">case</span> MaterialFunctionAssignment.Finish2:</span><br><span class="line">                                                layerMaterial =</span><br><span class="line">                                                        allCategories.get_Item(BuiltInCategory.OST_WallsFinish2).Material;</span><br><span class="line">                                                <span class="keyword">break</span>;</span><br><span class="line">                                        <span class="keyword">case</span> MaterialFunctionAssignment.Membrane:</span><br><span class="line">                                                layerMaterial =</span><br><span class="line">                                                        allCategories.get_Item(BuiltInCategory.OST_WallsMembrane).Material;</span><br><span class="line">                                                <span class="keyword">break</span>;</span><br><span class="line">                                        <span class="keyword">case</span> MaterialFunctionAssignment.Structure:</span><br><span class="line">                                                layerMaterial =</span><br><span class="line">                                                        allCategories.get_Item(BuiltInCategory.OST_WallsStructure).Material;</span><br><span class="line">                                                <span class="keyword">break</span>;</span><br><span class="line">                                        <span class="keyword">case</span> MaterialFunctionAssignment.Substrate:</span><br><span class="line">                                                layerMaterial = </span><br><span class="line">                                                        allCategories.get_Item(BuiltInCategory.OST_WallsSubstrate).Material;</span><br><span class="line">                                                <span class="keyword">break</span>;</span><br><span class="line">                                        <span class="keyword">case</span> MaterialFunctionAssignment.Insulation:</span><br><span class="line">                                                layerMaterial = </span><br><span class="line">                                                        allCategories.get_Item(BuiltInCategory.OST_WallsInsulation).Material;</span><br><span class="line">                                                <span class="keyword">break</span>;</span><br><span class="line">                                        <span class="literal">default</span>:</span><br><span class="line">                                                <span class="comment">// It is impossible to reach here</span></span><br><span class="line">                                                <span class="keyword">break</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">if</span> (<span class="literal">null</span> == layerMaterial)</span><br><span class="line">                                &#123;</span><br><span class="line">                                        <span class="comment">// CompoundStructureLayer&#x27;s default Material is its SubCategory</span></span><br><span class="line">                                        layerMaterial = wallMaterial;</span><br><span class="line">                                &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>,<span class="string">&quot;Layer Material: &quot;</span> + layerMaterial);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有时只需要“结构”层的材料。与其在每个层中查找其函数为MaterialFunctionAssignment.Structure的层，不如使用CompoundStructure.StructuralMaterialIndex属性查找其材料定义了类型的结构属性的层的索引，以便进行分析。<br>注意：调用SetLayers（）时，StructuralMaterialIndex值将被清除，需要重置。</p>
<h2 id="洞口"><a href="#洞口" class="headerlink" title="洞口"></a>洞口</h2><p>在Revit Platform API中，Opening对象派生自Element对象，并包含所有Element对象属性和方法。若要检索项目中的所有Openings，请使用Document.ElementIterator查找Elements.Opening对象。</p>
<h3 id="常规属性"><a href="#常规属性" class="headerlink" title="常规属性"></a>常规属性</h3><p>本节说明如何使用洞口属性。</p>
<ul>
<li><p>Isolation Boundary-确定洞口是否具有矩形边界。</p>
<ul>
<li>如果为true，则表示Opening具有矩形边界，并且可以从Opening BoundaryRect属性获取IList集合。否则，属性返回null。</li>
<li>如果为false，则可以从BoundaryCurves属性获取CurveArray对象。</li>
</ul>
</li>
<li><p>BoundaryCurves -如果开口边界不是矩形，则此属性检索几何信息;否则返回null。该属性返回一个CurveArray对象，其中包含表示Opening对象边界的曲线。有关曲线的更多详细信息，请参阅几何体。</p>
</li>
<li><p>BoundaryRect -如果开口边界是矩形，则可以使用此属性获取几何信息;否则返回null。</p>
<ul>
<li>该属性返回一个包含XYZ坐标的IList集合。</li>
<li>IList集合通常包含矩形边界的最小（左下）和最大（右上）坐标。</li>
</ul>
</li>
<li><p>Host -host属性检索Opening host元素。主体图元是由Opening对象剪切的图元。</p>
<p><strong>注意：</strong>如果洞口对象的类别为竖井洞口，则洞口主体为空。</p>
</li>
</ul>
<p>下面的示例说明如何检索现有的Opening属性。</p>
<p>代码区域11-6：检索现有洞口属性</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Getinfo_Opening</span>(<span class="params">Opening opening</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> message = <span class="string">&quot;Opening:&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//get the host element of this opening</span></span><br><span class="line">    message += <span class="string">&quot;\nThe id of the opening&#x27;s host element is : &quot;</span> + opening.Host.Id.IntegerValue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//get the information whether the opening has a rect boundary</span></span><br><span class="line">    <span class="comment">//If the opening has a rect boundary, we can get the geometry information from BoundaryRect property.</span></span><br><span class="line">    <span class="comment">//Otherwise we should get the geometry information from BoundaryCurves property</span></span><br><span class="line">    <span class="keyword">if</span> (opening.IsRectBoundary)</span><br><span class="line">    &#123;</span><br><span class="line">        message += <span class="string">&quot;\nThe opening has a rectangular boundary.&quot;</span>;</span><br><span class="line">        <span class="comment">//array contains two XYZ objects: the max and min coords of boundary</span></span><br><span class="line">        IList boundaryRect = opening.BoundaryRect;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//get the coordinate value of the min coordinate point</span></span><br><span class="line">        XYZ point = opening.BoundaryRect[<span class="number">0</span>];</span><br><span class="line">        message += <span class="string">&quot;\nMin coordinate point:(&quot;</span> + point.X + <span class="string">&quot;, &quot;</span></span><br><span class="line">                                + point.Y + <span class="string">&quot;, &quot;</span> + point.Z + <span class="string">&quot;)&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//get the coordinate value of the Max coordinate point</span></span><br><span class="line">        point = opening.BoundaryRect[<span class="number">1</span>];</span><br><span class="line">        message += <span class="string">&quot;\nMax coordinate point: (&quot;</span> + point.X + <span class="string">&quot;, &quot;</span></span><br><span class="line">                                + point.Y + <span class="string">&quot;, &quot;</span> + point.Z + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        message += <span class="string">&quot;\nThe opening doesn&#x27;t have a rectangular boundary.&quot;</span>;</span><br><span class="line">        <span class="comment">// Get curve number</span></span><br><span class="line">        <span class="built_in">int</span> curves = opening.BoundaryCurves.Size;</span><br><span class="line">        message += <span class="string">&quot;\nNumber of curves is : &quot;</span> + curves;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; curves; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Autodesk.Revit.DB.Curve curve = opening.BoundaryCurves.get_Item(i);</span><br><span class="line">            <span class="comment">// Get curve start point</span></span><br><span class="line">            message += <span class="string">&quot;\nCurve start point: &quot;</span> + XYZToString(curve.GetEndPoint(<span class="number">0</span>));</span><br><span class="line">            <span class="comment">// Get curve end point</span></span><br><span class="line">            message += <span class="string">&quot;; Curve end point: &quot;</span> + XYZToString(curve.GetEndPoint(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>,message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// output the point&#x27;s three coordinates</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">XYZToString</span>(<span class="params">XYZ point</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;(&quot;</span> + point.X + <span class="string">&quot;, &quot;</span> + point.Y + <span class="string">&quot;, &quot;</span> + point.Z + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="创建洞口"><a href="#创建洞口" class="headerlink" title="创建洞口"></a>创建洞口</h3><p>在Revit Platform API中，使用Document.NewOpening（）方法在项目中创建洞口。有四种方法重载可用于在不同的宿主元素中创建洞口：</p>
<p>代码区域11-7：NewOpening（）</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Create a new Opening in a beam, brace and column. </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Opening <span class="title">NewOpening</span>(<span class="params">Element famInstElement, CurveArray profile, eRefFace iFace</span>)</span>; </span><br></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Create a new Opening in a roof, floor and ceiling. </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Opening <span class="title">NewOpening</span>(<span class="params">Element hostElement, CurveArray profile, <span class="built_in">bool</span> bPerpendicularFace</span>)</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Create a new Opening Element. </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Opening <span class="title">NewOpening</span>(<span class="params">Level bottomLevel, Level topLevel, CurveArray  profile</span>)</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Create an opening in a straight wall or arc wall. </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Opening <span class="title">NewOpening</span>(<span class="params">Wall, XYZ pntStart, XYZ pntEnd</span>)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>在梁、支撑或柱中创建洞口-用于在族实例中创建洞口。iFace参数指示放置洞口的面。</li>
<li>创建屋顶、楼板或天花板洞口-用于在屋顶、楼板或天花板中创建洞口。</li>
<li>bPerceptiularFace参数指示洞口是垂直于面还是垂直于面。</li>
<li>如果该参数为true，则洞口垂直于主体图元面。请参见下图：</li>
</ul>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-EED350DF-2DD4-4562-998D-C020C739D6F8-low.png"></p>
<p>图40：垂直于主体元素切割的开口</p>
<ul>
<li>创建新洞口图元-用于在项目中创建竖井洞口。但是，请确保topLevel高于bottomLevel;否则将引发异常。</li>
<li>在直墙或弧形墙中创建洞口-用于在墙中创建矩形洞口。pntStart和pntEnd的坐标应该是可以塑造矩形的角坐标。例如，矩形的左下角和右上角。否则会引发异常。</li>
</ul>
<p>注意：使用“洞口”命令只能创建矩形墙洞口。要在墙上创建一些孔，请编辑墙轮廓而不是“洞口”命令。</p>
<h2 id="热属性"><a href="#热属性" class="headerlink" title="热属性"></a>热属性</h2><p>某些部件类型（如墙、楼板、天花板、屋顶和建筑地坪）具有计算和可设置的热属性，这些热属性由ThermalProperties类表示。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/ThermalProperties-76171.jpg"></p>
<p>hermalProperties类具有上面显示的值的属性。吸收率和粗糙度是可修改的，而传热系数、热阻和热质量是只读的。这些计算值的单位如下表所示。</p>
<table>
<thead>
<tr>
<th><strong>Property 属性</strong></th>
<th><strong>Unit 单位</strong></th>
</tr>
</thead>
<tbody><tr>
<td>HeatTransferCoefficient 导热系数</td>
<td>watts per meter-squared kelvin (W&#x2F;(m^2<em>K)</em></td>
</tr>
<tr>
<td>ThermalResistance 热阻</td>
<td>meter-squared kelvin per watt ((m^2K)&#x2F;Watt)</td>
</tr>
<tr>
<td>ThermalMass 热质量</td>
<td>kilogram feet-squared per second squared kelvin (kg ft^2&#x2F;(s^2 K))</td>
</tr>
</tbody></table>
<p>可以使用以下类型的ThermalProperties属性检索热属性：</p>
<ul>
<li>WallType </li>
<li>FloorType</li>
<li>CeilingType </li>
<li>RoofType </li>
<li>BuildingPadType</li>
</ul>
]]></content>
      <categories>
        <category>Revit二次开发人员指南</category>
      </categories>
      <tags>
        <tag>Revit</tag>
      </tags>
  </entry>
  <entry>
    <title>11事务</title>
    <url>/2024/11/20/%E4%BA%8C%E5%BC%80%E6%8C%87%E5%8D%97/11%E4%BA%8B%E5%8A%A1/</url>
    <content><![CDATA[<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a><a href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_Basic_Interaction_with_Revit_Elements_Transactions_html">事务</a></h1><p>事务是类似于上下文的对象，可封装对Revit模型所做的任何更改。只有在存在打开的活动事务处理时，才能对文档进行任何更改。尝试在事务之外更改文档将引发异常。在提交活动事务之前，更改不会成为模型的一部分。因此，事务中的所有更改都可以显式或隐式回滚（通过析构函数）。在任何给定时间，每个文档只能打开一个事务。一个事务可以由一个或多个操作组成。</p>
<p>Revit API中有三个与事务相关的主要类：</p>
<ul>
<li>Transaction 事务</li>
<li>SubTransaction 子事务</li>
<li>TransactionGroup 事务组</li>
</ul>
<p>本节将更深入地讨论这些类中的每一个类。对文档进行更改时只需要Transaction类。其他类可用于更好地组织更改。</p>
<p>***注意:***如果事务是从外部线程或外部非模态对话框启动的，则会引发异常。事务只能从支持的API工作流启动，例如外部命令、事件、更新程序或回调的一部分。</p>
<p><strong>本节中的页面</strong></p>
<ul>
<li>Transaction Classes 事务类</li>
<li>Transactions in Events 事件中的事务</li>
<li>Failure Handling Options 故障处理选项</li>
<li>Getting Element Geometry and AnalyticalModel<br>获取元素几何图形和分析模型</li>
<li>Temporary transactions 临时事务</li>
</ul>
<h2 id="Transaction-Classes-事务类"><a href="#Transaction-Classes-事务类" class="headerlink" title="Transaction Classes 事务类"></a>Transaction Classes 事务类</h2><p>三个事务对象共享通用方法：</p>
<p>表51：通用事务对象方法</p>
<table>
<thead>
<tr>
<th><strong>Method 方法</strong></th>
<th><strong>Description 描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Start</td>
<td>将启动上下文</td>
</tr>
<tr>
<td>Commit</td>
<td>结束上下文并将所有更改提交到文档</td>
</tr>
<tr>
<td>Rollback</td>
<td>结束上下文并放弃对文档的所有更改</td>
</tr>
<tr>
<td>GetStatus</td>
<td>返回事务对象的当前状态</td>
</tr>
</tbody></table>
<p>除了返回当前状态的GetStatus（）方法外，Start、Commit和RollBack方法还返回TransactionStatus，指示该方法是否成功。可用的TransactionStatus值包括：</p>
<p>表52：TransactionStatus值</p>
<table>
<thead>
<tr>
<th><strong>Status 状态</strong></th>
<th><strong>Description 描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Uninitialized</td>
<td>对象实例化后的初始值;上下文尚未启动</td>
</tr>
<tr>
<td>Started</td>
<td>事务对象已成功启动（调用了Start）</td>
</tr>
<tr>
<td>RolledBack</td>
<td>事务对象已成功回滚（调用了Rollback）</td>
</tr>
<tr>
<td>Committed</td>
<td>已成功提交事务对象（调用了Commit）</td>
</tr>
<tr>
<td>Pending</td>
<td>试图提交或回滚事务对象，但由于失败，该过程尚未完成，正在等待最终用户的响应（在非模态对话框中）。一旦故障处理完成，状态将自动更新（为Committed或RolledBack状态）。</td>
</tr>
</tbody></table>
<h3 id="Transaction-事务"><a href="#Transaction-事务" class="headerlink" title="Transaction 事务"></a>Transaction 事务</h3><p>事务是对Revit模型进行任何更改所需的上下文。一次只能打开一个事务;不允许嵌套。每个事务都必须有一个名称，一旦事务成功提交，该名称将列在Revit的“撤消”菜单中。</p>
<p>代码区域23-1：使用事务</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">CreatingSketch</span>(<span class="params">UIApplication uiApplication</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Autodesk.Revit.DB.Document document = uiApplication.ActiveUIDocument.Document;</span><br><span class="line">    Autodesk.Revit.ApplicationServices.Application application = uiApplication.Application;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create a few geometry lines. These lines are transaction (not in the model),</span></span><br><span class="line">    <span class="comment">// therefore they do not need to be created inside a document transaction.</span></span><br><span class="line">    XYZ Point1 = XYZ.Zero;</span><br><span class="line">    XYZ Point2 = <span class="keyword">new</span> XYZ(<span class="number">10</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    XYZ Point3 = <span class="keyword">new</span> XYZ(<span class="number">10</span>, <span class="number">10</span>, <span class="number">0</span>);</span><br><span class="line">    XYZ Point4 = <span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">10</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    Line geomLine1 = Line.CreateBound(Point1, Point2);</span><br><span class="line">    Line geomLine2 = Line.CreateBound(Point4, Point3);</span><br><span class="line">    Line geomLine3 = Line.CreateBound(Point1, Point4);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This geometry plane is also transaction and does not need a transaction</span></span><br><span class="line">    XYZ origin = XYZ.Zero;</span><br><span class="line">    XYZ normal = <span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    Plane geomPlane = Plane.CreateByNormalAndOrigin(normal, origin);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// In order to a sketch plane with model curves in it, we need</span></span><br><span class="line">    <span class="comment">// to start a transaction because such operations modify the model.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// All and any transaction should be enclosed in a &#x27;using&#x27;</span></span><br><span class="line">    <span class="comment">// block or guarded within a try-catch-finally blocks</span></span><br><span class="line">    <span class="comment">// to guarantee that a transaction does not out-live its scope.</span></span><br><span class="line">    <span class="keyword">using</span> (Transaction transaction = <span class="keyword">new</span> Transaction(document))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (transaction.Start(<span class="string">&quot;Create model curves&quot;</span>) == TransactionStatus.Started)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Create a sketch plane in current document</span></span><br><span class="line">            SketchPlane sketch = SketchPlane.Create(document,geomPlane);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Create a ModelLine elements using the geometry lines and sketch plane</span></span><br><span class="line">            ModelLine line1 = document.Create.NewModelCurve(geomLine1, sketch) <span class="keyword">as</span> ModelLine;</span><br><span class="line">            ModelLine line2 = document.Create.NewModelCurve(geomLine2, sketch) <span class="keyword">as</span> ModelLine;</span><br><span class="line">            ModelLine line3 = document.Create.NewModelCurve(geomLine3, sketch) <span class="keyword">as</span> ModelLine;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Ask the end user whether the changes are to be committed or not</span></span><br><span class="line">            TaskDialog taskDialog = <span class="keyword">new</span> TaskDialog(<span class="string">&quot;Revit&quot;</span>);</span><br><span class="line">            taskDialog.MainContent = <span class="string">&quot;Click either [OK] to Commit, or [Cancel] to Roll back the transaction.&quot;</span>;</span><br><span class="line">            TaskDialogCommonButtons buttons = TaskDialogCommonButtons.Ok | TaskDialogCommonButtons.Cancel;</span><br><span class="line">            taskDialog.CommonButtons = buttons;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (TaskDialogResult.Ok == taskDialog.Show())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// For many various reasons, a transaction may not be committed</span></span><br><span class="line">                <span class="comment">// if the changes made during the transaction do not result a valid model.</span></span><br><span class="line">                <span class="comment">// If committing a transaction fails or is canceled by the end user,</span></span><br><span class="line">                <span class="comment">// the resulting status would be RolledBack instead of Committed.</span></span><br><span class="line">                <span class="keyword">if</span> (TransactionStatus.Committed != transaction.Commit())</span><br><span class="line">                &#123;</span><br><span class="line">                    TaskDialog.Show(<span class="string">&quot;Failure&quot;</span>, <span class="string">&quot;Transaction could not be committed&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                transaction.RollBack();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="SubTransaction-子事务"><a href="#SubTransaction-子事务" class="headerlink" title="SubTransaction 子事务"></a>SubTransaction 子事务</h3><p>SubTransaction可以用来封装一组模型修改操作。子事务是可选的。修改模型时不需要它们。它们是一种方便的工具，允许将较大的任务逻辑拆分为较小的任务。子事务只能在已经打开的事务中创建，并且必须在事务关闭（提交或回滚）之前关闭（提交或回滚）。与事务不同，子事务可以嵌套，但任何嵌套的子事务都必须在封闭子事务之前关闭。子事务没有名称，因为它们不显示在Revit的“撤消”菜单上。</p>
<h3 id="TransactionGroup事务组"><a href="#TransactionGroup事务组" class="headerlink" title="TransactionGroup事务组"></a>TransactionGroup事务组</h3><p>TransactionGroup允许将几个独立的事务分组在一起，这使组的所有者有机会一次处理多个事务。当一个事务组要被关闭时，它可以被回滚，这意味着属于该组的所有以前提交的事务都将被回滚。如果不回滚，则可以提交或同化组。在前一种情况下，所有提交的事务（在组内）将保持原样。在后一种情况下，组内的事务将被合并到一个单独的事务中，该事务将使用组的名称。</p>
<p>事务组只能在没有打开的事务时启动，并且必须在关闭所有封闭的事务（回滚或提交）后关闭。事务组可以嵌套，但必须在封闭组关闭之前关闭任何嵌套组。事务组是可选的。修改模型时不需要这些参数。</p>
<p>下面的示例演示如何使用Assimilate（）方法使用TransactionGroup来合并两个单独的Transactions。下面的代码将导致单个Undo项添加到Undo菜单，名称为“Level and Grid”。</p>
<p>代码区域23-2：将多个事务合并到一个TransactionGroup中</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">CompoundOperation</span>(<span class="params">Autodesk.Revit.DB.Document document</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// All and any transaction group should be enclosed in a &#x27;using&#x27; block or guarded within</span></span><br><span class="line">    <span class="comment">// a try-catch-finally blocks to guarantee that the group does not out-live its scope.</span></span><br><span class="line">    <span class="keyword">using</span> (TransactionGroup transGroup = <span class="keyword">new</span> TransactionGroup(document, <span class="string">&quot;Level and Grid&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (transGroup.Start() == TransactionStatus.Started)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// We are going to call two methods, each having its own local transaction.</span></span><br><span class="line">            <span class="comment">// For our compound operation to be considered successful, both the individual</span></span><br><span class="line">            <span class="comment">// transactions must succeed. If either one fails, we will roll our group back,</span></span><br><span class="line">            <span class="comment">// regardless of what transactions might have already been committed.</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (CreateLevel(document, <span class="number">25.0</span>) &amp;&amp; CreateGrid(document, <span class="keyword">new</span> XYZ(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>), <span class="keyword">new</span> XYZ(<span class="number">10</span>,<span class="number">0</span>,<span class="number">0</span>)))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// The process of assimilating will merge the two (or any number of) committed</span></span><br><span class="line">                <span class="comment">// transaction together and will assign the grid&#x27;s name to the one resulting transaction,</span></span><br><span class="line">                <span class="comment">// which will become the only item from this compound operation appearing in the undo menu.</span></span><br><span class="line">                transGroup.Assimilate();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// Since we could not successfully finish at least one of the individual</span></span><br><span class="line">                <span class="comment">// operation, we are going to roll the entire group back, which will</span></span><br><span class="line">                <span class="comment">// undo any transaction already committed while this group was open.</span></span><br><span class="line">                transGroup.RollBack();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">CreateLevel</span>(<span class="params">Autodesk.Revit.DB.Document document, <span class="built_in">double</span> elevation</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// All and any transaction should be enclosed in a &#x27;using&#x27;</span></span><br><span class="line">    <span class="comment">// block or guarded within a try-catch-finally blocks</span></span><br><span class="line">    <span class="comment">// to guarantee that a transaction does not out-live its scope.</span></span><br><span class="line">    <span class="keyword">using</span> (Transaction transaction = <span class="keyword">new</span> Transaction(document, <span class="string">&quot;Creating Level&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Must start a transaction to be able to modify a document</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( TransactionStatus.Started == transaction.Start())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="literal">null</span> != Level.Create(document, elevation))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// For many various reasons, a transaction may not be committed</span></span><br><span class="line">                <span class="comment">// if the changes made during the transaction do not result a valid model.</span></span><br><span class="line">                <span class="comment">// If committing a transaction fails or is canceled by the end user,</span></span><br><span class="line">                <span class="comment">// the resulting status would be RolledBack instead of Committed.</span></span><br><span class="line">                <span class="keyword">return</span> (TransactionStatus.Committed == transaction.Commit());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// For we were unable to create the level, we will roll the transaction back</span></span><br><span class="line">            <span class="comment">// (although on this simplified case we know there weren&#x27;t any other changes)</span></span><br><span class="line"></span><br><span class="line">            transaction.RollBack();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">CreateGrid</span>(<span class="params">Autodesk.Revit.DB.Document document, XYZ p1, XYZ p2</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// All and any transaction should be enclosed in a &#x27;using&#x27;</span></span><br><span class="line">    <span class="comment">// block or guarded within a try-catch-finally blocks</span></span><br><span class="line">    <span class="comment">// to guarantee that a transaction does not out-live its scope.</span></span><br><span class="line">    <span class="keyword">using</span> (Transaction transaction = <span class="keyword">new</span> Transaction(document, <span class="string">&quot;Creating Grid&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Must start a transaction to be able to modify a document</span></span><br><span class="line">        <span class="keyword">if</span> (TransactionStatus.Started == transaction.Start())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// We create a line and use it as an argument to create a grid</span></span><br><span class="line">            Line gridLine = Line.CreateBound(p1, p2);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((<span class="literal">null</span> != gridLine) &amp;&amp; (<span class="literal">null</span> != Grid.Create(document, gridLine)))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (TransactionStatus.Committed == transaction.Commit())</span><br><span class="line">                &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// For we were unable to create the grid, we will roll the transaction back</span></span><br><span class="line">            <span class="comment">// (although on this simplified case we know there weren&#x27;t any other changes)</span></span><br><span class="line"></span><br><span class="line">            transaction.RollBack();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="事件中的事务"><a href="#事件中的事务" class="headerlink" title="事件中的事务"></a>事件中的事务</h2><h3 id="在事件期间修改文档"><a href="#在事件期间修改文档" class="headerlink" title="在事件期间修改文档"></a>在事件期间修改文档</h3><p>事件不会自动打开事务。因此，文档不会在事件期间被修改，除非事件的某个处理程序通过在事务内部进行更改来修改文档。如果事件处理程序打开一个事务，则要求它也关闭它（提交它或回滚它），否则所有更改都将被丢弃。</p>
<p>请注意，在某些事件（例如DocumentClosing事件）期间，不允许修改活动文档。如果事件处理程序试图在此类事件期间进行修改，则将引发异常。事件文档指示事件是否为只读。</p>
<h3 id="DocumentChanged事件"><a href="#DocumentChanged事件" class="headerlink" title="DocumentChanged事件"></a>DocumentChanged事件</h3><p>DocumentChanged事件在每个事务提交、撤消或重做后引发。这是一个只读事件，旨在使外部数据与Revit数据库的状态保持同步。若要更新Revit数据库以响应图元中的更改，请使用动态模型更新框架。</p>
<h2 id="失败处理选项"><a href="#失败处理选项" class="headerlink" title="失败处理选项"></a>失败处理选项</h2><p>失败处理选项是在事务结束时如何处理失败（如果有）的选项。在使用Transaction.SetFailureHandlingOptions（）方法调用Transaction.Commit（）或Transaction.RollBack（）之前，可以随时设置失败处理选项。但是，在提交或回滚事务后，这些选项将返回到各自的默认设置。</p>
<p>SetFailureHandlingOptions（）方法接受FailureHandlingOptions对象作为参数。无法创建此对象，必须使用GetFailureHandlingOptions（）方法从事务中获取它。通过调用相应的Set方法（如SetClearAfterRollback（））来设置选项。以下各节将更详细地讨论故障处理选项。</p>
<h3 id="ClearAfterRollback"><a href="#ClearAfterRollback" class="headerlink" title="ClearAfterRollback"></a>ClearAfterRollback</h3><p>此选项控制是否应在回滚事务后清除所有警告。默认值为False。</p>
<h3 id="DelayedMiniWarnings-DelayedMinimax"><a href="#DelayedMiniWarnings-DelayedMinimax" class="headerlink" title="DelayedMiniWarnings DelayedMinimax"></a>DelayedMiniWarnings DelayedMinimax</h3><p>此选项控制是否在当前正在结束的事务结束时显示小警告（如果有），或者是否应将其推迟到下一个事务结束时显示。当不希望在每个步骤结束时显示中间警告，而希望等到整个链完成时，通常在事务链中使用此方法。</p>
<p>多个事务可能会延迟验证。第一个未将此选项设置为True的事务将显示其自己的所有警告（如果有）以及可能从以前的事务累积的所有警告。默认值为False。</p>
<p>注意：此选项在模态模式下被忽略（请参阅下面的ForcedModalHandling）。</p>
<h3 id="ForcedModalHandling"><a href="#ForcedModalHandling" class="headerlink" title="ForcedModalHandling"></a>ForcedModalHandling</h3><p>此选项控制最终的故障是以模态方式还是以非模态方式处理。预设值为True。请注意，如果设置了非模态故障处理，则处理事务可能会异步完成，这意味着从Commit或RollBack调用返回时，事务将尚未完成（状态将为“Pending”）。</p>
<h3 id="SetFailuresPreprocessor"><a href="#SetFailuresPreprocessor" class="headerlink" title="SetFailuresPreprocessor"></a>SetFailuresPreprocessor</h3><p>如果提供此接口，则在事务结束时发现失败时调用此接口。预处理器可以检查当前的故障，甚至尝试解决它们。有关详细信息，请参阅故障发布和处理。</p>
<h3 id="SetTransactionFinalizer"><a href="#SetTransactionFinalizer" class="headerlink" title="SetTransactionFinalizer"></a>SetTransactionFinalizer</h3><p>终结器是一个接口，如果提供了该接口，则可用于在事务结束时执行自定义操作。请注意，它不会在调用Commit（）或RollBack（）方法时调用，而是仅在提交或回滚过程完成后调用。事务终结器必须实现<em>ITransactionFinalizer</em>接口，该接口需要定义两个函数：</p>
<ul>
<li>OnCommitted - called at the end of committing a transaction<br>OnCommitted -在提交事务结束时调用</li>
<li>OnRolledBack - called at the end of rolling back a transaction<br>OnRolledBack -在回滚事务结束时调用</li>
</ul>
<p><em><strong>注意：</strong></em>由于终结器是在事务完成后调用的，因此除非启动新事务，否则无法从终结器修改文档。</p>
<h2 id="获取元素几何图形和分析模型"><a href="#获取元素几何图形和分析模型" class="headerlink" title="获取元素几何图形和分析模型"></a>获取元素几何图形和分析模型</h2><p>创建新图元或修改图元后，需要重新生成和自动连接图元以将更改传播到整个模型中。如果不进行再生（以及相关的自动连接），则无法获得“几何”属性和“元素的分析模型”（在创建新元素的情况下），或者它们可能无效。在访问图元的“几何”或“分析模型”之前，了解再生发生的方式和时间非常重要。</p>
<p>尽管再生和自动连接对于传播模型中所做的更改是必要的，但这可能很耗时。最好是这些事件只在必要时发生。</p>
<p>当修改模型的事务成功提交时，或者调用Document.Regenerate（）或Document.AutoJoinElements（）方法时，自动进行重新生成和自动联接。Regenerate（）和AutoJoinElements（）只能在打开的事务中调用。应该注意的是，Regeneration（）方法可能会失败，在这种情况下，RegenerationFailedException将被抛出。如果发生这种情况，则需要通过回滚当前事务或子事务来回滚对文档的更改。</p>
<p>有关更多信息，请参见分析模型和几何形状。</p>
<p>下面的示例程序演示了事务如何填充这些属性：</p>
<p>代码区域23-3：填充几何和分析模型属性的事务处理</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TransactionDuringElementCreation</span>(<span class="params">UIApplication uiApplication, Level level</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Autodesk.Revit.DB.Document document = uiApplication.ActiveUIDocument.Document;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Build a location line for the wall creation</span></span><br><span class="line">    XYZ start = <span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    XYZ end = <span class="keyword">new</span> XYZ(<span class="number">10</span>, <span class="number">10</span>, <span class="number">0</span>);</span><br><span class="line">    Autodesk.Revit.DB.Line geomLine = Line.CreateBound(start, end);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// All and any transaction should be enclosed in a &#x27;using&#x27;</span></span><br><span class="line">    <span class="comment">// block or guarded within a try-catch-finally blocks</span></span><br><span class="line">    <span class="comment">// to guarantee that a transaction does not out-live its scope.</span></span><br><span class="line">    <span class="keyword">using</span> (Transaction wallTransaction = <span class="keyword">new</span> Transaction(document, <span class="string">&quot;Creating wall&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="comment">// To create a wall, a transaction must be first started</span></span><br><span class="line">       <span class="keyword">if</span> (wallTransaction.Start() == TransactionStatus.Started)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="comment">// Create a wall using the location line</span></span><br><span class="line">           Wall wall = Wall.Create(document, geomLine, level.Id, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">           <span class="comment">// the transaction must be committed before you can</span></span><br><span class="line">           <span class="comment">// get the value of Geometry and AnalyticalModel.</span></span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (wallTransaction.Commit() == TransactionStatus.Committed)</span><br><span class="line">           &#123;</span><br><span class="line">               Autodesk.Revit.DB.Options options = uiApplication.Application.Create.NewGeometryOptions();</span><br><span class="line">               Autodesk.Revit.DB.GeometryElement geoelem = wall.get_Geometry(options);</span><br><span class="line">               Autodesk.Revit.DB.Structure.AnalyticalModel analyticalmodel = wall.GetAnalyticalModel();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此示例的事务时间轴如下所示：</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-A7296713-19E7-4C50-A7B6-F3F7893A8EDD-low.png"></p>
<h2 id="临时事务"><a href="#临时事务" class="headerlink" title="临时事务"></a>临时事务</h2><p>并不总是需要提交事务。事务框架还允许回滚事务。这在事务处理过程中出现错误时很有用，但也可以直接用作创建临时事务的技术。</p>
<p>使用临时事务对于某些类型的分析可能很有用。例如，如果应用程序希望在墙或其他对象被洞口剪切之前从其提取几何属性，则应将临时事务与Document.Delete（）结合使用。当应用程序删除剪切目标元素的元素时，剪切元素的几何图形将恢复到其原始状态（在重新生成文档之后）。</p>
<p>要使用临时事务处理，请执行以下操作：</p>
<ol>
<li>使用Transaction构造函数实例化Transaction，并为其分配一个名称。</li>
<li>调用Transaction.Start（）</li>
<li>对文档进行临时更改（元素修改、删除或创建）</li>
<li>重新生成文档</li>
<li>提取所需的几何图形和属性</li>
<li>调用Transaction.RollBack（）将文档还原到以前的状态。</li>
</ol>
<p>这种技术也适用于子事务。</p>
<h2 id="注：翻译自Revit-API-Developers-Guide"><a href="#注：翻译自Revit-API-Developers-Guide" class="headerlink" title="注：翻译自Revit API Developers Guide"></a><em><strong>注：</strong></em>翻译自<a href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_html">Revit API Developers Guide</a></h2>]]></content>
      <categories>
        <category>Revit二次开发人员指南</category>
      </categories>
      <tags>
        <tag>Revit</tag>
      </tags>
  </entry>
  <entry>
    <title>10视图</title>
    <url>/2024/12/05/%E4%BA%8C%E5%BC%80%E6%8C%87%E5%8D%97/10%E8%A7%86%E5%9B%BE/</url>
    <content><![CDATA[<h1 id="视图"><a href="#视图" class="headerlink" title="视图"></a><a href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_Basic_Interaction_with_Revit_Elements_Views_html">视图</a></h1><p>视图是从 Revit 模型生成的图像，具有对文档中存储的数据的特权访问权限。它们可以是图形 （如计划） 或文本 （如计划）。每个项目文档都有一个或多个不同的视图。最后一个聚焦窗口是活动视图。</p>
<p>Autodesk.Revit.DB.View 类是 Revit 文档中所有视图类型的基类。Autodesk.Revit.UI.UIView 类表示 Revit 用户界面中的窗口视图。</p>
<p>在以下部分中，您将了解如何生成视图、Revit 支持的视图类型、每个视图的功能以及用户界面中视图窗口的可用功能。</p>
<p>Pages in this section 此部分中的页面</p>
<ul>
<li>About views 关于视图</li>
<li>View Graphics 视图图形</li>
<li>View Types 视图类型</li>
<li>Revisions 修改</li>
<li>View Filters 视图筛选器</li>
<li>View Cropping 视图裁剪</li>
<li>Displaced Views 置换视图</li>
<li>UIView</li>
</ul>
<h2 id="关于视图"><a href="#关于视图" class="headerlink" title="关于视图"></a>关于视图</h2><p>Revit API 提供对视图属性的访问，以及以编程方式创建和删除视图的功能。</p>
<p>本节是一个高级概述，其中包括以下内容：</p>
<ul>
<li>视图是如何生成的</li>
<li>视图类型</li>
<li>查看导航工具</li>
<li>创建和删除视图。</li>
</ul>
<h3 id="视图的生成"><a href="#视图的生成" class="headerlink" title="视图的生成"></a>视图的生成</h3><p>下图说明了视图是如何生成的。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-EBFC1A8B-6618-4D25-BAEF-AD97A02830F5-low.png"></p>
<p>图 94： 创建视图过程</p>
<p>每个视图都是通过将三维对象投影到二维投影平面上来生成的。投影分为两个基本类：</p>
<ul>
<li>Perspective 透视</li>
<li>Parallel 平行</li>
</ul>
<p>确定投影类型后，必须指定需要 3D 模型和渲染场景的条件。有关投影的更多信息，请参阅 View3D 部分。</p>
<p>世界坐标包括以下内容：</p>
<ul>
<li>观看者的眼睛位置</li>
<li>显示投影的视图平面位置。</li>
</ul>
<p>Revit 使用两个坐标系：</p>
<ul>
<li>建筑所在的全局空间或模型空间坐标</li>
<li>视图坐标系。</li>
</ul>
<p>视图坐标系表示模型在观察者视图中的呈现方式。它的原点是查看者的眼睛位置，其在模型空间中的坐标由View.Origin属性检索。X、Y和Z轴分别由View.RightDirection、View.UpDirection和View.ViewDirection属性表示。</p>
<ul>
<li>View.RightDirection 朝向屏幕右侧。</li>
<li>View.UpDirection 朝向屏幕的上方。</li>
<li>View.ViewDirection 从屏幕到观察者的方向。</li>
</ul>
<p>视图坐标系是右手坐标系。有关详细信息，请参见View3D和View3D中的平行投影图片。</p>
<p>在投影到投影平面上之前，将排除3D模型空间中不显示的某些部分，例如位于查看器后面或距离太远而无法清晰显示的部分。此操作需要裁剪视图。以下规则适用于裁剪：</p>
<ul>
<li>Elements outside of the crop region are no longer in the view.<br>裁剪区域之外的图元将不再位于视图中。</li>
<li>View.GetCropRegionShapeManager方法返回ViewCropRegionShapeManager，它提供裁剪区域的边界信息，裁剪区域可以是矩形，也可以不是矩形。</li>
<li>View.CropBoxVisible属性确定裁剪框在视图中是否可见。</li>
<li>View.CropBoxActive属性确定裁剪框是否实际用于裁剪视图。</li>
</ul>
<p>裁剪后，模型将投影到投影平面上。以下规则适用于投影：</p>
<ul>
<li>投影内容映射到屏幕视图端口进行显示。</li>
<li>在映射过程中，投影内容会被缩放，以便在屏幕上正确显示。</li>
<li>View.Scale属性是实际模型大小与视图大小的比率。</li>
<li>图纸上的视图边界是裁剪区域，它是裁剪形状在投影平面上的投影。</li>
<li>裁剪区域的大小和位置由View.Outline属性确定。</li>
</ul>
<h3 id="视图导航工具"><a href="#视图导航工具" class="headerlink" title="视图导航工具"></a>视图导航工具</h3><p>您可以访问有关当前在View Cube设置中设置的主视图摄影机的信息。文档只能设置一个主视图摄像机。这对应于用户调用ViewCube UI命令以在ViewCube右键单击关联菜单中“将当前视图设置为主视图”时保存的视图方向和其他摄影机参数。</p>
<p>通过调用静态方法ViewNavigationToolSettings.GetViewNavigationToolSettings（）访问ViewNavigationToolSettings，该方法将返回与文档关联的ViewNavigationToolSettings元素。</p>
<p>ViewNavigationToolSettings将允许您查询是否已使用IsHomeCameraSet（）方法设置主视图，该方法返回指示主视图设置的当前状态的布尔值。</p>
<p>通过使用ViewNavigationToolSettings.GetHomeCamera（）方法获取主摄影机的副本，可以访问有关在ViewCube中设置的主摄影机的只读信息。如果HomeCamera尚未设置，则此函数返回“否”。HomeCamera类提供有关相机和模型中存储的主视图方向（如EyePosition和UpDirection）的视图的信息。</p>
<h3 id="创建和删除视图"><a href="#创建和删除视图" class="headerlink" title="创建和删除视图"></a>创建和删除视图</h3><p>Revit Platform API提供了多种方法来创建从Autodesk.Revit.DB.View类派生的相应视图图元。大多数视图类型都是使用派生视图类的静态方法创建的。如果视图创建成功，这些方法返回对视图的引用，否则返回null。在下面的部分中，将针对每个视图类描述这些方法。</p>
<p>也可以使用View.Duplicate（）方法创建视图。可以从现有视图创建新视图，并可以选择新视图是从属视图还是具有详图。以下示例演示如何创建新的依赖视图。</p>
<p>代码区域：创建依赖视图</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> View <span class="title">CreateDependentCopy</span>(<span class="params">View view</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    View dependentView = <span class="literal">null</span>;</span><br><span class="line">    ElementId newViewId = ElementId.InvalidElementId;</span><br><span class="line">    <span class="keyword">if</span> (view.CanViewBeDuplicated(ViewDuplicateOption.AsDependent))</span><br><span class="line">    &#123;</span><br><span class="line">        newViewId = view.Duplicate(ViewDuplicateOption.AsDependent);</span><br><span class="line">        dependentView = view.Document.GetElement(newViewId) <span class="keyword">as</span> View;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != dependentView)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (dependentView.GetPrimaryViewId() == view.Id)</span><br><span class="line">            &#123;</span><br><span class="line">                TaskDialog.Show(<span class="string">&quot;Dependent View&quot;</span>, <span class="string">&quot;Dependent view created successfully!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dependentView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用Document.Delete（）方法和视图ID删除视图。您还可以删除与视图关联的元素。例如，删除标高图元会导致Revit删除相应的平面视图，或删除相机图元会导致Revit删除相应的三维视图。</p>
<p>依赖视图 如上所述，可以使用View.Duplicate（）方法并传入ViewDuplicationOption枚举器的AsDependent值来创建依赖视图。从属视图将与主视图和所有其他从属视图保持同步，以便在一个视图中进行视图特定更改（如视图比例和注释）时，这些更改将反映在所有视图中。并非所有视图类型都可以复制，并且不能从另一个从属视图创建从属视图。使用View.CanViewBeDuplicated（）确保可以从视图生成依赖视图。此方法采用ViewDuplicationOption枚举来检查是否可以以特定方式复制视图。可以将视图复制为独立视图，但不能复制为从属视图。 从属视图具有有效的主视图元素ID，可以从方法View.GetPrimaryViewId（）获得该ID。独立视图的主视图ID为InvalidElementId。可以使用View.ConvertToIndependent（）方法将依赖视图转换为独立视图。如果视图不是依赖的，这个方法将抛出一个异常。</p>
<p>代码区域：使依赖视图独立</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">MakeViewIndependent</span>(<span class="params">View view</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Independent views will have an InvalidElementId for the Primary View Id</span></span><br><span class="line">    <span class="keyword">if</span> (view.GetPrimaryViewId() != ElementId.InvalidElementId)</span><br><span class="line">    &#123;</span><br><span class="line">        view.ConvertToIndependent();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="视图图形"><a href="#视图图形" class="headerlink" title="视图图形"></a>视图图形</h2><p>视图的许多图形元素和显示选项都是通过API公开的。</p>
<p>视图类具有用于获取和设置显示样式设置和详细程度设置的属性。View. DisplayStyle属性使用DisplayStyle枚举，并与Revit窗口底部可用的显示选项相对应，如下所示。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/DisplayStyles.jpg"></p>
<p>注意：不能从Revit AP将显示样式设置为光线跟踪，因为此显示样式会将Revit置于功能有限的受限模式。View. DetailLevel属性使用ViewDetailLevel枚举，并对应于Revit窗口底部可用的详细程度选项，如下所示。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/DetailLevel.jpg"></p>
<p>ViewDetailLevel枚举在给定View不使用详细级别的情况下包含Undefined。</p>
<h3 id="Thin-Lines-细线"><a href="#Thin-Lines-细线" class="headerlink" title="Thin Lines 细线"></a>Thin Lines 细线</h3><p>“细线”选项（在Revit UI的“视图”选项卡的“图形”面板上可用）控制如何在视图中绘制线。通常，在小比例视图中放大模型时，元素线看起来比实际粗得多。启用“细线”时，无论缩放级别如何，所有线条都将绘制为单一宽度。此选项通过ThinLinesOptions实用程序类提供，该类具有一个名为AreThinLinesEnabled的属性。它是影响整个Revit任务的静态属性。</p>
<h3 id="临时视图模式"><a href="#临时视图模式" class="headerlink" title="临时视图模式"></a>临时视图模式</h3><p>TemporaryViewModes类允许控制临时视图模式。可以从View.TemporaryViewModes属性访问它。对于不支持临时视图模式的视图，此属性将为空。RevealConstraints、RevealHiddenElements和WorksharingDisplay属性可用于获取和设置相应视图中这些模式的当前状态。请注意，某些模式仅在某些视图和&#x2F;或特定上下文中可用。另外，在当前上下文中不一定启用可用模式。TemporaryViewModes方法IsModeAvailable（）和IsModeEnabled（）可用于测试特定模式在使用前是否可用和启用。这些方法采用TemporaryViewMode枚举。可能的选项如下所示。</p>
<table>
<thead>
<tr>
<th><strong>Member Name 成员名称</strong></th>
<th><strong>Description 描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>RevealHiddenElements</td>
<td>显示隐藏元素模式</td>
</tr>
<tr>
<td>TemporaryHideIsolate</td>
<td>临时隐藏&#x2F;隔离模式</td>
</tr>
<tr>
<td>WorksharingDisplay</td>
<td>工作共享显示模式</td>
</tr>
<tr>
<td>TemporaryViewProperties</td>
<td>临时视图属性模式</td>
</tr>
<tr>
<td>Raytrace</td>
<td>在交互式光线跟踪中显示模型的模式</td>
</tr>
<tr>
<td>ExplodedView</td>
<td>以分解视图显示模型并允许用户更改&#x2F;配置的模式</td>
</tr>
<tr>
<td>RevealConstraints</td>
<td>显示模型中元素之间约束的模式</td>
</tr>
</tbody></table>
<p>代码区域：显示视图中的隐藏元素</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">RevealHiddenElementsInView</span>(<span class="params">View view</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">bool</span> hiddenRevealed = <span class="literal">false</span>;</span><br><span class="line">    TemporaryViewModes viewModes = view.TemporaryViewModes;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (viewModes == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        TaskDialog.Show(<span class="string">&quot;Invalid View&quot;</span>, <span class="string">&quot;This view does not support temporary view modes.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Mode must be available and enabled to be activated</span></span><br><span class="line">        <span class="keyword">if</span> (viewModes.IsModeEnabled(TemporaryViewMode.RevealHiddenElements) &amp;&amp; viewModes.IsModeAvailable(TemporaryViewMode.RevealHiddenElements))</span><br><span class="line">        &#123;</span><br><span class="line">            viewModes.RevealHiddenElements = <span class="literal">true</span>;</span><br><span class="line">            hiddenRevealed = viewModes.RevealHiddenElements;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> hiddenRevealed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>IsModeActive（）方法测试给定的模式当前是否在视图中处于活动状态。使用DeactivateAllModes（）方法停用所有当前活动的视图，或使用DeactiveMode（）停用特定模式。 PreviewFamilyVisibility属性获取和设置关联视图中PreviewFamilyVisibility模式的当前状态。仅当视图的文档位于族编辑器的环境中时，此模式才可用。此属性是PreviewFamilyVisibilityMode枚举值而不是bool。此模式的可能状态为：</p>
<table>
<thead>
<tr>
<th>**Member Name **</th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Off</td>
<td>未应用图元可见性。所有族元素均可见。</td>
</tr>
<tr>
<td>On</td>
<td>视图的图元可见性应用于仅显示可见图元。由参照平面剪切的图元将显示其各自的剪切几何图元。</td>
</tr>
<tr>
<td>Uncut</td>
<td>视图的图元可见性应用于在实例未被剪切时显示可见的图元。请注意，此状态仅在某些视图（如楼层平面和天花板）中可用。</td>
</tr>
</tbody></table>
<p>即使视图的PreviewFamilyVisibility模式可用并已启用，也并非所有状态在所有视图中都有效。在将这些状态之一应用于视图之前，调用IsValidState（）以确保可以应用它。</p>
<p>代码区域：关闭预览族可见性模式</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TurnOffFamilyVisibilityMode</span>(<span class="params">View view</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    TemporaryViewModes viewModes = view.TemporaryViewModes;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (viewModes != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (viewModes.IsModeAvailable(TemporaryViewMode.PreviewFamilyVisibility) &amp;&amp; viewModes.IsModeEnabled(TemporaryViewMode.PreviewFamilyVisibility))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (viewModes.IsValidState(PreviewFamilyVisibilityMode.Off))</span><br><span class="line">            &#123;</span><br><span class="line">                viewModes.PreviewFamilyVisibility = PreviewFamilyVisibilityMode.Off;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首次打开视图时，其PreviewFamilyVisibility模式的状态将根据默认设置确定，该默认设置通过静态TemporaryViewModes属性PreviewFamilyVisibilityDefaultOnState和PreviewFamilyVisibilityDefaultUncutState进行控制，如下所示。</p>
<p>代码区域：设置默认预览族可见性状态</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetDefaultPreviewFamilyVisibilityState</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    TemporaryViewModes.PreviewFamilyVisibilityDefaultOnState = <span class="literal">true</span>;</span><br><span class="line">    TemporaryViewModes.PreviewFamilyVisibilityDefaultUncutState = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>PreviewFamilyVisibilityDefaultOnState值控制是否默认打开每个新打开的视图的PreviewFamilyVisibility模式。此属性适用于所有类型的视图。同时支持剪切和未剪切预览的视图（如楼层平面）将使用由PreviewFamilyVisibilityDefaultUncutState属性指示的剪切&#x2F;未剪切状态，但前提是PreviewFamilyVisibilityDefaultOnState属性设置为true。 这些设置适用于整个应用程序，而不是单个族文档;这些值在Revit任务之间保持不变。尽管允许随时设置该值，但在Revit应用程序初始化后所做的任何更改在下一个Revit任务之前都不会生效。 请注意，一旦显式修改PreviewFamilyVisibility属性，即使在关闭视图并稍后再次重新打开之后，应用的设置也会对相应视图保持有效。</p>
<p>视图中元素可见性 </p>
<p>视图跟踪可见元素。所有在视图中可见的图形化元素都可以使用FilteredElementCollector进行检索，该Collector是用文档和视图的id构造的。然而，集合中的某些元素可能被其他元素隐藏或覆盖。可以通过旋转视图或移除覆盖它们的图元来查看它们。删除这些可见图元可能需要Revit重新生成视图的几何图形。当您的代码第一次为给定视图使用此构造函数时，或者当您的代码第一次为显示设置刚刚更改的视图使用此构造函数时，您可能会遇到显著的性能下降。 可以在特定视图中隐藏单个图元。方法Element.IsHidden（）指示元素是否在给定视图中隐藏，Element.CanBeHidden（）返回元素是否可以隐藏。要隐藏单个元素，请使用View.HideElements（），它接受与要隐藏的元素相对应的ElementId集合。 元素可见性也可以按类别更改。 GetCategoryHidden（）方法查询类别ID以确定它在视图中是隐藏还是可见。 方法的作用是：将特定类别中的所有元素设置为隐藏或可见。 * CanCategoryBeHidden（）方法指示是否可以在视图中隐藏特定类别的元素。 基于视图的FilteredElementCollector将仅包含当前视图中可见的元素。不能检索非图形元素或不可见元素。基于文档的FilteredElementCollector检索文档中的所有元素，包括不可见元素和非图形元素。例如，在空项目中创建默认三维视图时，视图中没有元素，但文档中有许多元素，所有这些元素都不可见。 下面的代码示例计算活动文档和活动视图中墙类别元素的数量。活动视图中的元素数量与文档中的元素数量不同，因为文档包含非图形墙类别元素。</p>
<p>代码区域：计算活动视图中的元素</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">CountElements</span>(<span class="params">UIDocument uiDoc</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    StringBuilder message = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    FilteredElementCollector viewCollector = </span><br><span class="line">        <span class="keyword">new</span> FilteredElementCollector(uiDoc.Document, uiDoc.ActiveView.Id);</span><br><span class="line">    viewCollector.OfCategory(BuiltInCategory.OST_Walls);</span><br><span class="line">    message.AppendLine(<span class="string">&quot;Wall category elements within active View: &quot;</span></span><br><span class="line">        + viewCollector.ToElementIds().Count);</span><br><span class="line"></span><br><span class="line">    FilteredElementCollector docCollector = <span class="keyword">new</span> FilteredElementCollector(uiDoc.Document);</span><br><span class="line">    docCollector.OfCategory(BuiltInCategory.OST_Walls);</span><br><span class="line">    message.AppendLine(<span class="string">&quot;Wall category elements within document: &quot;</span></span><br><span class="line">        + docCollector.ToElementIds().Count);</span><br><span class="line"></span><br><span class="line">    TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>, message.ToString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>临时视图模式会影响图元的可见性。IsInTemporaryViewMode（）方法可用于确定View是否处于临时视图模式。方法View.IsElementVisibleInTemporaryViewMode（）标识元素在指定的视图模式中是否应可见。这仅适用于TemporaryHideIsolate和AnalyticalModel视图模式。其他模式将导致异常。 </p>
<p>深度提示 ViewDisplayDepthCueing类提供了对剖面视图和立面视图中远处对象显示的控制。当景深效果处于活动状态时，随着与观察者距离的增加，对象会融入背景色（淡入淡出）。可以使用View.GetDepthCueing（）检索视图的当前深度提示设置。如果对返回的ViewDisplayDepthCueing进行了更改，则在调用View.SetDepthCueing（）之前，这些更改不会应用于视图。 ViewDisplayDepthCueing类具有以下属性：</p>
<table>
<thead>
<tr>
<th><strong>Member Name 成员名称</strong></th>
<th><strong>Description 描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>EnableDepthCueing</td>
<td>为True，则启用深度提示。</td>
</tr>
<tr>
<td>StartPercentage</td>
<td>指示深度提示开始的位置。值为0表示深度提示从视图的前剪辑平面开始。</td>
</tr>
<tr>
<td>EndPercentage</td>
<td>指示深度提示结束的位置。比结束平面更远的对象将与结束平面处的对象淡入淡出相同的量。值100表示远剪裁平面。</td>
</tr>
<tr>
<td>FadeTo</td>
<td>指示通过深度提示淡入淡出对象的最大量。值为100表示完全不可见。</td>
</tr>
</tbody></table>
<p>SetStartEndPerception（）方法可用于在一次调用中设置开始和结束百分比。 下面的示例演示如何获取当前深度提示、更改其属性并将其设置回视图。请注意，并非所有视图都可以使用深度提示。</p>
<p>代码区域：更改视图的深度提示</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">AdjustDepthCueing</span>(<span class="params">View view</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (view.CanUseDepthCueing())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">using</span> (Transaction t = <span class="keyword">new</span> Transaction(view.Document, <span class="string">&quot;Change depth cueing&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            t.Start();</span><br><span class="line">            ViewDisplayDepthCueing depthCueing = view.GetDepthCueing();</span><br><span class="line">            depthCueing.EnableDepthCueing = <span class="literal">true</span>;</span><br><span class="line">            depthCueing.FadeTo = <span class="number">50</span>;    <span class="comment">// set fade to percent</span></span><br><span class="line">            depthCueing.SetStartEndPercentages(<span class="number">0</span>, <span class="number">75</span>);</span><br><span class="line">            view.SetDepthCueing(depthCueing);</span><br><span class="line">            t.Commit();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="视图类型"><a href="#视图类型" class="headerlink" title="视图类型"></a>视图类型</h2><p>不同类型的Revit视图由Revit API中的不同类表示。有关每种视图类型的详细信息，请参阅以下主题。</p>
<p>本节中的页面</p>
<ul>
<li>概述</li>
<li>3D视图</li>
<li>视图平面</li>
<li>视图图纸</li>
<li>剖面图</li>
<li>图纸</li>
<li>图表</li>
</ul>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>一个项目模型可以有几种视图类型。在API中，有三种方法对视图进行分类。第一种方法是使用视图元素View.ViewType属性。它返回指示视图类型的枚举值。下表列出了所有可用的视图类型。</p>
<p>表44：Autodesk.Revit.DB.ViewType</p>
<table>
<thead>
<tr>
<th><strong>Member Name 成员名称</strong></th>
<th><strong>Description 描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>AreaPlan</td>
<td>区域视图。</td>
</tr>
<tr>
<td>CeilingPlan</td>
<td>天花板反射平面图。</td>
</tr>
<tr>
<td>ColumnSchedule</td>
<td>柱表视图。</td>
</tr>
<tr>
<td>CostReport</td>
<td>成本报告视图。</td>
</tr>
<tr>
<td>Detail</td>
<td>局部视图。</td>
</tr>
<tr>
<td>DraftingView</td>
<td>草图视图。</td>
</tr>
<tr>
<td>DrawingSheet</td>
<td>图纸工作表。</td>
</tr>
<tr>
<td>Elevation</td>
<td>立面视图。</td>
</tr>
<tr>
<td>EngineeringPlan</td>
<td>工程视图。</td>
</tr>
<tr>
<td>FloorPlan</td>
<td>楼层平面视图。</td>
</tr>
<tr>
<td>Internal</td>
<td>Revit的内部视图。</td>
</tr>
<tr>
<td>Legend</td>
<td>图例视图。</td>
</tr>
<tr>
<td>LoadsReport</td>
<td>荷载报告视图。</td>
</tr>
<tr>
<td>PanelSchedule</td>
<td>配电盘明细表视图。</td>
</tr>
<tr>
<td>PressureLossReport</td>
<td>压力损失报告视图。</td>
</tr>
<tr>
<td>Rendering</td>
<td>渲染视图。</td>
</tr>
<tr>
<td>Report</td>
<td>报告视图。</td>
</tr>
<tr>
<td>Schedule</td>
<td>视图表。</td>
</tr>
<tr>
<td>Section</td>
<td>剖面视图。</td>
</tr>
<tr>
<td>ThreeD</td>
<td>3D视图。</td>
</tr>
<tr>
<td>Undefined</td>
<td>未定义&#x2F;未指定视图。</td>
</tr>
<tr>
<td>Walkthrough</td>
<td>Walkthrough视图。</td>
</tr>
</tbody></table>
<p>分类视图的第二种方法是按类类型。下表列出了项目浏览器中的视图类型和相应视图。</p>
<p>表45：项目浏览器视图</p>
<table>
<thead>
<tr>
<th><strong>Project Browser Views 项目浏览器视图</strong></th>
<th><strong>View Type 视图类型</strong></th>
<th><strong>Class Type 类类型</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Area Plans</td>
<td>ViewType.AreaPlan</td>
<td>Elements.ViewPlan</td>
</tr>
<tr>
<td>Ceiling Plans</td>
<td>ViewType.CeilingPlan</td>
<td>Elements.ViewPlan</td>
</tr>
<tr>
<td>Graphic Column Schedule</td>
<td>ViewType.ColumnSchedule</td>
<td>Elements.View</td>
</tr>
<tr>
<td>Detail Views</td>
<td>ViewType.Detail</td>
<td>Elements.ViewSection</td>
</tr>
<tr>
<td>Drafting Views</td>
<td>ViewType.DraftingView</td>
<td>Elements.ViewDrafting</td>
</tr>
<tr>
<td>Sheets</td>
<td>ViewType.DrawingSheet</td>
<td>Elements.ViewSheet</td>
</tr>
<tr>
<td>Elevations</td>
<td>ViewType.Elevation</td>
<td>Elements.ViewSection</td>
</tr>
<tr>
<td>Structural Plans</td>
<td>ViewType.EngineeringPlan</td>
<td>Elements.ViewPlan</td>
</tr>
<tr>
<td>Floor Plans</td>
<td>ViewType.FloorPlan</td>
<td>Elements.ViewPlan</td>
</tr>
<tr>
<td>Legends</td>
<td>ViewType.Legend</td>
<td>Elements.View</td>
</tr>
<tr>
<td>Reports (MEP engineering)</td>
<td>ViewType.LoadsReport</td>
<td>Elements.View</td>
</tr>
<tr>
<td>Reports (MEP engineering)</td>
<td>ViewType.PanelSchedule</td>
<td>Elements.PanelScheduleView</td>
</tr>
<tr>
<td>Reports (MEP engineering)</td>
<td>ViewType.PresureLossReport</td>
<td>Elements.View</td>
</tr>
<tr>
<td>Renderings</td>
<td>ViewType.Rendering</td>
<td>Elements.ViewDrafting</td>
</tr>
<tr>
<td>Reports</td>
<td>ViewType.Report</td>
<td>Elements.View</td>
</tr>
<tr>
<td>Schedules&#x2F;Quantities</td>
<td>ViewType.Schedule</td>
<td>Elements.ViewSchedule</td>
</tr>
<tr>
<td>Sections</td>
<td>ViewType.Section</td>
<td>Elements.ViewSection</td>
</tr>
<tr>
<td>3D Views</td>
<td>ViewType.ThreeD</td>
<td>Elements.View3D</td>
</tr>
<tr>
<td>Walkthroughs</td>
<td>ViewType.Walkthrough</td>
<td>Elements.View3D</td>
</tr>
</tbody></table>
<p>此示例说明如何使用视图的ViewType属性来确定视图的类型。</p>
<p>代码区域：确定视图类型</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetViewType</span>(<span class="params">Autodesk.Revit.DB.View view</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">// Get the view type of the given view, and format the prompt string</span></span><br><span class="line">        String prompt = <span class="string">&quot;The view is &quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (view.ViewType)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">case</span> ViewType.AreaPlan:</span><br><span class="line">                        prompt += <span class="string">&quot;an area view.&quot;</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> ViewType.CeilingPlan:</span><br><span class="line">                        prompt += <span class="string">&quot;a reflected ceiling plan view.&quot;</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> ViewType.ColumnSchedule:</span><br><span class="line">                        prompt += <span class="string">&quot;a column schedule view.&quot;</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> ViewType.CostReport:</span><br><span class="line">                        prompt += <span class="string">&quot;a cost report view.&quot;</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> ViewType.Detail:</span><br><span class="line">                        prompt += <span class="string">&quot;a detail view.&quot;</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> ViewType.DraftingView:</span><br><span class="line">                        prompt += <span class="string">&quot;a drafting view.&quot;</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> ViewType.DrawingSheet:</span><br><span class="line">                        prompt += <span class="string">&quot;a drawing sheet view.&quot;</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> ViewType.Elevation:</span><br><span class="line">                        prompt += <span class="string">&quot;an elevation view.&quot;</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> ViewType.EngineeringPlan:</span><br><span class="line">                        prompt += <span class="string">&quot;an engineering view.&quot;</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> ViewType.FloorPlan:</span><br><span class="line">                        prompt += <span class="string">&quot;a floor plan view.&quot;</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">                <span class="literal">default</span>:</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Give the user some information</span></span><br><span class="line">        MessageBox.Show(prompt, <span class="string">&quot;Revit&quot;</span>, MessageBoxButtons.OK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分类视图的第三种方法是使用ViewFamilyType类。大多数视图创建方法需要新视图的ViewFamilyType的ID。可以从View.GetTypeId（）方法中检索ViewFamilyType的ID。ViewFamily属性返回ViewFamily枚举，它指定ViewFamilyType的族，类似于上面记录的ViewType枚举。下面的示例说明如何从View获取ViewFamily。</p>
<p>代码区域：从ViewFamilyType确定视图类型</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ViewFamily <span class="title">GetViewFamily</span>(<span class="params">Document doc, View view</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ViewFamily viewFamily = ViewFamily.Invalid;</span><br><span class="line"></span><br><span class="line">    ElementId viewTypeId = view.GetTypeId();</span><br><span class="line">    <span class="keyword">if</span> (viewTypeId.IntegerValue &gt; <span class="number">1</span>) <span class="comment">// some views may not have a ViewFamilyType</span></span><br><span class="line">    &#123;</span><br><span class="line">        ViewFamilyType viewFamilyType = doc.GetElement(viewTypeId) <span class="keyword">as</span> ViewFamilyType;</span><br><span class="line">        viewFamily = viewFamilyType.ViewFamily;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> viewFamily;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3D视图"><a href="#3D视图" class="headerlink" title="3D视图"></a>3D视图</h3><p>View3D是一个自由导向的三维视图。</p>
<p>有两种三维视图：透视视图和等轴测视图，在Revit用户界面中也称为正交视图。差异基于投影射线关系。View3D.IsPerspective属性指示三维视图是透视视图还是等轴测视图。</p>
<h4 id="透视图"><a href="#透视图" class="headerlink" title="透视图"></a>透视图</h4><p>下图说明了如何创建透视图。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-EF11532A-32D3-40C1-9410-5AADA6FD8701-low.png"></p>
<p>图96：透视投影</p>
<ul>
<li>直投影射线穿过模型中的每个点并与投影平面相交以形成投影内容。</li>
<li>为了便于从世界坐标到视图平面的变换，视图坐标系基于观察者。</li>
<li>它的原点由View.Origin属性表示，是查看者的位置。</li>
<li>使用ViewOrientation3D.EyePosition属性（从View3D.GetOrientation（）检索）检索查看器的世界坐标。因此，在3D视图中，View.Origin始终等于相应的ViewOrientation3D.EyePosition。</li>
<li>如上图所述，<em>观察</em>坐标系确定如下：<ul>
<li>X轴由View.RightDirection确定。</li>
<li>Y轴由View.UpDirection确定。</li>
<li>Z轴由View.ViewDirection确定。</li>
</ul>
</li>
<li>观看方向是在3D空间中从目标点到观看者，以及在屏幕空间中从屏幕到观看者。</li>
</ul>
<p>静态方法View3D.ViewPerspective（）方法可用于创建新的透视图。</p>
<p>代码区域：View3D.CreatePerspective（）</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> View3D View3D.CreatePerspective (Document document, ElementId viewFamilyTypeId;</span><br></pre></td></tr></table></figure>

<p>viewFamilyTypeId参数必须是三维ViewType。 下面的代码示例说明如何创建透视三维视图。</p>
<p>代码区域：创建透视三维视图</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Find a 3D view type</span></span><br><span class="line">IEnumerable viewFamilyTypes = <span class="function"><span class="keyword">from</span> elem <span class="keyword">in</span> <span class="keyword">new</span> <span class="title">FilteredElementCollector</span>(<span class="params">document</span>).<span class="title">OfClass</span>(<span class="params"><span class="keyword">typeof</span>(ViewFamilyType</span>))</span></span><br><span class="line"><span class="function">                                                <span class="keyword">let</span> type</span> = elem <span class="keyword">as</span> ViewFamilyType</span><br><span class="line">                                                <span class="keyword">where</span> type.ViewFamily == ViewFamily.ThreeDimensional</span><br><span class="line">                                                <span class="keyword">select</span> type;</span><br><span class="line"><span class="comment">// Create a new Perspective View3D</span></span><br><span class="line">View3D view3D = View3D.CreatePerspective(document, viewFamilyTypes.First().Id);</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">null</span> != view3D)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// By default, the 3D view uses a default orientation.</span></span><br><span class="line">    <span class="comment">// Change the orientation by creating and setting a ViewOrientation3D </span></span><br><span class="line">    XYZ eye = <span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">-100</span>, <span class="number">10</span>); </span><br><span class="line">    XYZ up = <span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>); </span><br><span class="line">    XYZ forward = <span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>); </span><br><span class="line">    view3D.SetOrientation(<span class="keyword">new</span> ViewOrientation3D(eye, up, forward));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// turn off the far clip plane with standard parameter API</span></span><br><span class="line">    Parameter farClip = view3D.LookupParameter(<span class="string">&quot;Far Clip Active&quot;</span>);</span><br><span class="line">    farClip.Set(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>透视视图裁剪框是锥体的一部分，其顶点位于查看者位置。它是两个平行剪裁平面之间的几何体。裁剪框限定模型中被裁剪并投影到视图平面上的部分。 裁剪框由View.CropBox属性表示，该属性返回一个BoundingBoxXYZ对象。 CropBox.Min和CropBox.Max点在上一张图片中标记。请注意，透视图中的CropBox.Min点是通过将裁剪框前裁剪平面投影到后裁剪平面上而生成的。 裁剪框坐标基于查看坐标系。使用Transform.OfPoint（）将CropBox.Min和CropBox.Max变换到世界坐标系。有关变换的更多详细信息，请参见几何部分中的几何辅助类。 投影平面加上前剪裁平面和后剪裁平面都垂直于视图方向。CropBox.Max和CropBox.Min之间的线与查看方向平行。利用这些因子，可以计算裁剪框几何形状。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-CCAE0F1D-6889-4225-900A-45CF0D207B15-low.png"></p>
<p>图97：透视3D视图</p>
<p>上图显示了裁剪后屏幕上的投影平面。裁剪区域是投影平面和裁剪框的矩形相交。 使用View.CropRegion属性检索几何信息。此属性返回BoundingBoxUV实例。 View.Outline.Max属性指向右上角。 View.Outline.Min属性指向左下角。 与裁剪框类似，裁剪区域坐标基于查看坐标系。下列表达式是相等的。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">View.CropBox.Max.X(Y) / View.OutLine.Max.X(Y) == View.CropBox.Min.X(Y) / View.OutLine.Min.X(Y) </span><br></pre></td></tr></table></figure>

<p>由于物体的透视投影的大小与从该物体到投影中心的距离成反比，因此比例对于透视图来说是没有意义的。透视三维视图的“比例”属性始终返回零。 #管理摄像头目标 相机表示透视视图的查看者正在查看的方向。如果用户或API应用调整裁剪区域以暴露更宽的视场或不对称的视场，则透视图的失真可能变得过于剧烈。可以通过调用View3D方法RestCameraTarget（）将摄像机目标定位在视场的中心，从而将摄像机目标强制定位到观察区域的中心。在调用之前，请检查是否可以使用View3D.CanResetCameraTarget（）方法在此视图中重置摄像机，该方法指示是否可以重置摄像机目标。无法重置目标的主要情况是View3D当前处于等轴测投影中。尝试在等轴测视图中重置相机目标将引发Autodesk. Revit. Exceptions. InvalidOperationException。</p>
<p>等距视图 可以使用静态View3D.NETIsometric（）方法创建新的等轴测视图。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-6B8688A8-D480-4C35-84A2-5CA5CF8D1577-low.png"></p>
<p>图98：平行投影 </p>
<p>等轴测视图是使用平行投影光线通过将模型投影到与光线垂直的平面上而生成的。查看坐标系类似于透视图，但裁剪框是一个平行六面体，其面与投影光线平行或垂直。View.CropBox属性指向两个对角，其坐标基于查看坐标系。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-A25AEAB3-BBF1-41E9-8B40-B1D40168A7AE-low.png"></p>
<p>图99：将视图平面上的窗口缩放到屏幕视口</p>
<p> 模型将投影到视图平面上，然后缩放到屏幕上。View.Scale属性表示实际模型大小与视图大小的比率。相关表达式如下：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">View.CropBox.Max.X(Y) / View.OutLine.Max.X(Y) == View.CropBox.Min.X(Y) / View.OutLine.Min.X(Y) == View.Scale </span><br></pre></td></tr></table></figure>

<p>代码区域：View3D.Other Isometric（）</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> View3D View3D.CreateIsometric (Document document, ElementId viewFamilyTypeId;</span><br></pre></td></tr></table></figure>

<p>viewFamilyTypeId参数必须是三维ViewType。Revit确定以下内容：观察者的位置。 如何使用视图方向创建视图坐标系。 * 如何创建裁剪框来裁剪模型。 创建视图后，可以调整裁剪框的大小以查看模型的不同部分。也可以更改默认方向。API不支持修改查看坐标系。 下面的代码示例说明如何创建等轴测三维视图。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Find a 3D view type</span></span><br><span class="line"></span><br><span class="line">IEnumerable viewFamilyTypes = <span class="function"><span class="keyword">from</span> elem <span class="keyword">in</span> <span class="keyword">new</span> <span class="title">FilteredElementCollector</span>(<span class="params">document</span>).<span class="title">OfClass</span>(<span class="params"><span class="keyword">typeof</span>(ViewFamilyType</span>))</span></span><br><span class="line"><span class="function">                                              <span class="keyword">let</span> type</span> = elem <span class="keyword">as</span> ViewFamilyType</span><br><span class="line">                                              <span class="keyword">where</span> type.ViewFamily == ViewFamily.ThreeDimensional</span><br><span class="line">                                              <span class="keyword">select</span> type;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a new View3D</span></span><br><span class="line">View3D view3D = View3D.CreateIsometric(document, viewFamilyTypes.First().Id);</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">null</span> != view3D)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// By default, the 3D view uses a default orientation.</span></span><br><span class="line">    <span class="comment">// Change the orientation by creating and setting a ViewOrientation3D </span></span><br><span class="line">    XYZ eye = <span class="keyword">new</span> XYZ(<span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line">    XYZ up = <span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    XYZ forward = <span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    ViewOrientation3D viewOrientation3D = newViewOrientation3D(eye, up, forward);</span><br><span class="line">    view3D.SetOrientation(viewOrientation3D);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="在等距和透视之间切换"><a href="#在等距和透视之间切换" class="headerlink" title="在等距和透视之间切换"></a>在等距和透视之间切换</h4><p>大多数情况下，View3D可以在“等轴测”和“透视”之间切换，前提是视图中没有视图特定的元素。View3D类提供了在等轴测和透视模式之间切换视图的方法。在切换之前，使用CanToggleBetweenPerspectiveAndIsometric（）方法，该方法指示是否可以进行切换。</p>
<p>要切换视图，请调用以下两个View 3D类方法之一：ToggleToPerspective（）或ToggleToIsometric（）。如果无法切换视图（可能是由于视图中存在特定于视图的元素），则这两种方法中的任何一种都将引发Autodesk. Revit. Exceptions. InvalidOperationException。</p>
<h4 id="3D视图剖面框"><a href="#3D视图剖面框" class="headerlink" title="3D视图剖面框"></a>3D视图剖面框</h4><p>每个视图都有一个裁剪框。裁剪框聚焦于要投影并显示在视图中的模型部分。对于三维视图，还有另一个名为剖面框的框。</p>
<ul>
<li>剖面框确定在三维视图中显示的模型部分。</li>
<li>剖面框用于剪裁三维模型的可见部分。</li>
<li>即使在裁剪框中，框外的部分也不可见。</li>
<li>剖面框与裁剪框的不同之处在于，剖面框可以随模型一起旋转和移动。</li>
</ul>
<p>剖面框对于大型模型特别有用。例如，如果要渲染大型建筑，请使用剖面框。剖面框限制用于计算的模型部分。若要显示剖面框，请在“三维视图图元属性”对话框的“范围”区域中选择“剖面框”。也可以使用IsSectionBoxActive属性设置它。在下面的示例中，如果活动视图是三维视图，它将设置剖面框是否处于活动状态。</p>
<p>代码区域：显示&#x2F;隐藏剖面框</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ShowHideSectionBox</span>(<span class="params">UIDocument document, <span class="built_in">bool</span> active</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (document.ActiveView <span class="keyword">is</span> View3D)</span><br><span class="line">    &#123;</span><br><span class="line">        View3D view3d = document.ActiveView <span class="keyword">as</span> View3D;</span><br><span class="line">        view3d.IsSectionBoxActive = active;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-016E48BA-138E-4686-B864-D4A978DC406C-low.png"></p>
<p>图100：剖面框</p>
<p> View3D.GetSectionBox（）和View3D.SetSectionBox（）方法用于获取和更改长方体范围。在某些情况下，调用View3D.SetSectionBox（）可能会产生副作用。将该属性设置为某些值可以更改框的容量并将其显示在视图中。若要避免显示剖面框，请将IsSectionBoxActive属性设置为false。 下面的代码示例阐释如何更改剖面框的范围。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ExpandSectionBox</span>(<span class="params">View3D view</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// The original section box</span></span><br><span class="line">    BoundingBoxXYZ sectionBox = view.GetSectionBox();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Expand the section box (doubling in size in all directions while preserving the same center and orientation)</span></span><br><span class="line">    Autodesk.Revit.DB.XYZ deltaXYZ = sectionBox.Max - sectionBox.Min;</span><br><span class="line">    sectionBox.Max += deltaXYZ / <span class="number">2</span>;</span><br><span class="line">    sectionBox.Min -= deltaXYZ / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//After resetting the section box, it will be shown in the view.</span></span><br><span class="line">    <span class="comment">//It only works when the Section Box is active</span></span><br><span class="line">    view.SetSectionBox(sectionBox);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从GetSectionBox（）方法返回的BoundingBoxXYZ的Max和Min点的坐标不是全局坐标。要将Max和Min的坐标转换为全局坐标，需要通过从BoundingBoxXYZ.Transform属性获得的变换来转换每个点。</p>
<p>代码区域：将最大值和最小值转换为全局坐标</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ConvertMaxMinToGlobal</span>(<span class="params">View3D view, <span class="keyword">out</span> XYZ max, <span class="keyword">out</span> XYZ min</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    BoundingBoxXYZ sectionbox = view.GetSectionBox();</span><br><span class="line">    Transform transform = sectionbox.Transform;</span><br><span class="line">    max = transform.OfPoint(sectionbox.Max);</span><br><span class="line">    min = transform.OfPoint(sectionbox.Min);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="视图锁定"><a href="#视图锁定" class="headerlink" title="视图锁定"></a>视图锁定</h4><p>View3D类具有与Revit用户界面中可用的锁定功能相对应的方法和属性。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/3DLocking.jpg"></p>
<p>View3D.SaveOrientationAndLock（）方法将保存方向并锁定视图，而View3D.RestoreOrientationAndLock（）将恢复视图的方向并锁定它。View3D.RestoreOrientationAndLock（）将解锁当前锁定的视图。IsLocked属性将返回3D视图当前是否被锁定。</p>
<h3 id="视图平面"><a href="#视图平面" class="headerlink" title="视图平面"></a>视图平面</h3><p>平面视图是基于标高的。平面视图有三种类型：楼层平面视图、天花板平面视图和面积平面视图。</p>
<h4 id="创建平面视图"><a href="#创建平面视图" class="headerlink" title="创建平面视图"></a>创建平面视图</h4><ul>
<li>通常，楼层平面视图是在新项目中打开的默认视图。</li>
<li>大多数项目至少包括一个楼层平面视图和一个天花板平面视图。</li>
<li>通常在向项目中添加新标高后创建平面视图。</li>
</ul>
<p>使用API添加新标高不会自动添加平面视图。使用静态ViewPlan.Create（）方法创建新的地板和天花板平面视图。使用静态ViewPlan. ViewAreaPlan（）方法创建新的面积平面视图。</p>
<p>代码区域：创建平面视图</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ViewPlan ViewPlan.Create(Document document, ElementId viewFamilyTypeId, ElementId levelId);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ViewPlan ViewPlan.CreateAreaPlan(Document document, ElementId areaSchemeId, ElementId levelId);</span><br></pre></td></tr></table></figure>

<p>ViewPlan.Create（）中的viewFamilyTypeId参数必须是FloorPlan、CeilingPlan、AreaPlan或StructuralPlan ViewType。levelId参数表示与平面视图关联的项目中标高图元的ID。 下面的代码基于某个标高创建楼层平面和天花板平面。</p>
<p>代码区域：创建楼层平面和天花板平面</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">CreateViewPlan</span>(<span class="params">Autodesk.Revit.DB.Document document</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">    IList viewFamilyTypes = collector.OfClass(<span class="keyword">typeof</span>(ViewFamilyType)).ToElements();</span><br><span class="line">    ElementId floorPlanId = <span class="keyword">new</span> ElementId(<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">foreach</span> (Element e <span class="keyword">in</span> viewFamilyTypes)</span><br><span class="line">    &#123;</span><br><span class="line">        ViewFamilyType v = e <span class="keyword">as</span> ViewFamilyType;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (v != <span class="literal">null</span> &amp;&amp; v.ViewFamily == ViewFamily.FloorPlan)</span><br><span class="line">        &#123;</span><br><span class="line">            floorPlanId = e.Id;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ElementId ceilingPlanId = <span class="keyword">new</span> ElementId(<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">foreach</span> (Element e <span class="keyword">in</span> viewFamilyTypes)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.Name == <span class="string">&quot;Ceiling Plan&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ceilingPlanId = e.Id;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create a Level and a Floor Plan based on it</span></span><br><span class="line">    <span class="built_in">double</span> elevation = <span class="number">10.0</span>;</span><br><span class="line">    Level level1 = Level.Create(document, elevation);</span><br><span class="line">    ViewPlan floorView = ViewPlan.Create(document, floorPlanId, level1.Id);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create another Level and a Ceiling Plan based on it</span></span><br><span class="line">    elevation += <span class="number">10.0</span>;</span><br><span class="line">    Level level2 = Level.Create(document, elevation);</span><br><span class="line">    ViewPlan ceilingView = ViewPlan.Create(document, ceilingPlanId, level2.Id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="平面视图属性"><a href="#平面视图属性" class="headerlink" title="平面视图属性"></a>平面视图属性</h4><p>创建新平面视图后，可以使用类型为ViewDiscipline的Discipline参数设置视图的Discipline。选项包括建筑、结构、机械、电气、管道和协调。</p>
<p>对于结构平面视图，可以使用ViewFamilyType.PlanViewDirection属性将视图方向设置为“向上”或“向下”。尽管它是ViewFamilyType类的属性，但如果为StructuralPlan视图以外的视图访问该属性，则将引发异常。</p>
<h4 id="视图范围"><a href="#视图范围" class="headerlink" title="视图范围"></a>视图范围</h4><p>可以通过ViewPlan.GetViewRange（）方法检索平面视图的视图范围。返回的PlanViewRange对象可用于查找平面相对的标高以及每个平面与该标高的偏移量。该信息与Revit用户界面的“视图范围”对话框中提供的信息相同：</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/ViewRange-76168.jpg"></p>
<p>以下示例显示如何获取平面视图的顶部剪裁平面和关联偏移</p>
<p>代码区域：获取视图范围的信息</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ViewRange</span>(<span class="params">Document doc, View view</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (view <span class="keyword">is</span> ViewPlan)</span><br><span class="line">    &#123;</span><br><span class="line">        ViewPlan viewPlan = view <span class="keyword">as</span> ViewPlan;</span><br><span class="line">        PlanViewRange viewRange = viewPlan.GetViewRange();</span><br><span class="line"></span><br><span class="line">        ElementId topClipPlane = viewRange.GetLevelId(PlanViewPlane.TopClipPlane);</span><br><span class="line">        <span class="built_in">double</span> dOffset = viewRange.GetOffset(PlanViewPlane.TopClipPlane);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (topClipPlane.IntegerValue &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Element levelAbove = doc.GetElement(topClipPlane);</span><br><span class="line">            TaskDialog.Show(view.Name, <span class="string">&quot;Top Clip Plane: &quot;</span> + levelAbove.Name + <span class="string">&quot;\r\nTop Offset: &quot;</span> + dOffset + <span class="string">&quot; ft&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="平面图underlay"><a href="#平面图underlay" class="headerlink" title="平面图underlay"></a>平面图underlay</h4><p>可以从ViewPlan中检索和设置顶层和底层范围。使用GetUnderlayBaseLevel（）和SetUnderlayBaseLevel（）访问对象范围的基准标高。如果基本级别ID为InvalidElementId，则不设置无效基本级别，并且没有元素显示为无效。设置参考底图范围的基准标高时，下一个最高标高的高程将用于确定参考底图范围的顶部。如果为基准标高指定的标高是最高标高，则该范围将是无边界的，并且将由指定标高以上的所有内容组成。</p>
<p>使用GetUnderlayTopLevel（）和SetUnderlayRange（）访问对象范围的顶级。如果GetUnderlayTopLevel（）返回InvalidElementId，并且XML基础级别是有效级别，则XML范围是无边界的，并且包含XML基础级别之上的所有内容。若要设置顶层，必须使用SetUnderlayRange（），该方法将ElementIds用于底层和顶层。如果顶层的高程不大于底层的高程，此方法将引发异常。</p>
<p>使用GetUnderlayOrientation（）和SetUnderlayOrientation（）方法控制如何查看视图中的元素。UnderlayOrientation可以是LookingDown（向下查看图元，就像从上面向下查看一样）或LookingUp（向上查看图元，就像从下面向上查看一样）。</p>
<p>如果当前方向为LookingDown且顶级Id与新值不同，则以下代码设置范围。然后方向更改为LookingUp。</p>
<p>代码区域：更改视图范围</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ViewUnderlay</span>(<span class="params">ViewPlan planView, ElementId topLevelId, ElementId baseLevelId</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (planView.GetUnderlayOrientation() == UnderlayOrientation.LookingDown)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (planView.GetUnderlayTopLevel() != topLevelId)</span><br><span class="line">        &#123;</span><br><span class="line">            planView.SetUnderlayRange(baseLevelId, topLevelId);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        planView.SetUnderlayOrientation(UnderlayOrientation.LookingUp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="视图图纸"><a href="#视图图纸" class="headerlink" title="视图图纸"></a>视图图纸</h3><p>视图，用于创建不属于建模设计的、不关联的视图专有详图。</p>
<p>图纸视图未与模型关联。它允许用户创建不包括在模型中的详图。</p>
<ul>
<li><p>在绘图视图中，用户可以以不同的视图比例（粗略、精细或中等）创建详图。</p>
</li>
<li><p>您可以使用2D详图工具，包括：</p>
<table>
<thead>
<tr>
<th><em>Detail lines</em> Detail regions <em>Detail components</em> Insulation <em>详图线</em>详图区域<em>详图构件</em>隔热层</th>
<th><em>Reference planes</em> Dimensions <em>Symbols</em> Text <em>参照平面</em>尺寸<em>符号</em>文字</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>这些工具与用于创建局部视图的工具相同。</p>
</li>
<li><p>图纸视图不显示模型图元。</p>
</li>
</ul>
<p>使用静态ViewDrafting.Create（）方法创建图纸视图。模型图元不显示在图纸视图中。</p>
<h4 id="图片视图"><a href="#图片视图" class="headerlink" title="图片视图"></a>图片视图</h4><p>ImageView类派生自ViewDrafting。它可用于创建包含从磁盘导入的图像的渲染视图。使用静态ImageView.Create（）方法创建新的呈现视图。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/RenderingView-76170.jpg"></p>
<h3 id="剖面视图"><a href="#剖面视图" class="headerlink" title="剖面视图"></a>剖面视图</h3><p>表示剖面视图、局部视图、俯视图和立面视图，以及参照详图索引和参照剖面。</p>
<p>ViewSection类可用于创建剖面视图、局部视图、局部视图、参照详图索引和参照剖面。它还表示立面视图。</p>
<p>剖面视图和参照剖面</p>
<p>剖面视图剖切模型以显示内部结构。ViewSection.ViewSection（）方法创建剖面视图。</p>
<p>代码区域：ViewSection. ViewSection（）</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ViewSection ViewSection.CreateSection(Document document, ElementId viewFamilyTypeId, BoundingBoxXYZ sectionBox);</span><br></pre></td></tr></table></figure>

<p>viewFamilyTypeId参数是新ViewSection将使用的ViewFamilyType的ID。类型必须是截面视图族。sectionBox参数是剖面视图裁剪框。它提供剖面视图所需的方向和范围。通常，另一个视图的裁剪框用作参数。您还可以构建自定义BoundingBoxXYZ实例来表示方向和范围。 下面的代码演示如何创建剖面视图。将在墙的中心创建剖面视图的边界框。生成的剖面视图将位于项目浏览器的“剖面（建筑剖面）”节点中。请注意，远裁剪距离将等于创建时边界框的最小值和最大值的z坐标之差。</p>
<p>代码区域：创建剖面图</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Find a section view type</span></span><br><span class="line">IEnumerable viewFamilyTypes = <span class="function"><span class="keyword">from</span> elem <span class="keyword">in</span> <span class="keyword">new</span> <span class="title">FilteredElementCollector</span>(<span class="params">document</span>).<span class="title">OfClass</span>(<span class="params"><span class="keyword">typeof</span>(ViewFamilyType</span>))</span></span><br><span class="line"><span class="function">                                                <span class="keyword">let</span> type</span> = elem <span class="keyword">as</span> ViewFamilyType</span><br><span class="line">                                                <span class="keyword">where</span> type.ViewFamily == ViewFamily.Section</span><br><span class="line">                                                <span class="keyword">select</span> type;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a BoundingBoxXYZ instance centered on wall</span></span><br><span class="line">LocationCurve lc = wall.Location <span class="keyword">as</span> LocationCurve;</span><br><span class="line">Transform curveTransform = lc.Curve.ComputeDerivatives(<span class="number">0.5</span>, <span class="literal">true</span>);</span><br><span class="line"><span class="comment">// using 0.5 and &quot;true&quot; (to specify that the parameter is normalized) </span></span><br><span class="line"><span class="comment">// places the transform&#x27;s origin at the center of the location curve)</span></span><br><span class="line"></span><br><span class="line">XYZ origin = curveTransform.Origin; <span class="comment">// mid-point of location curve</span></span><br><span class="line">XYZ viewDirection = curveTransform.BasisX.Normalize(); <span class="comment">// tangent vector along the location curve</span></span><br><span class="line">XYZ normal = viewDirection.CrossProduct(XYZ.BasisZ).Normalize(); <span class="comment">// location curve normal @ mid-point</span></span><br><span class="line"></span><br><span class="line">Transform transform = Transform.Identity;</span><br><span class="line">transform.Origin = origin;</span><br><span class="line">transform.BasisX = normal;</span><br><span class="line">transform.BasisY = XYZ.BasisZ;</span><br><span class="line"></span><br><span class="line"><span class="comment">// can use this simplification because wall&#x27;s &quot;up&quot; is vertical.</span></span><br><span class="line"><span class="comment">// For a non-vertical situation (such as section through a sloped floor the surface normal would be needed)</span></span><br><span class="line">transform.BasisZ = normal.CrossProduct(XYZ.BasisZ);</span><br><span class="line"></span><br><span class="line">BoundingBoxXYZ sectionBox = <span class="keyword">new</span> BoundingBoxXYZ();</span><br><span class="line">sectionBox.Transform = transform;</span><br><span class="line">sectionBox.Min = <span class="keyword">new</span> XYZ(<span class="number">-10</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">sectionBox.Max = <span class="keyword">new</span> XYZ(<span class="number">10</span>,<span class="number">12</span>,<span class="number">5</span>);</span><br><span class="line"><span class="comment">// Min &amp; Max X values (-10 &amp; 10) define the section line length on each side of the wall</span></span><br><span class="line"><span class="comment">// Max Y (12) is the height of the section box// Max Z (5) is the far clip offset</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a new view section.</span></span><br><span class="line">ViewSection viewSection = ViewSection.CreateSection(document, viewFamilyTypes.First().Id, sectionBox);</span><br></pre></td></tr></table></figure>

<p>参照剖面是参照现有视图的剖面。创建新参照剖面时，Revit不会添加新视图。</p>
<p>代码区域：ViewSection. ViewReferenceSection（）</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ViewSection ViewSection.CreateReferenceSection(Document document, </span><br><span class="line">                                                      ElementId parentViewId,</span><br><span class="line">                                                      ElementId viewIdToReference, </span><br><span class="line">                                                      XYZ headPoint, </span><br><span class="line">                                                      XYZ tailPoint);</span><br></pre></td></tr></table></figure>

<p>parentViewId参数是将在其中显示新引用截面标记的视图的ID。可以在“楼层平面”、“天花板平面”、“结构平面”、“剖面”、“立面”、“绘图”和“详图”视图中创建参照剖面。viewIdToReference可以是详图、绘图或剖面视图的ID。新参照截面将使用参照视图的ViewFamilyType。这两个XYZ点将确定父视图中截面标记标头的位置。 #详细视图 局部视图是模型的视图，在其他视图中显示为剖面或截面。这种类型的视图通常以比父视图中更精细的细节比例来表示模型。它用于向模型的特定部分添加更多信息。静态ViewSection. ViewDetail（）方法用于创建新的细节ViewSection。</p>
<p>代码区域：ViewSection. ViewDetail（）</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ViewSection ViewSection.CreateDetail(Document document, ElementId viewFamilyTypeId, BoundingBoxXYZ sectionBox);</span><br></pre></td></tr></table></figure>

<p>viewFamilyTypeId参数是新ViewSection将使用的ViewFamilyType的ID。类型必须是详图视图族。与标准剖面视图一样，sectionBox参数是剖面视图裁剪框。它提供剖面视图所需的方向和范围。 添加新详图ViewSection后，它将显示在项目浏览器的“详图视图（Detail）”节点中。 #立面视图 立面视图是模型的横截面，其中显示标高线。立面视图由ViewSection类表示。但是，与其他类型的横断面图不同，不能使用ViewSection类的静态方法创建立面视图。要创建立面视图，请先创建立面标记，然后使用该标记生成立面视图。新创建的立面视图将显示在项目浏览器的“立面（建筑立面）”节点中。它将被分配一个唯一的名称。 以下示例基于梁的位置创建立面视图。</p>
<p>代码区域：创建立面视图</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function">ViewSection <span class="title">CreateElevationView</span>(<span class="params">Document document, FamilyInstance beam</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Find an elevation view type</span></span><br><span class="line">    IEnumerable viewFamilyTypes = <span class="function"><span class="keyword">from</span> elem <span class="keyword">in</span> <span class="keyword">new</span> <span class="title">FilteredElementCollector</span>(<span class="params">document</span>).<span class="title">OfClass</span>(<span class="params"><span class="keyword">typeof</span>(ViewFamilyType</span>))</span></span><br><span class="line"><span class="function">                                                    <span class="keyword">let</span> type</span> = elem <span class="keyword">as</span> ViewFamilyType</span><br><span class="line">                                                    <span class="keyword">where</span> type.ViewFamily == ViewFamily.Elevation</span><br><span class="line">                                                    <span class="keyword">select</span> type;</span><br><span class="line"></span><br><span class="line">    LocationCurve lc = beam.Location <span class="keyword">as</span> LocationCurve;</span><br><span class="line">    XYZ xyz = lc.Curve.GetEndPoint(<span class="number">0</span>);</span><br><span class="line">    ElevationMarker marker = ElevationMarker.CreateElevationMarker(document, viewFamilyTypes.First().Id, xyz, <span class="number">1</span>);</span><br><span class="line">    ViewSection elevationView = marker.CreateElevation(document, document.ActiveView.Id, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> elevationView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ElevationMarker. Elevation（）方法将ViewPlan的id作为参数。这是ElevationMarker可见的ViewPlan。新的立面ViewSection将从ViewPlan中导出其范围并继承设置。最后一个参数是将放置新立面视图的ElevationMarker上的索引。ElevationMarker上的索引必须有效且未使用。视图的方向由索引决定。 #标注和参考标注 视图以较大比例显示另一个视图的一部分。可以使用静态方法ViewSection. callout（）创建标注视图。详图索引可以在“楼层平面”、“天花板平面”、“结构平面”、“剖面”、“立面”、“绘图”和“详图”视图中创建。生成的视图将是ViewSection、ViewPlan或ViewDetail，具体取决于所使用的ViewFamilyType，并将显示在项目浏览器的相应节点中。</p>
<p>代码区域：ViewSection. callout（）</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ViewSection ViewSection.CreateCallout(Document document, </span><br><span class="line">                                            ElementId parentViewId, </span><br><span class="line">                                            ElementId viewFamilyTypeId,</span><br><span class="line">                                            XYZ point1,</span><br><span class="line">                                            XYZ point2);</span><br></pre></td></tr></table></figure>

<p>父视图ID参数可以是可在其上创建详图索引的任何类型的视图的ID。点参数确定父视图中的图元符号的范围。参照图元是指引用现有视图的图元。添加参照视图时，Revit不会在项目中创建视图。相反，它创建一个指向指定的现有视图的指针。多个参照详图索引可以指向同一视图。</p>
<p>代码区域：ViewSection. ViewReferenceCallout（）</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ViewSection ViewSection.CreateReferenceCallout(Document document, </span><br><span class="line">                                                      ElementId parentViewId, </span><br><span class="line">                                                      ElementId viewIdToReference,</span><br><span class="line">                                                      XYZ point1,</span><br><span class="line">                                                      XYZ point2);</span><br></pre></td></tr></table></figure>

<p>创建引用对象与创建对象类似。但是，与其将视图的ViewFamilyType的Id作为参数，还不如将视图ReferenceCallout（）方法作为要引用的视图的Id。被引用视图的ViewFamilyType将由新引用对象使用。 只能参照裁剪的视图，除非参照的视图是“绘图”视图。无论父视图类型如何，始终可以参照绘图视图。立面视图可以从立面父视图和图纸父视图中参照。可以从“截面”和“绘图”父视图中参照截面视图。可以从所有父视图中参照详图视图，但在FloorPlan、CeilingPlan和StructuralPlan父视图中除外，在这些父视图中只能参照水平方向的详图视图。FloorPlan、CeilingPlan和StructuralPlan视图可以从FloorPlan、CeilingPlan和StructuralPlan父视图中引用。 下面的示例使用Detail ViewFamilyType创建新的图元，然后使用新的图元视图创建引用图元。</p>
<p>代码区域：创建对象和引用对象</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">CreateCalloutView</span>(<span class="params">Document document, View parentView</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Find a detail view type</span></span><br><span class="line">    IEnumerable viewFamilyTypes = <span class="function"><span class="keyword">from</span> elem <span class="keyword">in</span> <span class="keyword">new</span> <span class="title">FilteredElementCollector</span>(<span class="params">document</span>).<span class="title">OfClass</span>(<span class="params"><span class="keyword">typeof</span>(ViewFamilyType</span>))</span></span><br><span class="line"><span class="function">                                                    <span class="keyword">let</span> type</span> = elem <span class="keyword">as</span> ViewFamilyType</span><br><span class="line">                                                    <span class="keyword">where</span> type.ViewFamily == ViewFamily.Detail</span><br><span class="line">                                                    <span class="keyword">select</span> type;</span><br><span class="line"></span><br><span class="line">    ElementId viewFamilyTypeId = viewFamilyTypes.First().Id;    XYZ point1 = <span class="keyword">new</span> XYZ(<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">    XYZ point2 = <span class="keyword">new</span> XYZ(<span class="number">30</span>, <span class="number">30</span>, <span class="number">30</span>);</span><br><span class="line">    ElementId parentViewId = parentView.Id;  <span class="comment">// a ViewPlan</span></span><br><span class="line">    View view = ViewSection.CreateCallout(document, parentViewId, viewFamilyTypeId, point1, point2);</span><br><span class="line"></span><br><span class="line">    ViewSection.CreateReferenceCallout(document, parentViewId, view.Id, point1, point2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="图纸"><a href="#图纸" class="headerlink" title="图纸"></a>图纸</h3><p>图纸包含视图和标题栏。使用ViewSheet.Create（）方法创建图纸视图时，标题栏族符号Id是该方法的必需参数。可以使用FilteredElementCollector找到标题栏族符号。</p>
<p>代码区域：ViewSheet.Create（）</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ViewSheet ViewSheet.Create(Document document, ElementId titleBlockTypeId);</span><br></pre></td></tr></table></figure>

<p>新创建的图纸没有视图。Viewport.Create（）方法用于添加视图。Viewport类用于将常规视图添加到视图工作表，即平面、立面、绘图和三维视图。若要向视图添加明细表，请改用ScheduleSheetInstance.Create（）。</p>
<p>代码区域：添加两个在左角对齐的视图</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PlaceAlignedViewsAtLeftCorner</span>(<span class="params">Document doc</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    FilteredElementCollector fec = <span class="keyword">new</span> FilteredElementCollector(doc);</span><br><span class="line">    fec.OfClass(<span class="keyword">typeof</span>(ViewPlan));</span><br><span class="line">    <span class="keyword">var</span> viewPlans = fec.Cast().Where(vp =&gt; !vp.IsTemplate &amp;&amp; vp.ViewType == ViewType.CeilingPlan);</span><br><span class="line"></span><br><span class="line">    ViewPlan vp1 = viewPlans.ElementAt(<span class="number">0</span>);</span><br><span class="line">    ViewPlan vp2 = viewPlans.ElementAt(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> (Transaction t = <span class="keyword">new</span> Transaction(doc, <span class="string">&quot;Place on sheet&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        t.Start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Add two viewports distinct from one another</span></span><br><span class="line">        ViewSheet vs = ViewSheet.Create(doc, ElementId.InvalidElementId);</span><br><span class="line">        Viewport viewport1 = Viewport.Create(doc, vs.Id, vp1.Id, <span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">        Viewport viewport2 = Viewport.Create(doc, vs.Id, vp2.Id, <span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">5</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">        doc.Regenerate();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Calculate the necessary move vector to align the lower left corner</span></span><br><span class="line">        Outline outline1 = viewport1.GetBoxOutline();</span><br><span class="line">        Outline outline2 = viewport2.GetBoxOutline();</span><br><span class="line">        XYZ boxCenter = viewport2.GetBoxCenter();</span><br><span class="line">        XYZ vectorToCenter = boxCenter - outline2.MinimumPoint;</span><br><span class="line">        XYZ newCenter = outline1.MinimumPoint + vectorToCenter;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Move the viewport to the new location</span></span><br><span class="line">        viewport2.SetBoxCenter(newCenter);</span><br><span class="line"></span><br><span class="line">        t.Commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>XYZ位置参数标识添加的视图所在的位置。它指向添加的视图的中心坐标（以英寸为单位）。 坐标[0，0]是相对于工作表左下角的坐标。 在完整的图形集中，每张图纸都有唯一的图纸编号。该编号将显示在项目浏览器中图纸名称的前面。使用视图标题中的图纸编号可以方便地交叉参考图形集中的图纸。可以使用SheetNumber属性检索或修改编号。数字必须是唯一的;否则，当您将数字设置为重复值时，将引发异常。 下面的示例说明如何创建和打印工作表视图。开始，在文档中查找可用的标题栏（在本例中使用过滤器），然后使用它创建图纸视图。接下来，添加三维视图。视图将以其左下角位于图纸中心的方式放置。最后，通过调用View.Print（）方法打印工作表。</p>
<p>代码区域：创建图纸视图</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">CreateSheetView</span>(<span class="params">Autodesk.Revit.DB.Document document, View3D view3D</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get an available title block from document</span></span><br><span class="line">    FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">    collector.OfClass(<span class="keyword">typeof</span>(FamilySymbol));</span><br><span class="line">    collector.OfCategory(BuiltInCategory.OST_TitleBlocks);</span><br><span class="line"></span><br><span class="line">    FamilySymbol fs = collector.FirstElement() <span class="keyword">as</span> FamilySymbol;</span><br><span class="line">    <span class="keyword">if</span> (fs != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">using</span> (Transaction t = <span class="keyword">new</span> Transaction(document, <span class="string">&quot;Create a new ViewSheet&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            t.Start();</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// Create a sheet view</span></span><br><span class="line">                ViewSheet viewSheet = ViewSheet.Create(document, fs.Id);</span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">null</span> == viewSheet)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Failed to create new ViewSheet.&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Add passed in view onto the center of the sheet</span></span><br><span class="line">                UV location = <span class="keyword">new</span> UV((viewSheet.Outline.Max.U - viewSheet.Outline.Min.U) / <span class="number">2</span>,</span><br><span class="line">                                        (viewSheet.Outline.Max.V - viewSheet.Outline.Min.V) / <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//viewSheet.AddView(view3D, location);</span></span><br><span class="line">                Viewport.Create(document, viewSheet.Id, view3D.Id, <span class="keyword">new</span> XYZ(location.U, location.V, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Print the sheet out</span></span><br><span class="line">                <span class="keyword">if</span> (viewSheet.CanBePrinted)</span><br><span class="line">                &#123;</span><br><span class="line">                    TaskDialog taskDialog = <span class="keyword">new</span> TaskDialog(<span class="string">&quot;Revit&quot;</span>);</span><br><span class="line">                    taskDialog.MainContent = <span class="string">&quot;Print the sheet?&quot;</span>;</span><br><span class="line">                    TaskDialogCommonButtons buttons = TaskDialogCommonButtons.Yes | TaskDialogCommonButtons.No;</span><br><span class="line">                    taskDialog.CommonButtons = buttons;</span><br><span class="line">                    TaskDialogResult result = taskDialog.Show();</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (result == TaskDialogResult.Yes)</span><br><span class="line">                    &#123;</span><br><span class="line">                        viewSheet.Print();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                t.Commit();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span></span><br><span class="line">            &#123;</span><br><span class="line">                t.RollBack();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：不能将工作表视图添加到另一个工作表，也不能将视图添加到多个工作表;否则会发生参数异常。</p>
<p>表单修订</p>
<p>ViewSheet类有几种用于处理图纸上的修订和云线批注的方法。</p>
<ul>
<li>GetAllRevisionIds（）-获取参与图纸修订明细表的修订的有序数组。</li>
<li>GetAdditionalRevisionIds（）-获取图纸修订明细表中额外包含的修订。SetAdditionalRevisionIds（）-设置要另外包含在图纸修订明细表中的修订。</li>
<li>GetCurrentRevision（）-返回此视图表中显示的最新编号版本。</li>
<li>GetRevisionCloudNumberOnSheet（）-当项目中的编号是按图纸编号时，获取此图纸上RevisionCloud的修订号。</li>
<li>GetRevisionNumberOnSheet（）-获取特定修订的修订号，当项目中的编号是按图纸编号时，该修订号将显示在此图纸上。</li>
</ul>
<p> 根据项目中的修订顺序对修订进行排序。附加包含的修订将始终参与图纸的修订明细表。通常，修订明细表中会列出修订明细表，因为其关联的RevisionClouds之一存在于图纸中。 下面的代码示例演示如何向图纸添加与给定条件匹配的其他修订。</p>
<p>代码区域：向图纸添加其他修订</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">AddAdditionalRevisionsToSheet</span>(<span class="params">ViewSheet viewSheet, String toMatch</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Document doc = viewSheet.Document;</span><br><span class="line"></span><br><span class="line">    ICollection revisions = viewSheet.GetAdditionalRevisionIds();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find revisions whose description matches input string</span></span><br><span class="line">    FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(doc);</span><br><span class="line">    collector.OfCategory(BuiltInCategory.OST_Revisions);</span><br><span class="line">    collector.WhereElementIsNotElementType();</span><br><span class="line">    <span class="keyword">if</span> (revisions.Count &gt; <span class="number">0</span>)</span><br><span class="line">        collector.Excluding(revisions);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check if revision should be added</span></span><br><span class="line">    <span class="keyword">foreach</span> (Element revision <span class="keyword">in</span> collector)</span><br><span class="line">    &#123;</span><br><span class="line">        Parameter descriptionParam = revision.get_Parameter(BuiltInParameter.PROJECT_REVISION_REVISION_DESCRIPTION);</span><br><span class="line">        String description = descriptionParam.AsString();</span><br><span class="line">        <span class="keyword">if</span> (description.Contains(toMatch))</span><br><span class="line">            revisions.Add(revision.Id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (revisions.Count &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Apply the new list of revisions</span></span><br><span class="line">        <span class="keyword">using</span> (Transaction t = <span class="keyword">new</span> Transaction(doc, <span class="string">&quot;Add revisions to sheet&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            t.Start();</span><br><span class="line">            viewSheet.SetAdditionalRevisionIds(revisions);</span><br><span class="line">            t.Commit();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="打印机设置"><a href="#打印机设置" class="headerlink" title="打印机设置"></a>打印机设置</h4><p>在打印纸张之前，您可能需要更改打印机的设置。API使用PrintManager类和相关的Autodesk. Revit. DB类公开打印机的设置：</p>
<table>
<thead>
<tr>
<th><strong>Class 类</strong></th>
<th><strong>Functionality 功能</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Autodesk.Revit.DB.PrintManager</td>
<td>表示Revit UI中“打印”对话框（文件-&gt;Print）中的打印信息。</td>
</tr>
<tr>
<td>Autodesk.Revit.DB.PrintParameters</td>
<td>包含用于打印文档的设置的对象。</td>
</tr>
<tr>
<td>Autodesk.Revit.DB.PrintSetup</td>
<td>表示打印设置（文件-&gt;Print Setup…）在Revit UI中。</td>
</tr>
<tr>
<td>Autodesk.Revit.DB.PaperSize</td>
<td>表示Autodesk Revit项目中打印设置纸张尺寸的对象。</td>
</tr>
<tr>
<td>Autodesk.Revit.DB.PaperSizeSet</td>
<td>可以包含任意数量的纸张大小对象的集合。</td>
</tr>
<tr>
<td>Autodesk.Revit.DB.PaperSource</td>
<td>表示Autodesk Revit项目中打印设置的纸张来源的对象。</td>
</tr>
<tr>
<td>Autodesk.Revit.DB.PaperSourceSet</td>
<td>可以包含任意数量纸张源对象的集合。</td>
</tr>
<tr>
<td>Autodesk.Revit.DB.ViewSheetSetting</td>
<td>表示Revit UI中的视图&#x2F;图纸集（文件-&gt;Print）。</td>
</tr>
<tr>
<td>Autodesk.Revit.DB.PrintSetting</td>
<td>表示打印设置（文件-&gt;Print Setup…）在Revit UI中。</td>
</tr>
</tbody></table>
<p>有关使用这些对象的代码示例，请参见随Revit Platform SDK提供的ViewPrinter示例应用程序。</p>
<h3 id="图表"><a href="#图表" class="headerlink" title="图表"></a>图表</h3><p>此类表示显示数据表的视图。</p>
<p>TableView是ViewSchedule和PanelScheduleView的基类。</p>
<p>本节中的页面</p>
<ul>
<li>Schedule Classes 明细表类</li>
<li>ViewSchedule 视图明细表</li>
<li>PanelScheduleView 配电盘明细表</li>
</ul>
<h4 id="明细表类"><a href="#明细表类" class="headerlink" title="明细表类"></a>明细表类</h4><p>明细表视图使用多个支持类。</p>
<p>TableView是一个表示显示表的视图的类，它是ViewSchedule和PanelScheduleView的基类。它有一个关联的TableData类，其中包含一个或多个节。对于ViewSchedule，只有一个页眉和一个正文部分。</p>
<p>TableSectionData类表示按行和列排列的一组连续单元格。对于ViewSchedule，TableSectionData的单元格内容由ScheduleDefinition和参数生成。此外，对于ViewSchedules，虽然头部分具有读&#x2F;写权限，但主体部分是只读的。</p>
<h5 id="使用明细表中的数据"><a href="#使用明细表中的数据" class="headerlink" title="使用明细表中的数据"></a>使用明细表中的数据</h5><p>表的实际数据包含在TableData类中。虽然无法直接从TableView类获取TableData对象，但两个子类都有GetTableData（）方法。对于ViewSchedule，此方法返回一个TableData对象。对于PanelScheduleView，GetTableData（）返回PanelScheduleData对象，该对象派生自TableData基类。TableData类保存描述表中行、列和单元格样式的大部分数据。PanelScheduleData提供了专门与配电盘明细表相关的其他方法。</p>
<p>使用行、列和单元格<br>表中的数据被分解为多个部分。要使用TableData的行、列和单元格，需要获取TableSectionData对象。GetSectionData（）可以使用请求的节数据的整数或使用SectionType（即Header或Body）调用。</p>
<p>TableSectionData类可用于插入或删除行或列，格式化单元格，以及获取组成该明细表部分的单元格的详细信息，例如单元格类型（即文本或图形）或单元格的类别ID。</p>
<p>在下面的示例中，将新行添加到明细表的页眉部分，并为新创建的单元格设置文本。请注意，在使用UI创建时，页眉部分的第一行默认为标题。</p>
<p>代码区域：插入行</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">CreateSubtitle</span>(<span class="params">ViewSchedule schedule</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    TableData colTableData = schedule.GetTableData();</span><br><span class="line"></span><br><span class="line">    TableSectionData tsd = colTableData.GetSectionData(SectionType.Header);</span><br><span class="line">    tsd.InsertRow(tsd.FirstRowNumber + <span class="number">1</span>);</span><br><span class="line">    tsd.SetCellText(tsd.FirstRowNumber + <span class="number">1</span>, tsd.FirstColumnNumber, <span class="string">&quot;Schedule of column top and base levels with offsets&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另请注意，在上面的代码示例中，它使用了FirstRowNumber和FirstColumnNumber属性。在某些部分中，行或列编号可能以0开头，也可能以1开头。这些属性应始终用于代替硬编码的0或1。 在下面的示例中，将创建一个带有自定义页眉节的新单类别明细表。</p>
<p>代码区域：自定义标题部分</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CreateSingleCategoryScheduleWithSimpleHeaderSection</span>(<span class="params">Document doc</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> (Transaction t = <span class="keyword">new</span> Transaction(doc, <span class="string">&quot;Create single-category with custom headers&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Build schedule</span></span><br><span class="line">        t.Start();</span><br><span class="line">        ViewSchedule vs = ViewSchedule.CreateSchedule(doc, <span class="keyword">new</span> ElementId(BuiltInCategory.OST_Windows));</span><br><span class="line"></span><br><span class="line">        AddRegularFieldToSchedule(vs, <span class="keyword">new</span> ElementId(BuiltInParameter.WINDOW_HEIGHT));</span><br><span class="line">        AddRegularFieldToSchedule(vs, <span class="keyword">new</span> ElementId(BuiltInParameter.WINDOW_WIDTH));</span><br><span class="line">        AddRegularFieldToSchedule(vs, <span class="keyword">new</span> ElementId(BuiltInParameter.ALL_MODEL_MARK));</span><br><span class="line">        AddRegularFieldToSchedule(vs, <span class="keyword">new</span> ElementId(BuiltInParameter.ALL_MODEL_COST));</span><br><span class="line"></span><br><span class="line">        doc.Regenerate();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Get header section</span></span><br><span class="line">        TableSectionData data = vs.GetTableData().GetSectionData(SectionType.Header);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">int</span> rowNumber = data.LastRowNumber;</span><br><span class="line">        <span class="built_in">int</span> columnNumber = data.LastColumnNumber;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Get the overall width of the table so that the new columns can be resized properly</span></span><br><span class="line">        <span class="built_in">double</span> tableWidth = data.GetColumnWidth(columnNumber);</span><br><span class="line"></span><br><span class="line">        data.InsertColumn(columnNumber);</span><br><span class="line">        data.InsertColumn(columnNumber);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Refresh data to be sure that schedule is ready for text insertion</span></span><br><span class="line">        vs.RefreshData();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Set text to the first header cell</span></span><br><span class="line">        data.SetCellText(rowNumber, data.FirstColumnNumber, <span class="string">&quot;Special Window Schedule Text&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Set width of first column</span></span><br><span class="line">        data.SetColumnWidth(data.FirstColumnNumber, tableWidth / <span class="number">3.0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Set a different parameter to the second cell - the project name</span></span><br><span class="line">        data.SetCellParamIdAndCategoryId(rowNumber, data.FirstRowNumber + <span class="number">1</span>, <span class="keyword">new</span> ElementId(BuiltInParameter.PROJECT_NAME),</span><br><span class="line">                                            <span class="keyword">new</span> ElementId(BuiltInCategory.OST_ProjectInformation));</span><br><span class="line">        data.SetColumnWidth(data.FirstColumnNumber + <span class="number">1</span>, tableWidth / <span class="number">3.0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Set the third column as the schedule view name - use the special category for schedule parameters for this</span></span><br><span class="line">        data.SetCellParamIdAndCategoryId(rowNumber, data.LastColumnNumber, <span class="keyword">new</span> ElementId(BuiltInParameter.VIEW_NAME),</span><br><span class="line">                                            <span class="keyword">new</span> ElementId(BuiltInCategory.OST_ScheduleViewParamGroup));</span><br><span class="line">        data.SetColumnWidth(data.LastColumnNumber, tableWidth / <span class="number">3.0</span>);</span><br><span class="line"></span><br><span class="line">        t.Commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">AddRegularFieldToSchedule</span>(<span class="params">ViewSchedule schedule, ElementId paramId</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ScheduleDefinition definition = schedule.Definition;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find a matching SchedulableField</span></span><br><span class="line">    SchedulableField schedulableField =</span><br><span class="line">        definition.GetSchedulableFields().FirstOrDefault(sf =&gt; sf.ParameterId == paramId);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (schedulableField != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Add the found field</span></span><br><span class="line">        definition.AddField(schedulableField);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以为明细表自定义行、列或单个单元格的样式。这包括为单元格的所有四边设置边框线样式，以及单元格颜色和文本外观（即颜色，字体，大小）的能力。对于常规计划，只能在表格的标题部分执行此操作。 在下面的示例中，ViewSchedule的副标题（假定为标题部分的第二行）的字体设置为粗体，字体大小设置为10。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">FormatSubtitle</span>(<span class="params">ViewSchedule colSchedule</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    TableData colTableData = colSchedule.GetTableData();</span><br><span class="line"></span><br><span class="line">    TableSectionData tsd = colTableData.GetSectionData(SectionType.Header);</span><br><span class="line">    <span class="comment">// Subtitle is second row, first column</span></span><br><span class="line">    <span class="keyword">if</span> (tsd.AllowOverrideCellStyle(tsd.FirstRowNumber + <span class="number">1</span>, tsd.FirstColumnNumber))</span><br><span class="line">    &#123;</span><br><span class="line">        TableCellStyle tcs = <span class="keyword">new</span> TableCellStyle();</span><br><span class="line">        TableCellStyleOverrideOptions options = <span class="keyword">new</span> TableCellStyleOverrideOptions();</span><br><span class="line">        options.FontSize = <span class="literal">true</span>;</span><br><span class="line">        options.Bold = <span class="literal">true</span>;</span><br><span class="line">        tcs.SetCellStyleOverrideOptions(options);</span><br><span class="line">        tcs.IsFontBold = <span class="literal">true</span>;</span><br><span class="line">        tcs.TextSize = <span class="number">10</span>;</span><br><span class="line">        tsd.SetCellStyle(tsd.FirstRowNumber + <span class="number">1</span>, tsd.FirstColumnNumber, tcs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="视图明细表"><a href="#视图明细表" class="headerlink" title="视图明细表"></a>视图明细表</h4><p>明细表是数据的表格表示形式。典型明细表显示类别的所有图元（门、房间等）。每行表示一个元素，每列表示一个参数。</p>
<p>ViewSchedule类表示明细表和其他类似明细表的视图，包括单类别和多类别明细表、关键字明细表、材质提取、视图列表、图纸列表、注释记号图例、修订明细表和注释块。</p>
<p>ViewSchedule.Export（）方法将日程数据导出到文本文件中。</p>
<p>在图纸上放置明细表</p>
<p>静态ScheduleSheetInstance.Create（）方法在工作表上创建明细表的实例。它需要要放置明细表的图纸的ID、明细表视图的ID以及要放置明细表的图纸上的XYZ位置。ScheduleSheetInstance对象具有用于访问生成此ScheduleSheetInstance的“主”明细表的ID、明细表在图纸上的旋转、明细表在图纸上的放置位置（在图纸坐标中）以及标识ScheduleSheetInstance是否为标题栏族中的修订明细表的标志的属性。</p>
<p>本节中的页面</p>
<ul>
<li>创建明细表</li>
<li>使用视图明细表</li>
</ul>
<h5 id="创建明细表"><a href="#创建明细表" class="headerlink" title="创建明细表"></a>创建明细表</h5><p>ViewSchedule类有几种方法用于根据计划类型创建新明细表。所有这些方法都有一个Document参数，该参数是要向其中添加新明细表或类似明细表的视图的文档。新创建的明细表视图将显示在项目浏览器中的“明细表&#x2F;明细表”节点下。</p>
<p>标准的单类别或多类别明细表可以用静态ViewSchedule. fullSchedule（）方法创建。</p>
<p>代码区域：创建具有2个字段的单一类别明细表</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CreateSingleCategorySchedule</span>(<span class="params">Document doc</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> (Transaction t = <span class="keyword">new</span> Transaction(doc, <span class="string">&quot;Create single-category&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        t.Start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create schedule</span></span><br><span class="line">        ViewSchedule vs = ViewSchedule.CreateSchedule(doc, <span class="keyword">new</span> ElementId(BuiltInCategory.OST_Windows));</span><br><span class="line"></span><br><span class="line">        doc.Regenerate();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Add fields to the schedule</span></span><br><span class="line">        AddRegularFieldToSchedule(vs, <span class="keyword">new</span> ElementId(BuiltInParameter.WINDOW_HEIGHT));</span><br><span class="line">        AddRegularFieldToSchedule(vs, <span class="keyword">new</span> ElementId(BuiltInParameter.WINDOW_WIDTH));</span><br><span class="line"></span><br><span class="line">        t.Commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> </span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> Adds a single parameter field to the schedule</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">AddRegularFieldToSchedule</span>(<span class="params">ViewSchedule schedule, ElementId paramId</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ScheduleDefinition definition = schedule.Definition;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find a matching SchedulableField</span></span><br><span class="line">    SchedulableField schedulableField =</span><br><span class="line">        definition.GetSchedulableFields().FirstOrDefault(sf =&gt; sf.ParameterId == paramId);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (schedulableField != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Add the found field</span></span><br><span class="line">        definition.AddField(schedulableField);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二个参数是其图元将包含在明细表中的类别的ID，或者是多类别明细表的InvalidElementId。 第二个RISKSchedule（）方法可用于创建面积明细表，并接受一个附加参数，即明细表的面积方案ID。</p>
<p>代码区域：创建面积明细表</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(doc);</span><br><span class="line">collector.OfCategory(BuiltInCategory.OST_AreaSchemes);</span><br><span class="line"><span class="comment">//Get first ElementId of AreaScheme.</span></span><br><span class="line">ElementId areaSchemeId = collector.FirstElementId();</span><br><span class="line"><span class="keyword">if</span> (areaSchemeId != <span class="literal">null</span> &amp;&amp; areaSchemeId != ElementId.InvalidElementId)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// If you want to create an area schedule, you must use CreateSchedule method with three arguments. </span></span><br><span class="line">    <span class="comment">// The value of the second argument must be ElementId of BuiltInCategory.OST_Areas category</span></span><br><span class="line">    <span class="comment">// and the value of third argument must be ElementId of an AreaScheme.</span></span><br><span class="line">    areaSchedule = Autodesk.Revit.DB.ViewSchedule.CreateSchedule(doc, <span class="keyword">new</span> ElementId(BuiltInCategory.OST_Areas), areaSchemeId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关键字明细表显示抽象的“关键”元素，这些元素可用于填充普通模型元素的参数，并且可以使用静态ViewSchedule.CreateKeySchedule（）方法创建，该方法的第二个参数是明细表的关键字将与之关联的元素类别的ID。材料提取是一个明细表，显示有关构成模型中元素的材料的信息。与每行（分组前）表示单个元素的常规明细表不同，材料提取中的每行表示单个&lt;元素、材料&gt;对。ViewSchedule. AccessMaterialTakeoff（）方法具有与ViewSchedule. AccessSchedule（）方法相同的参数，并且允许单类别和多类别材质提取明细表。 视图列表、图纸列表和注释记号图例与指定类别相关联，因此它们的创建方法将类别ID作为参数。视图列表是项目中视图的明细表。它是视图类别的明细表，使用ViewSchedule. ViewList（）创建。 图纸列表是项目中图纸的明细表。它是“图纸”类别的明细表，使用ViewSchedule. SetSheetList（）方法创建。 注释记号图例是“注释记号标记”类别的明细表，可使用ViewSchedule.CreateKeynoteLegend（）创建。 修订明细表将添加到标题栏族中，并作为图纸上标题栏的一部分可见。如果传入的文档不是标题栏族，ViewSchedule. RevisionSchedule（）方法将引发异常。 注释块是“常规注释”类别的明细表，它显示单个族的图元，而不是类别中的所有图元。</p>
<p>代码区域：ViewSchedule. NoteBlock（）</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ViewSchedule ViewSchedule.CreateNoteBlock(Document document, ElementId familyId);</span><br></pre></td></tr></table></figure>

<p>第二个参数是其图元将包含在明细表中的族的ID。</p>
<p>代码区域：创建注释块明细表</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> (Transaction transaction = <span class="keyword">new</span> Transaction(doc, <span class="string">&quot;Creating Note BLock&quot;</span>))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//Get first ElementId of a Note Block family.</span></span><br><span class="line">    ICollection noteblockFamilies = ViewSchedule.GetValidFamiliesForNoteBlock(doc);</span><br><span class="line">    ElementId symbolId = noteblockFamilies.First();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!symbolId.Equals(ElementId.InvalidElementId))</span><br><span class="line">    &#123;</span><br><span class="line">        transaction.Start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Create a note-block view schedule.</span></span><br><span class="line">        noteBlockSchedule = ViewSchedule.CreateNoteBlock(doc, symbolId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> != areaSchedule)</span><br><span class="line">    &#123;</span><br><span class="line">        transaction.Commit();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        transaction.RollBack();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="使用ViewSchedule"><a href="#使用ViewSchedule" class="headerlink" title="使用ViewSchedule"></a>使用ViewSchedule</h5><p>ScheduleDefinition类帮助定义ViewSchedule。</p>
<p>ScheduleDefinition类包含与明细表视图内容相关的各种设置，包括：</p>
<ul>
<li>明细表的类别和其他确定明细表类型的基本属性。</li>
<li>成为明细表列的一组字段。</li>
<li>排序和分组标准。</li>
<li>限制明细表中可见图元集的过滤器。</li>
<li>控制标题和&#x2F;或页眉可见性的设置。</li>
</ul>
<p>大多数计划都包含一个通过ViewSchedule.Definition属性检索的ScheduleDefinition。在Revit中，某些类别的明细表可以包含一个“嵌入式明细表”，其中包含与主明细表中的图元相关联的图元，例如，显示每个房间内图元的房间明细表或显示与每个系统相关联的图元的风管系统明细表。嵌入的计划有自己的类别、字段、过滤器等。这些设置存储在第二个ScheduleDefinition对象中。如果存在，则从ScheduleDefinition.EmbeddedDefinition属性获取嵌入的ScheduleDefinition。</p>
<h6 id="添加字段"><a href="#添加字段" class="headerlink" title="添加字段"></a>添加字段</h6><p>创建视图明细表后，可以添加字段。ScheduleDefinition. GetControlableFields（）方法将返回一个ControlableField对象的列表，这些对象表示可能包含在计划中的非计算字段。新字段可以从可扩展字段对象或使用ScheduleFieldType添加。下表描述了可从ScheduleFieldType枚举中使用的选项。</p>
<table>
<thead>
<tr>
<th><strong>Member name 成员名称</strong></th>
<th><strong>Description 描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Instance</td>
<td>明细表图元的实例参数。所有共享参数也都使用此类型，无论它们是实例参数还是类型参数。</td>
</tr>
<tr>
<td>ElementType</td>
<td>明细表图元的类型参数。</td>
</tr>
<tr>
<td>Count</td>
<td>明细表行上显示的图元数。</td>
</tr>
<tr>
<td>ViewBased</td>
<td>用于一些参数的专用字段类型，这些参数的显示值可以根据视图的设置而更改：<em>房间明细表和空间明细表中的ROOM_AREA和ROOM_PERIMETER。</em>修订明细表中的PROJECT_REVISION_REVISION_NUM。<em>注释记号图例中按图纸编号的KEYNOTE_NUMBER。</em></td>
</tr>
<tr>
<td>Formula</td>
<td>根据明细表中其他字段的值计算的公式。</td>
</tr>
<tr>
<td>Percentage</td>
<td>一个值，指示每个元素表示的另一个字段的总和的百分比。</td>
</tr>
<tr>
<td>Room</td>
<td>明细表图元所属房间的参数。</td>
</tr>
<tr>
<td>FromRoom</td>
<td>门或窗的“从”侧房间的参数。</td>
</tr>
<tr>
<td>ToRoom</td>
<td>门或窗“向”侧的房间参数。</td>
</tr>
<tr>
<td>ProjectInfo</td>
<td>明细表图元所属项目中的“项目信息”图元的参数，可以是链接文件。仅允许在包含链接文件图元的明细表中使用。</td>
</tr>
<tr>
<td>Material</td>
<td>在材质提取中，明细表图元的一种材质的参数。</td>
</tr>
<tr>
<td>MaterialQuantity</td>
<td>在材质提取中，表示如何在明细表图元中使用特定材质的值。参数ID可以是MATERIAL_AREA、MATERIAL_VOLUME或MATERIAL_ASPAINT。</td>
</tr>
<tr>
<td>RevitLinkInstance</td>
<td>链接文件中的元素所属的RevitLinkInstance的参数。当前，RVT_LINK_RELANCE_NAME是唯一受支持的参数。仅允许在包含链接文件图元的明细表中使用。</td>
</tr>
<tr>
<td>RevitLinkType</td>
<td>链接文件中的元素所属的RevitLinkType的参数。当前，RVT_LINK_FILE_NAME_WITHOUT_EXT是唯一受支持的参数。仅允许在包含链接文件图元的明细表中使用。</td>
</tr>
<tr>
<td>StructuralMaterial</td>
<td>明细表图元的结构材质参数。</td>
</tr>
<tr>
<td>Space</td>
<td>明细表图元所属空间的参数。</td>
</tr>
</tbody></table>
<p>使用一个ScheduleDefinition.AddField（）方法将把字段添加到字段列表的末尾。若要将新字段放置在字段列表中的特定位置，请使用ScheduleDefinition.InsertField（）方法之一。还可以在事后使用ScheduleDefinition.SetFieldOrder（）对字段进行排序。 下面是一个简单的示例，显示了如何在视图明细表中没有字段的情况下向视图添加字段。</p>
<p>代码区域：向明细表添加字段</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> </span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> Add fields to view schedule.</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> </span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> List of view schedule.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddFieldToSchedule</span>(<span class="params">List schedules</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    IList schedulableFields = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">foreach</span> (ViewSchedule vs <span class="keyword">in</span> schedules)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//Get all schedulable fields from view schedule definition.</span></span><br><span class="line">        schedulableFields = vs.Definition.GetSchedulableFields();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">foreach</span> (SchedulableField sf <span class="keyword">in</span> schedulableFields)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">bool</span> fieldAlreadyAdded = <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">//Get all schedule field ids</span></span><br><span class="line">            IList ids = vs.Definition.GetFieldOrder();</span><br><span class="line">            <span class="keyword">foreach</span> (ScheduleFieldId id <span class="keyword">in</span> ids)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//If the GetSchedulableField() method of gotten schedule field returns same schedulable field,</span></span><br><span class="line">                <span class="comment">// it means the field is already added to the view schedule.</span></span><br><span class="line">                <span class="keyword">if</span> (vs.Definition.GetField(id).GetSchedulableField() == sf)</span><br><span class="line">                &#123;</span><br><span class="line">                    fieldAlreadyAdded = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//If schedulable field doesn&#x27;t exist in view schedule, add it.</span></span><br><span class="line">            <span class="keyword">if</span> (fieldAlreadyAdded == <span class="literal">false</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                vs.Definition.AddField(sf);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ScheduleField类表示ScheduleDefinition的字段列表中的单个字段。每个（非隐藏）字段都将成为明细表中的一列。 最常见的情况是，字段表示明细表中出现的图元的实例或类型参数。某些字段表示其他相关图元的参数，如明细表图元所属的房间。字段还可以表示从明细表中的其他字段（特别是公式和百分比字段）计算的数据。 ScheduleField类具有控制列标题（包括文本和方向）的属性。也可以定义列内文本的列宽和水平对齐方式。 ScheduleField.IsHidden属性可用于隐藏字段。隐藏字段不显示在明细表中，但可用于筛选、排序、分组和条件格式设置，并且可由公式和百分比字段引用。</p>
<p>DisplayType</p>
<p>ScheduleField有一个DisplayType属性，用于指示字段的显示类型。可能的值为： 标准-如果元素的值不同，则不显示任何内容，否则将显示公共值总计-计算并显示总计值最小值最大值-计算并显示最小值和最大值最小值-计算并显示最大值最大值-计算并显示最小值 方法指示此字段是否可以显示最小值和最大值。 在非分项明细表中，当多个图元显示在同一行中时，非标准显示类型的值将显示在常规行中。 #字段的样式和格式 ScheduleField.GetStyle（）和ScheduleField.SetStyle（）使用TableCellStyle类来处理明细表中字段的样式。使用SetStyle（），可以设置字段的各种属性，包括单元格边框的线条样式以及文本字体、颜色和大小。 ScheduleField. SetOptions（）和ScheduleField. GetOptions（）使用DataOptions类来处理字段数据的格式。FormatOptions类包含控制如何将数字与单位格式化为字符串的设置。它包含通常由最终用户在“格式”对话框中选择并存储在文档中的设置。 在以下示例中，ViewSchedule中的所有长度字段都设置为以英尺和小数英寸为单位显示。</p>
<p>代码区域：格式化字段</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// format length units to display in feet and inches format</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">FormatLengthFields</span>(<span class="params">ViewSchedule schedule</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> nFields = schedule.Definition.GetFieldCount();</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> n = <span class="number">0</span>; n &lt; nFields; n++)</span><br><span class="line">    &#123;</span><br><span class="line">        ScheduleField field = schedule.Definition.GetField(n);</span><br><span class="line">        <span class="keyword">if</span> (field.UnitType == UnitType.UT_Length)</span><br><span class="line">        &#123;</span><br><span class="line">            FormatOptions formatOpts = <span class="keyword">new</span> FormatOptions();</span><br><span class="line">            formatOpts.UseDefault = <span class="literal">false</span>;</span><br><span class="line">            formatOpts.DisplayUnits = DisplayUnitType.DUT_FEET_FRACTIONAL_INCHES;</span><br><span class="line">            field.SetFormatOptions(formatOpts);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面的示例将格式和样式重写应用于给定字段。</p>
<p>代码区域：对字段应用格式和样式重写</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ApplyFormattingToField</span>(<span class="params">ViewSchedule schedule, <span class="built_in">int</span> fieldIndex</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Get the field.</span></span><br><span class="line">    ScheduleDefinition definition = schedule.Definition;</span><br><span class="line">    ScheduleField field = definition.GetField(fieldIndex);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Build unit formatting for the field.</span></span><br><span class="line">    FormatOptions options = field.GetFormatOptions();</span><br><span class="line">    options.UseDefault = <span class="literal">false</span>;</span><br><span class="line">    options.DisplayUnits = DisplayUnitType.DUT_SQUARE_INCHES;</span><br><span class="line">    options.UnitSymbol = UnitSymbolType.UST_IN_SUP_2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Build style overrides for the field</span></span><br><span class="line">    <span class="comment">// Use override options to indicate fields that are overridden and apply changes</span></span><br><span class="line">    TableCellStyle style = field.GetStyle();</span><br><span class="line">    TableCellStyleOverrideOptions overrideOptions = style.GetCellStyleOverrideOptions();</span><br><span class="line">    overrideOptions.BackgroundColor = <span class="literal">true</span>;</span><br><span class="line">    style.BackgroundColor = <span class="keyword">new</span> Color(<span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xFF</span>);</span><br><span class="line">    overrideOptions.FontColor = <span class="literal">true</span>;</span><br><span class="line">    style.TextColor = <span class="keyword">new</span> Color(<span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>);</span><br><span class="line">    overrideOptions.Italics = <span class="literal">true</span>;</span><br><span class="line">    style.IsFontItalic = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    style.SetCellStyleOverrideOptions(overrideOptions);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">double</span> width = field.GridColumnWidth;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> (Transaction t = <span class="keyword">new</span> Transaction(schedule.Document, <span class="string">&quot;Set style etc&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        t.Start();</span><br><span class="line">        field.SetStyle(style);</span><br><span class="line">        field.SetFormatOptions(options);</span><br><span class="line">        <span class="comment">// Change column width (affects width in grid and on sheet) - units are in Revit length units - ft.</span></span><br><span class="line">        field.GridColumnWidth = width + <span class="number">0.5</span>;</span><br><span class="line">        t.Commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="标题和标头"><a href="#标题和标头" class="headerlink" title="标题和标头"></a>标题和标头</h6><p>明细表标题和&#x2F;或页眉的显示是可选的。是否显示标题或标头可以使用ScheduleDefinition属性ShowTitle和ShowHeaders控制。</p>
<h6 id="明细表中的查询和排序"><a href="#明细表中的查询和排序" class="headerlink" title="明细表中的查询和排序"></a>明细表中的查询和排序</h6><p>可以按计划的一个或多个字段对计划进行排序或分组。有几种方法可用于控制字段的分组和排序。ScheduleSortGroupField类表示用于对计划进行排序或分组的字段之一。排序和分组是相关的操作。无论哪种情况，明细表中出现的元素都将根据其字段值进行排序，明细表将根据该字段值进行排序&#x2F;分组，这会自动将具有相同值的元素分组在一起。通过启用额外的页眉、页脚或空白行，可以实现组之间的视觉分隔。</p>
<p>如果ScheduleDefinition.IsItemized属性为false，则用于排序&#x2F;分组的所有字段具有相同值的元素将合并到同一行中。否则，明细表将在单独的行中显示每个元素</p>
<p>通过使用ScheduleField.IsHidden属性将用于排序&#x2F;分组的字段标记为隐藏，可以按计划中未显示的数据对计划进行排序或分组。</p>
<p>代码区域：将分组&#x2F;排序添加到计划</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">AddGroupingToSchedule</span>(<span class="params">ViewSchedule schedule, BuiltInParameter paramEnum, <span class="built_in">bool</span> withTotalsAndDecoration, ScheduleSortOrder order</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Find field </span></span><br><span class="line">    ScheduleField field = FindField(schedule, paramEnum);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (field == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Unable to find field.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Build sort/group field.</span></span><br><span class="line">    ScheduleSortGroupField sortGroupField = <span class="keyword">new</span> ScheduleSortGroupField(field.FieldId, order);</span><br><span class="line">    <span class="keyword">if</span> (withTotalsAndDecoration)</span><br><span class="line">    &#123;</span><br><span class="line">        sortGroupField.ShowFooter = <span class="literal">true</span>;</span><br><span class="line">        sortGroupField.ShowFooterTitle = <span class="literal">true</span>;</span><br><span class="line">        sortGroupField.ShowFooterCount = <span class="literal">true</span>;</span><br><span class="line">        sortGroupField.ShowHeader = <span class="literal">true</span>;</span><br><span class="line">        sortGroupField.ShowBlankLine = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add the sort/group field</span></span><br><span class="line">    ScheduleDefinition definition = schedule.Definition;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> (Transaction t = <span class="keyword">new</span> Transaction(schedule.Document, <span class="string">&quot;Add sort/group field&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        t.Start();</span><br><span class="line">        definition.AddSortGroupField(sortGroupField);</span><br><span class="line">        t.Commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduleField <span class="title">FindField</span>(<span class="params">ViewSchedule schedule, BuiltInParameter paramEnum</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ScheduleDefinition definition = schedule.Definition;</span><br><span class="line">    ScheduleField foundField = <span class="literal">null</span>;</span><br><span class="line">    ElementId paramId = <span class="keyword">new</span> ElementId(paramEnum);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">foreach</span> (ScheduleFieldId fieldId <span class="keyword">in</span> definition.GetFieldOrder())</span><br><span class="line">    &#123;</span><br><span class="line">        foundField = definition.GetField(fieldId);</span><br><span class="line">        <span class="keyword">if</span> (foundField.ParameterId == paramId)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> foundField;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>标头也可以分组。GroupHeaders（）方法可用于指定在标题部分的分组中包括哪些行和列。最后一个参数是一个字符串，表示分组的行和列的标头。 在下面的示例中，将为新创建的单类别明细表对列进行分组。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CreateSingleCategoryScheduleWithGroupedColumnHeaders</span>(<span class="params">Document doc</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> (Transaction t = <span class="keyword">new</span> Transaction(doc, <span class="string">&quot;Create single-category with grouped column headers&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Build the schedule</span></span><br><span class="line">        t.Start();</span><br><span class="line">        ViewSchedule vs = ViewSchedule.CreateSchedule(doc, <span class="keyword">new</span> ElementId(BuiltInCategory.OST_Windows));</span><br><span class="line"></span><br><span class="line">        AddRegularFieldToSchedule(vs, <span class="keyword">new</span> ElementId(BuiltInParameter.WINDOW_HEIGHT));</span><br><span class="line">        AddRegularFieldToSchedule(vs, <span class="keyword">new</span> ElementId(BuiltInParameter.WINDOW_WIDTH));</span><br><span class="line">        AddRegularFieldToSchedule(vs, <span class="keyword">new</span> ElementId(BuiltInParameter.ALL_MODEL_MARK));</span><br><span class="line">        AddRegularFieldToSchedule(vs, <span class="keyword">new</span> ElementId(BuiltInParameter.ALL_MODEL_COST));</span><br><span class="line"></span><br><span class="line">        doc.Regenerate();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Group the headers in the body section using ViewSchedule methods</span></span><br><span class="line">        vs.GroupHeaders(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="string">&quot;Size&quot;</span>);</span><br><span class="line">        vs.GroupHeaders(<span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="string">&quot;Other&quot;</span>);</span><br><span class="line">        vs.GroupHeaders(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="string">&quot;All&quot;</span>);</span><br><span class="line"></span><br><span class="line">        t.Commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">AddRegularFieldToSchedule</span>(<span class="params">ViewSchedule schedule, ElementId paramId</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ScheduleDefinition definition = schedule.Definition;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find a matching SchedulableField</span></span><br><span class="line">    SchedulableField schedulableField =</span><br><span class="line">        definition.GetSchedulableFields().FirstOrDefault(sf =&gt; sf.ParameterId == paramId);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (schedulableField != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Add the found field</span></span><br><span class="line">        definition.AddField(schedulableField);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h6><p>可使用“明细表过滤器”来过滤将在明细表中显示的图元。过滤器是要使图元显示在明细表中必须满足的条件。要使图元显示在明细表中，必须满足所有筛选条件。</p>
<p>通过使用ScheduleField.IsHidden属性将用于筛选的字段标记为隐藏，可以按未显示在计划中的数据筛选计划。</p>
<p>代码区域：将筛选器添加到计划</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">AddFilterToSchedule</span>(<span class="params">ViewSchedule schedule, ElementId levelId</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Find level field</span></span><br><span class="line">    ScheduleDefinition definition = schedule.Definition;</span><br><span class="line"></span><br><span class="line">    ScheduleField levelField = FindField(schedule, BuiltInParameter.ROOM_LEVEL_ID);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add filter</span></span><br><span class="line">    <span class="keyword">using</span> (Transaction t = <span class="keyword">new</span> Transaction(schedule.Document, <span class="string">&quot;Add filter&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        t.Start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If field not present, add it</span></span><br><span class="line">        <span class="keyword">if</span> (levelField == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            levelField = definition.AddField(ScheduleFieldType.Instance, <span class="keyword">new</span> ElementId(BuiltInParameter.ROOM_LEVEL_ID));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Set field to hidden</span></span><br><span class="line">        levelField.IsHidden = <span class="literal">true</span>;</span><br><span class="line">        ScheduleFilter filter = <span class="keyword">new</span> ScheduleFilter(levelField.FieldId, ScheduleFilterType.Equal, levelId);</span><br><span class="line">        definition.AddFilter(filter);</span><br><span class="line"></span><br><span class="line">        t.Commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> </span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> Finds an existing ScheduleField matching the given parameter</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> </span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> </span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> </span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduleField <span class="title">FindField</span>(<span class="params">ViewSchedule schedule, BuiltInParameter paramEnum</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ScheduleDefinition definition = schedule.Definition;</span><br><span class="line">    ScheduleField foundField = <span class="literal">null</span>;</span><br><span class="line">    ElementId paramId = <span class="keyword">new</span> ElementId(paramEnum);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">foreach</span> (ScheduleFieldId fieldId <span class="keyword">in</span> definition.GetFieldOrder())</span><br><span class="line">    &#123;</span><br><span class="line">        foundField = definition.GetField(fieldId);</span><br><span class="line">        <span class="keyword">if</span> (foundField.ParameterId == paramId)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> foundField;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="使用明细表数据"><a href="#使用明细表数据" class="headerlink" title="使用明细表数据"></a>使用明细表数据</h6><p>下面的示例说明如何确定明细表中的图元列表。</p>
<p>代码区域：获取计划的内容</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">GetScheduleContents</span>(<span class="params">ViewSchedule viewSchedule</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Collect types displayed in the schedule</span></span><br><span class="line">    FilteredElementCollector typeCollector = <span class="keyword">new</span> FilteredElementCollector(viewSchedule.Document, viewSchedule.Id);</span><br><span class="line">    typeCollector.WhereElementIsElementType();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> numberOfTypes = typeCollector.Count();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Collect instances displayed in the schedule</span></span><br><span class="line">    FilteredElementCollector instCollector = <span class="keyword">new</span> FilteredElementCollector(viewSchedule.Document, viewSchedule.Id);</span><br><span class="line">    instCollector.WhereElementIsNotElementType();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> numberOfInstances = instCollector.Count();</span><br><span class="line"></span><br><span class="line">    TaskDialog.Show(<span class="string">&quot;Elements in schedule&quot;</span>, String.Format(<span class="string">&quot;Types &#123;0&#125; instances &#123;1&#125;&quot;</span>, numberOfTypes, numberOfInstances));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>若要使用明细表中的实际数据，ViewSchedule.GetTableData（）返回一个TableData对象，该对象包含描述表中行、列和单元格的样式和内容的大部分数据。更多信息可以在TableView中找到。</p>
<h4 id="配电盘明细表"><a href="#配电盘明细表" class="headerlink" title="配电盘明细表"></a>配电盘明细表</h4><p>PanelScheduleView表示配电盘明细表，其中显示有关配电盘、连接到配电盘的线路及其相应负荷的信息。</p>
<p>可以创建一个明细表，其中列出连接到配电盘的线路，并显示有关每个线路的信息，例如配电盘上的位置、线路名称和视在负荷。配电盘明细表显示四个主要信息部分：页眉、线路表、负荷汇总和页脚。选定配电盘的新配电盘明细表视图将显示在绘图区域中，并且配电盘明细表将添加到项目浏览器的“配电盘明细表”文件夹下。配电盘明细表显示以下数据：</p>
<ul>
<li>面板名称</li>
<li>配电盘支持的配电系统</li>
<li>面板上可用的相数</li>
<li>为分配给此配电盘的配电系统指定的导线数</li>
<li>配电盘供电电源的额定值</li>
<li>安装类型（表面或嵌入式）</li>
<li>嵌板外壳类型</li>
<li>安装面板的房间</li>
<li>分配给负载电路的名称</li>
<li>断路器的额定跳闸电流</li>
<li>断路器上的极数</li>
<li>电路号</li>
<li>Phases 阶段</li>
<li>各相视在负荷（VA）</li>
<li>所有三相的总视在负荷</li>
<li>制造商</li>
<li>对面板进行的任何更改的注释</li>
<li>均方根安培数要显示的其他回路和配电盘信息可以在配电盘明细表样板中指定，在Revit API中由PanelScheduleTemplate类表示。</li>
</ul>
<p>PanelScheduleView和ViewSchedule一样，都是从TableView类派生的。明细表和配电盘明细表之间的一些常用功能可以在“明细表类”主题中找到。</p>
<h6 id="配电盘明细表创建"><a href="#配电盘明细表创建" class="headerlink" title="配电盘明细表创建"></a>配电盘明细表创建</h6><p>有两种用于创建PanelScheduleView的静态重载。PanelScheduleView. rnInstanceView（）的一个重载只需要在其中创建配电盘明细表的文档以及与明细表关联的电气配电盘元素的ID。此方法使用默认配电盘明细表样板创建新视图。另一个重载接受要使用的特定PanelScheduleTemplate的ID。</p>
<p>以下示例使用默认样板从用户选择的配电盘创建新配电盘明细表，并将活动视图切换到新配电盘明细表视图。</p>
<p>代码区域：创建配电盘明细表</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Create a new panel schedule and switch to that view</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">CreatePanelSchedule</span>(<span class="params">UIDocument uiDocument</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Document doc = uiDocument.Document;</span><br><span class="line"></span><br><span class="line">    Reference selected = uiDocument.Selection.PickObject(ObjectType.Element, <span class="string">&quot;Select an electrical panel&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Element panel = doc.GetElement(selected);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> != panel)</span><br><span class="line">    &#123;</span><br><span class="line">        PanelScheduleView psv = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">using</span> (Transaction trans = <span class="keyword">new</span> Transaction(doc, <span class="string">&quot;Create a new panel schedule&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            trans.Start();</span><br><span class="line">            psv = PanelScheduleView.CreateInstanceView(doc, panel.Id);</span><br><span class="line">            trans.Commit();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != psv)</span><br><span class="line">        &#123;</span><br><span class="line">            uiDocument.ActiveView = psv;    <span class="comment">// make new view the active view</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>, <span class="string">&quot;Please select one electrical panel.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="使用配电盘明细表"><a href="#使用配电盘明细表" class="headerlink" title="使用配电盘明细表"></a>使用配电盘明细表</h6><p>创建计划后，您可能需要对其进行修改。有几种方法有助于在计划中移动数据。若要移动数据，请使用PanelScheduleView.GetCellsBySlotNumber（）获取指定插槽号的单元格范围。PanelScheduleView.MoveSlotTo（）将源插槽中的回路移动到特定插槽。在移动回路之前，调用PanelScheduleView.CanMoveSlotTo（）以确保允许移动。</p>
<p>如果移动回路在一个组中，则该组中的所有回路都将相应地移动。IsSlotGrouped（）方法将检查插槽是否在组中。如果插槽不在组中，则此方法返回0。如果它在一个组中，则返回的值为组号（大于0的值）。</p>
<h2 id="修订"><a href="#修订" class="headerlink" title="修订"></a>修订</h2><p>Revit API提供了多个类和成员，用于访问项目修订、其设置和关联的云线批注。</p>
<h3 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h3><p>RevisionSettings类允许应用程序读取和修改影响修订和修订云线的项目范围设置。静态RevisionSettings.GetRevisionSettings（）方法返回给定项目文档的RevisionSettings对象。以下属性可用于访问项目范围的修订设置：</p>
<ul>
<li><p>RevisionCloudSpacing -确定项目中绘制的云线批注在图纸空间中的大小。</p>
</li>
<li><p>修订编号-确定项目的修订编号是按每张图纸还是按整个项目确定。AlphanumericRevisionSettings类包含应用于具有Alphanumeric RevisionNumberType的修订的设置。RevisionSettings方法GetAlphanumericRevisionSettings（）和SetAlphanumericRevisionSettings（）提供对AlphanumericRevisionSettings的读写访问。AlphanumericRevisionSettings提供以下成员：</p>
</li>
<li><p>前缀-前缀将被添加到每个版本号与字母数字类型。</p>
</li>
<li><p>后缀-要附加到每个版本号的字母数字类型的后缀。</p>
</li>
<li><p>GetSequence（）-获取字符串列表，这些字符串将用作字母数字类型的修订的编号序列。</p>
</li>
<li><p>SetSequence（）-设置此类型的修订编号的字符串列表。同样，NumericRevisionSettings类包含应用于具有Numeric</p>
</li>
</ul>
<p>RevisionNumberType的修订的设置。RevisionSettings方法GetNumericRevisionSettings（）和SetNumericRevisionSettings（）提供对这些设置的读写访问。NumericRevisionSettings提供以下成员：</p>
<ul>
<li>Prefix -每个版本号前面的数字类型前缀。</li>
<li>Suffix -要附加到每个版本号的数字类型的后缀。</li>
<li>StartNumber Property-用作数字修订序列中第一个数字的值。</li>
</ul>
<p>当修订云线显示在图纸上时，可以通过标记修订云线或通过图纸标题栏中的修订明细表来显示每个修订的修订编号。有两种方法可以确定数量：</p>
<p><strong>每个项目</strong>：版本号的值将始终对应于分配给该版本的项目范围的版本序号。例如，如果将序号为5、7和8的修订的云线批注放置在图纸上，则该图纸上的修订标记和明细表将显示5、7和8。</p>
<p><strong>每张图纸</strong>：将根据图纸上可见的修订云线为修订编号分配连续编号。例如，如果将指定了项目范围修订序号5、7和8的修订的云线批注放置在图纸上，则该图纸上的修订标记和明细表将显示1、2和3。图纸上的序列仍将遵循修订序列号的相对顺序，因此在本例中，修订5将在图纸上显示为1，修订7将显示为2，依此类推。</p>
<p>Revision类允许应用程序读取和修改项目中的现有修订以及创建新修订。Revision对象表示与项目中的单个修订相关的数据。它具有IssuedBy、IssuedTo、RevisionNumber、SequenceNumber和RevisionDate等属性。云线批注和标记可以与特定Revision对象关联，以在图纸上显示其特性。</p>
<p>项目中的修订以称为修订顺序的特定顺序存储。修订顺序表示将发布修订的概念顺序。静态方法Revision.GetAllRevisionIds（）将按此顺序返回所有Revision的ID。静态方法Revision.ReorderRevisionSequence（）可用于更改项目的修订顺序。请注意，新指定的序列必须只包含项目中的每个修订一次，并且更改修订的序列可能会更改已发布的修订的SequenceNumber和RevisionNumber。</p>
<p>静态Create（）方法将在指定的文档中创建一个新的Revision。在下面的示例中，添加了多个修订并设置了它们的属性。</p>
<p>代码区域：创建新修订</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> IList <span class="title">AddRevisions</span>(<span class="params">Document document</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    IList newRevisions = <span class="keyword">new</span> List();</span><br><span class="line">    <span class="keyword">using</span> (Transaction createRevision = <span class="keyword">new</span> Transaction(document, <span class="string">&quot;createRevision&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        createRevision.Start();</span><br><span class="line">        newRevisions.Add(AddNewRevision(document, <span class="string">&quot;Include door tags&quot;</span>, <span class="string">&quot;manager1&quot;</span>, <span class="string">&quot;employee1&quot;</span>, <span class="number">1</span>, DateTime.Now));</span><br><span class="line">        newRevisions.Add(AddNewRevision(document, <span class="string">&quot;Add a section view&quot;</span>, <span class="string">&quot;manager1&quot;</span>, <span class="string">&quot;employee1&quot;</span>, <span class="number">2</span>, DateTime.Now));</span><br><span class="line">        newRevisions.Add(AddNewRevision(document, <span class="string">&quot;Make callout view larger&quot;</span>, <span class="string">&quot;manager1&quot;</span>, <span class="string">&quot;employee1&quot;</span>, <span class="number">3</span>, DateTime.Now));</span><br><span class="line">        createRevision.Commit();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> newRevisions;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Revision <span class="title">AddNewRevision</span>(<span class="params">Document document, <span class="built_in">string</span> description, <span class="built_in">string</span> issuedBy, <span class="built_in">string</span> issuedTo, <span class="built_in">int</span> sequenceNumber, DateTime date</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Revision newRevision = Revision.Create(document);</span><br><span class="line">    newRevision.Description = description;</span><br><span class="line">    newRevision.IssuedBy = issuedBy;</span><br><span class="line">    newRevision.IssuedTo = issuedTo;</span><br><span class="line">    newRevision.NumberType = RevisionNumberType.Alphanumeric;</span><br><span class="line">    newRevision.RevisionDate = date.ToShortDateString();</span><br><span class="line">    <span class="keyword">return</span> newRevision;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CombineWithNext（）和CombineWithPrevious（）这两个方法允许应用程序将指定的Revision与模型中的下一个或上一个Revision合并。合并修订意味着与指定修订相关联的修订云和修订标签将与下一个修订重新关联，并且指定修订将从模型中删除。此方法返回重新关联的RevisionClouds的ID。但是，这些操作只能在两个修订版本都未发布的情况下实施。 下面的示例演示CombineWithNext（）方法的用法。它还使用GetAllRevisionIds（）方法查找下一个修订，以确保CombineWithNext（）方法成功。</p>
<p>代码区域：合并修订</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="built_in">bool</span> <span class="title">CombineRevision</span>(<span class="params">Document document, Revision revision</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">bool</span> combined = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// Can only combine two revisions if neither have been issued</span></span><br><span class="line">    <span class="keyword">if</span> (revision.Issued == <span class="literal">false</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ElementId revisionId = revision.Id;</span><br><span class="line">        Revision nextRevsion = GetNextRevision(document, revisionId);</span><br><span class="line">        <span class="keyword">if</span> (nextRevsion != <span class="literal">null</span> &amp;&amp; nextRevsion.Issued == <span class="literal">false</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ISet revisionCloudIds = Revision.CombineWithNext(document, revisionId);</span><br><span class="line">            combined = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">int</span> movedClouds = revisionCloudIds.Count;</span><br><span class="line">            <span class="keyword">if</span> (movedClouds &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                RevisionCloud cloud = document.GetElement(revisionCloudIds.ElementAt(<span class="number">0</span>)) <span class="keyword">as</span> RevisionCloud;</span><br><span class="line">                <span class="keyword">if</span> (cloud != <span class="literal">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">string</span> msg = <span class="built_in">string</span>.Format(<span class="string">&quot;Revision &#123;0&#125; deleted and &#123;1&#125; revision clouds were added to Revsion &#123;2&#125;&quot;</span>,</span><br><span class="line">                        revisionId.ToString(), movedClouds, cloud.RevisionId.ToString());</span><br><span class="line">                    TaskDialog.Show(<span class="string">&quot;Revision Combined&quot;</span>, msg);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> combined;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Revision <span class="title">GetNextRevision</span>(<span class="params">Document document, ElementId currentRevisionId</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Revision nextRevision = <span class="literal">null</span>;</span><br><span class="line">    IList revisionIds = Revision.GetAllRevisionIds(document);</span><br><span class="line">    <span class="built_in">int</span> currentRevisionIndex = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> n = <span class="number">0</span>; n &lt; revisionIds.Count; n++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (revisionIds[n] == currentRevisionId)</span><br><span class="line">        &#123;</span><br><span class="line">            currentRevisionIndex = n;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if the current revision id was found and is not the last index</span></span><br><span class="line">    <span class="keyword">if</span> (currentRevisionIndex &gt;= <span class="number">0</span> &amp;&amp; currentRevisionIndex &lt; revisionIds.Count - <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ElementId nextRevisionId = revisionIds[currentRevisionIndex + <span class="number">1</span>];</span><br><span class="line">        nextRevision = document.GetElement(nextRevisionId) <span class="keyword">as</span> Revision;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> nextRevision;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="修订云线"><a href="#修订云线" class="headerlink" title="修订云线"></a>修订云线</h3><p>RevisionCloud是一种图形化的“云”，可以显示在视图或图纸上，以指示模型中发生修订的位置。RevisionCloud类允许应用程序访问有关模型中存在的云线批注的信息，并创建新的云线批注。</p>
<p>RevisionCloud是特定于视图的，可以在大多数图形视图中创建，但3D视图除外。</p>
<p>另请注意，当在ViewLegend中创建RevisionCloud时，它会被视为RevisionCloud外观的图例表示，而不是模型更改的实际指示。因此，ViewLegends中的RevisionClouds不会影响修订明细表的内容。</p>
<h3 id="创建云线批注"><a href="#创建云线批注" class="headerlink" title="创建云线批注"></a>创建云线批注</h3><p>静态Create（）方法允许应用程序基于一系列直线和曲线在指定视图中创建新的RevisionCloud。只有在关联的Revision尚未发布时，才能创建RevisionClouds。</p>
<p>可以在大多数图形视图中创建RevisionClouds，但三维视图和图形柱明细表除外。与大多数其他元素不同，RevisionClouds可以直接在ViewSheet上创建。</p>
<p>RevisionCloud基于一系列草图曲线创建。不要求曲线形成闭合回路，也允许自相交。曲线将自动投影到视图的适当平面上。曲线列表不能为空，并且没有直线可以垂直于视图平面。如果视图是模型视图，则将在模型空间中解释为曲线指定的坐标。如果视图是非模型视图（例如ViewSheet），则坐标将在视图的空间中解释。</p>
<p>每条曲线都将有一系列的“云凸点”沿着它绘制沿着，形成云的外观。云图形将附加到假设每条曲线都是顺时针方向的曲线上。对于线，这意味着云的外部在视图平面内的线的法向量的方向上。因此，任何闭合的环都应该顺时针定向，以创建典型的云形状。</p>
<p>代码区域：创建修订云线</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">CreateRevisionCloudInActiveView</span>(<span class="params">Document document, Revision revision, IList curves</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> (Transaction newRevisionCloud = <span class="keyword">new</span> Transaction(document, <span class="string">&quot;Create Revision Cloud&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        newRevisionCloud.Start();</span><br><span class="line">        <span class="comment">// Can only create revision cloud for revision that is not issued</span></span><br><span class="line">        <span class="keyword">if</span> (revision.Issued == <span class="literal">false</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            RevisionCloud.Create(document, document.ActiveView, revision.Id, curves);</span><br><span class="line">            newRevisionCloud.Commit();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            newRevisionCloud.RollBack();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="修订云线几何图形"><a href="#修订云线几何图形" class="headerlink" title="修订云线几何图形"></a>修订云线几何图形</h3><p>RevisionCloud派生自Element类。云线批注的Element.Geometry属性将返回组成云线的实际曲线。另一方面，RevisionCloud.GetSketchCurves（）方法将返回定义云的基本轮廓的草图曲线，而不是Revit附着到这些曲线以创建云外观的弧。</p>
<h3 id="与RevisionCloud关联的修订版本"><a href="#与RevisionCloud关联的修订版本" class="headerlink" title="与RevisionCloud关联的修订版本"></a>与RevisionCloud关联的修订版本</h3><p>每个RevisionCloud与一个Revision相关联。关联的修订ID在调用Create（）时指定，可以从RevisionCloud.RevisionId属性中检索。如果RevisionCloud的RevisionId属性未与已发布的修订版本关联，则可以更改该属性。它只能更改为另一个尚未发布的修订版本的ID。IsRevisionIssued（）返回关联的Revision是否已发布。</p>
<h3 id="图纸-1"><a href="#图纸-1" class="headerlink" title="图纸"></a>图纸</h3><p>当RevisionCloud在ViewSheet上可见时（因为它直接放置在ViewSheet上，或者因为它在ViewSheet上放置的视图中可见），ViewSheet上显示的任何修订明细表将自动包括与RevisionCloud关联的修订。</p>
<p>RevisionCloud.GetSheetIds（）方法返回ViewSheets的ID，ViewSheets可能会出现在该ID中，并参与到图纸的修订明细表中。RevisionCloud可以出现在ViewSheet上，因为它是直接在ViewSheet上绘制的，或者因为它的所有者视图放置在ViewSheet上。如果RevisionCloud属于从属视图或具有关联从属视图的视图，则RevisionCloud也可以在放置相关从属视图或主视图的图纸上可见。</p>
<p>此RevisionCloud可能在此方法报告的所有ViewSheets中不可见。其他因素（例如视图的可见性设置或注释裁剪或关联修订的可见性设置）仍可能导致此RevisionCloud不显示在特定ViewSheet上。</p>
<p>如果此RevisionCloud归ViewLegend所有，则不会返回图纸，因为RevisionCloud不会参与修订明细表。ViewSheet类包括用于在图纸上使用Revisionsand RevisionClouds的方法。有关详细信息，请参见ViewSheet主题。</p>
<h2 id="视图过滤器"><a href="#视图过滤器" class="headerlink" title="视图过滤器"></a>视图过滤器</h2><p>过滤器是独立于视图的元素。它们可以使用ParameterFilterElement类或SelectionFilterElement类应用于视图。</p>
<h3 id="ParameterFilterElement"><a href="#ParameterFilterElement" class="headerlink" title="ParameterFilterElement"></a>ParameterFilterElement</h3><p>参数过滤元素根据其类别和一系列过滤规则过滤元素。可以指定一个或多个类别作为筛选器的允许类别。</p>
<p>定义过滤器（具有一个或多个类别和一个或多个过滤器规则）后，可以使用多种方法之一将其应用于视图。AddFilter（）方法将过滤器应用于视图，但使用默认覆盖，这意味着视图的显示不会更改。View.SetFilterOverrides（）将设置与过滤器关联的图形覆盖。而View.SetFilterVisibility（）将设置通过过滤器的元素在视图中是否可见。AddFilter（）和SetFilterVisibility（）都将过滤器应用到视图（如果它还没有应用），因此没有必要单独调用AddFilter（）。</p>
<p>下面的示例创建一个匹配多个条件的新视图筛选器，然后在视图中隐藏这些元素。</p>
<p>代码区域：将参数过滤器应用于视图</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CreateViewFilter</span>(<span class="params">Document doc, View view</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    List categories = <span class="keyword">new</span> List();</span><br><span class="line">    categories.Add(<span class="keyword">new</span> ElementId(BuiltInCategory.OST_Walls));</span><br><span class="line">    List filterRules = <span class="keyword">new</span> List();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> (Transaction t = <span class="keyword">new</span> Transaction(doc, <span class="string">&quot;Add view filter&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        t.Start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create filter element associated to the input categories</span></span><br><span class="line">        ParameterFilterElement parameterFilterElement = ParameterFilterElement.Create(doc, <span class="string">&quot;Example view filter&quot;</span>, categories);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Criterion 1 - wall type Function is &quot;Exterior&quot;</span></span><br><span class="line">        ElementId exteriorParamId = <span class="keyword">new</span> ElementId(BuiltInParameter.FUNCTION_PARAM);</span><br><span class="line">        filterRules.Add(ParameterFilterRuleFactory.CreateEqualsRule(exteriorParamId, (<span class="built_in">int</span>)WallFunction.Exterior));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Criterion 2 - wall height &gt; some number</span></span><br><span class="line">        ElementId lengthId = <span class="keyword">new</span> ElementId(BuiltInParameter.CURVE_ELEM_LENGTH);</span><br><span class="line">        filterRules.Add(ParameterFilterRuleFactory.CreateGreaterOrEqualRule(lengthId, <span class="number">28.0</span>, <span class="number">0.0001</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Criterion 3 - custom shared parameter value matches string pattern</span></span><br><span class="line">        <span class="comment">// Get the id for the shared parameter - the ElementId is not hardcoded, so we need to get an instance of this type to find it</span></span><br><span class="line">        Guid spGuid = <span class="keyword">new</span> Guid(<span class="string">&quot;96b00b61-7f5a-4f36-a828-5cd07890a02a&quot;</span>);</span><br><span class="line">        FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(doc);</span><br><span class="line">        collector.OfClass(<span class="keyword">typeof</span>(Wall));</span><br><span class="line">        Wall wall = collector.FirstElement() <span class="keyword">as</span> Wall;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (wall != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Parameter sharedParam = wall.get_Parameter(spGuid);</span><br><span class="line">            ElementId sharedParamId = sharedParam.Id;</span><br><span class="line"></span><br><span class="line">            filterRules.Add(ParameterFilterRuleFactory.CreateBeginsWithRule(sharedParamId, <span class="string">&quot;15.&quot;</span>, <span class="literal">true</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        parameterFilterElement.SetRules(filterRules);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Apply filter to view</span></span><br><span class="line">        view.AddFilter(parameterFilterElement.Id);</span><br><span class="line">        view.SetFilterVisibility(parameterFilterElement.Id, <span class="literal">false</span>);</span><br><span class="line">        t.Commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="SelectionFilterElement"><a href="#SelectionFilterElement" class="headerlink" title="SelectionFilterElement"></a>SelectionFilterElement</h3><p>SelectionFilterElement是一种特殊的视图筛选器，它不基于规则，而是基于一组可能不相关的元素。可以根据需要将特定元素添加到过滤器中，并且可以像ParameterFilterElement一样覆盖所产生的选择。</p>
<p>下面的示例创建一个新的选择筛选器并对其应用重写。</p>
<p>代码区域：将选择筛选器应用于视图</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CreateSelectionFilter</span>(<span class="params">Document doc, View view</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// find room tags in this view</span></span><br><span class="line">    FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(doc, view.Id);</span><br><span class="line">    collector.WherePasses(<span class="keyword">new</span> RoomTagFilter());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// collect tags whose room number matches criteria</span></span><br><span class="line">    List tagIds = <span class="keyword">new</span> List();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">foreach</span> (RoomTag tag <span class="keyword">in</span> collector.Cast())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> number = Int32.Parse(tag.Room.Number);</span><br><span class="line">        <span class="keyword">if</span> (number % <span class="number">3</span> == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            tagIds.Add(tag.Id);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> (Transaction t = <span class="keyword">new</span> Transaction(doc, <span class="string">&quot;Create SelectionFilterElement&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        t.Start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create selection filter and assign ids</span></span><br><span class="line">        SelectionFilterElement filterElement = SelectionFilterElement.Create(doc, <span class="string">&quot;Room tags filter&quot;</span>);</span><br><span class="line">        filterElement.SetElementIds(tagIds);</span><br><span class="line"></span><br><span class="line">        ElementId filterId = filterElement.Id;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Add the filter to the view</span></span><br><span class="line">        view.AddFilter(filterId);</span><br><span class="line"></span><br><span class="line">        doc.Regenerate();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Use the existing graphics settings, and change the color to Blue</span></span><br><span class="line">        OverrideGraphicSettings overrideSettings = view.GetFilterOverrides(filterId);</span><br><span class="line"></span><br><span class="line">        overrideSettings.SetProjectionLineColor(<span class="keyword">new</span> Color(<span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xFF</span>));</span><br><span class="line"></span><br><span class="line">        view.SetFilterOverrides(filterId, overrideSettings);</span><br><span class="line"></span><br><span class="line">        t.Commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Modifying filters</p>
<p>应用于视图的所有过滤器都可以使用View.GetFilters（）方法检索，该方法将返回过滤器ID列表。可以分别使用View.GetFilterVisibility（）和View.GetFilterOverrides（）方法检查特定筛选器的筛选器可见性和图形覆盖。RemoveFilter将从视图中删除筛选器。</p>
<p>下面的示例演示如何获取视图中的过滤器，然后修改与当前将剪切颜色设置为红色的任何过滤器关联的覆盖。</p>
<p>代码区域：修改现有筛选器</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ModifyExistingFilter</span>(<span class="params">Document doc, View view</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Find any filter with overrides setting cut color to Red</span></span><br><span class="line">    Dictionary&lt;ElementId, OverrideGraphicSettings&gt; filterIdsToChange = <span class="keyword">new</span> Dictionary&lt;ElementId, OverrideGraphicSettings&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">foreach</span> (ElementId filterId <span class="keyword">in</span> view.GetFilters())</span><br><span class="line">    &#123;</span><br><span class="line">        OverrideGraphicSettings overrideSettings = view.GetFilterOverrides(filterId);</span><br><span class="line"></span><br><span class="line">        Color lineColor = overrideSettings.CutLineColor;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (lineColor == Color.InvalidColorValue)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Save overrides setting the cut color to green</span></span><br><span class="line">        <span class="keyword">if</span> (lineColor.Red == <span class="number">0xFF</span> &amp;&amp; lineColor.Green == <span class="number">0x00</span> &amp;&amp; lineColor.Blue == <span class="number">0x00</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            overrideSettings.SetCutLineColor(<span class="keyword">new</span> Color(<span class="number">0x00</span>, <span class="number">0xFF</span>, <span class="number">0x00</span>));</span><br><span class="line">            filterIdsToChange[filterId] = overrideSettings;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make the change to all found filters</span></span><br><span class="line">    <span class="keyword">using</span> (Transaction t = <span class="keyword">new</span> Transaction(doc, <span class="string">&quot;Change override filters&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        t.Start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">foreach</span> (ElementId filterId <span class="keyword">in</span> filterIdsToChange.Keys)</span><br><span class="line">        &#123;</span><br><span class="line">            view.SetFilterOverrides(filterId, filterIdsToChange[filterId]);</span><br><span class="line">        &#125;</span><br><span class="line">        t.Commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="视图裁剪"><a href="#视图裁剪" class="headerlink" title="视图裁剪"></a>视图裁剪</h2><p>可以使用Revit API修改某些视图的裁剪区域。ViewCropRegionShapeManager.CanHaveShape属性指示是否允许视图管理裁剪区域形状，而ShapeSet属性指示是否已设置形状。下面的示例裁剪房间边界周围的视图。</p>
<p>代码区域：裁剪视图</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">CropAroundRoom</span>(<span class="params">Room room, View view</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (view != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        IList&lt;IList&lt;Autodesk.Revit.DB.BoundarySegment&gt;&gt; segments = room.GetBoundarySegments(<span class="keyword">new</span> SpatialElementBoundaryOptions());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != segments)  <span class="comment">//the room may not be bound</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">foreach</span> (IList&lt;Autodesk.Revit.DB.BoundarySegment&gt; segmentList <span class="keyword">in</span> segments)</span><br><span class="line">            &#123;</span><br><span class="line">                CurveLoop loop = <span class="keyword">new</span> CurveLoop();</span><br><span class="line">                <span class="keyword">foreach</span> (Autodesk.Revit.DB.BoundarySegment boundarySegment <span class="keyword">in</span> segmentList)</span><br><span class="line">                &#123;</span><br><span class="line">                    loop.Append(boundarySegment.GetCurve());</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                ViewCropRegionShapeManager vcrShapeMgr = view.GetCropRegionShapeManager();</span><br><span class="line">                vcrShapeMgr.SetCropShape(loop);</span><br><span class="line">                <span class="keyword">break</span>;  <span class="comment">// if more than one set of boundary segments for room, crop around the first one</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="置换视图"><a href="#置换视图" class="headerlink" title="置换视图"></a>置换视图</h2><p>使用DisplacementElement类创建置换视图。DisplacementElement是视图专有的元素，可用于使元素显示为从其实际位置偏移。置换视图对于说明模型元素与整个模型的关系非常有用。DisplacementElement实际上不会更改任何模型元素的位置;它只是使它们显示在不同的位置。</p>
<p>有关创建置换视图的详细示例，请参见Revit SDK中的DisplacementElementAnimation示例。</p>
<h3 id="创建置换视图"><a href="#创建置换视图" class="headerlink" title="创建置换视图"></a>创建置换视图</h3><p>静态DisplacementElement.Create（）方法创建一个新的DisplacementElement。如果parentDisplacementElement参数不为空，则新DisplacementElement可以是父DisplacementElement的子元素。如果指定了父代，则子DisplacementElement的转换将与父代的转换连接在一起，并且其关联元素的位移将相对于父代DisplacementElement。</p>
<p>Create（）方法还需要一个文档、一个要置换的元素列表、所有者视图以及要应用于置换元素图形的转换。在任何视图中，一个元素只能被单个DisplacementElement置换。将一个元素替换为多个DisplacementElement将导致异常。</p>
<p>可以在调用Create（）之前使用DisplaceementElement的其他静态方法来帮助防止任何异常。CanCategoryBeDisplaced（）测试属于特定类别的元素是否可以被置换，而重载的静态方法CanElementsBeDisplaced（）指示特定元素是否可以被分配给新的DisplacementElement。IsAllowedAsDisplacedElement（）测试单个元素是否有资格被置换。</p>
<p>静态GetAdditionalElementsToDisplace（）方法将返回任何其他元素，这些元素应与指定视图中的指定元素一起沿着移位。例如，当墙被置换时，所有插入对象或主体图元也应该被置换。</p>
<p>创建子DisplacementElement时，静态IsValidAsParentInView（）可用于验证特定DisplacementElement是否可用作特定View中的父代。</p>
<p>DisplacementElement的其他静态方法可用于查找包含特定元素的DisplacementElement，以获取View中所有移位元素的列表，或获取指定View所拥有的所有DisplacementElements。</p>
<h3 id="使用置换图元"><a href="#使用置换图元" class="headerlink" title="使用置换图元"></a>使用置换图元</h3><p>一旦创建了新的DisplacementElement，就可以使用方法来获取任何子DisplacementElements，以获取受DisplacementElement影响的所有元素的id，或者获取受DisplacementElement影响的所有元素以及任何子DisplacementElements的id。ParentId属性将返回父DisplacementElement的元素ID（如果存在）。</p>
<p>创建后，可以使用SetDisplacedElementIds（）或RemoveDisplacedElement（）修改受DisplacementElement影响的元素集。另外，相对位移可以改变。</p>
<p>方法ResetDisplacedElements（）将DisplacementElement的平移设置为（0，0，0）。DisplacementElement继续存在，但其元素显示在其实际位置。</p>
<h3 id="创建位移路径"><a href="#创建位移路径" class="headerlink" title="创建位移路径"></a>创建位移路径</h3><p>DisplacementPath是与DisplacementElement相关的视图特定注释。DisplacementPath类创建一个注释，该注释描述元素从其实际位置到其位移位置的移动。通过对DisplacementElement的已移位元素的边缘上的点的引用，将DisplacementPath锚定到DisplacementElement。它由一条直线或一系列折弯线表示，这些直线起源于位移元素上的指定点。</p>
<p>静态DisplacementPath.Create（）方法需要一个文档、关联DisplacementElement的ID、一个引用被DisplacementElement置换的元素之一的边或曲线的引用，以及一个在[0，1]范围内的值，该值是沿指定边的沿着参数。创建后，可以使用PathStyle属性设置DisplacementPath的路径样式。也可以使用SetAnchorPoint（）更改锚点。</p>
<p>下面的示例通过垂直和水平移动找到的第一面墙来创建新的位移，然后为其添加位移路径。</p>
<p>代码区域：创建位移和路径</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CreateDisplacementAndPath</span>(<span class="params">Document doc, View view</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Find roof</span></span><br><span class="line">    FilteredElementCollector fec = <span class="keyword">new</span> FilteredElementCollector(doc);</span><br><span class="line">    fec.OfClass(<span class="keyword">typeof</span>(RoofBase));</span><br><span class="line">    RoofBase roof = fec.FirstElement() <span class="keyword">as</span> RoofBase;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get a geometric reference for the path</span></span><br><span class="line">    Reference edgeRef = GetHorizontalEdgeReference(roof);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> (Transaction t = <span class="keyword">new</span> Transaction(doc, <span class="string">&quot;CreateDisplacementAndPath&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        t.Start();</span><br><span class="line">        <span class="comment">// Create a new top level DisplacementElement</span></span><br><span class="line">        DisplacementElement dispElem = DisplacementElement.Create(doc, <span class="keyword">new</span> ElementId[] &#123; roof.Id &#125;, <span class="keyword">new</span> XYZ(<span class="number">10</span>, <span class="number">0</span>, <span class="number">20</span>), view, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create the path associated to the element</span></span><br><span class="line">        DisplacementPath.Create(doc, dispElem, edgeRef, <span class="number">0.5</span>);</span><br><span class="line">        t.Commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Reference <span class="title">GetHorizontalEdgeReference</span>(<span class="params">Element elem</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//Find target edge from lower face of roof</span></span><br><span class="line">    Options options = <span class="keyword">new</span> Options();</span><br><span class="line">    options.ComputeReferences = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    GeometryElement geomElem = elem.get_Geometry(options);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> geomObj <span class="keyword">in</span> geomElem)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (geomObj <span class="keyword">is</span> Solid)</span><br><span class="line">        &#123;</span><br><span class="line">            Solid solid = geomObj <span class="keyword">as</span> Solid;</span><br><span class="line">            <span class="keyword">var</span> faces = solid.Faces;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">foreach</span> (Face face <span class="keyword">in</span> faces)</span><br><span class="line">            &#123;</span><br><span class="line">                BoundingBoxUV box = face.GetBoundingBox();</span><br><span class="line">                UV midpoint = (box.Min + box.Max) / <span class="number">2.0</span>;</span><br><span class="line">                <span class="keyword">if</span> (face.ComputeNormal(midpoint).Normalize().Z &lt; <span class="number">-0.1</span>) <span class="comment">// Downward facing, this is good enough</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">var</span> edgeLoops = face.EdgeLoops;</span><br><span class="line">                    <span class="keyword">foreach</span> (EdgeArray edgeArray <span class="keyword">in</span> edgeLoops)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">foreach</span> (Edge edge <span class="keyword">in</span> edgeArray)</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="comment">// horizontal?</span></span><br><span class="line">                            <span class="keyword">if</span> (Math.Abs(edge.AsCurve().ComputeDerivatives(<span class="number">0.0</span>, <span class="literal">true</span>).BasisX.DotProduct(XYZ.BasisZ)) - <span class="number">1</span> &lt;= <span class="number">0.00001</span>)</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="keyword">return</span> edge.Reference;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相关联的DisplacementElement可以具有父DisplacementElement，并且该父DisplacementElement可以具有其自己的父DisplacementElement，从而产生一系列祖先。终点可以是点的原始（未移位）位置，或者是与这些祖先DisplacementElements相对应的任何中间移位位置上的对应点。位移路径。PistorIdx属性指定路径的终点。</p>
<h2 id="UIView"><a href="#UIView" class="headerlink" title="UIView"></a>UIView</h2><p>View类是Revit中所有视图类型的基类，并跟踪视图中的图元，而UIView类则包含有关Revit用户界面中视图窗口的数据。可以使用GetOpenUIViews（）方法从UID目录中检索所有打开视图的列表。UIView类具有获取有关视图绘图区域的信息以及平移和缩放活动视图的方法。</p>
<p>GetWindowRectangle（）返回一个描述UIView窗口大小和位置的矩形。它不包括窗口边框或标题栏。</p>
<h3 id="缩放操作"><a href="#缩放操作" class="headerlink" title="缩放操作"></a>缩放操作</h3><p>UIView有几种与缩放活动视图相关的方法。UIView.GetZoomCorners（）获取模型坐标中视图矩形的角点，UIView.ZoomAndCenterRectangle（）提供缩放和平移活动视图的能力，使其以模型的输入区域为中心。</p>
<p>ZoomToFit（）和ZoomSheetSize（）方法提供了调整窗口缩放的快速方法，而Zoom（）方法可用于按指定因子放大或缩小。</p>
<h3 id="关闭视图"><a href="#关闭视图" class="headerlink" title="关闭视图"></a>关闭视图</h3><p>UIView.Close（）可以关闭可见窗口。但是，它不能用于关闭最后一个活动窗口。尝试关闭最后一个活动窗口将引发异常。</p>
<h2 id="注：翻译自Revit-API-Developers-Guide"><a href="#注：翻译自Revit-API-Developers-Guide" class="headerlink" title="注：翻译自Revit API Developers Guide"></a><em><strong>注：</strong></em>翻译自<a href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_html">Revit API Developers Guide</a></h2>]]></content>
      <categories>
        <category>Revit二次开发人员指南</category>
      </categories>
      <tags>
        <tag>Revit</tag>
      </tags>
  </entry>
  <entry>
    <title>09编辑元素</title>
    <url>/2024/12/05/%E4%BA%8C%E5%BC%80%E6%8C%87%E5%8D%97/09%E7%BC%96%E8%BE%91%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<h1 id="编辑元素"><a href="#编辑元素" class="headerlink" title="编辑元素"></a><a href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_Basic_Interaction_with_Revit_Elements_Editing_Elements_html">编辑元素</a></h1><p>在Revit中，可以使用Revit Platform API移动、复制、旋转、对齐、删除、镜像、编组和排列一个元素或一组元素。在API中使用编辑功能与在Revit UI中使用命令类似。</p>
<p>Pages in this section 本节中的页面</p>
<ul>
<li>Moving Elements 移动元素</li>
<li>Copying Elements 复制元素</li>
<li>Rotating elements 旋转元素</li>
<li>Aligning Elements 对齐元素</li>
<li>Mirroring Elements 镜像元素</li>
<li>Grouping Elements 对元素进行分组</li>
<li>Creating Arrays of Elements 创建元素数组</li>
<li>Deleting Elements 删除元素</li>
<li>Pinned Elements 固定元素</li>
</ul>
<h2 id="移动元素"><a href="#移动元素" class="headerlink" title="移动元素"></a>移动元素</h2><p>ElementTransformUtils类提供两个静态方法来将一个或多个元素从一个位置移动到另一个位置。</p>
<p>表19：移动方法</p>
<table>
<thead>
<tr>
<th><strong>Member</strong></th>
<th>**Description **</th>
</tr>
</thead>
<tbody><tr>
<td>MoveElement( Document, ElementId, XYZ)</td>
<td>将文档中的元素移动指定的向量。</td>
</tr>
<tr>
<td>MoveElements(Document, ICollection, XYZ)</td>
<td>将文档中的几个元素移动指定向量的一组ID。</td>
</tr>
</tbody></table>
<p>注意：当您使用MoveElement（）或MoveElements（）方法时，以下规则适用。这些方法不能将基于标高的图元从标高上移或下移。如果图元基于标高，则不能修改Z坐标值。但是，可以将图元放置在同一标高中的任何位置。同样，某些基于标高的图元具有偏移实例参数，可以使用该参数在Z方向上移动它们。例如，如果在标高1中的原始位置（0，0，0）创建新柱，然后将其移动到新位置（10，20，30），则柱将放置在位置（10，20，0）而不是（10，20，30）。</p>
<p>代码区域10-1：使用MoveElement（）</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">MoveColumn</span>(<span class="params">Autodesk.Revit.DB.Document document, FamilyInstance column</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">            <span class="comment">// get the column current location</span></span><br><span class="line">            LocationPoint columnLocation = column.Location <span class="keyword">as</span> LocationPoint;</span><br><span class="line"></span><br><span class="line">            XYZ oldPlace = columnLocation.Point;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Move the column to new location.</span></span><br><span class="line">            XYZ newPlace = <span class="keyword">new</span> XYZ(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>);</span><br><span class="line">            ElementTransformUtils.MoveElement(document, column.Id, newPlace);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// now get the column&#x27;s new location</span></span><br><span class="line">            columnLocation = column.Location <span class="keyword">as</span> LocationPoint;</span><br><span class="line">            XYZ newActual = columnLocation.Point;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">string</span> info = <span class="string">&quot;Original Z location: &quot;</span> + oldPlace.Z + </span><br><span class="line">                            <span class="string">&quot;\nNew Z location: &quot;</span> + newActual.Z;</span><br><span class="line"></span><br><span class="line">            TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>,info);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>移动一个或多个图元时，关联图元也会移动。例如，如果移动带窗的墙，则窗也会移动。 * 无法移动固定的图元。 在Revit中移动图元的另一种方法是使用位置及其衍生对象。在Revit Platform API中，Location对象提供了平移和旋转图元的功能。更多的位置信息和控制可以使用Location对象的派生，如LocationPoint或LocationCurve。如果Location元素向下转换为LocationCurve对象或LocationPoint对象，则直接将曲线或点移动到新位置。</p>
<p>代码区域10-2：使用位置移动</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">bool</span> <span class="title">MoveUsingLocationCurve</span>(<span class="params">Autodesk.Revit.ApplicationServices.Application application, Wall wall</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        LocationCurve wallLine = wall.Location <span class="keyword">as</span> LocationCurve;</span><br><span class="line">        XYZ translationVec = <span class="keyword">new</span> XYZ(<span class="number">10</span>, <span class="number">20</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> (wallLine.Move(translationVec));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-CA323378-0ABA-4B2B-B242-2D98C01F0A78-low.png"></p>
<p>图30：使用LocationCurve移动墙</p>
<p>此外，还可以使用LocationCurve Curve属性或LocationPoint Point属性在Revit中移动一个图元。 使用Curve特性将曲线驱动元素移动到任何指定位置。许多图元是曲线驱动的，例如墙、梁和支撑。还可以使用属性调整元素长度的大小。</p>
<p>代码区域10-3：使用曲线移动</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MoveUsingCurveParam</span>(<span class="params">Autodesk.Revit.ApplicationServices.Application application, Wall wall</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    LocationCurve wallLine = wall.Location <span class="keyword">as</span> LocationCurve;</span><br><span class="line">    XYZ p1 = XYZ.Zero;</span><br><span class="line">    XYZ p2 = <span class="keyword">new</span> XYZ(<span class="number">10</span>, <span class="number">20</span>, <span class="number">0</span>);</span><br><span class="line">    Line newWallLine = Line.CreateBound(p1, p2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Change the wall line to a new line.</span></span><br><span class="line">    wallLine.Curve = newWallLine;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还可以使用LocationCurve.JoinType属性获取或设置基于曲线的元素的联接属性。 使用LocationPoint Point属性设置元素的物理位置。</p>
<p>代码区域10-4：使用点移动</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LocationMove</span>(<span class="params">FamilyInstance column</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        LocationPoint columnPoint = column.Location <span class="keyword">as</span> LocationPoint;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != columnPoint)</span><br><span class="line">        &#123;</span><br><span class="line">                XYZ newLocation = <span class="keyword">new</span> XYZ(<span class="number">10</span>, <span class="number">20</span>, <span class="number">0</span>);</span><br><span class="line">                <span class="comment">// Move the column to the new location</span></span><br><span class="line">                columnPoint.Point = newLocation;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="复制元素"><a href="#复制元素" class="headerlink" title="复制元素"></a>复制元素</h2><p>ElementTransformUtils类提供了几个静态方法，用于将一个或多个元素从一个位置复制到另一个位置，可以在同一文档或视图中复制，也可以复制到不同的文档或视图中。</p>
<p>表：复制方法</p>
<table>
<thead>
<tr>
<th><strong>Member</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody><tr>
<td>CopyElement( Document, ElementId, XYZ)</td>
<td>复制元素并将副本放置在给定变换所指示的位置。</td>
</tr>
<tr>
<td>CopyElements(Document, ICollection, XYZ)</td>
<td>复制一组元素，并将副本放置在给定事务指示的位置。</td>
</tr>
<tr>
<td>CopyElements(Document, ICollection, Document, Transform, CopyPasteOptions)</td>
<td>将一组元素从源文档复制到目标文档。</td>
</tr>
<tr>
<td>CopyElements(View, ICollection, View, Transform, CopyPasteOptions)</td>
<td>将一组元素从源视图复制到目标视图。</td>
</tr>
</tbody></table>
<p>所有方法都返回新创建元素的ElementId集合，包括CopyElement（）。该集合包括由于依赖关系而创建的任何元素。</p>
<p>从一个文档复制到另一个文档的方法只能用于复制非视图特定的元素。副本被放置在其各自的原始位置或由可选转换指定的位置。</p>
<p>应使用从一个视图复制到另一个视图的方法来复制视图特定的图元。该方法可用于视图专有图元和模型图元，但绘图视图不能用作模型图元的目标。粘贴的图元将被重新定位，以确保在目标视图中正确放置。例如，从一个标高复制到另一个标高时，标高会发生更改。通过提供可选的Transform参数，可以在目标视图中执行其他转换。此附加变换必须在目标视图的平面内。</p>
<p>从一个视图复制到另一个视图时，源视图和目标视图都必须是能够绘制详图和视图专有图元（如楼板和天花板平面、立面、剖面或绘图视图）的二维图形视图。ElementTransformUtils.GetTransformFromViewToView（）方法将返回从源视图复制到目标视图时应用于元素的转换。</p>
<p>在视图之间或文档之间复制时，可以设置可选的CopyPasteOptions参数以覆盖默认的复制&#x2F;粘贴设置。默认情况下，如果在粘贴操作过程中出现重复的类型名称，Revit将显示一个模式对话框，其中包含仅复制具有唯一名称的类型或取消操作的选项。CopyPasteOptions可用于指定一个自定义处理程序，使用IDuplicateTypeException接口来处理重复的类型名称。</p>
<p>See the Duplicate Views sample in the Revit SDK for a detailed example of copying between documents and between views.<br>有关在文档之间和视图之间复制的详细示例，请参见Revit SDK中的“复制视图”示例。</p>
<h2 id="旋转元素"><a href="#旋转元素" class="headerlink" title="旋转元素"></a>旋转元素</h2><p>ElementTransformUtils类提供了两个静态方法来旋转项目中的一个或多个元素。</p>
<p>表20：旋转方法</p>
<table>
<thead>
<tr>
<th><strong>Member</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody><tr>
<td>RotateElement(Document, ElementId, Line, double)</td>
<td>将文档中的元素围绕给定轴旋转指定的弧度数。</td>
</tr>
<tr>
<td>RotateElements(Document, ICollection, Line, double)</td>
<td>按项目中的ID将多个图元围绕给定轴旋转指定的弧度数。</td>
</tr>
</tbody></table>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-2CDF32C7-BA19-499B-81BE-02A982E310D7-low.png"></p>
<p>图31：逆时针旋转 </p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-11A64EB3-0D9F-4A33-8DB7-CBA34CFBD04C-low.png"></p>
<p>图32：顺时针旋转 请注意，锁定的图元不能旋转。</p>
<p>代码区域10-5：使用RotateElement（）</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">RotateColumn</span>(<span class="params">Autodesk.Revit.DB.Document document, Autodesk.Revit.DB.Element element</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    XYZ point1 = <span class="keyword">new</span> XYZ(<span class="number">10</span>, <span class="number">20</span>, <span class="number">0</span>);</span><br><span class="line">    XYZ point2 = <span class="keyword">new</span> XYZ(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>);</span><br><span class="line">    <span class="comment">// The axis should be a bound line.</span></span><br><span class="line">    Line axis = Line.CreateBound(point1, point2);</span><br><span class="line">    ElementTransformUtils.RotateElement(document, element.Id, axis, Math.PI / <span class="number">3.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果元素Location可以向下转换为LocationCurve或LocationPoint，则可以直接旋转曲线或点。</p>
<p>代码区域10-6：基于位置曲线旋转</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">bool</span> <span class="title">LocationRotate</span>(<span class="params">Autodesk.Revit.ApplicationServices.Application application, Autodesk.Revit.DB.Element element</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">bool</span> rotated = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// Rotate the element via its location curve.</span></span><br><span class="line">    LocationCurve curve = element.Location <span class="keyword">as</span> LocationCurve;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> != curve)</span><br><span class="line">    &#123;</span><br><span class="line">        Curve line = curve.Curve;</span><br><span class="line">        XYZ aa = line.GetEndPoint(<span class="number">0</span>);</span><br><span class="line">        XYZ cc = <span class="keyword">new</span> XYZ(aa.X, aa.Y, aa.Z + <span class="number">10</span>);</span><br><span class="line">        Line axis = Line.CreateBound(aa, cc);</span><br><span class="line">        rotated = curve.Rotate(axis, Math.PI / <span class="number">2.0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rotated;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码区域10-7：基于位置点旋转</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">bool</span> <span class="title">LocationRotate</span>(<span class="params">Autodesk.Revit.ApplicationServices.Application application, Autodesk.Revit.Element element</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="built_in">bool</span> rotated = <span class="literal">false</span>;</span><br><span class="line">        LocationPoint location = element.Location <span class="keyword">as</span> LocationPoint;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != location)</span><br><span class="line">        &#123;</span><br><span class="line">                XYZ aa = location.Point;</span><br><span class="line">                XYZ cc = <span class="keyword">new</span> XYZ(aa.X, aa.Y, aa.Z + <span class="number">10</span>);</span><br><span class="line">                Line axis = Line.CreateBound(aa, cc);                </span><br><span class="line">            rotated = location.Rotate(axis, Math.PI / <span class="number">2.0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> rotated;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="对齐元素"><a href="#对齐元素" class="headerlink" title="对齐元素"></a>对齐元素</h2><p>ItemFactoryBase.NewAlignment（）方法可以在两个引用之间创建新的锁定对齐。这两个引用必须是以下组合之一：</p>
<ul>
<li>2个平面</li>
<li>2条线</li>
<li>线和点</li>
<li>直线和参考平面</li>
<li>2个弧</li>
<li>2个圆柱面</li>
</ul>
<p>这些参照必须已经几何对齐，因为此函数不会强制它们对齐。如果可以创建对齐，则返回一个表示锁定对齐的新Dimension对象。否则将抛出异常。</p>
<p>NewAlignment（）方法还需要一个视图来确定路线的方向。</p>
<p>请参见SDK Samples中包含的FamilyCreation文件夹中的“桁架”示例。其中有几个使用NewAlignment（）的示例，例如将新桁架的下弦杆锁定到底部参照平面。</p>
<h2 id="镜像元素"><a href="#镜像元素" class="headerlink" title="镜像元素"></a>镜像元素</h2><p>ElementTransformUtils类提供两个静态方法来镜像项目中的一个或多个元素。</p>
<p>表21：镜像方法</p>
<table>
<thead>
<tr>
<th><strong>Member 构件</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody><tr>
<td>MirrorElement(Document, ElementId, Plane)</td>
<td>关于几何平面镜像一个元素。</td>
</tr>
<tr>
<td>MirrorElements(Document, ICollection, Plane, Boolean)</td>
<td>关于几何平面镜像多个元素。可以在原始几何体或副本上执行。</td>
</tr>
</tbody></table>
<p>执行镜像操作后，可以从“选择元素集”（Selection ElementSet）访问新元素。</p>
<p>ElementTransformUtils. Canadian Element（）和ElementTransformUtils. Canadian Elements（）可用于在尝试镜像元素之前确定是否可以镜像一个或多个元素。</p>
<p>下面的代码演示如何使用根据墙的侧面计算的平面镜像墙。</p>
<p>代码区域10-8：镜像墙壁</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">MirrorWall</span>(<span class="params">Autodesk.Revit.DB.Document document, Wall wall</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        Reference reference = HostObjectUtils.GetSideFaces(wall, ShellLayerType.Exterior).First();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// get one of the wall&#x27;s major side faces</span></span><br><span class="line">        Face face = wall.GetGeometryObjectFromReference(reference) <span class="keyword">as</span> Face; </span><br><span class="line"></span><br><span class="line">        UV bboxMin = face.GetBoundingBox().Min;</span><br><span class="line">        <span class="comment">// create a plane based on this side face with an offset of 10 in the X &amp; Y directions</span></span><br><span class="line"></span><br><span class="line">        Plane plane = <span class="keyword">new</span> Plane(face.ComputeNormal(bboxMin), </span><br><span class="line">                face.Evaluate(bboxMin).Add(<span class="keyword">new</span> XYZ(<span class="number">10</span>, <span class="number">10</span>, <span class="number">0</span>)));</span><br><span class="line"></span><br><span class="line">        ElementTransformUtils.MirrorElement(document, wall.Id, plane);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个FamilyInstance都有一个镜像属性。它指示是否镜像FamilyInstance（例如柱）。</p>
<h2 id="对元素进行分组"><a href="#对元素进行分组" class="headerlink" title="对元素进行分组"></a>对元素进行分组</h2><p>Revit 平台 API 使用 Creation.Document.NewGroup（） 方法选择一个图元或多个图元或组，然后将它们组合在一起。对于您放置的组的每个实例，它们之间都有关联。例如，您可以创建一个包含床、墙和窗户的组，然后在项目中放置该组的多个实例。如果修改一个组中的墙，则该墙会针对该组的所有实例进行更改。这使得修改建筑模型变得更加容易，因为您可以在一次操作中更改组的多个实例。</p>
<p>代码区域 10-9：创建组</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Group <span class="keyword">group</span> = <span class="literal">null</span>;</span><br><span class="line">UIDocument uidoc = <span class="keyword">new</span> UIDocument(document);</span><br><span class="line">ICollection selectedIds = uidoc.Selection.GetElementIds();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (selectedIds.Count &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Group all selected elements</span></span><br><span class="line">    <span class="keyword">group</span> = document.Create.NewGroup(selectedIds);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最初，该组具有通用名称，例如 Group 1。可以通过更改组类型的名称来修改它，如下所示：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Change the default group name to a new name &quot;MyGroup&quot;</span></span><br><span class="line"><span class="keyword">group</span>.GroupType.Name = <span class="string">&quot;MyGroup&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>Revit 中有三种类型的组;模型组、详图组和附加详图组。所有 API 都是使用 NewGroup（） 方法创建的。创建的 Group 的类型取决于传递的 Elements。</p>
<ul>
<li>如果未传递详图元素，则会创建一个模型组。</li>
<li>如果所有元素都是详图元素，则会创建一个详图组。</li>
<li>如果同时包含两种类型的元素，则会创建并返回包含 Attached Detail Group 的模型组。</li>
</ul>
<p><em><strong>注意</strong></em>对元素进行分组后，可以从项目中删除这些元素。</p>
<ul>
<li>删除模型组中的模型元素后，当鼠标光标悬停在组上或单击该组时，该模型元素仍然可见，即使应用程序向 UI 返回 Succeeded 也是如此。实际上，模型元素已被删除，您无法选择或访问该元素。</li>
<li>当组实例的最后一个成员被删除、排除或从项目中移除时，模型组实例将被删除。</li>
</ul>
<p>对元素进行分组时，无法移动或旋转它们。如果对分组的元素执行这些操作，则元素不会发生任何变化，但 Move（） 或 Rotate（） 方法返回 true。</p>
<p>如果不对维度和标记引用的元素进行分组，则无法对它们进行分组。如果这样做，API 调用将失败。</p>
<p>您可以对引用模型组中的模型元素的维度和标签进行分组。尺寸和标记将添加到附加的详图组中。如果不对父组执行相同的操作，则无法移动、复制、旋转、阵列或镜像附着的详图组。</p>
<h2 id="创建元素阵列"><a href="#创建元素阵列" class="headerlink" title="创建元素阵列"></a>创建元素阵列</h2><p>Revit 平台 API 提供了两个类，即 LinearArray 和 RadialArray，用于对项目中的一个或多个图元进行阵列。这些类提供静态方法，用于创建一个或多个选定组件的线性或径向阵列。线性阵列表示从一个点沿直线创建的阵列，而径向阵列表示沿圆弧创建的阵列。</p>
<p>作为使用阵列的示例，您可以选择位于同一墙中的门和窗，然后创建门、墙和窗配置的多个实例。</p>
<p>LinearArray 和 RadialArray 都提供了对一个或多个元素进行阵列的方法，而无需进行分组和关联。尽管类似于用于阵列元素的 Create（） 方法，但每个生成的元素都独立于其他元素，并且可以在不影响其他元素的情况下进行操作。有关可用于创建线性或径向阵列的方法的更多信息，请参阅下表。</p>
<p>表 22：LinearArray 方法</p>
<table>
<thead>
<tr>
<th><strong>Member 成员</strong></th>
<th><strong>Description 描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Create(Document, View, ElementId, int, XYZ, ArrayAnchorMember)</td>
<td>按指定数字对项目中的一个元素进行阵列。</td>
</tr>
<tr>
<td>Create(Document, View, ICollection, int, XYZ, ArrayAnchorMember)</td>
<td>按指定数字对项目中的一组元素进行阵列。</td>
</tr>
<tr>
<td>ArrayElementWithoutAssociation(Document, View, ElementId, int, XYZ, ArrayAnchorMember)</td>
<td>按指定数字对项目中的一个元素进行阵列。生成的元素不与线性阵列关联。</td>
</tr>
<tr>
<td>ArrayElementsWithoutAssociation(Document, View, ICollection, int, XYZ, ArrayAnchorMember)</td>
<td>按指定数字对项目中的一组元素进行阵列排列。生成的元素不与线性阵列关联。</td>
</tr>
</tbody></table>
<p>表 23：RadialArray 方法</p>
<table>
<thead>
<tr>
<th><strong>Member 成员</strong></th>
<th><strong>Description 描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Create(Document, View, ElementId, int, Line, double, ArrayAnchorMember)</td>
<td>根据输入旋转轴对项目中的一个元素进行阵列。</td>
</tr>
<tr>
<td>Create(Document, View, ICollection, int, Line, double, ArrayAnchorMember)</td>
<td>根据输入旋转轴对项目中的一组元素进行阵列。</td>
</tr>
<tr>
<td>ArrayElementWithoutAssociation(Document, View, ElementId, int, Line, double, ArrayAnchorMember)</td>
<td>根据输入旋转轴对项目中的一个元素进行阵列.生成的元素不与线性阵列关联。</td>
</tr>
<tr>
<td>ArrayElementsWithoutAssociation(Document, View, ICollection, int, Line, double, ArrayAnchorMember)</td>
<td>根据输入旋转轴对项目中的一组元素进行阵列。生成的元素不与线性阵列关联。</td>
</tr>
</tbody></table>
<p>如果您需要创建组件的多个实例并同时操作它们，则排列元素的方法非常有用。数组中的每个实例都可以是组的成员。</p>
<p>注意：使用方法对元素进行阵列时，以下规则适用：</p>
<ul>
<li>执行 Linear 和 Radial Array 操作时，依赖于阵列元素的元素也会排列。</li>
<li>某些元素无法排列，因为它们无法分组。有关组和阵列限制的详细信息，请参见《Revit 用户指南》。</li>
<li>大多数注释符号不支持数组。</li>
</ul>
<h2 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h2><p>Revit 平台 API 提供了 Delete（） 方法，用于删除项目中的一个或多个图元。</p>
<p> 表 23：删除成员</p>
<table>
<thead>
<tr>
<th><strong>Member</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Delete(ElementId)</td>
<td>使用元素 ID 从项目中删除元素</td>
</tr>
<tr>
<td>Delete(<a href="http://msdn2.microsoft.com/en-us/library/92t2ye13">ICollection</a>)</td>
<td>按元素的 ID 从项目中删除多个元素。</td>
</tr>
</tbody></table>
<p>第一种方法根据 Id 删除单个元素，如以下示例所示。</p>
<p>代码区域：根据 ElementId 删除元素</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">DeleteElement</span>(<span class="params">Autodesk.Revit.DB.Document document, Element element</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">// Delete an element via its id</span></span><br><span class="line">        Autodesk.Revit.DB.ElementId elementId = element.Id;</span><br><span class="line">        ICollection&lt;Autodesk.Revit.DB.ElementId&gt; deletedIdSet = document.Delete(elementId);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == deletedIdSet.Count)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Deleting the selected element in Revit failed.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String prompt = <span class="string">&quot;The selected element has been removed and &quot;</span>;</span><br><span class="line">        prompt += deletedIdSet.Count - <span class="number">1</span>;</span><br><span class="line">        prompt += <span class="string">&quot; more dependent elements have also been removed.&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Give the user some information</span></span><br><span class="line">        TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>, prompt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：删除元素时，与该元素关联的任何子元素也将被删除，如上面的示例所示。</p>
<p>该 API 还提供了一种删除多个元素的方法。</p>
<p>代码区域：根据 Id 删除多个元素</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Delete all the selected elements via the set of elements</span></span><br><span class="line">UIDocument uidoc = <span class="keyword">new</span> UIDocument(document); </span><br><span class="line">ICollection elements = uidoc.Selection.GetElementIds();</span><br><span class="line">ICollection&lt;Autodesk.Revit.DB.ElementId&gt; deletedIdSet = document.Delete(elements);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="number">0</span> == deletedIdSet.Count)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Deleting the selected elements in Revit failed.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>,<span class="string">&quot;The selected element has been removed.&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>注意：删除元素后，对已删除元素的任何引用都将无效，并在访问这些元素时引发异常。</p>
<h2 id="固定元素"><a href="#固定元素" class="headerlink" title="固定元素"></a>固定元素</h2><p>可以固定元素以防止它们移动。Element.Pinned 属性可用于检查元素是否已固定，或者固定或取消固定元素。</p>
<p>当 Element.Pinned 设置为 true 时，无法移动或旋转元素。</p>
<h2 id="注：翻译自Revit-API-Developers-Guide"><a href="#注：翻译自Revit-API-Developers-Guide" class="headerlink" title="注：翻译自Revit API Developers Guide"></a><em><strong>注：</strong></em>翻译自<a href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_html">Revit API Developers Guide</a></h2>]]></content>
      <categories>
        <category>Revit二次开发人员指南</category>
      </categories>
      <tags>
        <tag>Revit</tag>
      </tags>
  </entry>
  <entry>
    <title>08集合</title>
    <url>/2024/12/05/%E4%BA%8C%E5%BC%80%E6%8C%87%E5%8D%97/08%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a><a href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_Basic_Interaction_with_Revit_Elements_Collections_Collections_and_Iterators_html">集合</a></h1><p>大多数Revit Platform API属性和方法在提供对一组相关项的访问时都使用.NET Framework集合类。</p>
<p>在Revit集合类型中实现的IEnumerator和IEnumerator接口在System.Collection命名空间中定义。</p>
<p>Pages in this section 本节中的页面</p>
<ul>
<li>Interface 接口</li>
<li>Collections and Iterators 集合和迭代器</li>
</ul>
<h2 id="Interface-接口"><a href="#Interface-接口" class="headerlink" title="Interface 接口"></a>Interface 接口</h2><p>以下各节讨论与接口相关的集合类型。</p>
<h3 id="IEnumerable"><a href="#IEnumerable" class="headerlink" title="IEnumerable"></a>IEnumerable</h3><p>IELTS接口位于System.Collections命名空间中。它公开枚举数，该枚举数支持对非泛型集合进行简单迭代。GetEnumerator（）方法获取实现此接口的枚举器。返回的IEnumerator对象在整个集合中迭代。GetEnumerator（）方法由C#中的foreach循环隐式使用。</p>
<h3 id="IEnumerator"><a href="#IEnumerator" class="headerlink" title="IEnumerator"></a>IEnumerator</h3><p>IEnumerator接口位于System.Collections命名空间中。它支持对非泛型集合进行简单迭代。IEnumerator是所有非泛型枚举器的基接口。C#中的foreach语句隐藏了枚举器的复杂性。</p>
<p>注意：建议使用foreach而不是直接操作枚举器。</p>
<p>枚举数用于读取集合数据，但不能用于修改基础集合。使用IEnumerator如下：</p>
<ul>
<li>最初，枚举数位于集合中第一个元素的前面。但是，最好总是在第一次获取枚举数时调用Reset（）。<ul>
<li>Reset（）方法将枚举数移回原始位置。在此位置，调用Current属性将引发异常。</li>
<li>调用MoveNext（）方法，在阅读当前迭代器值之前，将枚举器前进到集合的第一个元素。</li>
</ul>
</li>
<li>在调用MoveNext（）方法或Reset（）方法之前，Current属性返回相同的对象。MoveNext（）方法将当前迭代器设置为下一个元素。</li>
<li>如果MoveNext通过了集合的末尾，则枚举数位于集合中最后一个元素之后，MoveNext返回false。<ul>
<li>当枚举数处于此位置时，对MoveNext的后续调用也返回false。</li>
<li>如果对MoveNext的最后一次调用返回false，则调用Current属性将引发异常。</li>
<li>要再次将当前迭代器设置为集合中的第一个元素，请调用Reset（）方法，然后调用MoveNext（）。</li>
</ul>
</li>
<li>只要集合保持不变，枚举数就保持有效。<ul>
<li>如果对集合进行了更改（如添加、修改或删除元素），则枚举数将失效，并且下次调用MoveNext（）或Reset（）方法时将引发InvalidOperationException。</li>
<li>如果在MoveNext和当前迭代器之间修改了集合，则Current属性返回到指定的元素，即使枚举器已经无效。</li>
</ul>
</li>
</ul>
<p>注意：所有对Reset（）方法的调用都必须导致枚举数的相同状态。首选的实现是将枚举数移动到集合的开头，在第一个元素之前。如果在创建枚举数之后修改了集合，则这将使枚举数无效，这与MoveNext（）和Current属性一致。</p>
<h2 id="Collections-and-Iterators-集合和迭代器"><a href="#Collections-and-Iterators-集合和迭代器" class="headerlink" title="Collections and Iterators 集合和迭代器"></a>Collections and Iterators 集合和迭代器</h2><p>在Revit Platform API中，集合和迭代器是通用且类型安全的。</p>
<p>所有集合都实现IEnumerator接口，所有相关迭代器都实现IEnumerator接口。因此，所有方法和属性都在Revit Platform API中实现，并且可以在相关集合中发挥作用。</p>
<p>所有集合的实现都是类似的。下面的示例使用ModelCurveArray演示如何使用主集合属性：</p>
<p>代码区域9-2：使用集合</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">UIDocument uidoc = <span class="keyword">new</span> UIDocument(document); </span><br><span class="line">ICollection selectedIds = uidoc.Selection.GetElementIds();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Store the ModelLine references</span></span><br><span class="line">ModelCurveArray lineArray = <span class="keyword">new</span> ModelCurveArray();</span><br><span class="line"></span><br><span class="line"><span class="comment">// … Store operation</span></span><br><span class="line">Autodesk.Revit.DB.ElementId id = <span class="keyword">new</span> Autodesk.Revit.DB.ElementId(<span class="number">131943</span>); <span class="comment">//assume 131943 is a model line element id</span></span><br><span class="line">lineArray.Append(document.GetElement(id) <span class="keyword">as</span> ModelLine);</span><br><span class="line"></span><br><span class="line"><span class="comment">// use Size property of Array</span></span><br><span class="line">TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>,<span class="string">&quot;Before Insert: &quot;</span> + lineArray.Size + <span class="string">&quot; in lineArray.&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// use IsEmpty property of Array</span></span><br><span class="line"><span class="keyword">if</span> (!lineArray.IsEmpty)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// use Item(int) property of Array</span></span><br><span class="line">    ModelCurve modelCurve = lineArray.get_Item(<span class="number">0</span>) <span class="keyword">as</span> ModelCurve;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// erase the specific element from the set of elements</span></span><br><span class="line">    selectedIds.Remove(modelCurve.Id);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create a new model line and insert to array of model line</span></span><br><span class="line">    SketchPlane sketchPlane = modelCurve.SketchPlane;</span><br><span class="line"></span><br><span class="line">    XYZ startPoint = <span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);  <span class="comment">// the start point of the line</span></span><br><span class="line">    XYZ endPoint = <span class="keyword">new</span> XYZ(<span class="number">10</span>, <span class="number">10</span>, <span class="number">0</span>);  <span class="comment">// the end point of the line</span></span><br><span class="line">    <span class="comment">// create geometry line</span></span><br><span class="line">    Line geometryLine = Line.CreateBound(startPoint, endPoint);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create the ModelLine</span></span><br><span class="line">    ModelLine line = document.Create.NewModelCurve(geometryLine, sketchPlane) <span class="keyword">as</span> ModelLine;</span><br><span class="line"></span><br><span class="line">    lineArray.Insert(line, lineArray.Size - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>,<span class="string">&quot;After Insert: &quot;</span> + lineArray.Size + <span class="string">&quot; in lineArray.&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// use the Clear() method to remove all elements in lineArray</span></span><br><span class="line">lineArray.Clear();</span><br><span class="line"></span><br><span class="line">TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>,<span class="string">&quot;After Clear: &quot;</span> + lineArray.Size + <span class="string">&quot; in lineArray.&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="注：翻译自Revit-API-Developers-Guide"><a href="#注：翻译自Revit-API-Developers-Guide" class="headerlink" title="注：翻译自Revit API Developers Guide"></a><em><strong>注：</strong></em>翻译自<a href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_html">Revit API Developers Guide</a></h2>]]></content>
      <categories>
        <category>Revit二次开发人员指南</category>
      </categories>
      <tags>
        <tag>Revit</tag>
      </tags>
  </entry>
  <entry>
    <title>07参数</title>
    <url>/2024/11/23/%E4%BA%8C%E5%BC%80%E6%8C%87%E5%8D%97/07%E5%8F%82%E6%95%B0/</url>
    <content><![CDATA[<h1 id="参数"><a href="#参数" class="headerlink" title="参数"></a><a href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_Basic_Interaction_with_Revit_Elements_Parameters_html">参数</a></h1><p>Revit提供了一种常规机制，为每个图元提供一组可编辑的参数。</p>
<p>在Revit UI中，某些图元参数在“图元属性”窗口中可见。以下各节介绍如何获取和使用内置参数、共享参数和全局参数。</p>
<p>在Revit Platform API中，参数在Element类中进行管理。您可以通过以下方式访问参数：</p>
<ul>
<li>通过迭代元素的所有参数的Element.Parameters集合（有关示例，请参见获取选定元素参数演练中的示例代码）。</li>
<li>通过迭代Element.GetOrderedParameters()返回的集合，该集合仅返回属性选项板中可见的参数。</li>
<li>通过重载的Element.Parameter属性直接访问参数。如果参数不存在，则属性返回null。</li>
<li>通过Element.ParametersMap集合按名称访问参数。</li>
<li>按名称字符串Element.LookupParameter()或Element.GetParameters()。</li>
</ul>
<p>如果知道内置ID、定义或参数，则可以使用重载的Parameter属性从Element中检索Parameter对象。Parameter[NULL]属性重载根据其全局唯一ID（Global Unique ID，NULL）获取共享参数，该全局唯一ID在创建共享参数时分配给该共享参数。}]}</p>
<p>Element.LookupParameter()方法根据参数的本地化名称获取参数，因此如果要按名称查找参数并且需要在多个区域设置中运行，则代码应处理不同的语言。此外，请记住，可能会出现同名参数的多个匹配，因为即使已经存在同名的内置参数，共享参数或项目参数也可以绑定到元素类别。因此，最好使用Element. GetParameter()，它将返回与给定名称匹配的所有参数。LookupParameter()将返回找到的第一个匹配项。</p>
<p>本节中的页面</p>
<ul>
<li>演练：获取选定的元素参数</li>
<li>参数关系</li>
<li>定义</li>
<li>内置参数</li>
<li>共享参数</li>
<li>全局参数</li>
<li>参数</li>
</ul>
<h2 id="演练：获取选定的元素参数"><a href="#演练：获取选定的元素参数" class="headerlink" title="演练：获取选定的元素参数"></a>演练：获取选定的元素参数</h2><p>元素参数是通过遍历元素参数集来检索的。下面的代码示例阐释如何从选定的元素中检索Parameter。</p>
<p>****注意：****此示例使用了一些参数成员，如AsValueString和DataType，这些将在后续主题中介绍。</p>
<p>代码区域8-1：获取选定的元素参数</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetElementParameterInformation</span>(<span class="params">Document document, Element element</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Format the prompt information string</span></span><br><span class="line">    String prompt = <span class="string">&quot;Show parameters in selected Element: \n\r&quot;</span>;</span><br><span class="line"></span><br><span class="line">    StringBuilder st = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="comment">// iterate element&#x27;s parameters</span></span><br><span class="line">    <span class="keyword">foreach</span> (Parameter para <span class="keyword">in</span> element.Parameters)</span><br><span class="line">    &#123;</span><br><span class="line">        st.AppendLine(GetParameterInformation(para, document));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Give the user some information</span></span><br><span class="line">    TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>, prompt + st.ToString());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">String <span class="title">GetParameterInformation</span>(<span class="params">Parameter para, Document document</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> defName = para.Definition.Name + <span class="string">&quot;\t : &quot;</span>;</span><br><span class="line">    <span class="built_in">string</span> defValue = <span class="built_in">string</span>.Empty;</span><br><span class="line">    <span class="comment">// Use different method to get parameter data according to the storage type</span></span><br><span class="line">    <span class="keyword">switch</span> (para.StorageType)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> StorageType.Double:</span><br><span class="line">            <span class="comment">//covert the number into Metric</span></span><br><span class="line">            defValue = para.AsValueString();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> StorageType.ElementId:</span><br><span class="line">            <span class="comment">//find out the name of the element</span></span><br><span class="line">            Autodesk.Revit.DB.ElementId id = para.AsElementId();</span><br><span class="line">            <span class="keyword">if</span> (id.IntegerValue &gt;= <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                defValue = document.GetElement(id).Name;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                defValue = id.IntegerValue.ToString();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> StorageType.Integer:</span><br><span class="line">            <span class="keyword">if</span> (ParameterType.YesNo == para.Definition.ParameterType)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (para.AsInteger() == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    defValue = <span class="string">&quot;False&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    defValue = <span class="string">&quot;True&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                defValue = para.AsInteger().ToString();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> StorageType.String:</span><br><span class="line">            defValue = para.AsString();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="literal">default</span>:</span><br><span class="line">            defValue = <span class="string">&quot;Unexposed parameter.&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> defName + defValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-07A40B76-5AD7-46C8-983F-494CECF88543-low.png"></p>
<p>图26：获取墙参数结果</p>
<p>注意：在Revit中，某些参数的值位于“图元属性”对话框的下拉列表中。可以使用Revit Platform API获取与Parameter的枚举类型对应的数值，但不能使用Parameter.AsValueString()方法获取值的字符串表示形式。</p>
<h2 id="参数关系"><a href="#参数关系" class="headerlink" title="参数关系"></a>参数关系</h2><p>参数可以相互影响。</p>
<p>参数之间存在关系，其中一个参数的值可以影响：</p>
<ul>
<li>是否可以设置另一个参数，或者是否为只读</li>
<li>哪些参数对元素有效</li>
<li>另一个参数的计算值</li>
</ul>
<p>此外，某些参数始终是只读的。</p>
<p>某些参数在Revit中计算，例如墙长度和面积参数。这些参数总是只读的，因为它们依赖于元素的内部状态。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-B11C1A73-B5DE-4429-B728-C739D963AE1A-low.png"></p>
<p>在此代码示例中，洞口的“Sill Height”参数将被调整，从而导致重新计算“Head Height”参数：</p>
<p>代码区域：参数关系示例</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// opening should be an opening such as a window or a door</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ShowParameterRelationship</span>(<span class="params">FamilyInstance opening</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">// get the original Sill Height and Head Height parameters for the opening</span></span><br><span class="line">        Parameter sillPara = opening.get_Parameter(BuiltInParameter.INSTANCE_SILL_HEIGHT_PARAM);</span><br><span class="line">        Parameter headPara = opening.get_Parameter(BuiltInParameter.INSTANCE_HEAD_HEIGHT_PARAM);</span><br><span class="line">        <span class="built_in">double</span> sillHeight = sillPara.AsDouble();</span><br><span class="line">        <span class="built_in">double</span> origHeadHeight = headPara.AsDouble();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Change the Sill Height only and notice that Head Height is recalculated</span></span><br><span class="line">        sillPara.Set(sillHeight + <span class="number">2.0</span>);</span><br><span class="line">        <span class="built_in">double</span> newHeadHeight = headPara.AsDouble();</span><br><span class="line">        MessageBox.Show(<span class="string">&quot;Old head height: &quot;</span> + origHeadHeight + <span class="string">&quot;; new head height: &quot;</span> </span><br><span class="line">                + newHeadHeight);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>全局参数也与其他参数有关系。有关详细信息，请参见“全局参数基础”主题。</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>定义对象描述数据类型、名称和其他参数细节。</p>
<p>有两种类型的定义对象派生自该对象。</p>
<ul>
<li>InternalDefinition表示完全存在于Revit数据库中的所有类型的定义。</li>
<li>ExternalDefinition表示存储在磁盘上的共享参数文件中的定义。</li>
</ul>
<p>您应该编写使用Definition基类的代码，以便该代码适用于内部和外部参数定义。下面的代码示例演示如何使用定义类型查找特定参数。</p>
<p> 代码区域8-2：根据定义类型查找参数</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Find parameter using the Parameter&#x27;s definition type.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Parameter <span class="title">FindParameter</span>(<span class="params">Element element</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        Parameter foundParameter = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// This will find the first parameter that measures length</span></span><br><span class="line">        <span class="keyword">foreach</span> (Parameter parameter <span class="keyword">in</span> element.Parameters)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">if</span> (parameter.Definition.ParameterType == ParameterType.Length)</span><br><span class="line">                &#123;</span><br><span class="line">                        foundParameter = parameter;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> foundParameter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="参数类型"><a href="#参数类型" class="headerlink" title="参数类型"></a>参数类型</h3><p>此属性返回参数数据类型，这会影响参数在Revit UI中的显示方式。一些参数类型枚举成员包括：</p>
<table>
<thead>
<tr>
<th><strong>Member name 成员名称</strong></th>
<th><strong>Description 描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td><em>Number</em></td>
<td>参数数据应解释为真实的数字，可能包括小数点。</td>
</tr>
<tr>
<td><em>Moment</em></td>
<td>数据值将表示为力矩。</td>
</tr>
<tr>
<td><em>AreaForce</em></td>
<td>数据值将表示为面积力。</td>
</tr>
<tr>
<td><em>LinearForce</em></td>
<td>数据值将表示为线性力。</td>
</tr>
<tr>
<td><em>Force</em></td>
<td>数据值将表示为力。</td>
</tr>
<tr>
<td><em>YesNo</em></td>
<td>一个布尔值，表示为Yes或No。</td>
</tr>
<tr>
<td><em>Material</em></td>
<td>此属性的值被视为材料。</td>
</tr>
<tr>
<td><em>URL</em></td>
<td>表示网址的文本字符串。</td>
</tr>
<tr>
<td><em>Angle</em></td>
<td>参数数据表示角度。内部表示将以弧度表示。用户可见表示将使用用户选择的单位。</td>
</tr>
<tr>
<td><em>Volume</em></td>
<td>参数数据表示体积。内部表示将以十进制立方英尺为单位。用户可见表示将使用用户选择的单位。</td>
</tr>
<tr>
<td><em>Area</em></td>
<td>参数数据表示一个区域。内部表示将以十进制平方英尺为单位。用户可见表示将使用用户选择的单位。</td>
</tr>
<tr>
<td><em>Integer</em></td>
<td>参数数据应解释为整数，正数或负数。</td>
</tr>
<tr>
<td><em>Invalid</em></td>
<td>参数类型无效。不应使用此值。</td>
</tr>
<tr>
<td><em>Length</em></td>
<td>参数数据表示长度。内部表示将以十进制英尺为单位。用户可见表示将在用户选择的单位系统中。</td>
</tr>
<tr>
<td><em>Text</em></td>
<td>参数数据应解释为文本字符串。</td>
</tr>
<tr>
<td><em>MultilineText</em></td>
<td>此参数的值将表示为多行文本。</td>
</tr>
<tr>
<td><em>FamilyType</em></td>
<td>用于控制嵌套在另一个族中的族的类型的参数。</td>
</tr>
<tr>
<td><em>Image</em></td>
<td>该参数的值是图像的id。</td>
</tr>
</tbody></table>
<p>有关参数类型.材质的更多详细信息，请参见材质。</p>
<p>ParameterGroup 参数组</p>
<p>定义类参数组属性返回参数定义组ID。BuiltInParameterGroup是一种枚举类型，列出了Revit支持的所有内置参数组。参数组用于对“图元属性”对话框中的参数进行排序。</p>
<h2 id="内部定义"><a href="#内部定义" class="headerlink" title="内部定义"></a>内部定义</h2><p>每个Parameter对象都有一个InternalDefinition，它可以从Definition属性中获得。InternalDefinition表示Revit文档中的参数定义。除了从Definition继承的属性之外，它还具有一些其他关键属性。</p>
<h3 id="BuiltInParameter-内置参数"><a href="#BuiltInParameter-内置参数" class="headerlink" title="BuiltInParameter 内置参数"></a>BuiltInParameter 内置参数</h3><p>此属性测试此定义是否标识内置参数。对于内置参数，此属性返回BuiltInParameter枚举值之一。对于自定义参数（如共享参数、全局参数或族参数），该值将为BuiltInParameter.INVALID。</p>
<h3 id="Id"><a href="#Id" class="headerlink" title="Id"></a>Id</h3><p>如果参数不是内置的，则此属性返回关联的ParameterElement的ID。</p>
<h3 id="VariesAcrossGroups"><a href="#VariesAcrossGroups" class="headerlink" title="VariesAcrossGroups"></a>VariesAcrossGroups</h3><p>该属性和相应的SetAllowVaryBetweenGroups()方法确定该参数的值是否可以在组实例的相关成员之间变化。如果为False，则组实例中相关成员的值将保持一致。这只能为非内置参数设置。</p>
<h3 id="Visible-可见"><a href="#Visible-可见" class="headerlink" title="Visible 可见"></a>Visible 可见</h3><p>visible属性指示是否对用户隐藏共享参数。如果您希望将数据添加到仅对您的应用程序有意义而对用户没有意义的元素中，这将非常有用。此值只能在创建共享参数定义时设置。</p>
<h2 id="内置参数"><a href="#内置参数" class="headerlink" title="内置参数"></a>内置参数</h2><p>Revit Platform API具有大量内置参数。</p>
<p>内置参数在Autodesk.Revit.Parameters.BuiltInParameter枚举中定义（有关此枚举的定义，请参见RevitAPI Help.chm文件）。此枚举已生成可从Visual Studio intellisense看到的文档，如下所示。每个id的文档都包括参数名称，如Autodesk Revit英文版的“图元属性”对话框中所示。请注意，多个不同的参数id可能映射到同一个英文名称;在这种情况下，您必须检查与特定元素关联的参数，以确定使用哪个参数id。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/BuiltInParameter-76164.jpg"></p>
<p>参数ID用于从元素中检索特定参数，如果它存在，使用Element.Parameter属性。但是，并非所有参数都可以使用ID进行检索。例如，族参数未在Revit Platform API中显示，因此，您无法使用内置参数ID获取它们。</p>
<p>以下代码示例显示如何使用BuiltInParameter Id获取特定参数：</p>
<p>代码区域8-3：基于BuiltInParameter获取参数</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Parameter <span class="title">FindWithBuiltinParameterID</span>(<span class="params">Wall wall</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">// Use the WALL_BASE_OFFSET paramametId</span></span><br><span class="line">        <span class="comment">// to get the base offset parameter of the wall.</span></span><br><span class="line">        BuiltInParameter paraIndex = BuiltInParameter.WALL_BASE_OFFSET;</span><br><span class="line">        Parameter parameter = wall.get_Parameter(paraIndex);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> parameter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：通过Parameter重载，可以使用枚举类型BuiltInParameter作为方法参数.例如，使用BuiltInParameter.GENERIC_WIDTH。</p>
<p>如果不知道确切的BuiltInParameter ID，请通过迭代ParameterSet集合获取参数。另一种用于测试或识别目的的方法是使用get_Parameter()方法测试每个BuiltInParameter。当您使用此方法时，参数集集合可能不包含从get_Parameter()方法返回的所有参数，尽管这种情况并不常见。</p>
<h2 id="共享参数"><a href="#共享参数" class="headerlink" title="共享参数"></a>共享参数</h2><p>共享参数是存储在外部文本文件中的参数定义。</p>
<p>定义由创建定义时生成的唯一标识符标识，并且可以在多个项目中使用。</p>
<p>与共享参数关联的主要对象有：</p>
<ul>
<li>DefinitionFile -表示磁盘上的共享参数文件</li>
<li>DefinitionGroup -一组共享参数，它们被组织成有意义的集合</li>
<li>ExternalDefinition -表示一个共享参数定义，属于一个配置组</li>
<li>ExternalDefinitions -支持创建新的共享参数定义</li>
<li>Binding-将参数定义绑定到一个或多个类别</li>
<li>BindingMap -包含Autodesk Revit项目中存在的所有参数绑定</li>
<li>ParameterElement-存储有关文档中特定用户定义参数的信息</li>
<li>SharedParameterElement -从ParameterElement派生，存储共享参数的定义以下各节介绍如何通过Revit Platform API访问共享参数定义，包括如何获取共享参数定义并将其绑定到某些类别中的元素。</li>
</ul>
<p>要在定义共享参数并将其绑定到类别后访问共享参数，请参见参数。</p>
<p>本节中的页面</p>
<ul>
<li>Definition File</li>
<li>Working with the Definition File</li>
<li>Binding </li>
<li>SharedParameterElement</li>
</ul>
<h3 id="Definition-File"><a href="#Definition-File" class="headerlink" title="Definition File"></a>Definition File</h3><p>DefinitionFile 表示一个共享参数文件，它是一个通用文本文件。</p>
<h4 id="Format-格式"><a href="#Format-格式" class="headerlink" title="Format 格式"></a>Format 格式</h4><p>共享参数定义文件是一个文本文件（.txt），包含三个块：Meta、GROUP和PARAM。GROUP和PARAM块与Revit API中的共享参数功能相关。不要直接编辑定义文件;而是使用UI或API编辑它。</p>
<p>尽管Revit API负责阅读和写入此文件，但以下部分提供了文件格式的信息，该文件格式与用于访问共享参数的API对象和方法密切对应。该文件使用制表符分隔字段，在文本编辑器中很难阅读。下面的代码区域显示了示例共享参数文本文件的内容。</p>
<p>代码区域22-1：参数定义文件示例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># This is a Revit shared parameter file.</span><br><span class="line"># Do not edit manually.</span><br><span class="line">META    VERSION    MINVERSION</span><br><span class="line">META    2    1</span><br><span class="line">GROUP    ID    NAME</span><br><span class="line">GROUP    1    MyGroup</span><br><span class="line">GROUP    2    AnotherGroup</span><br><span class="line">*PARAM    GUID    NAME    DATATYPE    DATACATEGORY    GROUP    VISIBLE    DESCRIPTION    USERMODIFIABLE</span><br><span class="line">PARAM    bb7f0005-9692-4b76-8fa3-30cec8aecf74    Price    INTEGER        2    1    Enter price in USD    1</span><br><span class="line">PARAM    b7ea2654-b206-4694-a087-756359b52e7f    areaTags    FAMILYTYPE    -2005020    1    1        1</span><br><span class="line">PARAM    d1a5439d-dc8d-4053-99fa-2f33804bae0e    MyParam    TEXT        1    1        1</span><br></pre></td></tr></table></figure>

<ul>
<li><p>GROUP块包含将每个参数定义与组关联的组条目。以下字段显示在GROUP块中：</p>
<ul>
<li>ID -唯一标识组并将参数定义与组关联。</li>
<li>Name - UI中显示的组名称。</li>
</ul>
</li>
<li><p>PARAM块包含参数定义。以下字段出现在PARAM块中：</p>
<ul>
<li><p>GUID - 识别参数定义。</p>
</li>
<li><p>NAME - 参数定义名称。</p>
</li>
<li><p>DATATYPE -参数类型。此字段可以是常见类型（TEXT、INTEGER等），结构类型（力、力矩等）或常用族类型（面积标记等）。通用类型和结构类型参数直接在文本文件中指定（例如：文本，力）。如果DATATYPE字段的值为FAMILYTYPE，则添加一个额外的数字。例如，FAMILYTYPE后跟-2005020表示族类型：面积标记。</p>
</li>
<li><p>DATACATEGORY -DATATYPE为FAMILYTYPE的参数的可选字段。</p>
</li>
<li><p>GROUP -用于标识包含当前参数定义的组的组ID。</p>
</li>
<li><p>VISIBLE -确定参数是否可见。此字段的值为0或1.0 </p>
</li>
<li><p>DESCRIPTION - 此参数的工具提示的可选字段。</p>
</li>
<li><p>USERMODIFIABLE -确定参数是否可由用户编辑。0 &#x3D;用户无法编辑参数，并且该参数在UI中呈灰色显示</p>
</li>
</ul>
</li>
</ul>
<p>在示例定义文件中，有两个组：</p>
<ul>
<li>MyGroup - ID 1 -包含MyParam的参数定义（文本类型参数）和areaTags的定义（家庭类型参数）。</li>
<li>AnotherGroup - ID 2 -包含Price的参数定义，它是一个价格类型参数。</li>
</ul>
<p>Of the 3 parameters in the sample file, only Price has a description. All of the parameters are visible and user modifiable.<br>在示例文件中的3个参数中，只有Price有描述。所有的参数都是可见的，用户可以修改。</p>
<h3 id="Working-with-the-Definition-File"><a href="#Working-with-the-Definition-File" class="headerlink" title="Working with the Definition File"></a>Working with the Definition File</h3><p>定在定义文件中设置参数义文件提供对共享参数的访问。</p>
<h4 id="在定义文件中设置参数"><a href="#在定义文件中设置参数" class="headerlink" title="在定义文件中设置参数"></a>在定义文件中设置参数</h4><p>使用以下步骤访问定义文件及其参数：</p>
<ol>
<li>使用现有文本文件或新文本文件指定Application.SharedParametersFiltrate属性。</li>
<li>使用Application.OpenSharedParameterFile()方法打开共享参数文件。</li>
<li>打开一个现有组或使用configtionFile.groups属性创建一个新组。</li>
<li>打开现有的外部参数定义或使用configuretionGroup.Definitions属性创建新定义。</li>
</ol>
<p>Autodesk. Revit. DB命名空间中的以下类和方法提供了使用Revit API访问共享参数的功能。</p>
<ul>
<li>DefinitionFile 类<ul>
<li>使用Application.OpenSharedParameterFile()方法检索。Revit每次使用一个共享参数文件。</li>
<li>表示一个共享参数文件。</li>
<li>包含多个Group对象。</li>
<li>共享参数被分组以便于管理，并包含共享参数定义。</li>
<li>可以根据需要添加新的定义。</li>
</ul>
</li>
<li>ExternalDefinition 类<ul>
<li>ExternalDefinition对象是由一个共享参数文件中的ExternationGroup对象创建的。</li>
<li>外部参数定义必须属于一个组，该组是共享参数定义的集合。</li>
</ul>
</li>
<li>Application.SharedParametersFilename 属性<ul>
<li>使用此属性获取和设置共享参数文件路径。</li>
<li>默认情况下，Revit没有共享参数文件。</li>
<li>使用前初始化此属性。如果它没有初始化，则会引发异常。</li>
</ul>
</li>
</ul>
<h4 id="创建共享参数文件"><a href="#创建共享参数文件" class="headerlink" title="创建共享参数文件"></a>创建共享参数文件</h4><p>代码区域22-3：创建共享参数文件</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">CreateExternalSharedParamFile</span>(<span class="params"><span class="built_in">string</span> sharedParameterFile</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        System.IO.FileStream fileStream = System.IO.File.Create(sharedParameterFile);</span><br><span class="line">        fileStream.Close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="访问现有共享参数文件"><a href="#访问现有共享参数文件" class="headerlink" title="访问现有共享参数文件"></a>访问现有共享参数文件</h4><p>由于Revit可以有许多共享参数文件，因此必须明确标识要访问的文件和外部参数。以下两个过程说明如何访问现有的共享参数文件。</p>
<p>从外部参数文件中获取配置文件</p>
<p>按照下面的代码所示设置共享参数文件路径，然后调用Application.OpenSharedParameterFile()方法。</p>
<p>代码区域22-4：从外部参数文件获取定义文件</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> DefinitionFile <span class="title">SetAndOpenExternalSharedParamFile</span>(<span class="params">Autodesk.Revit.ApplicationServices.Application application, <span class="built_in">string</span> sharedParameterFile</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// set the path of shared parameter file to current Revit</span></span><br><span class="line">    application.SharedParametersFilename = sharedParameterFile;</span><br><span class="line">    <span class="comment">// open the file</span></span><br><span class="line">    <span class="keyword">return</span> application.OpenSharedParameterFile();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注：设置共享参数路径时，请考虑以下几点： 在每次安装过程中，Revit无法检测是否在其他版本中设置了共享参数文件。必须再次为新的Revit安装绑定共享参数文件。 如果Application. SharedParametersFilm设置为无效路径，则仅在调用OpenSharedParameterFile()时引发异常。 * Revit可以使用多个共享参数文件。即使加载参数时只使用一个参数文件，也可以自由更改当前文件。 </p>
<h4 id="遍历所有参数"><a href="#遍历所有参数" class="headerlink" title="遍历所有参数"></a>遍历所有参数</h4><p>下面的示例阐释如何遍历参数项并在消息框中显示结果。</p>
<p>代码区域22-5：遍历参数条目</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ShowDefinitionFileInfo</span>(<span class="params">DefinitionFile myDefinitionFile</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    StringBuilder fileInformation = <span class="keyword">new</span> StringBuilder(<span class="number">500</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get the file name </span></span><br><span class="line">    fileInformation.AppendLine(<span class="string">&quot;File Name: &quot;</span> + myDefinitionFile.Filename);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// iterate the Definition groups of this file</span></span><br><span class="line">    <span class="keyword">foreach</span> (DefinitionGroup myGroup <span class="keyword">in</span> myDefinitionFile.Groups)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// get the group name</span></span><br><span class="line">        fileInformation.AppendLine(<span class="string">&quot;Group Name: &quot;</span> + myGroup.Name);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// iterate the difinitions</span></span><br><span class="line">        <span class="keyword">foreach</span> (Definition definition <span class="keyword">in</span> myGroup.Definitions)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// get definition name</span></span><br><span class="line">            fileInformation.AppendLine(<span class="string">&quot;Definition Name: &quot;</span> + definition.Name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>,fileInformation.ToString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="更改参数定义所有者组"><a href="#更改参数定义所有者组" class="headerlink" title="更改参数定义所有者组"></a>更改参数定义所有者组</h4><p>以下示例说明如何更改参数定义组所有者。</p>
<p>代码区域22-6：更改参数定义组所有者</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ReadEditExternalParam</span>(<span class="params">DefinitionFile <span class="keyword">file</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// get ExternalDefinition from shared parameter file</span></span><br><span class="line">    DefinitionGroups myGroups = <span class="keyword">file</span>.Groups;</span><br><span class="line">    DefinitionGroup myGroup = myGroups.get_Item(<span class="string">&quot;MyGroup&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (myGroup != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ExternalDefinition myExtDef = myGroup.Definitions.get_Item(<span class="string">&quot;MyParam&quot;</span>) <span class="keyword">as</span> ExternalDefinition;</span><br><span class="line">        <span class="keyword">if</span> (myExtDef != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            DefinitionGroup newGroup = myGroups.get_Item(<span class="string">&quot;AnotherGroup&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (newGroup != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// change the OwnerGroup of the ExternalDefinition</span></span><br><span class="line">                myExtDef.OwnerGroup = newGroup;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Binding"><a href="#Binding" class="headerlink" title="Binding"></a>Binding</h3><p>绑定是将共享参数与模型中某些类别的元素联系在一起。</p>
<p>有两种类型的绑定可用，实例绑定和类型绑定。两者之间的主要区别在于，实例绑定参数出现在这些类别中元素的所有实例上。更改其中一个实例的参数不会影响该参数的其他实例。类型绑定参数仅出现在类型对象上，并由使用该类型的所有实例共享。更改类型绑定参数会影响使用该类型的元素的所有实例。请注意，定义只能绑定到实例或类型，而不能同时绑定到两者。</p>
<p>要绑定参数，请执行以下操作：</p>
<ol>
<li>使用InstanceBinding或TypeBinding对象可以创建一个新的Binding对象，该对象包括参数绑定到的类别。</li>
<li>使用Document.ParameterBindings属性提供的BindingMap对象将绑定和定义添加到文档中。</li>
</ol>
<p>Autodesk.Revit.DB命名空间中的以下类和方法提供了有关将参数绑定到元素的详细信息。</p>
<ul>
<li>BindingMap类<ul>
<li>从Document.ParameterBindings属性检索。</li>
<li>参数绑定将参数定义连接到一个或多个类别中的元素。</li>
<li>该映射用于查询现有绑定以及使用Insert方法生成新的参数绑定。</li>
</ul>
</li>
<li>BindingMap.Insert()方法<ul>
<li>绑定对象类型规定参数是绑定到所有实例还是仅绑定到类型。</li>
<li>参数定义不能同时绑定到实例和类型。</li>
<li>如果参数绑定存在，则该方法返回false。</li>
</ul>
</li>
</ul>
<h4 id="Type-Binding"><a href="#Type-Binding" class="headerlink" title="Type Binding"></a>Type Binding</h4><p>TypeBinding对象用于将特性绑定到Revit类型（如墙类型）。它与实例绑定的不同之处在于，该属性由类型绑定中标识的所有实例共享。更改一个类型的参数会影响同一类型的所有实例。</p>
<p>下面的代码示例演示如何使用共享参数文件添加参数定义。以下代码执行的操作与使用Revit UI中的对话框执行的操作相同。参数定义按以下顺序创建：</p>
<ol>
<li>将创建共享参数文件。</li>
<li>将为墙类型创建定义组和参数定义。</li>
<li>定义将根据墙类别绑定到当前文档中的墙类型参数。</li>
</ol>
<p>代码区域22-7：使用共享参数文件添加类型参数定义</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">SetNewParameterToTypeWall</span>(<span class="params">UIApplication app, DefinitionFile myDefinitionFile</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Create a new group in the shared parameters file</span></span><br><span class="line">    DefinitionGroups myGroups = myDefinitionFile.Groups;</span><br><span class="line">    DefinitionGroup myGroup = myGroups.Create(<span class="string">&quot;MyParameters&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create a type definition</span></span><br><span class="line">    ExternalDefinitionCreationOptions option = <span class="keyword">new</span> ExternalDefinitionCreationOptions(<span class="string">&quot;CompanyName&quot;</span>, ParameterType.Text);</span><br><span class="line">    Definition myDefinition_CompanyName = myGroup.Definitions.Create(option);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create a category set and insert category of wall to it</span></span><br><span class="line">    CategorySet myCategories = app.Application.Create.NewCategorySet();</span><br><span class="line">    <span class="comment">// Use BuiltInCategory to get category of wall</span></span><br><span class="line">    Category myCategory = Category.GetCategory(app.ActiveUIDocument.Document, BuiltInCategory.OST_Walls);</span><br><span class="line"></span><br><span class="line">    myCategories.Insert(myCategory);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Create an object of TypeBinding according to the Categories</span></span><br><span class="line">    TypeBinding typeBinding = app.Application.Create.NewTypeBinding(myCategories);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get the BingdingMap of current document.</span></span><br><span class="line">    BindingMap bindingMap = app.ActiveUIDocument.Document.ParameterBindings;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Bind the definitions to the document</span></span><br><span class="line">    <span class="built_in">bool</span> typeBindOK = bindingMap.Insert(myDefinition_CompanyName, typeBinding,</span><br><span class="line">        BuiltInParameterGroup.PG_TEXT);</span><br><span class="line">    <span class="keyword">return</span> typeBindOK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Instance-Binding"><a href="#Instance-Binding" class="headerlink" title="Instance Binding"></a>Instance Binding</h4><p>InstanceBinding对象指示参数定义和某些类别实例中的参数之间的绑定。</p>
<p>Once bound, the parameter appears in all property dialog boxes for the instance (if the visible property is set to true). Changing the parameter in any one instance does not change the value in any other instance.<br>绑定后，该参数将显示在实例的所有属性对话框中（如果visible属性设置为true）。在任何一个实例中更改参数不会更改任何其他实例中的值。</p>
<p>The following code sample demonstrates how to add parameter definitions using a shared parameter file. Parameter definitions are added in the following order:<br>下面的代码示例演示如何使用共享参数文件添加参数定义。参数定义按以下顺序添加：</p>
<ol>
<li>A shared parameter file is created<br>创建共享参数文件</li>
<li>A definition group and a definition for all Walls instances is created<br>将创建所有墙实例的定义组和定义</li>
<li>Definitions are bound to each wall instance parameter in the current document based on the wall category.<br>定义将根据墙类别绑定到当前文档中的每个墙实例参数。</li>
</ol>
<p>代码区域22-8：使用共享参数文件添加实例参数定义</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">SetNewParameterToInstanceWall</span>(<span class="params">UIApplication app, DefinitionFile myDefinitionFile</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// create a new group in the shared parameters file</span></span><br><span class="line">    DefinitionGroups myGroups = myDefinitionFile.Groups;</span><br><span class="line">    DefinitionGroup myGroup = myGroups.Create(<span class="string">&quot;MyParameters1&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create an instance definition in definition group MyParameters</span></span><br><span class="line">    ExternalDefinitonCreationOptions option = <span class="keyword">new</span> ExternalDefinitonCreationOptions(<span class="string">&quot;Instance_ProductDate&quot;</span>, ParameterType.Text);</span><br><span class="line">    <span class="comment">// Don&#x27;t let the user modify the value, only the API</span></span><br><span class="line">    option.UserModifiable = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// Set tooltip</span></span><br><span class="line">    option.Description = <span class="string">&quot;Wall product date&quot;</span>;</span><br><span class="line">    Definition myDefinition_ProductDate = myGroup.Definitions.Create(option);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create a category set and insert category of wall to it</span></span><br><span class="line">    CategorySet myCategories = app.Application.Create.NewCategorySet();</span><br><span class="line">    <span class="comment">// use BuiltInCategory to get category of wall</span></span><br><span class="line">    Category myCategory = Category.GetCategory(app.ActiveUIDocument.Document, BuiltInCategory.OST_Walls);</span><br><span class="line"></span><br><span class="line">    myCategories.Insert(myCategory);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Create an instance of InstanceBinding</span></span><br><span class="line">    InstanceBinding instanceBinding = app.Application.Create.NewInstanceBinding(myCategories);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get the BingdingMap of current document.</span></span><br><span class="line">    BindingMap bindingMap = app.ActiveUIDocument.Document.ParameterBindings;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Bind the definitions to the document</span></span><br><span class="line">    <span class="built_in">bool</span> instanceBindOK = bindingMap.Insert(myDefinition_ProductDate,</span><br><span class="line">                                    instanceBinding, BuiltInParameterGroup.PG_TEXT);</span><br><span class="line">    <span class="keyword">return</span> instanceBindOK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="SharedParameterElement"><a href="#SharedParameterElement" class="headerlink" title="SharedParameterElement"></a>SharedParameterElement</h3><p>SharedParameterElements存储有关文档中特定用户定义的共享参数的信息</p>
<p>用户定义的参数存储在文档中，并由ParameterElement类表示。子类SharedParameterElement表示加载到文档中的共享参数。ParemeterElement也是GlobalParameter的基类。</p>
<p>一旦共享参数被加载到文档中，就可以从SharedParameterElement类中检索有关它的信息。SharedParameterElement从父ParameterElement类继承GetDefinition()方法。GetDefinition()返回表示文档中参数定义的InternalDefinition，而不是存储在共享参数文件中的共享参数的ExternalDefinition。SharedParameterElement还通过GuidValue属性提供对标识共享参数的Guid的访问。</p>
<p>该类的静态Create()方法可以从ExternalDefinition在文档中创建一个新的SharedParameterElement。</p>
<p>静态函数可以从给定的Guid中检索SharedParameterElement。</p>
<p>在下面的示例中，明细表包含一个表示共享参数值的字段。从SharedParameterElement检索共享参数的定义。</p>
<p>代码区域：获取共享参数的定义</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Check if a given shared parameter in a schedule can vary across groups</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">CanParamVaryAcrossGroups</span>(<span class="params">ViewSchedule schedule, <span class="built_in">string</span> sharedParamName</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">bool</span> variesAcrossGroups = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> numFields =  schedule.Definition.GetFieldCount();</span><br><span class="line">    <span class="comment">// Find the field with the given name</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; numFields; i++)</span><br><span class="line">       &#123;</span><br><span class="line">              ScheduleField field = schedule.Definition.GetField(i);</span><br><span class="line">        <span class="keyword">if</span> (field.GetName().Contains(sharedParamName))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Get the SharedParameterElement from the field&#x27;s parameter id</span></span><br><span class="line">            SharedParameterElement spe = schedule.Document.GetElement(field.ParameterId) <span class="keyword">as</span> SharedParameterElement;</span><br><span class="line">            <span class="keyword">if</span> (spe != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                InternalDefinition definition = spe.GetDefinition();</span><br><span class="line">                variesAcrossGroups = definition.VariesAcrossGroups;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> variesAcrossGroups;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SharedParameterElements在使用RebarContainers时特别有用。可以将共享参数作为覆盖添加到RebarContainer的参数管理器中。shared参数不需要绑定到要作为覆盖添加的任何类别。下面的示例将给定的共享参数作为重写添加到RebarContainer。</p>
<p>代码区域：使用SharedParameterElement重写RebarContainer</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Find the named shared parameter and add it as an override to the parameter manger for the given RebarContainer</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddSharedParameterOverride</span>(<span class="params">RebarContainer container, <span class="built_in">string</span> sharedParamName</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// find the shared parameter guid</span></span><br><span class="line">    FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(container.Document);</span><br><span class="line">    collector.OfClass(<span class="keyword">typeof</span>(SharedParameterElement));</span><br><span class="line">    IEnumerable paramCollector = collector.Cast();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">foreach</span> (SharedParameterElement spe <span class="keyword">in</span> paramCollector)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (spe.Name.CompareTo(sharedParamName) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            RebarContainerParameterManager paramManager = container.GetParametersManager();</span><br><span class="line">            paramManager.AddSharedParameterAsOverride(spe.Id);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="全局参数"><a href="#全局参数" class="headerlink" title="全局参数"></a>全局参数</h2><p>全局参数支持通过项目文档中定义的特殊参数控制几何约束。</p>
<p>全局参数可用于标注和报告至&#x2F;自标注，以及设置实例参数的值。它们可用于驱动尺寸或其他元素参数的值，也可由选定尺寸驱动，选定尺寸的值将确定全局参数的值。</p>
<p>本节中的页面</p>
<ul>
<li>管理全局参数</li>
<li>全局参数基础</li>
<li>报告与非报告参数</li>
<li>公式和全局参数</li>
<li>使用全局参数标注标注</li>
</ul>
<h3 id="管理全局参数"><a href="#管理全局参数" class="headerlink" title="管理全局参数"></a>管理全局参数</h3><p>GlobalParametersManager类提供对特定模型中的全局参数元素的常规信息和数据的访问。</p>
<p>GlobalParametersManager提供了管理项目文档中全局参数的主要访问点。它提供了静态方法来访问和重新排序全局参数，并测试名称的唯一性和ID的有效性。</p>
<h4 id="全局参数-1"><a href="#全局参数-1" class="headerlink" title="全局参数"></a>全局参数</h4><p>仅在项目文档中支持全局参数，而在族文档中不支持全局参数。然而，即使有项目文件，在某些情况下也可能暂时或永久地不允许使用全局参数。AreGlobalParametersAllowed()方法将指示在指定文档中是否允许全局参数。</p>
<p>如果允许在项目文档中使用全局参数，请使用方法GetAllGlobalParameters()获取指定文档中的所有全局参数，或使用GetGlobalParametersOrdered()获取全局参数的有序列表。检索有序列表时，项目的顺序与Revit用户界面中标准“全局参数”对话框中全局参数的显示顺序相对应。</p>
<p>要按名称获取全局参数，请调用FindByName()，它将返回命名的全局参数的ElementId，如果没有找到具有给定名称的全局参数，则返回ElementId.InvalidElementId。由于全局参数名称必须是唯一的，因此应在创建新的GlobalParameter之前调用IsUniqueName()方法来检查名称。</p>
<p>给定全局参数的ElementId，IsValidGlobalParameter()将确认给定的ElementId是有效的全局参数id。</p>
<p>下面的示例演示如何获取所有全局参数（如果文档中允许全局参数）。</p>
<p>代码区域：获取全局参数</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> Returns all global parameter elements defined in the given document. </span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> </span></span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> Revit project document.</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> A set of ElementIds of global parameter elements</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ISet <span class="title">GetAllGlobalParameters</span>(<span class="params">Document document</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Global parameters are not available in all documents.</span></span><br><span class="line">    <span class="comment">// They are available in projects, but not in families.</span></span><br><span class="line">    <span class="keyword">if</span> (GlobalParametersManager.AreGlobalParametersAllowed(document))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> GlobalParametersManager.GetAllGlobalParameters(document);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// return an empty set if global parameters are not available in the document</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HashSet();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="重新排序全局参数"><a href="#重新排序全局参数" class="headerlink" title="重新排序全局参数"></a>重新排序全局参数</h4><p>GlobalParametersManager提供了更改项目文档中全局参数的给定顺序的方法。这些操作对全局参数本身没有影响。重新排列的顺序仅在Revit的标准“全局参数”对话框中可见，并反映在GetGlobalParametersOrdered()方法中。</p>
<ul>
<li>SortParameters()-按字母顺序的升序或降序对全局参数进行排序，但仅在其各自的参数组范围内。</li>
<li>MoveParameterDownOrder()-按当前顺序向下移动给定参数。</li>
<li>MoveParameterUpOrder()-将给定参数按当前顺序上移。一个参数只能在其参数组内移动，所以如果一个参数因为位于其组的边界而不能再移动，MoveParameter方法将返回False。</li>
</ul>
<h3 id="全局参数基础"><a href="#全局参数基础" class="headerlink" title="全局参数基础"></a>全局参数基础</h3><p>GlobalParameter类表示项目文档中的全局参数，可用于创建和修改全局参数。</p>
<h4 id="创建全局参数"><a href="#创建全局参数" class="headerlink" title="创建全局参数"></a>创建全局参数</h4><p>全局参数只能在项目文档中创建，而不能在族中创建。全局参数通过静态Create()方法在给定文档中创建，具有给定的名称和参数类型。每个新参数在文档中必须有一个唯一的名称，可以使用静态GlobalParametersManager.IsUniqueName()方法确定该名称。全局参数几乎可以使用任何类型的数据创建，但有几种类型目前不受支持，例如ElementId类型。使用静态GlobalParameter.IsValidDataType()方法测试特定数据类型是否适合全局参数。</p>
<p>代码区域：创建新的全局参数</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> </span></span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> Creates a new Global Parameter of type Length, assigns it an initial value,</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> and uses it to label a set of input dimension elements.</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> </span></span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> Revit project document in which to create the parameter.</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> Name of the global parameter to create.</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> A value the new global parameter is to have.</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> A set of dimension to labe by the new global parameter.</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> ElementId of the new GlobalParameter</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ElementId <span class="title">CreateNewGlobalParameter</span>(<span class="params">Document document, String name, <span class="built_in">double</span> <span class="keyword">value</span>, ISet dimensionsToLabel</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!GlobalParametersManager.AreGlobalParametersAllowed(document))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> System.InvalidOperationException(<span class="string">&quot;Global parameters are not permitted in the given document&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!GlobalParametersManager.IsUniqueName(document, name))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> System.ArgumentException(<span class="string">&quot;Global parameter with such name already exists in the document&quot;</span>, <span class="string">&quot;name&quot;</span>);</span><br><span class="line"></span><br><span class="line">    ElementId gpid = ElementId.InvalidElementId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// creation of any element must be in a transaction</span></span><br><span class="line">    <span class="keyword">using</span> (Transaction trans = <span class="keyword">new</span> Transaction(document, <span class="string">&quot;Create Global Parameter&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        trans.Start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// create a GP with the given name and type Length</span></span><br><span class="line">        GlobalParameter gp = GlobalParameter.Create(document, name, ParameterType.Length);</span><br><span class="line">        <span class="keyword">if</span> (gp != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// if created successfully, assign it a value</span></span><br><span class="line">            <span class="comment">// note: parameters of type Length accept Double values</span></span><br><span class="line">            gp.SetValue(<span class="keyword">new</span> DoubleParameterValue(<span class="keyword">value</span>));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// if a collection of dimensions was given, label them with this new parameter</span></span><br><span class="line">            <span class="keyword">foreach</span> (ElementId elemid <span class="keyword">in</span> dimensionsToLabel)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// not just any dimension is allowed to be labeled</span></span><br><span class="line">                <span class="comment">// check first to avoid exceptions</span></span><br><span class="line">                <span class="keyword">if</span> (gp.CanLabelDimension(elemid))</span><br><span class="line">                &#123;</span><br><span class="line">                    gp.LabelDimension(elemid);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            gpid = gp.Id;</span><br><span class="line">        &#125;</span><br><span class="line">        trans.Commit();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> gpid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="获取和设置全局参数的值"><a href="#获取和设置全局参数的值" class="headerlink" title="获取和设置全局参数的值"></a>获取和设置全局参数的值</h4><p>所有全局参数，无论是公式驱动的、尺寸驱动的还是独立的，都有值。可以通过调用GetValue()方法来获取值。该方法返回的对象是从ParameterValue类派生的类之一的实例：</p>
<ul>
<li>IntegerParameterValue </li>
<li>DoubleParameterValue</li>
<li>StringParameterValue</li>
</ul>
<p>所有派生类都只有一个属性Value，它获取或设置相应类型的值。</p>
<p>具体实例由创建时指定的全局参数的类型确定。既不是公式驱动的参数也不是维度驱动的参数（报告）可以被赋值。要使用的方法是SetValue()，它接受GetValue()返回的相同类型的参数值。但是，类型也可以很容易地推导出来：Text参数只接受StringParameterValue。Integer 和 YesNo 参数仅接受IntegerParameterValue。所有其他参数仅接受DoubleParameterValue。</p>
<h4 id="受全局参数影响的元素"><a href="#受全局参数影响的元素" class="headerlink" title="受全局参数影响的元素"></a>受全局参数影响的元素</h4><p>全局参数可以与其他全局参数以及常规族实例参数相关联（常规族实例参数可以通过指定公式将全局参数报告为它们的值）。有两种方法可用于查找参数之间的关系：GlobalParameter.GetAffectedGlobalParameters()和GlobalParameter.GetAffectedElements()。前者返回在其各自的公式中引用特定全局参数的所有其他全局参数。后一个方法返回一组所有元素，其中一些参数由全局参数控制。这两个方法与GlobalParameter.GetLabeledDimensions()一起可以帮助确定模型元素如何通过全局参数相互关联。</p>
<p>可以在Parameter类中找到用于维护元素属性和全局参数之间的关联的方法。</p>
<h3 id="报告与非报告参数"><a href="#报告与非报告参数" class="headerlink" title="报告与非报告参数"></a>报告与非报告参数</h3><p>全局参数类型的最大区别是它们是报告参数还是非报告参数。</p>
<h4 id="什么是报告和非报告参数？"><a href="#什么是报告和非报告参数？" class="headerlink" title="什么是报告和非报告参数？"></a>什么是报告和非报告参数？</h4><p>有几种方法可以对全局参数进行分类，但最重要的分类可能源于GlobalParameter.IsReporting属性，该属性将全局参数分为两组-报告和非报告。报告参数的重要性在于它们的值由报告参数标记的维度驱动。这意味着报告参数的值反映了尺寸（长度或角度）的值，并在尺寸更改时更新。非报告参数的行为方式相反-它们驱动已由其标记的尺寸的值，这导致通过全局参数的值控制模型的几何体。</p>
<p>报告参数在几个方面受到限制。它们只能是“长度”或“角度”类型，这是因为尺寸必须能够驱动值。出于同样的原因，报告参数可能没有公式。</p>
<p>另一方面，非报告参数几乎可以是任何类型（长度、宽度、面积等）。ElementId类型除外。此外，非报告参数可能已分配公式，其中其他全局参数可用作参数。这样，一个全局参数的值可以从其他参数（或多个参数）导出，而其他参数可以是报告或非报告的。</p>
<p>全局参数的其他重要属性是IsDrivenByDimension和IsDrivenByFormula，它们是互斥的-分配了公式的参数不能由维驱动（也不能由报告驱动），反之亦然。</p>
<h4 id="使全局参数报告或不报告"><a href="#使全局参数报告或不报告" class="headerlink" title="使全局参数报告或不报告"></a>使全局参数报告或不报告</h4><p>全局参数在创建时最初是非报告的，但一旦创建了全局参数并且属于合格类型，就可以使用GlobalParameter.IsReporting属性将其设置为报告。使用GlobalParameter.HasValidTypeForReporting()确保可以使特定数据类型进行报告。请注意，当一个参数标记了多个维度后，该参数可能无法进行报告。这是因为报告参数只能标记一个维度（并由一个维驱动）。</p>
<p>生成参数报告的另一种方法是通过GlobalParameter.SetDrivingDimension()方法，该方法通过全局参数标记一个维度，如果尚未报告，则也生成参数报告。</p>
<p>尽管由尺寸驱动的参数会自动生成报告，但由公式驱动的参数则不会。为了设置公式，全局参数必须为非报告参数。因此，在分配公式之前，必须首先将报告参数更改为非报告参数。</p>
<h3 id="公式和全局参数"><a href="#公式和全局参数" class="headerlink" title="公式和全局参数"></a>公式和全局参数</h3><p>公式可以分配给非报告参数。</p>
<p>与族参数一样，可以使用GlobalParameter.SetFormula()方法将公式分配给全局参数。由于要设置公式，全局参数必须为非报告参数，因此在分配公式之前，必须将报告参数更改为非报告参数。</p>
<p>计算公式的值必须与参数的值类型兼容。例如，允许在分配给Double（<strong>Number</strong>）参数的公式中使用<strong>NULL</strong>参数，反之亦然。但是，不允许在公式中的参数类型为<strong>“ether”</strong>或“<strong>Number”</strong>的参数中使用<strong>Length</strong>或<strong>Angle</strong>参数。</p>
<p>公式可以包括所有标准的算术运算和逻辑运算（如函数<strong>and</strong>，<strong>or</strong>，<strong>not</strong>）。逻辑运算的输入必须是布尔值（YesNo类型的参数）。因此，算术运算只能应用于数值。虽然字符串（文本）参数不支持任何操作，但字符串可以用作逻辑<strong>If</strong>操作的结果。根据其类型（和单位），不同值类型的参数可以组合。但是，无单位值（例如<strong>，“”</strong>和<strong>“Number</strong>（double）”）只能相互组合。</p>
<p>由于公式可能会变得非常复杂，并且由于某些公式无法分配给某些参数，因此可以使用IsValidFormula()方法来测试公式对于全局参数是否有效。如果调用SetFormula()时全局参数的公式无效，则将引发异常。</p>
<p>GetFormula()将以字符串的形式返回当前公式。</p>
<p>下面的代码示例创建四个全局参数，然后将公式设置为1，以便它的值为其他两个参数中的任何一个，具体取决于第四个参数的布尔值。</p>
<p>代码区域：设置公式</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetCombinationParameters</span>(<span class="params">Document document</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    GlobalParameter gpB = <span class="literal">null</span>;</span><br><span class="line">    GlobalParameter gpT = <span class="literal">null</span>;</span><br><span class="line">    GlobalParameter gpF = <span class="literal">null</span>;</span><br><span class="line">    GlobalParameter gpX = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> TRUE = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">int</span> FALSE = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// transaction to create global parameters and set their values</span></span><br><span class="line">    <span class="keyword">using</span> (Transaction trans = <span class="keyword">new</span> Transaction(document, <span class="string">&quot;Creating global parameters&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// create 4 new global parameters</span></span><br><span class="line"></span><br><span class="line">        trans.Start();</span><br><span class="line"></span><br><span class="line">        gpB = GlobalParameter.Create(document, <span class="string">&quot;GPB&quot;</span>, ParameterType.YesNo);</span><br><span class="line">        gpT = GlobalParameter.Create(document, <span class="string">&quot;GPT&quot;</span>, ParameterType.Text);</span><br><span class="line">        gpF = GlobalParameter.Create(document, <span class="string">&quot;GPF&quot;</span>, ParameterType.Text);</span><br><span class="line">        gpX = GlobalParameter.Create(document, <span class="string">&quot;GPX&quot;</span>, ParameterType.Text);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// assign initial values and a formula to the global parameters</span></span><br><span class="line"></span><br><span class="line">        gpB.SetValue(<span class="keyword">new</span> IntegerParameterValue(TRUE));</span><br><span class="line">        gpT.SetValue(<span class="keyword">new</span> StringParameterValue(<span class="string">&quot;TypeA&quot;</span>));</span><br><span class="line">        gpF.SetValue(<span class="keyword">new</span> StringParameterValue(<span class="string">&quot;TypeB&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Set the formula to GPX so that its final value is either the value of GPT (TypeA)</span></span><br><span class="line">        <span class="comment">// or GPF (TypeB) depending on whether the value of GPB is True or False.</span></span><br><span class="line">        <span class="comment">// Note: in this particular case we are certain the formula is valid, but if weren&#x27;t </span></span><br><span class="line">        <span class="comment">// certain, we could use a validation method as we are now going to illustrate here:</span></span><br><span class="line">        <span class="built_in">string</span> expression = <span class="string">&quot;if(GPB,GPT,GPF)&quot;</span>; <span class="comment">// XPX &lt;== if (GPB == TRUE) then GPT else GPF</span></span><br><span class="line">        <span class="keyword">if</span> (gpX.IsValidFormula(expression))</span><br><span class="line">        &#123;</span><br><span class="line">            gpX.SetFormula(expression);        &#125;</span><br><span class="line"></span><br><span class="line">        trans.Commit();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// we can test that the formula works</span></span><br><span class="line">    <span class="comment">// since the boolean value is TRUE, the value of the GPX parameter</span></span><br><span class="line">    <span class="comment">// should be the same as the value of the GPT parameters</span></span><br><span class="line"></span><br><span class="line">    StringParameterValue sTrue = gpT.GetValue() <span class="keyword">as</span> StringParameterValue;</span><br><span class="line">    StringParameterValue sFalse = gpF.GetValue() <span class="keyword">as</span> StringParameterValue;</span><br><span class="line">    StringParameterValue sValue = gpX.GetValue() <span class="keyword">as</span> StringParameterValue;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sValue.Value != sTrue.Value)</span><br><span class="line">    &#123;</span><br><span class="line">        TaskDialog.Show(<span class="string">&quot;Error&quot;</span>, <span class="string">&quot;Unexpected value of a global parameter&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// we can also test that evaluation of the formula is affected by changes</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> (Transaction trans = <span class="keyword">new</span> Transaction(document, <span class="string">&quot;Change value of a YesNo parameter&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        trans.Start();</span><br><span class="line">        gpB.SetValue(<span class="keyword">new</span> IntegerParameterValue(FALSE));</span><br><span class="line">        trans.Commit();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sValue = gpX.GetValue() <span class="keyword">as</span> StringParameterValue;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sValue.Value != sFalse.Value)</span><br><span class="line">    &#123;</span><br><span class="line">        TaskDialog.Show(<span class="string">&quot;Error&quot;</span>, <span class="string">&quot;Unexpected value of a global parameter&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用全局参数标注标注"><a href="#使用全局参数标注标注" class="headerlink" title="使用全局参数标注标注"></a>使用全局参数标注标注</h3><p>全局参数的一个关键特性是它们能够“标记”尺寸。</p>
<p>当维度由全局参数标记时，其值要么由参数控制（非报告），要么驱动参数的值（报告）。需要注意的是，报告参数最多只能标记一个维对象，这意味着参数只能由一个维驱动。如果尺寸标注有多个线段，并且由非报告参数标记，则每个线段的值将由该参数驱动。多段维不能用报告参数标记。</p>
<p>如果该维度已被另一个全局参数标记，则再次标记它将自动将其与该参数分离。</p>
<p>目前，只能标记单个<strong>线性</strong>和<strong>角度</strong>尺寸，但也有其他限制。使用CanLabelDimension()方法来确定是否可以标记特定的维度元素。此外，由于参数的值和由其标记的尺寸相互依赖，因此全局参数的数据类型必须是<strong>Length</strong>或<strong>Angle</strong>，因为这是尺寸可以表示的唯一单位。</p>
<p>下面的示例创建一个全局参数，并使用它来标记给定维度元素集。</p>
<p>代码区域：标签尺寸</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">DriveSelectedDimensions</span>(<span class="params">Document document, <span class="built_in">string</span> name, <span class="built_in">double</span> <span class="keyword">value</span>, ISet dimset</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!GlobalParametersManager.AreGlobalParametersAllowed(document))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> System.InvalidOperationException(<span class="string">&quot;Global parameters are not permitted in the given document&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!GlobalParametersManager.IsUniqueName(document, name))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> System.ArgumentException(<span class="string">&quot;Global parameter with such name already exists in the document&quot;</span>, <span class="string">&quot;name&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">value</span> &lt;= <span class="number">0.0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> System.ArgumentException(<span class="string">&quot;Value of a global parameter that drives dimension must be a positive number&quot;</span>, <span class="string">&quot;value&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> nLabeledDims = <span class="number">0</span>;   <span class="comment">// number of labeled dimensions (for testing)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// creation of any element must be in a transaction</span></span><br><span class="line">    <span class="keyword">using</span> (Transaction trans = <span class="keyword">new</span> Transaction(document, <span class="string">&quot;Create Global Parameter&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        trans.Start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// create a GP with the given name and type Length</span></span><br><span class="line">        <span class="comment">// Note: Length (or Angle) is required type of global parameters that are to label a dimension</span></span><br><span class="line">        GlobalParameter newgp = GlobalParameter.Create(document, name, ParameterType.Length);</span><br><span class="line">        <span class="keyword">if</span> (newgp != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            newgp.SetValue(<span class="keyword">new</span> DoubleParameterValue(<span class="keyword">value</span>));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// use the parameter to label the given dimensions</span></span><br><span class="line">            <span class="keyword">foreach</span> (ElementId elemid <span class="keyword">in</span> dimset)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// not just any dimension is allowed to be labeled</span></span><br><span class="line">                <span class="comment">// check first to avoid exceptions</span></span><br><span class="line">                <span class="keyword">if</span> (newgp.CanLabelDimension(elemid))</span><br><span class="line">                &#123;</span><br><span class="line">                    newgp.LabelDimension(elemid);</span><br><span class="line">                    nLabeledDims += <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            trans.Commit();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// for illustration purposes only, we&#x27;ll test the results of our modifications </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.) Check the new parameter can be found</span></span><br><span class="line"></span><br><span class="line">    ElementId gpid = GlobalParametersManager.FindByName(document,name);</span><br><span class="line">    <span class="keyword">if</span> (gpid == ElementId.InvalidElementId)</span><br><span class="line">    &#123;</span><br><span class="line">        TaskDialog.Show(<span class="string">&quot;Error&quot;</span>, <span class="string">&quot;Failed to find a newly created global parameter&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    GlobalParameter gp = document.GetElement(gpid) <span class="keyword">as</span> GlobalParameter;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. Check the number of labeled dimension is as expected</span></span><br><span class="line"></span><br><span class="line">    ISet labeledSet = gp.GetLabeledDimensions();</span><br><span class="line">    <span class="keyword">if</span> (labeledSet.Count != nLabeledDims)</span><br><span class="line">    &#123;</span><br><span class="line">        TaskDialog.Show(<span class="string">&quot;Error&quot;</span>, <span class="string">&quot;Have not found all the dimension that were labeled.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> labeledSet.Count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SetDrivingDimension()方法结合了两个操作：a）如果参数尚未报告，则进行参数报告，以及B）使用它标记给定维。因此，全局参数必须符合报告条件，并且不得用于标记多个维。有关报告参数的详细信息，请参阅报告参数与非报告参数页面 如果此参数已由另一个维度驱动，则在标记给定的维度之前，将首先取消标记另一个维度。这是因为报告参数一次只能标记一个维度（即，它只能由一个维度驱动）。 下一个示例创建由尺寸值驱动的全局参数。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">AssignDrivingDimension</span>(<span class="params">Document document, ElementId gpid, ElementId dimid</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// we expect to find the global parameter in the document</span></span><br><span class="line">    GlobalParameter gp = document.GetElement(gpid) <span class="keyword">as</span> GlobalParameter;</span><br><span class="line">    <span class="keyword">if</span> (gp == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// we expect to find the given dimension in the document</span></span><br><span class="line">    Dimension dim = document.GetElement(dimid) <span class="keyword">as</span> Dimension;</span><br><span class="line">    <span class="keyword">if</span> (dim == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// not every global parameter can label</span></span><br><span class="line">    <span class="comment">// and not every dimension can be labeled</span></span><br><span class="line">    <span class="keyword">if</span> (!gp.CanLabelDimension(dimid))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// we need a transaction to modify the model</span></span><br><span class="line">    <span class="keyword">using</span> (Transaction trans = <span class="keyword">new</span> Transaction(document,<span class="string">&quot;Assign a driving dimension&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        trans.Start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// we cannot assign a driving dimension to a global</span></span><br><span class="line">        <span class="comment">// parameter that is already used to label other dimensions</span></span><br><span class="line">        ISet dimset = gp.GetLabeledDimensions();</span><br><span class="line">        <span class="keyword">foreach</span> (ElementId elemid <span class="keyword">in</span> dimset)</span><br><span class="line">        &#123;</span><br><span class="line">            gp.UnlabelDimension(elemid);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// with the GP free of all previously labels (if there were any)</span></span><br><span class="line">        gp.SetDrivingDimension(dimid);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// we should be able to commit, but we test the result anyway</span></span><br><span class="line">        <span class="keyword">if</span> (trans.Commit() != TransactionStatus.Committed)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h2><p>Parameter类包含给定参数的值。</p>
<p>Autodesk Revit中的所有图元都包含参数，这些参数可以作为一个集合或单独检索。可以使用BuiltInParameter枚举、Definition对象或Shared Parameter对象从任何Element中获取单个参数对象。参数中包含的数据可以是Double、String、String或ElementId，如其String Type属性所示。对于值类型，DisplayUnitType属性将指示用于参数值的显示单位。Parameter对象还包含一个Definition对象，用于描述参数的数据类型、名称和其他详细信息。</p>
<h3 id="StorageType"><a href="#StorageType" class="headerlink" title="StorageType"></a>StorageType</h3><p>储存类型描述内部存储的参数值的类型。</p>
<p>根据属性值，使用相应的get和set方法来检索和设置参数数据值。</p>
<p>“储存类型”是一种枚举类型，列出了Revit支持的所有内部参数数据存储类型：</p>
<table>
<thead>
<tr>
<th><strong>Member Name 成员名称</strong></th>
<th><strong>Description 描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td><em>String</em></td>
<td>内部数据存储为字符串。</td>
</tr>
<tr>
<td><em>ElementId</em></td>
<td>数据类型表示一个元素，并存储为元素ID。</td>
</tr>
<tr>
<td><em>Double</em></td>
<td>数据在内部存储为8字节浮点数。</td>
</tr>
<tr>
<td><em>Integer</em></td>
<td>内部数据存储为有符号的32位整数。</td>
</tr>
<tr>
<td><em>None</em></td>
<td>无表示无效的存储类型。仅供内部使用。</td>
</tr>
</tbody></table>
<p>在大多数情况下，ElementId值为正数。但是，它可以是负数。当ElementId值为负时，它不表示元素，而是具有另一种含义。例如，梁的垂直投影的存储类型参数为ElementId。当参数值为Level 1或Level 2时，ElementId值为正，并与该级别的ElementId相对应。但是，当参数值设置为“自动检测”、“梁中心”或“梁顶部”时，ElementId值为负值。 下面的代码示例显示如何根据参数的类型检查参数的值是否可以设置为double值：</p>
<p>代码区域：检查参数的类型</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">SetParameter</span>(<span class="params">Parameter parameter, <span class="built_in">double</span> <span class="keyword">value</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">bool</span> result = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//if the parameter is readonly, you can&#x27;t change the value of it</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> != parameter &amp;&amp; !parameter.IsReadOnly)</span><br><span class="line">    &#123;</span><br><span class="line">        StorageType parameterType = parameter.StorageType;</span><br><span class="line">        <span class="keyword">if</span> (StorageType.Double != parameterType)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;The storagetypes of value and parameter are different!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//If successful, the result is true</span></span><br><span class="line">        result = parameter.Set(<span class="keyword">value</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Set()方法返回值指示参数值已更改。Set()方法在参数值被更改时返回true，否则返回false。 并非所有参数都是可写的。如果参数为只读，则引发异常。 ## AsValueString()和SetValueString() 这两个Parameter类方法仅适用于值类型参数，这些参数是表示测量量的双精度或整数参数。 使用AsValueString()方法以带有度量单位的字符串形式获取参数值。例如，“底部偏移”值（墙参数）为“双精度”值。通常，该值在“图元属性”中显示为字符串，如-20 ‘0”。使用AsValueString()方法，您可以直接获得-20 ‘0”字符串值。使用AsDouble()方法，可以得到一个不带度量单位的double值，如-20。 使用SetValueString()方法更改值类型参数的值，而不是使用Set()方法。下面的代码示例说明如何使用SetValueString()方法更改参数值：</p>
<p>使用参数. SetValueString()</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">SetWithValueString</span>(<span class="params">Parameter foundParameter</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">bool</span> result = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (!foundParameter.IsReadOnly)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//If successful, the result is true</span></span><br><span class="line">        result = foundParameter.SetValueString(<span class="string">&quot;-22\&#x27;3\&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="全局参数关联"><a href="#全局参数关联" class="headerlink" title="全局参数关联"></a>全局参数关联</h3><p>Parameter类有几种方法用于维护元素参数和全局参数之间的关联。方法GetAssociatedGlobalParameter()返回当前与参数关联的全局参数的ElementId（如果有）。如果此参数未与任何全局参数关联，则返回InvalidElementId。InvalidElementId也会在为一个甚至不能与全局参数相关联的参数（即一个不可参数化的参数或一个带有公式的参数）调用时返回。</p>
<p>有两种方法可以确定参数是否可以与全局参数关联。参数.CanBeAssociatedWithGlobalParameters()测试参数是否可以与任何全局参数相关联。只有定义为可参数化的属性才能与全局参数相关联。这不包括任何只读参数和公式驱动参数，以及具有Revit施加的其他显式或隐式限制的参数。若要测试特定全局参数是否可以与此参数关联，请使用Parameter.CanBeAssociatedWithGlobalParameter()。请记住，参数的值类型必须与全局参数的类型匹配，才能创建关联。</p>
<p>对于可以与全局参数关联的参数，请使用AssociateWithGlobalParameter()创建关联。关联后，可以在以后通过调用DissociateFromGlobalParameter()方法解除参数关联</p>
<h2 id="注：翻译自Revit-API-Developers-Guide"><a href="#注：翻译自Revit-API-Developers-Guide" class="headerlink" title="注：翻译自Revit API Developers Guide"></a><em><strong>注：</strong></em>翻译自<a href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_html">Revit API Developers Guide</a></h2>]]></content>
      <categories>
        <category>Revit二次开发人员指南</category>
      </categories>
      <tags>
        <tag>Revit</tag>
      </tags>
  </entry>
  <entry>
    <title>06选择</title>
    <url>/2024/12/05/%E4%BA%8C%E5%BC%80%E6%8C%87%E5%8D%97/06%E9%80%89%E6%8B%A9/</url>
    <content><![CDATA[<h1 id="选择"><a href="#选择" class="headerlink" title="选择"></a><a href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_Basic_Interaction_with_Revit_Elements_Selection_html">选择</a></h1><p>您可以使用UIDo.Selection.GetElementIds()方法从当前活动文档中获取所选对象，该方法返回所选元素的ElementIds集合。此方法返回的集合可以直接与FilteredElementCollector一起使用，以筛选选定的元素。</p>
<p>Selection对象还可以用于使用SetElementIds()方法以编程方式更改当前选择。</p>
<p>Pages in this section 本节中的页面</p>
<ul>
<li>Changing the Selection 更改选择</li>
<li>User Selection 用户选择</li>
<li>Filtered User Selection 筛选的用户选择</li>
</ul>
<h2 id="更改选择"><a href="#更改选择" class="headerlink" title="更改选择"></a>更改选择</h2><p>要修改选定的图元，请执行以下操作：</p>
<ol>
<li>创建新的ElementId列表。</li>
<li>把ElementIds放进去。</li>
<li>使用新列表调用SetElementIds()。</li>
</ol>
<p>下面的示例说明了如何通过获取当前选择并仅过滤出墙以设置为新选择来更改选定的元素。</p>
<p><strong>代码区域7-1：更改所选元素</strong></p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ChangeSelection</span>(<span class="params">UIDocument uidoc</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Get selected elements from current document.</span></span><br><span class="line">    ICollection selectedIds = uidoc.Selection.GetElementIds();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Display current number of selected elements</span></span><br><span class="line">    TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>, <span class="string">&quot;Number of selected elements: &quot;</span> + selectedIds.Count.ToString());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Go through the selected items and filter out walls only.</span></span><br><span class="line">    ICollection selectedWallIds = <span class="keyword">new</span> List();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">foreach</span> (ElementId id <span class="keyword">in</span> selectedIds)</span><br><span class="line">    &#123;</span><br><span class="line">        Element elements = uidoc.Document.GetElement(id);</span><br><span class="line">        <span class="keyword">if</span> (elements <span class="keyword">is</span> Wall)</span><br><span class="line">        &#123;</span><br><span class="line">            selectedWallIds.Add(id);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set the created element set as current select element set.</span></span><br><span class="line">    uidoc.Selection.SetElementIds(selectedWallIds);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Give the user some information.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != selectedWallIds.Count)</span><br><span class="line">    &#123;</span><br><span class="line">        TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>, selectedWallIds.Count.ToString() + <span class="string">&quot; Walls are selected!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>,<span class="string">&quot;No Walls have been selected!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="用户选择"><a href="#用户选择" class="headerlink" title="用户选择"></a>用户选择</h2><p>Selection类也有一些方法，允许用户选择新对象，甚至是屏幕上的一个点。这允许用户使用光标选择一个或多个元素（或其他对象，如边或面），然后将控制权返回给应用程序。这些函数不会自动将新选区添加到活动选区集合中。</p>
<ul>
<li>PickObject()方法提示用户在Revit模型中选择对象。</li>
<li>PickObjects()方法提示用户在Revit模型中选择多个对象。</li>
<li>PickElementsByRectangle()方法提示用户使用矩形选择多个元素。</li>
<li>PickPoint()方法提示用户在活动草图平面中拾取点。</li>
<li>PickBox()方法调用一个通用的双击编辑器，让用户在屏幕上指定一个矩形区域。</li>
</ul>
<p>调用PickObject()或PickObject时指定要选择的对象类型。可以指定的对象类型有：元素、PointOnElement、边或面。</p>
<p>当应用程序提示用户拾取对象或元素时，StatusbarTip属性在状态栏中显示一条消息。每个Pick函数都有一个重载，该重载具有一个String参数，可以在其中提供自定义状态消息。</p>
<p>代码区域7-2：使用PickObject()和PickElementsByRectangle()添加选定元素</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">UIDocument uidoc = <span class="keyword">new</span> UIDocument(document);</span><br><span class="line">Selection choices = uidoc.Selection;</span><br><span class="line"><span class="comment">// Pick one object from Revit.</span></span><br><span class="line">Reference hasPickOne = choices.PickObject(ObjectType.Element);</span><br><span class="line"><span class="keyword">if</span> (hasPickOne != <span class="literal">null</span>)</span><br><span class="line">&#123;</span><br><span class="line">    TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>, <span class="string">&quot;One element selected.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Use the rectangle picking tool to identify model elements to select.</span></span><br><span class="line">IList pickedElements = uidoc.Selection.PickElementsByRectangle(<span class="string">&quot;Select by rectangle&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (pickedElements.Count &gt; <span class="number">0</span>)</span><br><span class="line">&#123; </span><br><span class="line">    <span class="comment">// Collect Ids of all picked elements</span></span><br><span class="line">    IList idsToSelect = <span class="keyword">new</span> List(pickedElements.Count);</span><br><span class="line">    <span class="keyword">foreach</span> (Element element <span class="keyword">in</span> pickedElements)</span><br><span class="line">    &#123;</span><br><span class="line">        idsToSelect.Add(element.Id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update the current selection</span></span><br><span class="line">    uidoc.Selection.SetElementIds(idsToSelect);</span><br><span class="line">    TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>, <span class="built_in">string</span>.Format(<span class="string">&quot;&#123;0&#125; elements added to Selection.&quot;</span>, idsToSelect.Count));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>PickPoint()方法有2个重载，其中ObjectSnapTypes参数用于指定用于选择的捕捉类型的类型。可以指定多个，如下一个示例所示。</p>
<p>代码区域7-3：捕捉点</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PickPoint</span>(<span class="params">UIDocument uidoc</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">        ObjectSnapTypes snapTypes = ObjectSnapTypes.Endpoints | ObjectSnapTypes.Intersections;</span><br><span class="line">        XYZ point = uidoc.Selection.PickPoint(snapTypes, <span class="string">&quot;Select an end point or intersection&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">string</span> strCoords = <span class="string">&quot;Selected point is &quot;</span> + point.ToString();</span><br><span class="line"></span><br><span class="line">        TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>, strCoords);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>PickBox()方法接受一个PickBoxStyle枚举器。这些选项包括“交叉”、“包围”和“方向”，前者是选择完全或部分位于框内的对象时使用的样式，后者是选择完全被框包围的对象时使用的样式，前者是框的样式取决于框的绘制方向。如果从右向左绘制，则使用“交叉”样式;如果以相反方向绘制，则使用“包围”样式。 PickBox()返回一个PickedBox，其中包含选定的Min和Max点。以下示例演示了在点云选择中使用PickBox()。</p>
<p>代码区域：PickBox</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PromptForPointCloudSelection</span>(<span class="params">UIDocument uiDoc, PointCloudInstance pcInstance</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Autodesk.Revit.ApplicationServices.Application app = uiDoc.Application.Application;</span><br><span class="line">    Selection currentSel = uiDoc.Selection;</span><br><span class="line"></span><br><span class="line">    PickedBox pickedBox = currentSel.PickBox(PickBoxStyle.Enclosing, <span class="string">&quot;Select region of cloud for highlighting&quot;</span>);</span><br><span class="line"></span><br><span class="line">    XYZ min = pickedBox.Min;</span><br><span class="line">    XYZ max = pickedBox.Max;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Transform points into filter</span></span><br><span class="line">    View view = uiDoc.ActiveView;</span><br><span class="line">    XYZ right = view.RightDirection;</span><br><span class="line">    XYZ up = view.UpDirection;</span><br><span class="line"></span><br><span class="line">    List planes = <span class="keyword">new</span> List();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// X boundaries</span></span><br><span class="line">    <span class="built_in">bool</span> directionCorrect = IsPointAbovePlane(right, min, max);</span><br><span class="line">    planes.Add(Plane.CreateByNormalAndOrigin(right, directionCorrect ? min : max));</span><br><span class="line">    planes.Add(Plane.CreateByNormalAndOrigin(-right, directionCorrect ? max : min));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Y boundaries</span></span><br><span class="line">    directionCorrect = IsPointAbovePlane(up, min, max);</span><br><span class="line">    planes.Add(Plane.CreateByNormalAndOrigin(up, directionCorrect ? min : max));</span><br><span class="line">    planes.Add(Plane.CreateByNormalAndOrigin(-up, directionCorrect ? max : min));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create filter</span></span><br><span class="line">    PointCloudFilter filter = PointCloudFilterFactory.CreateMultiPlaneFilter(planes);</span><br><span class="line">    Transaction t = <span class="keyword">new</span> Transaction(uiDoc.Document, <span class="string">&quot;Highlight&quot;</span>);</span><br><span class="line">    t.Start();</span><br><span class="line">    pcInstance.SetSelectionFilter(filter);</span><br><span class="line">    pcInstance.FilterAction = SelectionFilterAction.Highlight;</span><br><span class="line">    t.Commit();</span><br><span class="line">    uiDoc.RefreshActiveView();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="筛选的用户选择"><a href="#筛选的用户选择" class="headerlink" title="筛选的用户选择"></a>筛选的用户选择</h2><p>PickObject()、PickObjects()和PickElementsByRectangle()都具有将ISelectionFilter作为参数的重载。ISelectionFilter是一个接口，可用于在选择操作期间过滤对象。它有两个可以覆盖的方法：AllowElement()用于指定是否允许选择元素，以及AllowReference()用于指定是否允许选择对一段几何图形的引用。</p>
<p>下面的示例阐释如何使用ISelectionFilter接口将用户的选择限制为“体量”类别中的元素。它不允许选择对几何图元的任何参照。</p>
<p>使用ISelectionFilter限制元素选择</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IList <span class="title">GetManyRefByRectangle</span>(<span class="params">UIDocument doc</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        ReferenceArray ra = <span class="keyword">new</span> ReferenceArray();</span><br><span class="line">        ISelectionFilter selFilter = <span class="keyword">new</span> MassSelectionFilter();</span><br><span class="line">        IList eList = doc.Selection.PickElementsByRectangle(selFilter, </span><br><span class="line">                <span class="string">&quot;Select multiple faces&quot;</span>) <span class="keyword">as</span> IList;</span><br><span class="line">        <span class="keyword">return</span> eList;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MassSelectionFilter</span> : <span class="title">ISelectionFilter</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">AllowElement</span>(<span class="params">Element element</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">if</span> (element.Category.Name == <span class="string">&quot;Mass&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">AllowReference</span>(<span class="params">Reference refer, XYZ point</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下一个示例演示如何使用ISelectionFilter仅允许选择平面。</p>
<p>代码区域7-5：使用ISelectionFilter限制几何选择</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SelectPlanarFaces</span>(<span class="params">Autodesk.Revit.DB.Document document</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        UIDocument uidoc = <span class="keyword">new</span> UIDocument(document);</span><br><span class="line">        ISelectionFilter selFilter = <span class="keyword">new</span> PlanarFacesSelectionFilter(document);</span><br><span class="line">        IList faces = uidoc.Selection.PickObjects(ObjectType.Face, </span><br><span class="line">                selFilter, <span class="string">&quot;Select multiple planar faces&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PlanarFacesSelectionFilter</span> : <span class="title">ISelectionFilter</span></span><br><span class="line">&#123;</span><br><span class="line">        Document doc = <span class="literal">null</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">PlanarFacesSelectionFilter</span>(<span class="params">Document document</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">                doc = document;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">AllowElement</span>(<span class="params">Element element</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">AllowReference</span>(<span class="params">Reference refer, XYZ point</span>)</span></span><br><span class="line">        &#123;                <span class="keyword">if</span> (doc.GetElement(refer).GetGeometryObjectFromReference(refer) <span class="keyword">is</span> PlanarFace)</span><br><span class="line">                &#123;</span><br><span class="line">                        <span class="comment">// Only return true for planar faces. Non-planar faces will not be selectable </span></span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有关从选定元素中检索元素的更多信息，请参见“入门”部分中的演练：检索选定元素。</p>
<h2 id="注：翻译自Revit-API-Developers-Guide"><a href="#注：翻译自Revit-API-Developers-Guide" class="headerlink" title="注：翻译自Revit API Developers Guide"></a><em><strong>注：</strong></em>翻译自<a href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_html">Revit API Developers Guide</a></h2>]]></content>
      <categories>
        <category>Revit二次开发人员指南</category>
      </categories>
      <tags>
        <tag>Revit</tag>
      </tags>
  </entry>
  <entry>
    <title>04元素要点</title>
    <url>/2024/11/26/%E4%BA%8C%E5%BC%80%E6%8C%87%E5%8D%97/04%E5%85%83%E7%B4%A0%E8%A6%81%E7%82%B9/</url>
    <content><![CDATA[<h1 id="元素要点"><a href="#元素要点" class="headerlink" title="元素要点"></a><a href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_Introduction_Elements_Essentials_html">元素要点</a></h1><p>元素对应于单个建筑或绘图构件，例如门、墙或尺寸标注。此外，元素可以是门类型、视图或材质定义。</p>
<h2 id="元素分类"><a href="#元素分类" class="headerlink" title="元素分类"></a>元素分类</h2><p>Revit 图元分为六组：模型、草图、视图、组、注释和信息。每个组都包含相关的元素及其相应的符号。</p>
<h4 id="模型元素"><a href="#模型元素" class="headerlink" title="模型元素"></a>模型元素</h4><p>模型元素表示建筑项目中存在的物理项。“模型元素”组中的元素可以细分为以下元素：</p>
<p>族实例 - 族实例包含族实例对象。可以将族对象载入到项目中，也可以从族样板创建族对象。有关更多信息，请参阅系列实例。</p>
<p>主体图元 - 主体图元包含系统族对象，这些对象可以包含其他模型图元，例如墙、屋顶、天花板和楼板。有关主体图元的更多信息，请参见墙、楼板、屋顶和洞口。</p>
<p>结构元素-结构图元包含仅用于 Revit 结构特征的图元。有关 Structure Elements 的更多信息，请参见 Structural Engineering。</p>
<h4 id="视图元素"><a href="#视图元素" class="headerlink" title="视图元素"></a>视图元素</h4><p>视图图元表示在 Revit 中查看其他对象并与其他对象交互的方式。有关更多信息，请参阅视图。</p>
<h4 id="组元素"><a href="#组元素" class="headerlink" title="组元素"></a>组元素</h4><p>组图元表示辅助图元，例如 Revit 中的“阵列”和“组”对象。有关详细信息，请参阅编辑元素。</p>
<h4 id="注释和基准元素"><a href="#注释和基准元素" class="headerlink" title="注释和基准元素"></a>注释和基准元素</h4><p>注释和基准元素包含可见的非物理项。</p>
<p>注释元素表示在图纸上保持比例的二维构件，并且仅在一个视图中可见。有关注释元素的更多信息，请参阅注释元素。<br>注： 表示 2D 组件的注释元素不仅存在于 2D 视图中。例如，可以在 3D 视图中绘制尺寸，而它们所引用的形状仅存在于 2D 平面中。<br>基准元素表示用于建立项目上下文的非物理项。这些元素可以存在于视图中。基准元素进一步分为以下几部分：</p>
<ul>
<li>通用基准元素 - 通用基准元素表示用于存储建模数据的非物理可见项目。</li>
<li>基准 FamilyInstance - 基准 FamilyInstance 表示加载到项目中或从族模板创建的非物理可见项目。注意有关常用基准元素和基准族实例的更多信息，请参阅基准和信息元素;有关 ModelCurve 相关内容，请参阅草绘。</li>
<li>结构基准元素 - 结构基准元素表示用于存储结构建模数据的非物理可见项目。有关结构基准元素的详细信息，请参阅结构工程。</li>
</ul>
<h4 id="草图元素"><a href="#草图元素" class="headerlink" title="草图元素"></a>草图元素</h4><p>草图元素表示用于草绘 2D&#x2F;3D 形状的临时项目。此组包含族建模和体量分析中使用的以下对象：</p>
<p>SketchPlane 草图平面）</p>
<ul>
<li>Sketch 素描</li>
<li>Path3D 路径3D</li>
<li>GenericForm. 泛型形式。</li>
</ul>
<p>有关草图详细信息，请参阅草图绘制。</p>
<h4 id="信息元素"><a href="#信息元素" class="headerlink" title="信息元素"></a>信息元素</h4><p>信息元素包含用于存储项目和应用程序数据的非物理不可见项。信息元素进一步分为以下几部分：</p>
<ul>
<li>Project Datum Elements 项目基准元素</li>
<li>Project Datum Elements (Unique).项目基准元素 （Unique）。</li>
</ul>
<p>有关基准元素的更多信息，请参阅基准和信息元素。</p>
<h2 id="其他分类"><a href="#其他分类" class="headerlink" title="其他分类"></a>其他分类</h2><p>元素可以按Category, Family, Symbol and Instance.进行分类。</p>
<p>分类之间存在一些关系。例如：</p>
<p>您可以按类别区分不同类型的 FamilyInstances。结构柱等项目位于“结构柱”类别中，梁和支撑位于“结构框架”类别中，依此类推。<br>您可以通过Symbol来区分结构 FamilyInstance 元素。</p>
<h4 id="Category-类别"><a href="#Category-类别" class="headerlink" title="Category 类别"></a>Category 类别</h4><p>Element.Category 属性表示 Element 所属的类别或子类别。它用于标识元素类型。例如，“墙”类别中的任何内容都被视为墙。其他类别包括门和房间。</p>
<p>Category 是最通用的类。 Document.Settings.Categories 属性是一个包含文档中所有 Category 对象的映射，并细分为以下对象：</p>
<ul>
<li>模型类别 - 模型类别包括梁、柱、门、窗和墙。</li>
<li>注释类别 - 注释类别包括维度、网格、级别和文本注释。</li>
</ul>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-4C0CA7CF-C5CF-4042-B99D-AE185F64D17F-low.png" alt="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-4C0CA7CF-C5CF-4042-B99D-AE185F64D17F-low.png"></p>
<p> 图 20：类别</p>
<p>注意：以下指南适用于分类：</p>
<ul>
<li><p>一般而言，以下规则适用于类别：</p>
<ul>
<li><p>每个族对象都属于一个类别</p>
</li>
<li><p>非族对象（如材质和视图）不属于某个类别</p>
</li>
<li><p>也有例外，例如 ProjectInfo，它属于“项目信息”类别。</p>
</li>
</ul>
</li>
<li><p>元素及其对应的符号通常属于同一类别。例如，基本墙及其墙类型“通用 - 8”都属于“墙”类别。</p>
</li>
<li><p>相同类型的元素可以属于不同的类别。例如，SpotDimensions 具有 SpotDimensionType，但它可以属于两个不同的类别：高程点和高程点坐标。</p>
</li>
<li><p>不同的元素可以由于相似性或体系结构原因而属于同一类别。ModelLine 和 DetailLine 位于 Lines 类别中。</p>
</li>
</ul>
<p>要访问类别，您可以从文档的 Settings 类访问所有类别（例如，插入新的类别集），或者如果您只需要访问与内置类别关联的类别对象，您可以直接从 Category 类的静态重载 GetCategory（） 方法访问类别对象。</p>
<p>要访问类别：</p>
<ul>
<li><p>从文档属性中获取类别的完整映射：Document.Settings.Categories 返回一个 CategoryNameMap，其中包含按其名称编制索引的所有 Revit 类别的映射。</p>
</li>
<li><p>通过调用静态方法 Category.GetCategory（） 的相应重载来获取特定的内置类别。</p>
</li>
<li><p>通过调用静态方法 Category.GetCategory（) 的相应重载，按其 ElementId 获取特定类别或子类别。</p>
</li>
<li><p>代码区域 5-1：从文档设置中获取类别</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// Get settings of current document</span></span><br><span class="line">  Settings documentSettings = document.Settings;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get all categories of current document</span></span><br><span class="line">Categories groups = documentSettings.Categories;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Show the number of all the categories to the user</span></span><br><span class="line">String prompt = <span class="string">&quot;Number of all categories in current Revit document:&quot;</span> + groups.Size; </span><br><span class="line"></span><br><span class="line"><span class="comment">// get Floor category according to OST_Floors and show its name</span></span><br><span class="line">Category floorCategory = groups.get_Item(BuiltInCategory.OST_Floors);</span><br><span class="line">prompt += floorCategory.Name;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Give the user some information</span></span><br><span class="line">MessageBox.Show(prompt, <span class="string">&quot;Revit&quot;</span>, MessageBoxButtons.OK);</span><br></pre></td></tr></table></figure></li>
</ul>
<p>Category 的使用方式如下：</p>
<ul>
<li>Category 用于对元素进行分类。元素类别确定某些行为。例如，同一类别中的所有图元都可以包含在同一个明细表中。</li>
<li>元素具有基于其类别的参数。</li>
<li>类别还用于控制 Revit 中的可见性和图形外观。</li>
</ul>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-FD2C68CC-B442-4A39-B507-8965B15B1DCF-low.png" alt="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-FD2C68CC-B442-4A39-B507-8965B15B1DCF-low.png"><br>图 21：按类别划分的可见性</p>
<p>元素的类别由 Category ID 确定。</p>
<ul>
<li>类别 ID 由 ElementId 类表示。</li>
<li>导入的类别 ID 与文档中的元素相对应。</li>
<li>大多数类别都是内置的，它们的 ID 是存储在 ElementId 中的常量。</li>
<li>每个内置类别 ID 在 BuiltInCategory 枚举中都有相应的值。它们可以转换为相应的 BuiltInCategory 枚举类型。</li>
</ul>
<p>如果类别不是内置类别，则 ID 将转换为 null 值。</p>
<p>代码区域 5-2：获取元素类别</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">  Element selectedElement = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">foreach</span> (ElementId id <span class="keyword">in</span> uidoc.Selection.GetElementIds())</span><br><span class="line">    &#123;</span><br><span class="line">        selectedElement = document.GetElement(id);</span><br><span class="line">        <span class="keyword">break</span>;  <span class="comment">// just get one selected element</span></span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Get the category instance from the Category property</span></span><br><span class="line">  Category category = selectedElement.Category;</span><br><span class="line"></span><br><span class="line">BuiltInCategory enumCategory = (BuiltInCategory)category.Id.IntegerValue;</span><br></pre></td></tr></table></figure>

<p>注意：为了避免在使用 Category.Name 时出现全球化问题，BuiltInCategory 是更好的选择。Category.Name 在不同的语言中可能会有所不同。</p>
<h4 id="Family-族"><a href="#Family-族" class="headerlink" title="Family 族"></a>Family 族</h4><p>族是类别中的元素类。族可以按以下方式对图元进行分组：</p>
<ul>
<li>一组通用的参数 （属性）。</li>
<li>相同使用。</li>
<li>类似的图形表示。</li>
</ul>
<p>大多数族都是构件族文件，这意味着您可以将它们加载到项目中或从族模板创建它们。您可以确定属性集和族图形表示。<br>另一种族类型是系统 Family。系统族不可用于加载或创建。Revit 预定义了系统族属性和图形表示;它们包括墙、尺寸、屋顶、楼板（或楼板）和标高。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-428BCB2F-3741-4F05-A51A-9D5A9A03813D-low.png" alt="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-428BCB2F-3741-4F05-A51A-9D5A9A03813D-low.png"></p>
<p>图 22：族</p>
<p>除了用作 Element 类之外，Family 还是用于生成属于 Family 的新项目的模板。</p>
<h4 id="Revit-平台-API-中的族"><a href="#Revit-平台-API-中的族" class="headerlink" title="Revit 平台 API 中的族"></a>Revit 平台 API 中的族</h4><p>在 Revit 平台 API 中，Family 类和 FamilyInstance 都属于构件族。其他元素包括 System Family。</p>
<p>Revit 平台 API 中的族由三个对象表示：</p>
<ul>
<li>Family 族</li>
<li>FamilySymbol  族符号</li>
<li>FamilyInstance  族实例</li>
</ul>
<p>每个对象在 Family 结构中都起着重要作用。</p>
<p>Family 对象具有以下特征：</p>
<ul>
<li>表示整个族，例如梁。</li>
<li>表示磁盘上的整个族文件。</li>
<li>包含许多 FamilySymbol。</li>
</ul>
<p>FamilySymbol 对象表示族中的一组特定族设置，例如类型、混凝土矩形梁：16×32。</p>
<p>FamilyInstance 对象是一个 FamilySymbol 实例，表示 Revit 项目中的单个实例。例如，FamilyInstance 可以是项目中 16×32 混凝土矩形梁的单个实例。</p>
<p>注意：请记住，FamilyInstance 存在于 FamilyInstance 元素、基准元素和注释元素中。</p>
<p>因此，以下规则适用：</p>
<ul>
<li>每个 FamilyInstance 都有一个 FamilySymbol。</li>
<li>每个 FamilySymbol 都属于一个 Family。</li>
<li>每个 Family 都包含一个或多个 FamilySymbol。</li>
</ul>
<p>有关更多详细信息，请参阅系列实例。</p>
<h4 id="ElementType-元素类型"><a href="#ElementType-元素类型" class="headerlink" title="ElementType 元素类型"></a>ElementType 元素类型</h4><p>在 Revit Platform API 中，符号通常是用于定义实例的不可见图元。Symbols 在用户界面中称为Types。</p>
<ul>
<li>Type可以是族中的特定大小，例如 1730 × 2032 的门，也可以是 8×4×1&#x2F;2 的角度。</li>
<li>Type可以是样式，例如尺寸的默认线性或默认角度样式。</li>
</ul>
<p>Symbols表示包含一组类似元素的共享数据的元素。在某些情况下，Symbols表示可以从仓库获取的建筑构件，例如门或窗，并且可以在同一建筑物中多次放置。在其他情况下，Symbols 包含主机对象参数或其他元素。例如，WallType Symbol 包含特定墙壁类型的厚度、层数、每层的材料以及其他属性。</p>
<p>FamilySymbol 是 API 中的一个Symbols。它在 Revit 用户界面中也称为族类型。FamilySymbol 是族中的一类图元，其所有属性的值都完全相同。例如，所有 32×78 个六面板门都属于一种类型，而所有 24×80 个六面板门都属于另一种类型。与 Family 一样，FamilySymbol 也是一个模板。FamilySymbol 对象派生自 ElementType 对象和 Element 对象。</p>
<p>Instance 实例</p>
<p>实例是在建筑 （模型实例） 或绘图图纸 （注释实例） 上具有特定位置的项。Instance 表示 ElementType 的转换后的相同副本。例如，如果建筑物包含 20 个特定类型的窗户，则有一个 ElementType 具有 20 个实例。实例在用户界面中称为 Components。</p>
<p>注意：对于 FamilyInstance，可以使用 Symbol 属性而不是 GetTypeId（） 方法来获取相应的 FamilySymbol。它既方便又安全，因为您不需要进行类型转换。</p>
<h2 id="元素检索"><a href="#元素检索" class="headerlink" title="元素检索"></a>元素检索</h2><p>Revit中的图元非常常见。在对任何 Element 命令使用 API 之前，必须从 Revit 中检索所需的图元。有几种方法可以使用 Revit API 检索图元：</p>
<ul>
<li>ElementId - 如果元素的 ElementId 已知，则可以从文档中检索该元素。</li>
<li>元素过滤和迭代 - 这是检索文档中一组相关元素的好方法。</li>
<li>选定元素 - 检索用户已选定的元素集</li>
<li>特定元素 - 某些元素可用作文档的属性</li>
</ul>
<p>以下各节将更详细地讨论这些元素检索方法中的每一种。</p>
<h4 id="按-ID-获取元素"><a href="#按-ID-获取元素" class="headerlink" title="按 ID 获取元素"></a>按 ID 获取元素</h4><p>当所需元素的 ElementId 已知时，请使用 Document.Element 属性获取该元素。</p>
<h4 id="筛选-Elements-集合"><a href="#筛选-Elements-集合" class="headerlink" title="筛选 Elements 集合"></a>筛选 Elements 集合</h4><p>获取文档中元素的最常见方法是使用筛选来检索元素集合。Revit API 提供了 FilteredElementCollector 类和支持类，用于创建经过过滤的元素集合，然后可以迭代这些元素。有关更多信息，请参阅筛选。</p>
<h4 id="Selection-选择"><a href="#Selection-选择" class="headerlink" title="Selection 选择"></a>Selection 选择</h4><p>您可以只访问已选择的元素，而不是获取模型中所有元素的过滤集合。您可以使用 UIDocument.Selection.GetElementIds 方法从当前活动文档中获取所选对象。有关使用活动选择的更多信息，请参阅选择。</p>
<h4 id="从文档中访问特定元素"><a href="#从文档中访问特定元素" class="headerlink" title="从文档中访问特定元素"></a>从文档中访问特定元素</h4><p>除了使用常规方式访问图元外，Revit Platform API 还在 Document 类中具有属性，用于从当前活动文档中获取指定的图元，而无需迭代所有图元。下表列出了您可以检索的指定元素。</p>
<p>表 11：从文档属性中检索元素</p>
<table>
<thead>
<tr>
<th><strong>Element 元素</strong></th>
<th><strong>Document 属性中的访问</strong></th>
</tr>
</thead>
<tbody><tr>
<td>ProjectInfo 项目信息</td>
<td>Document.ProjectInformation</td>
</tr>
<tr>
<td>ProjectLocation 项目位置</td>
<td>Document.ProjectLocations</td>
</tr>
<tr>
<td>SiteLocation 站点位置</td>
<td>Document.SiteLocation</td>
</tr>
<tr>
<td>Phase 阶段</td>
<td>Document.Phases</td>
</tr>
</tbody></table>
<h2 id="一般属性"><a href="#一般属性" class="headerlink" title="一般属性"></a>一般属性</h2><p>以下特性对于使用 Revit 创建的每个图元都是通用的。</p>
<h4 id="ElementId-元素-Id"><a href="#ElementId-元素-Id" class="headerlink" title="ElementId 元素 Id"></a>ElementId 元素 Id</h4><p>活动文档中的每个元素都有一个唯一标识符，由 ElementId 存储类型表示。ElementId 对象是项目范围的。它是一个唯一编号，在元素模型中永远不会改变，这使得它可以存储在外部，以便在需要时检索元素。<br>在 Revit Platform API 中，您可以直接创建 ElementId，然后将唯一整数值与新的 ElementId 关联。默认情况下，新的 ElementId 值为 0。</p>
<p>代码区域 5-3：设置 ElementId</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Get the id of the element</span></span><br><span class="line">Autodesk.Revit.DB.ElementId selectedId = element.Id;</span><br><span class="line"><span class="built_in">int</span> idInteger = selectedId.IntegerValue;</span><br><span class="line"></span><br><span class="line"><span class="comment">// create a new id and set the value</span></span><br><span class="line">Autodesk.Revit.DB.ElementId id = <span class="keyword">new</span> Autodesk.Revit.DB.ElementId(idInteger);</span><br></pre></td></tr></table></figure>

<p>ElementId 具有以下用途：</p>
<p>使用 ElementId 从 Revit 中检索特定图元。从 Revit Application 类中，获取对活动文档的访问权限，然后使用Document.GetElement（ElementId） 方法获取指定的元素。</p>
<p>代码区域 5-4：使用 ElementId</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Get the id of the element</span></span><br><span class="line">Autodesk.Revit.DB.ElementId selectedId = element.Id;</span><br><span class="line"><span class="built_in">int</span> idInteger = selectedId.IntegerValue;</span><br><span class="line"></span><br><span class="line"><span class="comment">// create a new id and set the value</span></span><br><span class="line">Autodesk.Revit.DB.ElementId id = <span class="keyword">new</span> Autodesk.Revit.DB.ElementId(idInteger);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get the element </span></span><br><span class="line">Autodesk.Revit.DB.Element first = document.GetElement(id);</span><br></pre></td></tr></table></figure>

<p>如果项目中不存在 ID 号，则检索的元素为 null。</p>
<p>使用 ElementId 检查一个项目中的两个元素是否相等。不建议使用 Object.Equal（） 方法。</p>
<h4 id="UniqueId-唯一-Id"><a href="#UniqueId-唯一-Id" class="headerlink" title="UniqueId 唯一 Id"></a>UniqueId 唯一 Id</h4><p>每个元素都有一个 UniqueId，由 String 存储类型表示。UniqueId 对应于 ElementId。但是，与 ElementId 不同，UniqueId 的功能类似于 GUID（全局唯一标识符），它在单独的 Revit 项目中是唯一的。UniqueId 可以帮助您在将 Revit 项目文件导出为其他格式时跟踪元素。</p>
<p>代码区域 5-5：UniqueId</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">String uniqueId = element.UniqueId;</span><br></pre></td></tr></table></figure>

<p>注意：ElementId 仅在当前项目中是唯一的。它在单独的 Revit 项目中不是唯一的。UniqueId 在单独的项目中始终是唯一的。</p>
<h4 id="Location-位置"><a href="#Location-位置" class="headerlink" title="Location 位置"></a>Location 位置</h4><p>在建筑建模过程中，对象的位置非常重要。在Revit中，某些对象具有点位置。例如，一个表有一个点位置。其他对象具有线位置，表示位置曲线或根本没有位置。墙是具有线位置的元素。</p>
<p>Revit Platform API 为大多数图元提供 Location 类和位置功能。例如，它具有 Move（） 和 Rotate（） 方法来平移和旋转元素。但是，Location 类没有可以从中获取坐标等信息的属性。在这种情况下，将 Location 对象降级到其子类（如 LocationPoint 或 LocationCurve），以获取更详细的位置信息并使用对象派生进行控制。</p>
<p>在获取对象的几何图形时，检索元素在项目中的物理位置非常有用。检索位置时，以下规则适用：<br>Wall、Beam 和 Brace 使用 LocationCurve 进行曲线驱动。</p>
<p>Room、RoomTag、SpotDimension、Group、非曲线驱动的 FamilyInstances 以及所有 In-Place-FamilyInstances 都使用 LocationPoint。</p>
<p>在 Revit Platform API 中，曲线驱动意味着元素的几何图形或位置由一个或多个关联的曲线确定。几乎所有的分析模型元素都是曲线驱动的 - 线性荷载和面积荷载、墙、框架元素等。</p>
<p>其他元素无法检索 LocationCurve 或 LocationPoint。他们返回“Location ”，但未提供任何信息。</p>
<p>表 12：元素位置信息</p>
<table>
<thead>
<tr>
<th><strong>位置信息</strong></th>
<th><strong>Elements 元素</strong></th>
</tr>
</thead>
<tbody><tr>
<td>LocationCurve 位置曲线</td>
<td>Wall, Beam, Brace, Structural Truss, LineLoad(without host)</td>
</tr>
<tr>
<td>LocationPoint 位置点</td>
<td>Room, RoomTag, SpotDimension, Group, Column, Mass</td>
</tr>
<tr>
<td>Only Location 仅位置</td>
<td>Level, Floor, some Tags, BeamSystem, Rebar, Reinforcement, PointLoad, AreaLoad(without Host), Span Direction(IndependentTag)</td>
</tr>
<tr>
<td>No Location 无位置</td>
<td>View, LineLoad(with host), AreaLoad(with Host), BoundaryCondition</td>
</tr>
</tbody></table>
<p>注意：还有其他没有 Location 信息的元素。例如，LineLoad（带 host）或 AreaLoad（带 host）没有 Location。</p>
<p>某些 FamilyInstance LocationPoints（例如所有就地 FamilyInstances 和 mass）在创建时被指定为点 （0， 0， 0）。如果转换或移动实例，则 LocationPoint 坐标将更改。</p>
<p>若要更改 Group-s LocationPoint，请执行下列操作之一：</p>
<ul>
<li>在Revit UI中拖动组原点以更改LocationPoint坐标。在此情况下，组 LocationPoint 将更改，而 Group-s 的位置不会更改。</li>
<li>使用 ElementTransformUtils.MoveElement（） 方法移动组以更改 LocationPoint。这将更改 Group location 和 LocationPoint。</li>
</ul>
<p>有关 LocationCurve 和 LocationPoint 的更多信息，请参阅移动元素。</p>
<h4 id="Level-标高"><a href="#Level-标高" class="headerlink" title="Level 标高"></a>Level 标高</h4><p>楼层是有限的水平平面，用作楼层托管或基于楼层的元素（如屋顶、地板和天花板）的参考。Revit Platform API 提供了一个 Level 类，用于表示 Revit 中的标高线。如果元素是基于Level 的，请使用 API 获取元素分配到的 Level 对象。</p>
<p>代码区域 5-6：分配标高</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Get the level object to which the element is assigned.</span></span><br><span class="line"><span class="keyword">if</span> (element.LevelId.Equals(ElementId.InvalidElementId))</span><br><span class="line">&#123;</span><br><span class="line">    TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>,<span class="string">&quot;The element isn&#x27;t based on a level.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    Level level = element.Document.GetElement(element.LevelId) <span class="keyword">as</span> Level;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Format the prompt information(Name and elevation)</span></span><br><span class="line">    String prompt = <span class="string">&quot;The element is based on a level.&quot;</span>;</span><br><span class="line">    prompt += <span class="string">&quot;\nThe level name is:  &quot;</span> + level.Name;</span><br><span class="line">    prompt += <span class="string">&quot;\nThe level elevation is:  &quot;</span> + level.Elevation;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Show the information to the user.</span></span><br><span class="line">    TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>,prompt);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>许多元素（如柱）使用标高作为基本参考。当您获取柱标高时，您检索的标高是基础标高。</p>
<p>注意：使用 Reference Level 参数获取 Beam 或 Brace 标高。从 Level 属性中，您只会获得 null，而不是引用标高信息。标高是 Revit 中最常用的图元。在 Revit 平台 API 中，使用“level  ”过滤器检索所有标高。</p>
<p>有关更多级别详细信息，请参阅基准和信息元素。</p>
<h4 id="Parameter-参数"><a href="#Parameter-参数" class="headerlink" title="Parameter 参数"></a>Parameter 参数</h4><p>每个元素都有一组参数，用户可以在Revit中查看和编辑这些参数。参数在“元素属性”对话框中可见（选择任何元素，然后单击类型选择器旁边的“属性”按钮）。例如，下图显示了房间参数。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-78903670-DCD6-473B-AA90-45A0AA31B65D-low.png" alt="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-78903670-DCD6-473B-AA90-45A0AA31B65D-low.png"></p>
<p>图 25：Room 参数</p>
<p>在 Revit Platform API 中，每个 Element 对象都有一个 Parameters 属性，该属性是附加到 Element 的所有属性的集合。您可以更改集合中的属性值。例如，您可以从房间对象参数中获取房间的面积;此外，您还可以使用房间对象参数设置房间号。Parameter 是提供对元素对象中未公开的属性信息的访问的另一种方法。</p>
<p>通常，每个元素参数都有一个关联的参数 ID。参数 ID 由 ElementId 类表示。对于用户创建的参数，ID 对应于文档中的实际元素。但是，大多数参数都是内置的，其 ID 是存储在 ElementIds 中的常量。</p>
<p>参数是元素中数据存储的通用形式。在 Revit Platform API 中，最好使用内置参数 ID 来获取参数。Revit 具有大量使用 BuiltInParameter 枚举类型的内置参数。</p>
<p>有关详细信息，请参阅参数说明。</p>
<h2 id="注：翻译自Revit-API-Developers-Guide"><a href="#注：翻译自Revit-API-Developers-Guide" class="headerlink" title="注：翻译自Revit API Developers Guide"></a><em><strong>注：</strong></em>翻译自<a href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_html">Revit API Developers Guide</a></h2>]]></content>
      <categories>
        <category>Revit二次开发人员指南</category>
      </categories>
      <tags>
        <tag>Revit</tag>
      </tags>
  </entry>
  <entry>
    <title>05过滤</title>
    <url>/2024/11/26/%E4%BA%8C%E5%BC%80%E6%8C%87%E5%8D%97/05%E8%BF%87%E6%BB%A4/</url>
    <content><![CDATA[<h1 id="Filtering-过滤"><a href="#Filtering-过滤" class="headerlink" title="Filtering 过滤"></a>Filtering 过滤</h1><p>Revit API提供了一种过滤和迭代Revit文档中图元的机制。这是获取一组相关元素（如文档中的所有墙或门）的最佳方法。过滤器也可以用来找到一个非常具体的元素集，如所有特定大小的梁。</p>
<p>获取通过指定过滤器的元素的基本步骤如下：</p>
<ol>
<li>创建新的FilteredElementCollector</li>
<li>对它应用一个或多个过滤器</li>
<li>获取过滤后的元素或元素ID（使用以下几种方法之一）</li>
</ol>
<p>下面的示例涵盖了在文档中筛选和迭代元素的基本步骤。</p>
<p><strong>代码区域6-1：使用元素过滤获取文档中的所有墙实例</strong></p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Find all Wall instances in the document by using category filter</span></span><br><span class="line">ElementCategoryFilter filter = <span class="keyword">new</span> ElementCategoryFilter(BuiltInCategory.OST_Walls);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Apply the filter to the elements in the active document</span></span><br><span class="line"><span class="comment">// Use shortcut WhereElementIsNotElementType() to find wall instances only</span></span><br><span class="line">FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">IList walls = </span><br><span class="line">collector.WherePasses(filter).WhereElementIsNotElementType().ToElements();</span><br><span class="line">String prompt = <span class="string">&quot;The walls in the current document are:\n&quot;</span>;</span><br><span class="line"><span class="keyword">foreach</span> (Element e <span class="keyword">in</span> walls)</span><br><span class="line">&#123;</span><br><span class="line">        prompt += e.Name + <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>, prompt);</span><br></pre></td></tr></table></figure>

<p><strong>Pages in this section 本节中的页面</strong></p>
<ul>
<li>创建FilteredElementCollector</li>
<li>应用过滤器</li>
<li>获取筛选的元素或元素ID</li>
<li>LINQ查询</li>
<li>边界框过滤器</li>
<li>元素交叉过滤器</li>
</ul>
<h2 id="创建FilteredElementCollector"><a href="#创建FilteredElementCollector" class="headerlink" title="创建FilteredElementCollector"></a>创建FilteredElementCollector</h2><p>用于元素迭代和筛选的主类称为FilteredElementCollector。它以三种方式之一构建：</p>
<ol>
<li>从文档-将搜索和筛选文档中的元素集</li>
<li>从一个文档和一组ElementId-将搜索和筛选一组指定的元素</li>
<li>从文档和视图-将搜索和过滤视图中的可见元素</li>
</ol>
<p><em><strong>注意：</strong></em>使用静态FilteredElementCollector.IsViewValidForElementIteration()过滤指定视图中的元素时，请始终检查视图是否对元素迭代有效。</p>
<p>首次创建对象时，没有应用任何过滤器。此类要求在尝试访问元素之前至少设置一个条件，否则将引发异常。</p>
<h2 id="应用过滤器"><a href="#应用过滤器" class="headerlink" title="应用过滤器"></a>应用过滤器</h2><p>可以使用ElementFilters将筛选器应用于FilteredElementCollector。ElementFilter是一个类，它检查元素以查看它是否满足特定条件。ElementFilter基类有三个派生类，它们将元素筛选器分为三个类别。</p>
<ul>
<li><em><strong>ElementQuickFilter</strong></em>-快速过滤器仅在ElementRecord上操作，ElementRecord是一个低内存类，它具有有限的读取元素属性的接口。被快速筛选器拒绝的元素将不会在内存中展开。</li>
<li><em><strong>ElementSlowFilter</strong></em>-慢过滤器要求首先获取元素并在内存中展开。因此，最好将慢速过滤器与至少一个ElementQuickFilter耦合，这应该最小化扩展的元素数量，以便根据该过滤器设置的标准进行评估。</li>
<li><em><strong>ElementLogicalFilter</strong></em>-逻辑筛选器将联合收割机两个或多个筛选器逻辑组合。Revit可能会对构件过滤器重新排序，以使最快作用的过滤器首先被评估。</li>
</ul>
<p>大多数过滤器可以使用重载构造函数来反转，该重载构造函数接受指示反转过滤器的布尔参数，以便通常被过滤器接受的元素将被拒绝，而通常被拒绝的元素将被接受。不能反转的过滤器在下面的相应部分中注明。</p>
<p>有一组预定义的过滤器可用于常见用途。这些内置过滤器中的许多都为上面的FilteredElementCollector部分中提到的FilteredElementCollector快捷方法提供了基础。接下来的三个部分提供了有关内置过滤器的更多信息。</p>
<p>创建筛选器后，需要将其应用于FilteredElementCollector。泛型方法WherePasses()用于将单个ElementFilter应用于FilteredElementCollector。</p>
<p>还可以使用FilteredElementCollector提供的许多快捷方法应用筛选器。有些应用一个特定的过滤器而不需要进一步的输入，比如WhereElementIsCurveDriven()，而其他应用一个特定的过滤器而只需要一个简单的输入，比如OfCategory()方法，它将BuiltInCategory作为一个参数。最后，还有一些方法，如UnionWith()，可以将过滤器连接在一起。所有这些方法都返回相同的收集器，从而可以轻松地将过滤器链接在一起。</p>
<h3 id="Quick-filters-快速筛选器"><a href="#Quick-filters-快速筛选器" class="headerlink" title="Quick filters 快速筛选器"></a>Quick filters 快速筛选器</h3><p>快速过滤器只在ElementRecord上操作，ElementRecord是一个低内存类，它具有有限的读取元素属性的接口。被快速筛选器拒绝的元素将不会在内存中展开。下表总结了内置的快速过滤器，下面是一些过滤器的示例。</p>
<p><strong>Table 13: Built-in Quick Filters<br>表13：内置快速过滤器</strong></p>
<table>
<thead>
<tr>
<th><strong>Built-in Filter 内置过滤器</strong></th>
<th><strong>What it passes 它所经过的</strong></th>
<th><strong>Shortcut Method(s) 快捷方法</strong></th>
</tr>
</thead>
<tbody><tr>
<td>BoundingBoxContainsPointFilter</td>
<td>具有包含给定点的边界框的元素</td>
<td>None</td>
</tr>
<tr>
<td>BoundingBoxIntersectsFilter</td>
<td>具有与给定轮廓相交的边界框的元素</td>
<td>None</td>
</tr>
<tr>
<td>BoundingBoxIsInsideFilter</td>
<td>在给定轮廓内有边界框的元素</td>
<td>None</td>
</tr>
<tr>
<td>ElementCategoryFilter</td>
<td>id 与输入类别id匹配的元素</td>
<td>OfCategoryId()</td>
</tr>
<tr>
<td>ElementClassFilter</td>
<td>与输入运行时类（或派生类）匹配的元素</td>
<td>OfClass()</td>
</tr>
<tr>
<td>ElementDesignOptionFilter</td>
<td>特定设计选项中的图元</td>
<td>ContainedInDesignOption()</td>
</tr>
<tr>
<td>ElementIsCurveDrivenFilter</td>
<td>曲线驱动的元素</td>
<td>WhereElementIsCurveDriven()</td>
</tr>
<tr>
<td>ElementIsElementTypeFilter</td>
<td>属于“元素类型”的元素</td>
<td>WhereElementIsNotElementType()</td>
</tr>
<tr>
<td>ElementMulticategoryFilter</td>
<td>与给定类别集中的任何一个相匹配的元素</td>
<td>None</td>
</tr>
<tr>
<td>ElementMulticlassFilter</td>
<td>与给定的类（或派生类）集匹配的元素</td>
<td>None</td>
</tr>
<tr>
<td>ElementOwnerViewFilter</td>
<td>视图专有的图元</td>
<td>OwnedByView()<br />WhereElementIsViewIndependent()</td>
</tr>
<tr>
<td>ElementStructuralTypeFilter</td>
<td>与给定结构类型匹配的元素</td>
<td>None</td>
</tr>
<tr>
<td>ExclusionFilter</td>
<td>除元素id之外的所有元素都输入到过滤器</td>
<td>Excluding()</td>
</tr>
<tr>
<td>FamilySymbolFilter</td>
<td>特定族的Symbol</td>
<td></td>
</tr>
</tbody></table>
<p><strong>注意：</strong>FamilySymbolFilter不能反转。</p>
<p><strong>注意：</strong>边界框过滤器排除所有从View派生的对象和从ElementType派生的对象。 下面的示例在文档中创建一个大纲，然后使用BoundingBoxIntersectsFilter查找文档中具有与该大纲相交的边界框的元素。然后，它展示了如何使用反向过滤器来查找边界框不与给定轮廓相交的所有墙。请注意，使用OfClass()方法也会将ElementClassFilter应用于集合。</p>
<p><strong>代码区域6-2：BoundingBoxIntersectsFilter示例</strong></p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Use BoundingBoxIntersects filter to find elements with a bounding box that intersects the </span></span><br><span class="line"><span class="comment">// given Outline in the document.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a Outline, uses a minimum and maximum XYZ point to initialize the outline. </span></span><br><span class="line">Outline myOutLn = <span class="keyword">new</span> Outline(<span class="keyword">new</span> XYZ(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="keyword">new</span> XYZ(<span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a BoundingBoxIntersects filter with this Outline</span></span><br><span class="line">BoundingBoxIntersectsFilter filter = <span class="keyword">new</span> BoundingBoxIntersectsFilter(myOutLn);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Apply the filter to the elements in the active document</span></span><br><span class="line"><span class="comment">// This filter excludes all objects derived from View and objects derived from ElementType</span></span><br><span class="line">FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">IList elements = collector.WherePasses(filter).ToElements();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Find all walls which don&#x27;t intersect with BoundingBox: use an inverted filter </span></span><br><span class="line"><span class="comment">// to match elements</span></span><br><span class="line"><span class="comment">// Use shortcut command OfClass() to find walls only</span></span><br><span class="line">BoundingBoxIntersectsFilter invertFilter = <span class="keyword">new</span> BoundingBoxIntersectsFilter(myOutLn, <span class="literal">true</span>);</span><br><span class="line">collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">IList notIntersectWalls = collector.OfClass(<span class="keyword">typeof</span>(Wall)).WherePasses(invertFilter).ToElements();</span><br></pre></td></tr></table></figure>

<p>下一个示例使用排除过滤器查找文档中当前未选定的所有墙。</p>
<p>代码区域6-3：创建排除过滤器</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Find all walls that are not currently selected, </span></span><br><span class="line"><span class="comment">// Get all element ids which are current selected by users, exclude these ids when filtering</span></span><br><span class="line">ICollection selectedIds = uiDocument.Selection.GetElementIds();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Use the selection to instantiate an exclusion filter</span></span><br><span class="line">ExclusionFilter filter = <span class="keyword">new</span> ExclusionFilter(selectedIds);</span><br><span class="line"><span class="comment">// For the sake of simplicity we do not test here whether the selection is empty or not,</span></span><br><span class="line"><span class="comment">// but in production code a proper validation would have to be done to avoid an argument</span></span><br><span class="line"><span class="comment">// exception from the filter&#x27;s consructor.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Apply the filter to the elements in the active document,</span></span><br><span class="line"><span class="comment">// Use shortcut method OfClass() to find Walls only</span></span><br><span class="line">FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(uiDocument.Document);</span><br><span class="line">IList walls = collector.WherePasses(filter).OfClass(<span class="keyword">typeof</span>(Wall)).ToElements();</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>ElementClassFilter将匹配其类与输入类完全匹配的元素，或其类派生自输入类的元素。下面的示例使用ElementClassFilter获取文档中的所有加载。</p>
<p>代码区域6-4：使用ElementClassFilter获取负载</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Use ElementClassFilter to find all loads in the document</span></span><br><span class="line"><span class="comment">// Using typeof(LoadBase) will yield all AreaLoad, LineLoad and PointLoad</span></span><br><span class="line">ElementClassFilter filter = <span class="keyword">new</span> ElementClassFilter(<span class="keyword">typeof</span>(LoadBase));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Apply the filter to the elements in the active document</span></span><br><span class="line">FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">ICollection allLoads = collector.WherePasses(filter).ToElements();</span><br></pre></td></tr></table></figure>

<p>API中有一小部分元素子类不受元素类过滤器支持。这些类型存在于API中，但不存在于Revit的本机对象模型中，这意味着此过滤器不支持这些类型。为了使用类过滤器来查找这些类型的元素，需要使用更高级别的类，然后进一步处理结果以查找仅匹配子类型的元素。</p>
<p><strong>注：</strong>其中一些类型存在专用过滤器。 以下类型受此限制影响：</p>
<table>
<thead>
<tr>
<th><strong>Type 类型</strong></th>
<th><strong>Dedicated Filter 专用过滤器</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Autodesk.Revit.DB.Material的子类</td>
<td>None</td>
</tr>
<tr>
<td>Autodesk.Revit.DB.CurveElement的子类</td>
<td>CurveElementFilter</td>
</tr>
<tr>
<td>Autodesk.Revit.DB.ConnectorElement的子类</td>
<td>None</td>
</tr>
<tr>
<td>Autodesk.Revit.DB.HostedSweep的子类</td>
<td>None</td>
</tr>
<tr>
<td>Autodesk.Revit.DB.Architecture.Room</td>
<td>RoomFilter</td>
</tr>
<tr>
<td>Autodesk.Revit.DB.Mechanical.Space</td>
<td>SpaceFilter</td>
</tr>
<tr>
<td>Autodesk.Revit.DB.Area</td>
<td>AreaFilter</td>
</tr>
<tr>
<td>Autodesk.Revit.DB.Architecture.RoomTag</td>
<td>RoomTagFilter</td>
</tr>
<tr>
<td>Autodesk.Revit.DB.Mechanical.SpaceTag</td>
<td>SpaceTagFilter</td>
</tr>
<tr>
<td>Autodesk.Revit.DB.AreaTag</td>
<td>AreaTagFilter</td>
</tr>
<tr>
<td>Autodesk.Revit.DB.CombinableElement</td>
<td>None</td>
</tr>
<tr>
<td>Autodesk.Revit.DB.Mullion</td>
<td>None</td>
</tr>
<tr>
<td>Autodesk.Revit.DB.Panel</td>
<td>None</td>
</tr>
<tr>
<td>Autodesk.Revit.DB.AnnotationSymbol</td>
<td>None</td>
</tr>
<tr>
<td>Autodesk.Revit.DB.Structure.AreaReinforcementType</td>
<td>None</td>
</tr>
<tr>
<td>Autodesk.Revit.DB.Structure.PathReinforcementType</td>
<td>None</td>
</tr>
<tr>
<td>Autodesk.Revit.DB.AnnotationSymbolType</td>
<td>None</td>
</tr>
<tr>
<td>Autodesk.Revit.DB.Architecture.RoomTagType</td>
<td>None</td>
</tr>
<tr>
<td>Autodesk.Revit.DB.Mechanical.SpaceTagType</td>
<td>None</td>
</tr>
<tr>
<td>Autodesk.Revit.DB.AreaTagType</td>
<td>None</td>
</tr>
<tr>
<td>Autodesk.Revit.DB.Structure.TrussType</td>
<td>None</td>
</tr>
</tbody></table>
<h3 id="Slow-Filters-慢过滤器"><a href="#Slow-Filters-慢过滤器" class="headerlink" title="Slow Filters 慢过滤器"></a>Slow Filters 慢过滤器</h3><p>慢过滤器要求首先获得元素并在内存中展开。因此，最好将慢速过滤器与至少一个ElementQuickFilter耦合，这应该最小化扩展的元素数量，以便根据该过滤器设置的标准进行评估。下表总结了内置的慢速过滤器，下面的几个示例提供了对某些过滤器的深入了解。</p>
<p><strong>表14：内置慢速过滤器</strong></p>
<table>
<thead>
<tr>
<th><strong>Built-in Filter 内置过滤器</strong></th>
<th><strong>What it passes 它所经过的</strong></th>
<th><strong>Shortcut Method(s) 快捷方法</strong></th>
</tr>
</thead>
<tbody><tr>
<td>AreaFilter</td>
<td>Areas 区域</td>
<td>None</td>
</tr>
<tr>
<td>AreaTagFilter</td>
<td>Area tags 面积标记</td>
<td>None</td>
</tr>
<tr>
<td>CurveElementFilter</td>
<td>CurveElements 曲线元素</td>
<td>None</td>
</tr>
<tr>
<td>ElementLevelFilter</td>
<td>与给定级别ID关联的元素</td>
<td>None</td>
</tr>
<tr>
<td>ElementParameterFilter</td>
<td>元素传递一个或多个参数筛选规则</td>
<td>None</td>
</tr>
<tr>
<td>ElementPhaseStatusFilter</td>
<td>给定阶段上具有给定阶段状态的元素</td>
<td>None</td>
</tr>
<tr>
<td>FamilyInstanceFilter</td>
<td>一个特定的族实例</td>
<td>None</td>
</tr>
<tr>
<td>FamilyStructuralMaterialTypeFilter</td>
<td>给定结构材料类型的族元素</td>
<td>None</td>
</tr>
<tr>
<td>PrimaryDesignOptionMemberFilter</td>
<td>任何主设计选项所拥有的图元</td>
<td>None</td>
</tr>
<tr>
<td>RoomFilter</td>
<td>房间</td>
<td>None</td>
</tr>
<tr>
<td>RoomTagFilter</td>
<td>房间标记</td>
<td>None</td>
</tr>
<tr>
<td>SpaceFilter</td>
<td>空间</td>
<td>None</td>
</tr>
<tr>
<td>SpaceTagFilter</td>
<td>空间标签</td>
<td>None</td>
</tr>
<tr>
<td>StructuralInstanceUsageFilter</td>
<td>给定结构用途的族</td>
<td>None</td>
</tr>
<tr>
<td>StructuralMaterialTypeFilter</td>
<td>给定结构材料类型的族</td>
<td>None</td>
</tr>
<tr>
<td>StructuralWallUsageFilter</td>
<td>指定结构墙用途的墙</td>
<td>None</td>
</tr>
<tr>
<td>Element Intersection Filters</td>
<td>与给定图元的实体几何相交的图元</td>
<td>None</td>
</tr>
<tr>
<td>Element Intersection Filters</td>
<td>与给定实体几何相交的元素</td>
<td>None</td>
</tr>
</tbody></table>
<p>以下慢速过滤器不能反转： <em>RoomFilter</em> RoomTagFilter <em>AreaFilter</em> AreaTagFilter <em>SpaceFilter</em> * </p>
<p>FamilyInstanceFilter 如快速过滤器一节所述，有些类不能与ElementClassFilter一起使用。其中一些类，如Room和RoomTag有自己的专用过滤器。</p>
<p> 代码区域6-5：使用房间过滤器</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Use a RoomFilter to find all room elements in the document. It is necessary to use the </span></span><br><span class="line"><span class="comment">// RoomFilter and not an ElementClassFilter or the shortcut method OfClass() because the Room </span></span><br><span class="line"><span class="comment">// class is not supported by those methods.</span></span><br><span class="line">RoomFilter filter = <span class="keyword">new</span> RoomFilter();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Apply the filter to the elements in the active document</span></span><br><span class="line">FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">IList rooms = collector.WherePasses(filter).ToElements();</span><br></pre></td></tr></table></figure>

<p>ElementParameterFilter是一个功能强大的过滤器，可以根据元素可能具有的参数值查找元素。它可以查找参数值与特定值匹配或大于或小于某个值的元素。ElementParameterFilter还可用于查找支持特定共享参数的元素。 下面的示例使用ElementParameterFilter查找大小超过100平方英尺的房间和小于100平方英尺的房间。</p>
<p>代码区域6-6：使用参数过滤器</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Creates an ElementParameter filter to find rooms whose area is </span></span><br><span class="line"><span class="comment">// greater than specified value</span></span><br><span class="line"><span class="comment">// Create filter by provider and evaluator </span></span><br><span class="line">BuiltInParameter areaParam = BuiltInParameter.ROOM_AREA;</span><br><span class="line"><span class="comment">// provider</span></span><br><span class="line">ParameterValueProvider pvp = <span class="keyword">new</span> ParameterValueProvider(<span class="keyword">new</span> ElementId((<span class="built_in">int</span>)areaParam));</span><br><span class="line"><span class="comment">// evaluator</span></span><br><span class="line">FilterNumericRuleEvaluator fnrv = <span class="keyword">new</span> FilterNumericGreater();</span><br><span class="line"><span class="comment">// rule value </span></span><br><span class="line"><span class="built_in">double</span> ruleValue = <span class="number">100.0f</span>;      <span class="comment">// filter room whose area is greater than 100 SF</span></span><br><span class="line"><span class="comment">// rule</span></span><br><span class="line">FilterRule fRule = <span class="keyword">new</span> FilterDoubleRule(pvp, fnrv, ruleValue, <span class="number">1E-6</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create an ElementParameter filter</span></span><br><span class="line">ElementParameterFilter filter = <span class="keyword">new</span> ElementParameterFilter(fRule);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Apply the filter to the elements in the active document</span></span><br><span class="line">FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">IList rooms = collector.WherePasses(filter).ToElements();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Find rooms whose area is less than or equal to 100: </span></span><br><span class="line"><span class="comment">// Use inverted filter to match elements</span></span><br><span class="line">ElementParameterFilter lessOrEqualFilter = <span class="keyword">new</span> ElementParameterFilter(fRule, <span class="literal">true</span>); </span><br><span class="line">collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">IList lessOrEqualFounds = collector.WherePasses(lessOrEqualFilter).ToElements();</span><br></pre></td></tr></table></figure>

<p>下面的示例显示如何使用FamilyStructuralMaterialTypeFilter查找材质类型为木材的所有族。它还说明了如何使用反向过滤器来查找材质类型不是木材的所有族。</p>
<p>代码区域6-7：查找所有使用木质材料的家庭</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Use FamilyStructuralMaterialType filter to find families whose material type is Wood</span></span><br><span class="line">FamilyStructuralMaterialTypeFilter filter = <span class="keyword">new</span> FamilyStructuralMaterialTypeFilter(StructuralMaterialType.Wood);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Apply the filter to the elements in the active document</span></span><br><span class="line">FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">ICollection woodFamiles = collector.WherePasses(filter).ToElements();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Find families are not Wood: Use inverted filter to match families</span></span><br><span class="line">FamilyStructuralMaterialTypeFilter notWoodFilter = </span><br><span class="line">        <span class="keyword">new</span> FamilyStructuralMaterialTypeFilter(StructuralMaterialType.Wood, <span class="literal">true</span>);</span><br><span class="line">collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">ICollection notWoodFamilies = collector.WherePasses(notWoodFilter).ToElements();</span><br></pre></td></tr></table></figure>

<p>最后两个慢过滤器派生自ElementIntersectsFilter，后者是用于匹配与几何体相交的元素的过滤器的基类。有关此类过滤器的使用示例，请参见几何工具类一节中的代码区域：查找附近的墙。#逻辑过滤器逻辑过滤器联合收割机将两个或多个过滤器逻辑组合。下表总结了内置的逻辑筛选器。表15：内置逻辑过滤器</p>
<table>
<thead>
<tr>
<th><strong>Built-in Filter 内置过滤器</strong></th>
<th><strong>What it passes 它所经过的</strong></th>
<th><strong>Shortcut Method(s) 快捷方法</strong></th>
</tr>
</thead>
<tbody><tr>
<td>LogicalAndFilter</td>
<td>通过2个或更多过滤器的元素</td>
<td>WherePasses()-添加一个额外的过滤器IntersectWith()-连接两组独立的过滤器</td>
</tr>
<tr>
<td>LogicalOrFilter</td>
<td>至少通过2个或多个过滤器之一的元素</td>
<td>UnionWith()-连接两组独立的过滤器</td>
</tr>
</tbody></table>
<p>在下面的示例中，使用逻辑过滤器组合了两个快速过滤器，以获取文档中的所有door FamilyInstance元素。</p>
<p>代码区域6-8：使用LogicalAndFilter查找所有门实例</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Find all door instances in the project by finding all elements that both belong to the</span></span><br><span class="line"><span class="comment">// door category and are family instances.</span></span><br><span class="line">ElementClassFilter familyInstanceFilter = <span class="keyword">new</span> ElementClassFilter(<span class="keyword">typeof</span>(FamilyInstance));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a category filter for Doors</span></span><br><span class="line">ElementCategoryFilter doorsCategoryfilter = </span><br><span class="line">        <span class="keyword">new</span> ElementCategoryFilter(BuiltInCategory.OST_Doors);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a logic And filter for all Door FamilyInstances</span></span><br><span class="line">LogicalAndFilter doorInstancesFilter = <span class="keyword">new</span> LogicalAndFilter(familyInstanceFilter, </span><br><span class="line">        doorsCategoryfilter);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Apply the filter to the elements in the active document</span></span><br><span class="line">FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">IList doors = collector.WherePasses(doorInstancesFilter).ToElements();</span><br></pre></td></tr></table></figure>



<h2 id="获取筛选的元素或元素ID"><a href="#获取筛选的元素或元素ID" class="headerlink" title="获取筛选的元素或元素ID"></a>获取筛选的元素或元素ID</h2><p>将一个或多个过滤器应用于FilteredElementCollector后，可以通过以下三种方式之一来检索已过滤的元素集：</p>
<ol>
<li>获取Elements或ElementId的集合。<ul>
<li>ToElements()-返回通过所有应用的过滤器的所有元素</li>
<li>ToElementIds()-返回通过所有应用过滤器的所有元素的ElementIds</li>
</ul>
</li>
<li>获取与筛选器匹配的第一个Element或ElementId。<ul>
<li>FirstElement()-返回第一个元素以通过所有应用的过滤器</li>
<li>FirstElementId()-返回第一个元素的id，以通过所有应用的过滤器</li>
</ul>
</li>
<li>获取ElementId或Element迭代器。<ul>
<li>GetElementIdIterator()-将FilteredElementIdIterator返回到通过过滤器的元素id</li>
<li>GetElementIterator()-将FilteredElementIterator返回给通过过滤器的元素</li>
<li>GetEnumerator()-返回一个IEnumerator，它遍历传递元素的集合</li>
</ul>
</li>
</ol>
<p>一次只能使用这些组中的一个方法;如果调用另一个方法来提取元素，收集器将重置。因此，如果您之前已经获得了一个迭代器，那么当您调用另一个方法来提取元素时，它将停止并且不再遍历任何元素。</p>
<p>哪种方法最好取决于应用。如果只需要一个匹配元素，那么FirstElement()或FirstElementId()是最佳选择。如果需要所有匹配的元素，请使用ToElements()。如果需要一个变量，使用迭代器。</p>
<p>如果应用程序将删除元素或对过滤列表中的元素进行重大更改，ToElementIds()或元素id迭代器是最佳选择。这是因为删除元素或对元素进行重大更改会使元素句柄无效。对于元素id，对具有ElementId的Document.GetElement()的调用将始终返回有效的Element（如果元素已被删除，则返回空引用）。</p>
<p>使用ToElements()方法将筛选结果作为元素集合获取，允许使用foreach检查集合中的每个元素，如下所示：</p>
<p>代码区域6-9：使用ToElements()获取筛选结果</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Use ElementClassFilter to find all loads in the document</span></span><br><span class="line"><span class="comment">// Using typeof(LoadBase) will yield all AreaLoad, LineLoad and PointLoad</span></span><br><span class="line">ElementClassFilter filter = <span class="keyword">new</span> ElementClassFilter(<span class="keyword">typeof</span>(LoadBase));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Apply the filter to the elements in the active document</span></span><br><span class="line">FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">collector.WherePasses(filter);</span><br><span class="line">ICollection allLoads = collector.ToElements();</span><br><span class="line"></span><br><span class="line">String prompt = <span class="string">&quot;The loads in the current document are:\n&quot;</span>;</span><br><span class="line"><span class="keyword">foreach</span> (Element loadElem <span class="keyword">in</span> allLoads)</span><br><span class="line">&#123;</span><br><span class="line">        LoadBase load = loadElem <span class="keyword">as</span> LoadBase;</span><br><span class="line">        prompt += load.GetType().Name +  <span class="string">&quot;: &quot;</span> + </span><br><span class="line">                        load.Name + <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>, prompt);</span><br></pre></td></tr></table></figure>

<p>当只需要一个传递元素时，使用FirstElement()：</p>
<p>代码区域6-10：获取第一个通过的元素</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Create a filter to find all columns</span></span><br><span class="line">StructuralInstanceUsageFilter columnFilter = </span><br><span class="line">        <span class="keyword">new</span> StructuralInstanceUsageFilter(StructuralInstanceUsage.Column);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Apply the filter to the elements in the active document</span></span><br><span class="line">FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">collector.WherePasses(columnFilter);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get the first column from the filtered results</span></span><br><span class="line"><span class="comment">// Element will be a FamilyInstance</span></span><br><span class="line">FamilyInstance column = collector.FirstElement() <span class="keyword">as</span> FamilyInstance;</span><br></pre></td></tr></table></figure>

<p>在某些情况下，FirstElement()是不够的。下一个示例显示如何使用扩展方法获取第一个非模板3D视图（这对于ReferenceIntersector构造函数的输入很有用）。</p>
<p>代码区域6-11：使用扩展方法获取第一个传递元素</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Use filter to find a non-template 3D view</span></span><br><span class="line"><span class="comment">// This example does not use FirstElement() since first filterd view3D might be a template</span></span><br><span class="line">FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">Func&lt;View3D, <span class="built_in">bool</span>&gt; isNotTemplate = v3 =&gt; !(v3.IsTemplate);</span><br><span class="line"></span><br><span class="line"><span class="comment">// apply ElementClassFilter</span></span><br><span class="line">collector.OfClass(<span class="keyword">typeof</span>(View3D));</span><br><span class="line"></span><br><span class="line"><span class="comment">// use extension methods to get first non-template View3D</span></span><br><span class="line">View3D view3D = collector.Cast().First(isNotTemplate);</span><br></pre></td></tr></table></figure>

<p>The following example demonstrates the use of the FirstElementId() method to get one passing element (a 3d view in this case) and the use of ToElementIds() to get the filter results as a collection of element ids (in order to delete a set of elements in this case).<br>下面的示例演示了使用FirstElementId()方法获取一个传递元素（本例中为3D视图），以及使用ToElementIds()获取作为元素ID集合的过滤结果（本例中为删除一组元素）。</p>
<p>代码区域6-12：使用得到过滤器结果作为元素id</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Use shortcut OfClass to get View elements</span></span><br><span class="line">collector.OfClass(<span class="keyword">typeof</span>(View3D));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get the Id of the first view</span></span><br><span class="line">ElementId viewId = collector.FirstElementId();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Test if the view is valid for element filtering</span></span><br><span class="line"><span class="keyword">if</span> (FilteredElementCollector.IsViewValidForElementIteration(document, viewId))</span><br><span class="line">&#123;</span><br><span class="line">        FilteredElementCollector viewCollector = <span class="keyword">new</span> FilteredElementCollector(document, viewId);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Get all FamilyInstance items in the view</span></span><br><span class="line">        viewCollector.OfClass(<span class="keyword">typeof</span>(FamilyInstance));</span><br><span class="line">        ICollection familyInstanceIds = viewCollector.ToElementIds();</span><br><span class="line"></span><br><span class="line">        document.Delete(familyInstanceIds);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在下面的示例中使用了GetElementIterator()方法，该方法循环访问已筛选的元素以检查某些管道的流状态。</p>
<p>代码区域6-13：以元素迭代器的形式获取结果</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Apply a filter to get all pipes in the document</span></span><br><span class="line">collector.OfClass(<span class="keyword">typeof</span>(Autodesk.Revit.DB.Plumbing.Pipe));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get results as an element iterator and look for a pipe with</span></span><br><span class="line"><span class="comment">// a specific flow state</span></span><br><span class="line">FilteredElementIterator elemItr = collector.GetElementIterator();</span><br><span class="line">elemItr.Reset();</span><br><span class="line"><span class="keyword">while</span> (elemItr.MoveNext())</span><br><span class="line">&#123;</span><br><span class="line">        Pipe pipe = elemItr.Current <span class="keyword">as</span> Pipe;</span><br><span class="line">        <span class="keyword">if</span> (pipe.FlowState == PipeFlowState.LaminarState)</span><br><span class="line">        &#123;</span><br><span class="line">                TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>, <span class="string">&quot;Model has at least one pipe with Laminar flow state.&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者，过滤结果可以作为元素id迭代器返回：</p>
<p>代码区域6-14：以元素id迭代器的形式获取结果</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Use a RoomFilter to find all room elements in the document. </span></span><br><span class="line">RoomFilter filter = <span class="keyword">new</span> RoomFilter();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Apply the filter to the elements in the active document</span></span><br><span class="line">FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">collector.WherePasses(filter);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get results as ElementId iterator</span></span><br><span class="line">FilteredElementIdIterator roomIdItr = collector.GetElementIdIterator();</span><br><span class="line">roomIdItr.Reset();</span><br><span class="line"><span class="keyword">while</span> (roomIdItr.MoveNext())</span><br><span class="line">&#123;</span><br><span class="line">        ElementId roomId = roomIdItr.Current;</span><br><span class="line">        <span class="comment">// Warn rooms smaller than 50 SF</span></span><br><span class="line">        Room room = document.GetElement(roomId) <span class="keyword">as</span> Room;</span><br><span class="line">        <span class="keyword">if</span> (room.Area &lt; <span class="number">50.0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                String prompt = <span class="string">&quot;Room is too small: id = &quot;</span> + roomId.ToString();</span><br><span class="line">                TaskDialog.Show(<span class="string">&quot;Revit&quot;</span>, prompt);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在某些情况下，针对给定的过滤器测试单个元素，而不是获取通过过滤器的所有元素，可能会很有用。ElementFilter.PassesFilter()有两个重载，它们根据筛选器测试给定的Element或ElementId，如果元素通过筛选器，则返回true。</p>
<h2 id="LINQ查询"><a href="#LINQ查询" class="headerlink" title="LINQ查询"></a>LINQ查询</h2><p>在.NET中，FilteredElementCollector类支持Elements的IEEETM接口。您可以将此类与LINQ查询和操作一起使用来处理元素列表。请注意，由于此类提供的ElementFilters和快捷方法在生成托管包装之前处理本机代码中的元素，因此在尝试使用LINQ查询处理结果之前，在收集器上使用尽可能多的本机筛选器将获得更好的性能。</p>
<p>The following example uses an ElementClassFilter to get all FamilyInstance elements in the document, and then uses a LINQ query to narrow down the results to those FamilyInstances with a specific name.<br>下面的示例使用ElementClassFilter获取文档中的所有FamilyInstance元素，然后使用LINQ查询将结果范围缩小到具有特定名称的FamilyInstance。</p>
<p>代码区域6-15：使用LINQ查询</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Use ElementClassFilter to find family instances whose name is 60&quot; x 30&quot; Student </span></span><br><span class="line">ElementClassFilter filter = <span class="keyword">new</span> ElementClassFilter(<span class="keyword">typeof</span>(FamilyInstance));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Apply the filter to the elements in the active document</span></span><br><span class="line">FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">collector.WherePasses(filter);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Use Linq query to find family instances whose name is 60&quot; x 30&quot; Student</span></span><br><span class="line"><span class="keyword">var</span> query = <span class="keyword">from</span> element <span class="keyword">in</span> collector</span><br><span class="line">                        <span class="keyword">where</span> element.Name == <span class="string">&quot;60\&quot; x 30\&quot; Student&quot;</span></span><br><span class="line">                        <span class="keyword">select</span> element;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Cast found elements to family instances, </span></span><br><span class="line"><span class="comment">// this cast to FamilyInstance is safe because ElementClassFilter for FamilyInstance was used</span></span><br><span class="line">List familyInstances = query.Cast().ToList();</span><br></pre></td></tr></table></figure>

<h2 id="边界框过滤器"><a href="#边界框过滤器" class="headerlink" title="边界框过滤器"></a>边界框过滤器</h2><p> BoundingBox过滤器：</p>
<ul>
<li>BoundingBoxIsInsideFilter</li>
<li>BoundingBoxIntersectsFilter</li>
<li>BoundingBoxContainsPointFilter</li>
</ul>
<p>帮助您查找其边界框满足特定条件的元素。您可以检查每个元素的边界框是否在给定体积内，是否与给定体积相交，或者是否包含给定点。也可以反向执行此检查，以查找不与体积相交或不包含给定点的元素。</p>
<p>BoundingBox过滤器使用Outline作为其输入。Outline是一个表示直角棱柱的类，其轴与Revit世界坐标系对齐。</p>
<p>这些过滤器最适合于实际几何形状与其边界框的几何形状紧密匹配的形状。示例可能包括曲线与X或Y方向对齐的线性墙、由此类墙形成的矩形房间、与此类墙对齐的楼板或屋顶，或者合理的矩形族。否则，可能会出现误报，因为元素的边界框可能比实际几何形状大得多。(在这些情况下，您可以使用实际图元的几何图形来确定图元是否真正满足条件）。</p>
<h2 id="元素交叉过滤器"><a href="#元素交叉过滤器" class="headerlink" title="元素交叉过滤器"></a>元素交叉过滤器</h2><p> 元素过滤器：</p>
<ul>
<li>ElementIntersectsElementFilter</li>
<li>ElementIntersectsSolidFilter</li>
</ul>
<p>其实际三维几何体与目标对象的三维几何体相交的过程元素。</p>
<p>使用ElementIntersectsElementFilter，目标对象是另一个元素。交点的确定与Revit在生成冲突报告期间确定是否存在冲突时使用的逻辑相同。(意味着某些图元组合永远不会通过此过滤器，例如在相交处自动连接的混凝土构件，或也从干涉检查中排除的场地图元）。此外，没有实心几何图形的图元（如钢筋）也不会通过此过滤器。</p>
<p>使用ElementIntersectsSolidFilter，目标对象是任何实体。该实体可以从现有图元中获得，使用GeometryCreationUtilities中的例程从头开始创建，或者是布尔运算等二次运算的结果。与ElementIntersectsElementFilter类似，此过滤器不会传递缺少实心几何图形的元素。</p>
<p>两个过滤器都可以反转以匹配目标对象体积之外的元素。</p>
<p>这两个过滤器都是慢速过滤器，因此最好与一个或多个快速过滤器（如类或类别过滤器）组合使用。</p>
<p> 代码区域：使用ElementIntersectsSolidFilter匹配阻止禁用出口到门的元素</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> </span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> Finds any Revit physical elements which interfere with the target </span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> solid region surrounding a door.</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> This routine is useful for detecting interferences which are </span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> violations of the Americans with Disabilities Act or other local disabled </span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> access codes.</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> The door instance.</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> The accessibility region calculated</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> to surround the approach of the door.</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> Because the geometric parameters of this region are code- and </span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> door-specific, calculation of the geometry of the region is not </span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> demonstrated in this example.</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> A collection of interfering element ids.</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> ICollection <span class="title">FindElementsInterferingWithDoor</span>(<span class="params">FamilyInstance doorInstance, Solid doorAccessibilityRegion</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// Setup the filtered element collector for all document elements.</span></span><br><span class="line">   FilteredElementCollector interferingCollector = </span><br><span class="line">      <span class="keyword">new</span> FilteredElementCollector(doorInstance.Document);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Only accept element instances</span></span><br><span class="line">   interferingCollector.WhereElementIsNotElementType();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Exclude intersections with the door itself or the host wall for the door.</span></span><br><span class="line">   List excludedElements = <span class="keyword">new</span> List();</span><br><span class="line">   excludedElements.Add(doorInstance.Id);</span><br><span class="line">   excludedElements.Add(doorInstance.Host.Id);</span><br><span class="line">   ExclusionFilter exclusionFilter = <span class="keyword">new</span> ExclusionFilter(excludedElements);</span><br><span class="line">   interferingCollector.WherePasses(exclusionFilter);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Set up a filter which matches elements whose solid geometry intersects </span></span><br><span class="line">   <span class="comment">// with the accessibility region</span></span><br><span class="line">   ElementIntersectsSolidFilter intersectionFilter = </span><br><span class="line">      <span class="keyword">new</span> ElementIntersectsSolidFilter(doorAccessibilityRegion);</span><br><span class="line">   interferingCollector.WherePasses(intersectionFilter);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Return all elements passing the collector</span></span><br><span class="line">   <span class="keyword">return</span> interferingCollector.ToElementIds();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="注：翻译自Revit-API-Developers-Guide"><a href="#注：翻译自Revit-API-Developers-Guide" class="headerlink" title="注：翻译自Revit API Developers Guide"></a><em><strong>注：</strong></em>翻译自<a href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_html">Revit API Developers Guide</a></h2>]]></content>
      <categories>
        <category>Revit二次开发人员指南</category>
      </categories>
      <tags>
        <tag>Revit</tag>
      </tags>
  </entry>
  <entry>
    <title>03应用及文档</title>
    <url>/2024/11/26/%E4%BA%8C%E5%BC%80%E6%8C%87%E5%8D%97/03%E5%BA%94%E7%94%A8%E5%8F%8A%E6%96%87%E6%A1%A3/</url>
    <content><![CDATA[<h1 id="Application及Document"><a href="#Application及Document" class="headerlink" title="Application及Document"></a><a href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_Introduction_Application_and_Document_html">Application及Document</a></h1><p>Revit 平台 API 中的顶级对象是Application和Document。这些类由 Application、UIApplication、Document 和 UIDocument 类表示。</p>
<p>Application对象是指单个 Revit 任务，提供对文档、选项和其他应用程序范围的数据和设置的访问。</p>
<p>Autodesk.Revit.UI.UIApplication - 提供对应用程序的 UI 级界面的访问，包括将 RibbonPanel 添加到用户界面的功能，以及在用户界面中获取活动文档的功能。</p>
<p>Autodesk.Revit.ApplicationServices.Application - 提供对所有其他应用程序级别属性的访问。</p>
<p>Document是表示建筑模型的单个 Revit 项目文件。Revit 可以打开多个项目，并为一个项目打开多个视图。</p>
<p>Autodesk.Revit.UI.UIDocument - 提供对文档的 UI 级界面的访问，例如选择的内容以及提示用户进行选择和选取点的功能。</p>
<p>Autodesk.Revit.DB.Document - 提供对所有其他文档级别属性的访问。</p>
<p>如果打开了多个文档，则活动文档是其视图在 Revit 任务中处于活动状态的文档。</p>
<p>本章介绍了所有Application和Document，然后重点介绍文件管理、设置和单位。有关 Element 类的更多详细信息，请参阅 Elements Essentials和 编辑元素 ，并参阅 视图 以了解有关视图元素的更多详细信息。</p>
<h2 id="Applicaion功能"><a href="#Applicaion功能" class="headerlink" title="Applicaion功能"></a>Applicaion功能</h2><p>Application和 UIApplication 成员提供对应用程序范围的数据和设置以及 Revit 的活动会话的访问。</p>
<h4 id="Application-应用"><a href="#Application-应用" class="headerlink" title="Application 应用"></a>Application 应用</h4><p>该类表示 Autodesk Revit 应用程序，提供对文档、选项和其他应用程序范围的数据和设置的访问。</p>
<h4 id="应用程序版本信息"><a href="#应用程序版本信息" class="headerlink" title="应用程序版本信息"></a>应用程序版本信息</h4><p>应用程序属性包括 VersionBuild、VersionNumber 和 VersionName。这些属性可用于根据 Revit 的发布和内部版本提供附加模块行为，如如何使用应用程序属性为附加模块强制实施正确的版本所示。</p>
<h4 id="应用程序范围的设置"><a href="#应用程序范围的设置" class="headerlink" title="应用程序范围的设置"></a>应用程序范围的设置</h4><p>Revit 一次使用一个共享参数文件。Application.OpenSharedParameterFile() 方法访问其路径在 SharedParametersFilename 属性中设置的共享参数文件。有关更多详细信息，请参阅共享参数。</p>
<h4 id="库内容"><a href="#库内容" class="headerlink" title="库内容"></a>库内容</h4><p>GetLibraryPaths() 和 SetLibraryPaths() 方法提供对路径信息的访问，用于标识 Revit 搜索内容的位置。</p>
<h4 id="图形显示"><a href="#图形显示" class="headerlink" title="图形显示"></a>图形显示</h4><p>BackgroundColor 属性允许读取和写入此会话中用于模型视图的背景颜色。AllowNavigationDuringRedraw 属性启用或禁用允许在重绘期间进行视图操作的选项。这可用于在重绘模型期间优化性能。</p>
<h4 id="文档管理"><a href="#文档管理" class="headerlink" title="文档管理"></a>文档管理</h4><p>Application 类提供了用于创建以下类型文档的方法：</p>
<ul>
<li>Family document 族文件</li>
<li>Project document 项目文档</li>
<li>Project template 项目模板</li>
</ul>
<p>OpenDocumentFile() 方法可用于打开这些文档类型中的任何一种。所有打开的文档都可以使用 Documents 属性进行检索。<br>有关更多详细信息，请参阅文档和文件管理。</p>
<h4 id="会话信息"><a href="#会话信息" class="headerlink" title="会话信息"></a>会话信息</h4><p>UserName 等属性和GetRevitServerNetworkHosts() 等方法提供对此会话特定信息的只读访问。</p>
<h4 id="登录信息"><a href="#登录信息" class="headerlink" title="登录信息"></a>登录信息</h4><p>静态 IsLoggedIn 属性检查用户是否已从此会话登录到其 Autodesk A360 帐户。如果用户已登录，则 LoginUserId 属性将返回当前登录的用户的用户 ID。（如果用户未登录，则用户 ID 将为空。与上一节中的 UserName 不同，LoginUserId 值不是可识别的值，而是内部 ID。结合 Store Entitlement REST API，Autodesk 应用程序的发布者可以验证当前用户是否已从 Autodesk App Store 购买了其应用程序。有关 Store Entitlement API 的更多信息，请参阅 <a href="http://www.autodesk.com/developapps%E3%80%82">www.autodesk.com/developapps。</a></p>
<h4 id="共享参数管理"><a href="#共享参数管理" class="headerlink" title="共享参数管理"></a>共享参数管理</h4><h4 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h4><p>Application 类公开 document 和 application 事件，例如 document open 和 save。订阅这些事件会在启用事件时通知应用程序并采取相应的措施。有关更多详细信息，请参阅 Add-In Integration 部分中的事件。</p>
<h4 id="创造"><a href="#创造" class="headerlink" title="创造"></a>创造</h4><p>“Create ”属性返回一个对象工厂，该对象工厂用于在 Revit 平台 API 中创建应用程序范围的实用程序和几何对象。如果要在 Revit Revit application memory （而不是your application’s memory）中创建对象，则使用“Create ”。</p>
<p>失败发布和处理</p>
<p>包含所有已注册的 FailureDefinitions 的 FailureDefinitionRegistry 可从静态 GetFailureDefinitionRegistry () 方法获得。静态方法 RegisterFailuresProcessor() 可用于注册自定义 IFailuresProcessor。有关发布和处理失败的更多信息，请参阅失败发布和处理。</p>
<h4 id="断开连接警告"><a href="#断开连接警告" class="headerlink" title="断开连接警告"></a>断开连接警告</h4><p>以下属性控制是否显示各种类型断开连接的图形警告。</p>
<ul>
<li>ShowGraphicalWarningCableTrayConduitDisconnects</li>
<li>ShowGraphicalWarningDuctDisconnects</li>
<li>ShowGraphicalWarningElectricalDisconnects</li>
<li>ShowGraphicalWarningHangerDisconnects</li>
</ul>
<h4 id="UIApplication"><a href="#UIApplication" class="headerlink" title="UIApplication"></a>UIApplication</h4><p>此类表示 Autodesk Revit 用户界面的活动会话，提供对 UI 自定义方法、事件和活动文档的访问。<br>文档管理</p>
<p>UIApplication 使用 UIActiveDocument 属性提供对活动文档的访问。此外，可以使用重载的 OpenAndActivateDocument() 方法打开 Revit 文档。文档将在默认视图处于活动状态的情况下打开。此方法不能在事务中调用，并且只能在事件期间调用 Revit 中尚未打开活动文档，并且该事件未嵌套在其他事件中。</p>
<h4 id="插件管理"><a href="#插件管理" class="headerlink" title="插件管理"></a>插件管理</h4><p>ActiveAddInId 属性获取当前活动的外部应用程序或外部命令 ID，而 LoadedApplications 属性返回成功加载的外部应用程序的数组。</p>
<h4 id="功能区面板实用程序"><a href="#功能区面板实用程序" class="headerlink" title="功能区面板实用程序"></a>功能区面板实用程序</h4><p>使用 UIApplication 对象将新的功能区面板和控件添加到 Revit。<br>有关更多详细信息，请参阅“加载项集成”部分中的 Ribbon 面板和控件。</p>
<h4 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h4><p>DrawingAreaExtents 属性返回一个矩形，该矩形表示绘图区域的屏幕像素坐标，而 MainWindowExtents 属性返回一个矩形，该矩形表示 Revit 主窗口的屏幕像素坐标</p>
<h4 id="事件-1"><a href="#事件-1" class="headerlink" title="事件"></a>事件</h4><p>UIApplication 类公开与 UI 相关的事件，例如显示对话框时。订阅这些事件会在启用事件时通知应用程序并采取相应的措施。有关更多详细信息，请参阅 Add-In Integration 部分中的事件。</p>
<h3 id="学科控制"><a href="#学科控制" class="headerlink" title="学科控制"></a>学科控制</h3><p>The properties:</p>
<ul>
<li>Application.IsArchitectureEnabled</li>
<li>Application.IsStructureEnabled</li>
<li>Application.IsStructuralAnalysisEnabled</li>
<li>Application.IsMassingEnabled</li>
<li>Application.IsEnergyAnalysisEnabled</li>
<li>Application.IsSystemsEnabled</li>
<li>Application.IsMechanicalEnabled</li>
<li>Application.IsMechanicalAnalysisEnabled</li>
<li>Application.IsElectricalEnabled</li>
<li>Application.IsElectricalAnalysisEnabled</li>
<li>Application.IsPipingEnabled</li>
<li>Application.IsPipingAnalysisEnabled</li>
</ul>
<p>提供对可用学科的 READ 和 MODIFY 访问权限。应用程序可以读取属性以确定何时启用或禁用其 UI 的各个方面。</p>
<p>切换领域状态时，Revit 的 UI 将进行调整，并且将根据需要启用或禁用某些操作和功能。启用分析模式仅在启用相应专业时生效。例如，除非还启用了机械专业，否则启用 Mechanical Analysis 不会生效。</p>
<h3 id="如何使用Application属性为外接程序强制实施正确的版本"><a href="#如何使用Application属性为外接程序强制实施正确的版本" class="headerlink" title="如何使用Application属性为外接程序强制实施正确的版本"></a>如何使用Application属性为外接程序强制实施正确的版本</h3><p>有时，由于存在特定的修复或兼容的 API，您需要仅在存在特定的 Revit Update Release 的情况下运行附加模块。</p>
<p>使用“Application”的属性可以检查 Revit 的特定版本。属性 VersionNumber 将返回表示主版本号的字符串，而 VersionBuild 属性将返回 Autodesk Revit 应用程序的内部内部版本号。</p>
<p>另一个有用的属性是 Application.SubVersionNumber 属性。它返回一个字符串，该字符串表示 Revit 应用程序的主要-次要版本号，例如“2018.0.0”。Autodesk 会针对所有主要和次要更新更新更新此字符串。小版本（如 2018.1.0）可能具有初始客户版本（如 2018.0.0）中未提供的其他 API 和功能。为支持初始版本而编写的加载项可能与订阅更新兼容，但在订阅更新中使用新功能的加载项将与初始版本不兼容。</p>
<p>以下示例代码演示了一种技术，用于确定 Revit 版本是否为初始已知 Revit 版本之后的任何 Update Release。</p>
<p>代码区域：使用 VersionBuild 确定您的外接程序是否兼容</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetVersionInfo</span>(<span class="params">Autodesk.Revit.ApplicationServices.Application app</span>)</span></span><br><span class="line">&#123; </span><br><span class="line">   <span class="comment">// 20110309_2315 is the datecode of the initial release of Revit 2012 </span></span><br><span class="line">   <span class="keyword">if</span> (app.VersionNumber == <span class="string">&quot;2012&quot;</span> &amp;&amp; </span><br><span class="line">       String.Compare(app.VersionBuild, <span class="string">&quot;20110309_2315&quot;</span>) &gt; <span class="number">0</span>)</span><br><span class="line">   &#123;</span><br><span class="line">       TaskDialog.Show(<span class="string">&quot;Supported version&quot;</span>, </span><br><span class="line">                      <span class="string">&quot;This application supported in this version.&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">   &#123;</span><br><span class="line">       TaskDialog dialog = <span class="keyword">new</span> TaskDialog(<span class="string">&quot;Unsupported version.&quot;</span>);</span><br><span class="line">       dialog.MainIcon = TaskDialogIcon.TaskDialogIconWarning;</span><br><span class="line">       dialog.MainInstruction = <span class="string">&quot;This Revit 2012 application is supported in UR1 and later releases.&quot;</span>;</span><br><span class="line">       dialog.Show();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Document功能"><a href="#Document功能" class="headerlink" title="Document功能"></a>Document功能</h2><p>Document存储 Revit 图元、管理数据并更新多个数据视图。Document 类主要提供以下功能。</p>
<p>Document </p>
<p>Document 类表示打开的 Autodesk Revit 项目。</p>
<p>Settings 属性</p>
<p>Settings 属性返回一个对象，该对象提供对 Revit 项目中常规组件的访问。有关更多详细信息，请参阅设置。</p>
<p>地点和位置</p>
<p>每个项目只有一个场地位置，用于标识 Earth 上的物理项目位置。一个工程可以有多个工程位置。每个位置都是站点位置的偏移或旋转。有关更多详细信息，请参阅地点和位置。</p>
<p>视图管理</p>
<p>一个项目文档可以有多个视图。ActiveView 属性返回表示活动视图的 View 对象。您可以过滤项目中的图元以检索其他视图。有关更多详细信息，请参阅 视图。</p>
<p>元素检索</p>
<p>Document 对象将元素存储在项目中。使用 Element 属性按 ElementId 或 UniqueId 检索特定元素。<br>有关更多详细信息，请参阅 Elements Essential。</p>
<p>文件管理</p>
<p>每个 Document 对象都代表一个 Revit 项目文件。Document 提供如下功能：<br>检索文件信息，例如文件路径名和项目标题。<br>提供 Close() 和 Save() 方法来关闭和保存文档。<br>有关更多详细信息，请参阅文档和文件管理。</p>
<p>元素管理</p>
<p>Revit 会保留项目中的所有图元对象。要创建新图元，请使用“Create”属性，该属性返回用于在 Revit 平台 API 中创建新项目图元实例（如 FamilyInstance 或 Group）的对象工厂。<br>Document 类还可用于删除元素。使用 Delete() 方法删除项目中的元素。已删除的元素和任何从属元素不会显示，并且会从文档中删除。对已删除元素的引用无效，并会导致异常。有关更多详细信息，请参阅编辑元素。</p>
<p>事件</p>
<p>某些操作会引发事件，例如当您使用 Save 或 Save As 保存项目时。要在应用程序中捕获事件并做出响应，必须注册事件处理程序。有关更多详细信息，请参阅 事件。</p>
<p>文档状态</p>
<p>多个属性提供有关文档状态的信息：</p>
<ul>
<li>IsModifiable - 当前是否可以修改文档（这意味着文档中有一个活动事务，并且更改不会被其他任何内容暂时阻止）</li>
<li>IsModified - 文档在打开或保存后是否发生更改</li>
<li>IsReadOnly - 如果为 true，则文档当前为只读且无法修改</li>
<li>IsReadOnlyFile - 文档是否以只读模式打开</li>
<li>IsFamilyDocument - 文档是否为家庭文档</li>
<li>IsWorkshared - 是否已在文档中启用工作集</li>
</ul>
<p>其他</p>
<p>Document 还提供其他功能：</p>
<ul>
<li>ParameterBindings 属性 - 参数定义和类别之间的映射。有关更多详细信息，请参阅共享参数。</li>
<li>ReactionsAreUpToDate 属性 - 报告反作用载荷是否发生变化。有关更多详细信息，请参阅负载。</li>
<li>Default Types - 访问族和非族元素的默认类型。有关更多详细信息，请参阅默认类型。</li>
</ul>
<p>UIDocument</p>
<p>UIDocument 类表示在 Revit 用户界面中打开的 Autodesk Revit 项目。</p>
<p>元素检索</p>
<p>使用 UIDocument 中的 Selection 属性检索所选元素。此属性返回一个对象，该对象表示包含所选项目元素的活动选择。它还提供了 UI 交互方法，用于在 Revit 模型中拾取对象。有关更多详细信息，请参阅 Elements Essentials。</p>
<p>元素显示</p>
<p>ShowElements() 方法使用来关注多个元素。</p>
<p>视图管理</p>
<p>通过调用 RefreshActiveView() 方法，可以使用 UIDocument 类来刷新活动文档中的活动视图。ActiveView 属性可用于检索或设置文档的活动视图。更改活动视图有一些限制。它只能在活动文档中使用，该文档不得处于只读状态，也不得位于事务中。此外，在 ViewActivating 或 ViewActivated 事件期间，或任何操作前事件 （如 DocumentSaving、DocumentClosing 或其他类似事件） 期间，不得更改活动视图。</p>
<p>UIDocument.ActiveGraphicalView 属性检索文档的活动图形视图。与 UIDocument.ActiveView 不同，如果用户碰巧在其中一个视图中进行选择，则此属性将永远不会返回辅助视图（如 Project Browser 或 System Browser）。</p>
<p>UIDocument 还可用于获取 Revit 用户界面中所有打开的视图窗口的列表。GetOpenUIViews 方法返回一个 UIViews 列表，其中包含有关 Revit 用户界面中视图窗口的数据。</p>
<h3 id="Default-Types-默认类型"><a href="#Default-Types-默认类型" class="headerlink" title="Default Types 默认类型"></a>Default Types 默认类型</h3><p>Revit 具有不同类别的默认类型。调用相关工具创建此类别的图元时，此默认类型将显示在 Revit 用户界面中。Revit API 通过 Document 类公开族和非族类型的默认类型。</p>
<p>族类型</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">GetDefaultFamilyTypeId()</td>
<td align="left">获取与给定族类别 ID 关联的默认系列类型 ID。</td>
</tr>
<tr>
<td align="left">SetDefaultFamilyTypeId()</td>
<td align="left">设置与给定族类别 ID 关联的默认族类型 ID。</td>
</tr>
<tr>
<td align="left">IsDefaultFamilyTypeIdValid()</td>
<td align="left">检查族类型 ID 是否有效，可设置为给定族类别 ID 的默认值。</td>
</tr>
</tbody></table>
<p>此外，给定 ElementType，ElementType.IsValidDefaultFamilyType() 标识它是否是给定族类别 ID 的有效默认族类型。 以下示例演示了如何获取结构柱类别的默认族类型 ID。然后，它获取默认类型的族符号并将其分配给给定的柱。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">AssignDefaultTypeToColumn</span>(<span class="params">Document document, FamilyInstance column</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ElementId defaultTypeId = document.GetDefaultFamilyTypeId(<span class="keyword">new</span> ElementId(BuiltInCategory.OST_StructuralColumns));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (defaultTypeId != ElementId.InvalidElementId)</span><br><span class="line">    &#123;</span><br><span class="line">        FamilySymbol defaultType = document.GetElement(defaultTypeId) <span class="keyword">as</span> FamilySymbol;</span><br><span class="line">        <span class="keyword">if</span> (defaultType != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            column.Symbol = defaultType;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下一个示例在首先检查给定门是否为有效的默认族类型 ID 后，为给定门的门类别设置默认类型。</p>
<p>代码区域：设置默认族类型 ID</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">SetDefaultTypeFromDoor</span>(<span class="params">Document document, FamilyInstance door</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ElementId doorCategoryId = <span class="keyword">new</span> ElementId(BuiltInCategory.OST_Doors);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// It is necessary to test the type suitability to be a default family type, for not every type can be set as default. </span></span><br><span class="line">    <span class="comment">// Trying to set a non-qualifying default type will cause an exception</span></span><br><span class="line">    <span class="keyword">if</span> (door.Symbol.IsValidDefaultFamilyType(doorCategoryId))</span><br><span class="line">    &#123;</span><br><span class="line">        document.SetDefaultFamilyTypeId(doorCategoryId, door.Symbol.Id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>非族类型</p>
<p>下表中的文档成员提供对非 Family 元素类型的默认类型的访问。</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">GetDefaultElementTypeId()</td>
<td align="left">获取给定非 Family 元素类型的默认元素类型 ID。</td>
</tr>
<tr>
<td align="left">SetDefaultElementTypeId()</td>
<td align="left">为给定的非 Family 元素类型设置默认元素类型 ID。</td>
</tr>
<tr>
<td align="left">IsDefaultElementTypeIdValid()</td>
<td align="left">检查元素类型 ID 是否对给定的非 Family 元素类型有效。</td>
</tr>
</tbody></table>
<p>下面的示例检查给定的墙壁是否使用墙壁类型的默认元素类型。</p>
<p>代码区域：获取默认元素类型 ID</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private bool IsWallUsingDefaultType(Document document, Wall wall)</span><br><span class="line">&#123;</span><br><span class="line">    ElementId defaultElementTypeId = document.GetDefaultElementTypeId(ElementTypeGroup.WallType);</span><br><span class="line">    return (wall.WallType.Id == defaultElementTypeId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="文档和文件管理"><a href="#文档和文件管理" class="headerlink" title="文档和文件管理"></a>文档和文件管理</h2><p>文档和文件管理使创建和查找文档变得容易。</p>
<p>文档检索</p>
<p>Application 类维护所有文档。如前所述，您可以在一个会话中打开多个文档。使用 UIApplication 类属性 ActiveUIDocument 检索活动文档。所有打开的文档（包括活动文档）都使用 Application 类 Documents 属性进行检索。该属性返回一个包含 Revit 任务中所有打开的文档的集。</p>
<p>文档文件信息</p>
<p>Document 类为每个相应的文件提供两个属性，即 PathName 和 Title。</p>
<p>PathName 返回文档的完全限定文件路径。如果项目自创建以来尚未保存，则 PathName 将返回空字符串。</p>
<p>Title 是项目标题，通常从项目文件名派生而来。返回值因您的系统设置而异。</p>
<p>打开文档</p>
<p>Application 类提供了一个重载的方法来打开现有项目文件：</p>
<p>表 3：在 API 中打开文档</p>
<table>
<thead>
<tr>
<th><strong>Method 方法</strong></th>
<th><strong>Event 事件</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Document OpenDocumentFile(string filename )<br /> Document OpenDocumentFile(ModelPath modelPath, OpenOptions openOptions)</td>
<td>DocumentOpened 文档已打开</td>
</tr>
</tbody></table>
<p>指定具有完全限定文件路径的字符串时，Revit 将打开该文件并创建一个 Document 实例。使用此方法可以通过为此方法分配文件通用命名转换 （UNC） 名称，在其他计算机上打开文件。该文件可以是扩展名为 .rvt 的项目文件、扩展名为 .rfa 的族文件或扩展名为 .rte 的样板文件。第二个重载将模型的路径作为 ModelPath 而不是字符串，并且 OpenOptions 参数提供用于打开文件的选项，例如从中心分离打开的文档（如果适用）的功能，以及与工作共享相关的选项。有关打开工作共享文档的更多信息，请参阅打开工作共享文档。这些方法在发生故障时引发特定的记录异常。例外情况分为 4 大类。</p>
<p>表 4：引发的异常类型</p>
<table>
<thead>
<tr>
<th><strong>Type 类型</strong></th>
<th><strong>Example 例</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Disk errors 磁盘错误</td>
<td>文件不存在或版本错误</td>
</tr>
<tr>
<td>Resource errors 资源错误</td>
<td>没有足够的内存或磁盘空间来打开文件</td>
</tr>
<tr>
<td>Central model file errors 中心模型文件错误</td>
<td>文件已锁定或损坏</td>
</tr>
<tr>
<td>Central model&#x2F;server errors 中心模型&#x2F;服务器错误</td>
<td>与服务器发生网络通信错误</td>
</tr>
</tbody></table>
<p>如果文档打开成功，则会引发 DocumentOpened 事件。</p>
<p> 创建文档 </p>
<p>使用下表中的 Application 方法创建新文档。<br>表 5：在 API 中创建文档</p>
<table>
<thead>
<tr>
<th><strong>Method 方法</strong></th>
<th><strong>Event 事件</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>Document NewProjectDocument(string templateFileName);</code></td>
<td>DocumentCreated</td>
</tr>
<tr>
<td><code>Document NewProjectDocument(UnitSystem unitSystem);</code></td>
<td>DocumentCreated</td>
</tr>
<tr>
<td><code>Document NewFamilyDocument(string templateFileName);</code></td>
<td>DocumentCreated</td>
</tr>
<tr>
<td><code>Document NewProjectTemplateDocument(string templateFilename);</code></td>
<td>DocumentCreated</td>
</tr>
</tbody></table>
<p>对于需要模板文件名作为参数的方法，将基于模板文件返回创建的文档。NewProjectDocument（UnitSystem）将创建一个没有指定模板的新英制或公制项目文档。</p>
<p>保存并关闭文档 Document 类提供了保存或关闭实例的方法。</p>
<p>表 6：在 API 中保存和关闭文档</p>
<table>
<thead>
<tr>
<th><strong>Method 方法</strong></th>
<th><strong>Event 事件</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Save() 保存</td>
<td>DocumentSaved 文档已保存</td>
</tr>
<tr>
<td>SaveAs() 保存为</td>
<td>DocumentSavedAs</td>
</tr>
<tr>
<td>Close() 关闭</td>
<td>DocumentClosed 文档已关闭</td>
</tr>
</tbody></table>
<p>Save() 有 2 个重载，一个没有参数，另一个带有 SaveOptions 参数，可以指定是否强制操作系统从磁盘上的文件中删除所有死数据。如果之前未保存该文件，则必须改为调用 SaveAs()。 </p>
<p>SaveAs() 有 3 个重载。一个重载仅将文件名作为参数，如果存在另一个具有给定文件名的文件，则会引发异常。其他 2 个重载将文件名作为参数（在一种情况下以 ModelPath 的形式）以及第二个 SaveAsOptions 参数，该参数可用于指定是否覆盖现有文件（如果存在）。SaveAsOptions 还可用于指定其他相关选项，例如是否删除磁盘上与文件相关的死数据和工作共享选项。 Save() 和 SaveAs() 在与打开文档时相同的 4 个类别中引发特定的记录异常，如上面的表 4 所示。</p>
<p> Close() 有两个重载。一个参数采用 Boolean 参数，该参数指示是否在关闭文件之前保存文件。第二个重载不带任何参数，如果文档被修改，系统会询问用户是否要在关闭之前保存文件。如果尚未设置文档的路径名，或者保存的目标文件是只读的，则此方法将引发异常。</p>
<p>注： Close() 方法不会影响活动文档或引发 DocumentClosed 事件，因为该文档由外部应用程序使用。您只能对非活动文档调用此方法。UIDocument 类还提供了保存和关闭实例的方法。</p>
<p>表 7：在 API 中保存和关闭 UIDocument</p>
<table>
<thead>
<tr>
<th><strong>Method 方法</strong></th>
<th><strong>Event 事件</strong></th>
</tr>
</thead>
<tbody><tr>
<td>SaveAndClose()</td>
<td>DocumentSaved, DocumentClosed</td>
</tr>
<tr>
<td>SaveAs() 保存为</td>
<td>DocumentSavedAs</td>
</tr>
</tbody></table>
<p>SaveAndClose() 在保存文档后关闭文档。如果尚未设置文档的路径名称，则向 Revit 用户显示“另存为”对话框，以设置其名称和位置。 SaveAs() 方法将文档保存为通过“另存为”对话框从 Revit 用户处获取的文件名和路径。</p>
<p>文档预览</p>
<p> 可以从 Document 获取 DocumentPreviewSettings 类，该类包含与保存给定文档的预览图像相关的设置。</p>
<p>代码区域：文档预览</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SaveActiveViewWithPreview</span>(<span class="params">UIApplication application</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Get the handle of current document.</span></span><br><span class="line">    Autodesk.Revit.DB.Document document = application.ActiveUIDocument.Document;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get the document&#x27;s preview settings</span></span><br><span class="line">    DocumentPreviewSettings settings = document.GetDocumentPreviewSettings();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Find a candidate 3D view</span></span><br><span class="line">    FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(document);</span><br><span class="line">    collector.OfClass(<span class="keyword">typeof</span>(View3D));</span><br><span class="line">    </span><br><span class="line">    Func&lt;View3D, <span class="built_in">bool</span>&gt; isValidForPreview = v =&gt; settings.IsViewIdValidForPreview(v.Id);</span><br><span class="line">    </span><br><span class="line">    View3D viewForPreview = collector.OfType().First(isValidForPreview);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Set the preview settings</span></span><br><span class="line">    <span class="keyword">using</span> (Transaction setTransaction = <span class="keyword">new</span> Transaction(document, <span class="string">&quot;Set preview view id&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        setTransaction.Start();</span><br><span class="line">        settings.PreviewViewId = viewForPreview.Id;</span><br><span class="line">        setTransaction.Commit();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Save the document</span></span><br><span class="line">    document.Save();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>荷载族</p>
<p>Document 类使您能够将整个族及其所有符号加载到项目中。由于加载整个族可能需要很长时间和大量内存，因此 Document 类提供了类似的方法 LoadFamilySymbol() 来仅加载指定的符号。有关更多详细信息，请参阅 族。</p>
<h2 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h2><p>下表标识了 Revit Platform UI“管理”选项卡中的命令以及相应的 API。</p>
<p>表 7：API 和 UI 中的设置</p>
<table>
<thead>
<tr>
<th><strong>UI 命令</strong></th>
<th><strong>关联 API</strong></th>
<th><strong>参考</strong></th>
</tr>
</thead>
<tbody><tr>
<td>设置 <img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/ac.menuaro.gif" alt="img"> 项目信息</td>
<td>Document.ProjectInformation</td>
<td>请参阅以下注释</td>
</tr>
<tr>
<td>设置 <img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/ac.menuaro.gif" alt="img"> 项目参数</td>
<td>Document.ParameterBindings (Only for Shared Parameter)</td>
<td>请参阅<a href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Shared_Parameters">共享参数</a></td>
</tr>
<tr>
<td>“项目位置”面板</td>
<td>Document.ProjectLocations</td>
<td>查看<a href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Place_and_Locations">地点和位置</a></td>
</tr>
<tr>
<td>设置 <img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/ac.menuaro.gif" alt="img"> 其他设置 <img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/ac.menuaro.gif" alt="img"> 填充图案</td>
<td>FilteredElementCollector filtering on class FillPatternElement</td>
<td>请参阅以下注释</td>
</tr>
<tr>
<td>设置 <img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/ac.menuaro.gif" alt="img"> 材质</td>
<td>FilteredElementCollector filtering on class Material</td>
<td>请参阅<a href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Material_Management">物料管理</a></td>
</tr>
<tr>
<td>设置 <img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/ac.menuaro.gif" alt="img"> 对象样式</td>
<td>Document.Settings.Categories</td>
<td>请参阅以下注释</td>
</tr>
<tr>
<td>阶段划分 <img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/ac.menuaro.gif" alt="img"> 阶段</td>
<td>Document.Phases</td>
<td>请参阅以下注释</td>
</tr>
<tr>
<td>设置 <img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/ac.menuaro.gif" alt="img"> 结构设置</td>
<td>Loads and related structural settings are available in the API</td>
<td>参见 <a href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Structural_Engineering">Structural Engineering</a></td>
</tr>
<tr>
<td>设置 <img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/ac.menuaro.gif" alt="img"> 项目单位</td>
<td>Document.GetUnits()</td>
<td>见<a href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Units">单位</a></td>
</tr>
<tr>
<td>面积和体积计算（在房间和面积面板上）</td>
<td>AreaVolumeSettings.GetAreaVolumeSettings()</td>
<td>请参阅以下注释</td>
</tr>
</tbody></table>
<p>注意：项目信息 - API 提供 ProjectInfo 类，该类使用 Document.ProjectInformation 检索，以表示 Revit 项目中的项目信息。下表标识了 Project Information 参数的相应 API。</p>
<p>表 8：项目信息</p>
<table>
<thead>
<tr>
<th><strong>参数</strong></th>
<th><strong>对应 API</strong></th>
<th><strong>内置参数</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Project Issue Date 项目发布日期</td>
<td>ProjectInfo.IssueDate</td>
<td>PROJECT_ISSUE_DATE</td>
</tr>
<tr>
<td>Project Status 项目进展</td>
<td>ProjectInfo.Status</td>
<td>PROJECT_STATUS</td>
</tr>
<tr>
<td>Client Name 客户端名称</td>
<td>ProjectInfo.ClientName</td>
<td>CLIENT_NAME</td>
</tr>
<tr>
<td>Project Address 项目地址</td>
<td>ProjectInfo.Address</td>
<td>PROJECT_ADDRESS</td>
</tr>
<tr>
<td>Project Name 项目名称</td>
<td>ProjectInfo.Name</td>
<td>PROJECT_NAME</td>
</tr>
<tr>
<td>Project Number 项目编号</td>
<td>ProjectInfo.Number</td>
<td>PROJECT_NUMBER</td>
</tr>
</tbody></table>
<p>使用 ProjectInfo 公开的属性来检索和设置所有字符串。这些属性由相应的内置参数实现。您可以直接通过内置参数获取或设置值。有关如何通过内置参数访问这些参数的更多信息，请参阅“Elements Essentials”部分中的参数。获取项目信息的推荐方法是使用 ProjectInfo 属性。</p>
<p>Fill Patterns</p>
<p>使用对类 FillPatternElement 的 FilteredElementCollector 过滤来检索当前文档中的所有填充图案。可以使用静态方法 FillPatternElement.GetFillPattern（Document， ElementId） 或 FillPatternElement.GetFillPatternByName （Document， string） 来检索特定的 FillPattern。</p>
<p>Object Styles</p>
<p>使用 Settings.Categories 检索 Category 对象中除 Line Style 之外的所有信息。有关更多详细信息，请参阅 Elements Essentials和 Material 部分中的 Other Classifications。</p>
<p>Phases</p>
<p>Revit 按阶段维护图元生命周期，阶段是项目生命周期中的不同时间段。文档中的所有阶段都使用 Document.Phases 属性进行检索。该属性返回一个包含 Phase 类实例的数组。但是，Revit API 不会公开 Phase 类中的函数。</p>
<p>Options</p>
<p> “Options”命令用于配置项目全局设置。您可以使用 Application.Options 属性检索 Options.Application 实例。目前，Options.Application 类仅支持访问库路径和共享参数文件。</p>
<p>Area and Volume Calculations</p>
<p>AreaVolumeSettings 类允许您启用或禁用体积计算，以及更改房间边界位置。</p>
<h2 id="单位"><a href="#单位" class="headerlink" title="单位"></a>单位</h2><p>Revit API 中用于处理单位的两个主要类是 Units 和 FormatOptions。Units 类表示文档的默认设置，用于将带有单位的数字格式设置为字符串。它包含每个单位类型的 FormatOptions 对象以及与小数符号和数字分组相关的设置。</p>
<p>Units 类为每个有效的 Unit 类型存储一个 FormatOptions 对象，但并非所有 Unit 类型都可以直接修改。有些 （如 UT_Number 和 UT_SiteAngle）具有固定的定义。其他单位的定义是从其他单位类型自动派生的。例如，UT_SheetLength 派生自 UT_Length UT_ForceScale 派生自 UT_Force。</p>
<p>FormatOptions 类包含一些设置，这些设置控制如何将带有单位的数字格式设置为字符串。它包含通常由最终用户在“格式”对话框中选择并存储在文档中的设置，例如舍入、准确性、显示单位以及是否禁止空格或前导零或尾随零。</p>
<p>FormatOptions 类以两种不同的方式使用。Units 类中的 FormatOptions 对象表示文档的默认设置。在其他位置使用的 FormatOptions 对象表示可以选择性地覆盖默认设置的设置。</p>
<p>UseDefault 属性控制 FormatOptions 对象是表示默认格式还是自定义格式。如果 UseDefault 为 true，则格式设置将根据 Units 类中的默认设置进行，并且对象中的其他设置都没有意义的。如果 UseDefault 为 false，则对象包含替代 Units 类中的默认设置的自定义设置。对于 Units 类中的 FormatOptions 对象，UseDefault 始终为 false。</p>
<p>Revit API 中与单元相关的重要枚举包括：</p>
<ul>
<li>UnitType - 要测量的物理量类型，例如长度或力（UT_Length 或 UT_Force）</li>
<li>DisplayUnitType - 用于将数字格式化为字符串或转换单位（即 DUT_METERS）的单位和显示格式</li>
<li>UnitSymbolType - 以数字的格式化字符串表示形式显示的单位符号，以指示值的单位（即 UST_M）</li>
</ul>
<p>单位换算<br>Revit API 提供了实用程序类，以便于在 Revit 中处理数量。使用 UnitUtils 类，可以轻松地将单位数据与 Revit 的内部单位相互转换。<br>Revit 有七个基本单位，每个基本单位都有自己的内部单位。下表列出了这些内部单位。</p>
<p>表 9：Revit Unit System 中的 7 个基本单元</p>
<table>
<thead>
<tr>
<th><strong>基本单位</strong></th>
<th><strong>Revit 中的单位</strong></th>
<th><strong>单位制</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Length 长度</td>
<td>Feet (ft) 英尺（英尺）</td>
<td>Imperial 英制</td>
</tr>
<tr>
<td>Angle 角度</td>
<td>Radian 弧度</td>
<td>Metric 公制</td>
</tr>
<tr>
<td>Mass 质量</td>
<td>Kilogram (kg) 千克 （kg）</td>
<td>Metric 公制</td>
</tr>
<tr>
<td>Time 时间</td>
<td>Seconds (s) 秒 （s）</td>
<td>Metric 公制</td>
</tr>
<tr>
<td>Electric Current 电流</td>
<td>Ampere (A) 安培 （A）</td>
<td>Metric 公制</td>
</tr>
<tr>
<td>Temperature 温度</td>
<td>Kelvin (K) 开尔文 （K）</td>
<td>Metric 公制</td>
</tr>
<tr>
<td>Luminous Intensity 发光强度</td>
<td>Candela (cd) 坎德拉 （cd）</td>
<td>Metric 公制</td>
</tr>
</tbody></table>
<p>注意：由于 Revit 以英尺为单位存储长度，以公制单位存储其他基本量，因此涉及长度的派生单位将是基于英制和公制的非标准单位。例如，由于力是以“每时间平方的质量长度”来测量的，因此它以 kg-ft &#x2F; s2 为单位存储。以下示例使用 UnitUtils.ConvertFromInternalUnits() 方法获取材料的最小屈服应力（以 kips&#x2F;平方英寸为单位）。</p>
<p>代码区域：从 Revit 的内部单位转换</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">double</span> <span class="title">GetYieldStressInKsi</span>(<span class="params">Material material</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">double</span> dMinYieldStress = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// Get the structural asset for the material</span></span><br><span class="line">    ElementId strucAssetId = material.StructuralAssetId;</span><br><span class="line">    <span class="keyword">if</span> (strucAssetId != ElementId.InvalidElementId)</span><br><span class="line">    &#123;</span><br><span class="line">        PropertySetElement pse = material.Document.GetElement(strucAssetId) <span class="keyword">as</span> PropertySetElement;</span><br><span class="line">        <span class="keyword">if</span> (pse != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            StructuralAsset asset = pse.GetStructuralAsset();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Get the min yield stress and convert to ksi</span></span><br><span class="line">            dMinYieldStress = asset.MinimumYieldStress;</span><br><span class="line">            dMinYieldStress = UnitUtils.ConvertFromInternalUnits(dMinYieldStress,</span><br><span class="line">                DisplayUnitType.DUT_KIPS_PER_SQUARE_INCH);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">return</span> dMinYieldStress;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>UnitUtils 还可用于将值从一种单位类型转换为另一种单位类型，例如平方英尺到平方米。在以下示例中，以英寸为单位输入的墙的顶部偏移值将转换为英尺，这是设置该值的预期单位。</p>
<p>代码区域：在单位之间转换</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetTopOffset</span>(<span class="params">Wall wall, <span class="built_in">double</span> dOffsetInches</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// convert user-defined offset value to feet from inches prior to setting</span></span><br><span class="line">    <span class="built_in">double</span> dOffsetFeet = UnitUtils.Convert(dOffsetInches,</span><br><span class="line">                                            DisplayUnitType.DUT_DECIMAL_INCHES,</span><br><span class="line">                                            DisplayUnitType.DUT_DECIMAL_FEET);</span><br><span class="line"></span><br><span class="line">    Parameter paramTopOffset = wall.get_Parameter(BuiltInParameter.WALL_TOP_OFFSET);</span><br><span class="line">    paramTopOffset.Set(dOffsetFeet);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>单元格式设置和解析</p>
<p>另一个实用程序类 UnitFormatUtils 可以格式化数据或分析格式化单元数据。</p>
<p>重载方法 Format() 可用于根据格式设置选项将值格式化为字符串，如以下示例所示。检索材料密度，然后使用 Format() 方法将该值转换为用户友好的单位值。</p>
<p>代码区域：将值格式化为字符串</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DisplayDensityOfMaterial</span>(<span class="params">Material material</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">double</span> density = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// get structural asset of material in order to get the density</span></span><br><span class="line">    ElementId strucAssetId = material.StructuralAssetId;</span><br><span class="line">    <span class="keyword">if</span> (strucAssetId != ElementId.InvalidElementId)</span><br><span class="line">    &#123;</span><br><span class="line">        PropertySetElement pse = material.Document.GetElement(strucAssetId) <span class="keyword">as</span> PropertySetElement;</span><br><span class="line">        <span class="keyword">if</span> (pse != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            StructuralAsset asset = pse.GetStructuralAsset();</span><br><span class="line"></span><br><span class="line">            density = asset.Density;</span><br><span class="line">            <span class="comment">// convert the density value to a user readable string that includes the units</span></span><br><span class="line">            Units units = material.Document.GetUnits();</span><br><span class="line">            <span class="comment">// false for maxAccuracy means accuracy specified by the FormatOptions should be used</span></span><br><span class="line">            <span class="comment">// false for forEditing since this will be for display only and no formatting modifications are necessary</span></span><br><span class="line">            <span class="built_in">string</span> strDensity = UnitFormatUtils.Format(units, UnitType.UT_UnitWeight, density, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">            <span class="built_in">string</span> msg = <span class="built_in">string</span>.Format(<span class="string">&quot;Raw Value: &#123;0&#125;\r\nFormatted Value: &#123;1&#125;&quot;</span>, density, strDensity);</span><br><span class="line">            TaskDialog.Show(<span class="string">&quot;Material Density&quot;</span>, msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重载的 UnitFormatUtils.TryParse() 方法使用指定单位类型的 Revit 内部单位（如果可能）将格式化字符串（包括单位）解析为值。以下示例采用用户输入的长度值（假定为数字和长度单位），并尝试将其分析为长度值。出于演示目的，将结果与 TaskDialog 中的输入字符串进行比较。</p>
<p>代码区域：解析字符串</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">double</span> <span class="title">GetLengthInput</span>(<span class="params">Document document, String userInputLength</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">double</span> dParsedLength = <span class="number">0</span>;</span><br><span class="line">    Units units = document.GetUnits();</span><br><span class="line">    <span class="comment">// try to parse a user entered string (i.e. 100 mm, 1&#x27;6&quot;)</span></span><br><span class="line">    <span class="built_in">bool</span> parsed = UnitFormatUtils.TryParse(units, UnitType.UT_Length, userInputLength, <span class="keyword">out</span> dParsedLength);</span><br><span class="line">    <span class="keyword">if</span> (parsed == <span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> msg = <span class="built_in">string</span>.Format(<span class="string">&quot;User Input: &#123;0&#125;\r\nParsed value: &#123;1&#125;&quot;</span>, userInputLength, dParsedLength);</span><br><span class="line">        TaskDialog.Show(<span class="string">&quot;Parsed Data&quot;</span>, msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dParsedLength;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="注：翻译自Revit-API-Developers-Guide"><a href="#注：翻译自Revit-API-Developers-Guide" class="headerlink" title="注：翻译自Revit API Developers Guide"></a><em><strong>注：</strong></em>翻译自<a href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_html">Revit API Developers Guide</a></h2>]]></content>
      <categories>
        <category>Revit二次开发人员指南</category>
      </categories>
      <tags>
        <tag>Revit</tag>
      </tags>
  </entry>
  <entry>
    <title>02插件集成</title>
    <url>/2024/11/23/%E4%BA%8C%E5%BC%80%E6%8C%87%E5%8D%97/02%E6%8F%92%E4%BB%B6%E9%9B%86%E6%88%90/</url>
    <content><![CDATA[<h1 id="插件集成"><a href="#插件集成" class="headerlink" title="插件集成"></a><a href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_Introduction_Add_In_Integration_html">插件集成</a></h1><p>开发人员通过创建和实现 External Commands 和 External Applications 来添加功能。Revit 使用 .addin 清单文件标识新命令和应用程序。外部命令显示在 Add-Ins 选项卡上的 External Tools 菜单按钮下。外部应用程序在 Revit 启动时调用，在 Revit 关闭时卸载。</p>
<p>本章重点介绍以下内容：</p>
<ul>
<li>了解如何使用 External Commands 和 External Applications 添加功能。</li>
<li>如何访问 Revit 事件。</li>
<li>如何自定义 Revit UI。</li>
</ul>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Revit 平台 API 基于 Revit 应用程序功能。Revit 平台 API 由两个类库组成，这两个类库仅在 Revit 运行时工作。</p>
<p>RevitAPI.dll包含用于在数据库级别访问 Revit 的应用程序、文档、图元和参数的方法。它还包含 IExternalDBApplication 和相关接口。</p>
<p>RevitAPIUI.dll包含与 Revit 用户界面的操作和自定义相关的所有 API 接口，包括：</p>
<ul>
<li>IExternalCommand 和 External Command 相关接口</li>
<li>IExternalApplication 和相关接口</li>
<li>Selection 选择</li>
<li>RibbonPanel、RibbonItem 和子类</li>
<li>TaskDialogs 任务对话框</li>
</ul>
<p>如下图所示，Revit Architecture、Revit Structure 和 Revit MEP 分别特定于 Architecture、Structure 和 MEP。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-EADE225A-E8F2-4EB8-BB94-00CA8759C1E9-low.png" alt="[]()"></p>
<p>要创建基于 RevitAPI 的插件，必须在插件 DLL 中提供特定的入口点类型。这些入口点类实现接口IExternalCommand、IExternalApplication 或 IExternalDBApplication。通过这种方式，加载项在某些事件上自动运行，或者在 IExternalCommand 和 IExternalApplication 的情况下，从“外部工具”菜单按钮手动运行。</p>
<p>本章介绍了 IExternalCommand、IExternalApplication、IExternalDBApplication 和其他可用于附加模块集成的 Revit 事件。</p>
<h2 id="外部命令"><a href="#外部命令" class="headerlink" title="外部命令"></a>外部命令</h2><p>开发人员可以通过实现 External Tools 菜单按钮中显示的 External Commands 来添加功能。</p>
<h3 id="加载和运行外部命令"><a href="#加载和运行外部命令" class="headerlink" title="加载和运行外部命令"></a>加载和运行外部命令</h3><p>当 Revit 中没有其他命令或编辑模式处于活动状态时，将启用已注册的外部命令。选择命令后，将创建一个命令对象并调用其 Execute() 方法。此方法返回到 Revit 后，命令对象将被销毁。因此，在命令执行之间，数据无法保留在对象中。但是，还有其他方法可以在命令执行之间保存数据;例如，可以使用 Revit 共享参数机制将数据存储在 Revit 项目中。</p>
<p>您可以将外部命令添加到“外部工具”菜单按钮下的“外部工具面板”中，或者作为“插件”选项卡、“分析”选项卡或新的自定义功能区选项卡上的自定义功能区面板。有关这两种方法的示例，请参阅演练：Hello World 和演练：添加 Hello World 功能区面板。<br>外部工具、功能区选项卡和功能区面板在启动时进行初始化。初始化步骤如下：</p>
<ul>
<li>Revit 读取清单文件并识别：</li>
<li>可调用的外部应用程序。</li>
<li>可添加到 Revit 外部工具菜单按钮的外部工具。</li>
<li>外部应用程序会话将面板和内容添加到“加载项”选项卡中。</li>
</ul>
<h3 id="IExternalCommand"><a href="#IExternalCommand" class="headerlink" title="IExternalCommand"></a>IExternalCommand</h3><p>通过创建实现 IExternalCommand 接口的对象，可以创建外部命令。IExternalCommand 接口有一个抽象方法 Execute，它是外部命令的主要方法。</p>
<p>Execute() 方法有三个参数：</p>
<ul>
<li>commandData (ExternalCommandData）</li>
<li>message (String) </li>
<li>elements (ElementSet)</li>
</ul>
<p>ExternalCommandData 对象包含外部命令所需的对 Application 和 View 的引用。所有 Revit 数据都是从外部命令中的此参数直接或间接检索的。</p>
<p>例如，以下语句说明了如何从 commandData 参数检索 Autodesk.Revit.Document：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Document doc = commandData.Application.ActiveUIDocument.Document;</span><br></pre></td></tr></table></figure>

<p>下表说明了 ExternalCommandData </p>
<p>公共属性表 1：ExternalCommandData 公共属性</p>
<table>
<thead>
<tr>
<th><strong>Property 成员</strong></th>
<th><strong>Description 描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Application (Autodesk.Revit.UI.UIApplication)</td>
<td>检索表示当前 UIApplication for external 命令的对象。</td>
</tr>
<tr>
<td>JournalData (IDictionary&lt;String, String&gt;)</td>
<td>可用于将数据读取和写入 Revit 日志文件的数据映射。</td>
</tr>
<tr>
<td>View (Autodesk.Revit.DB.View)</td>
<td>检索表示 View 外部命令处理的对象。</td>
</tr>
</tbody></table>
<p>message (String):错误消息由外部命令使用输出参数 message 返回。string-type 参数在外部命令进程中设置。返回 Autodesk.Revit.UI.Result.Failed 或 Autodesk.Revit.UI.Result.Cancelled 并设置消息参数时，会显示一个错误对话框。<br>以下代码示例说明了如何使用 message 参数。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">IExternalCommand_message</span> : <span class="title">IExternalCommand</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">public</span> Autodesk.Revit.UI.<span class="function">Result <span class="title">Execute</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">                Autodesk.Revit.ExternalCommandData commandData, <span class="keyword">ref</span> <span class="built_in">string</span> message,</span></span></span><br><span class="line"><span class="params"><span class="function">                Autodesk.Revit.ElementSet elements</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">                message = <span class="string">&quot;Could not locate walls for analysis.&quot;</span>;</span><br><span class="line">                <span class="keyword">return</span> Autodesk.Revit.UI.Result.Failed;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实施前面的 external 命令会导致出现以下对话框：</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-6E76ABBE-ED74-437E-B2FC-D92C9955C035-low.png"></p>
<p>elements（ElementSet）：每当返回 Autodesk.Revit.UI.Result.Failed 或 Autodesk.Revit.UI.Result.Canceled 且参数消息不为空时，都会显示错误或警告对话框。此外，如果向 elements 参数添加了任何元素，则这些元素将在屏幕上突出显示。每当命令失败时，无论是否还返回元素，最好设置 message 参数。 以下代码高亮显示预先选择的墙：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">IExternalcommand_elements</span> : <span class="title">IExternalCommand</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Result <span class="title">Execute</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">                Autodesk.Revit.UI.ExternalCommandData commandData, <span class="keyword">ref</span> <span class="built_in">string</span> message,</span></span></span><br><span class="line"><span class="params"><span class="function">                Autodesk.Revit.DB.ElementSet elements</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">                message = <span class="string">&quot;Please note the highlighted Walls.&quot;</span>;</span><br><span class="line">                FilteredElementCollector collector = <span class="keyword">new</span> FilteredElementCollector(commandData.Application.ActiveUIDocument.Document);</span><br><span class="line">                ICollection collection = collector.OfClass(<span class="keyword">typeof</span>(Wall)).ToElements();</span><br><span class="line">                <span class="keyword">foreach</span> (Element e <span class="keyword">in</span> collection)</span><br><span class="line">                &#123;</span><br><span class="line">                        elements.Insert(e);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> Result.Failed;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Return 返回:Return 结果表示执行失败、成功或被用户取消。如果不成功，Revit 将撤消外部命令所做的更改。</p>
<p><strong>表 2：IExternalCommand.Result</strong></p>
<table>
<thead>
<tr>
<th><strong>Member Name 成员名称</strong></th>
<th><strong>Description 描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Autodesk.Revit.UI.Result.Succeeded</td>
<td>外部命令已成功完成。Revit 保留由外部命令所做的所有更改。</td>
</tr>
<tr>
<td>Autodesk.Revit.UI.Result.Failed</td>
<td>外部命令未能完成任务。Revit 将撤消由外部命令执行的操作。如果设置了 Execute 的消息参数，Revit 将显示一个对话框，其中包含文本“错误 - 无法忽略”。</td>
</tr>
<tr>
<td>Autodesk.Revit.UI.Result.Cancelled</td>
<td>Revit 将撤消由外部命令所做的更改。如果设置了 Execute 的消息参数，Revit 将显示一个对话框，其中包含文本“警告 - 可以忽略”。</td>
</tr>
</tbody></table>
<p>以下示例显示问候消息，并允许用户选择返回值。使用 Execute() 方法作为 Revit 应用程序的入口。<br>代码区域 3-4：提示用户</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Autodesk.Revit.UI.<span class="function">Result <span class="title">Execute</span>(<span class="params">ExternalCommandData commandData,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">ref</span> <span class="built_in">string</span> message, ElementSet elements</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        Document doc = commandData.Application.ActiveUIDocument.Document;</span><br><span class="line">        UIDocument uidoc = commandData.Application.ActiveUIDocument;</span><br><span class="line">        <span class="comment">// Delete selected elements</span></span><br><span class="line"></span><br><span class="line">        ICollection&lt;Autodesk.Revit.DB.ElementId&gt; ids =</span><br><span class="line">            doc.Delete(uidoc.Selection.GetElementIds());</span><br><span class="line">    </span><br><span class="line">        TaskDialog taskDialog = <span class="keyword">new</span> TaskDialog(<span class="string">&quot;Revit&quot;</span>); </span><br><span class="line">        taskDialog.MainContent = </span><br><span class="line">            (<span class="string">&quot;Click Yes to return Succeeded. Selected members will be deleted.\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;Click No to return Failed.  Selected members will not be deleted.\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;Click Cancel to return Cancelled.  Selected members will not be deleted.&quot;</span>);</span><br><span class="line">        TaskDialogCommonButtons buttons = TaskDialogCommonButtons.Yes | </span><br><span class="line">            TaskDialogCommonButtons.No | TaskDialogCommonButtons.Cancel;</span><br><span class="line">        taskDialog.CommonButtons = buttons;</span><br><span class="line">        TaskDialogResult taskDialogResult = taskDialog.Show();</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> (taskDialogResult == TaskDialogResult.Yes)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> Autodesk.Revit.UI.Result.Succeeded;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (taskDialogResult == TaskDialogResult.No)</span><br><span class="line">        &#123;</span><br><span class="line">            ICollection selectedElementIds = uidoc.Selection.GetElementIds();</span><br><span class="line">            <span class="keyword">foreach</span> (ElementId id <span class="keyword">in</span> selectedElementIds)</span><br><span class="line">            &#123;</span><br><span class="line">                elements.Insert( doc.GetElement(id) );</span><br><span class="line">            &#125;</span><br><span class="line">            message = <span class="string">&quot;Failed to delete selection.&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span> Autodesk.Revit.UI.Result.Failed;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> Autodesk.Revit.UI.Result.Cancelled;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span></span><br><span class="line">    &#123;</span><br><span class="line">        message = <span class="string">&quot;Unexpected Exception thrown.&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> Autodesk.Revit.UI.Result.Failed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>IExternalCommandAvailability</p>
<p>此界面允许您控制是否可以按下外部命令按钮。IsCommandAvailable 接口方法将应用程序和一组与 Revit 中选定项目的类别匹配的类别传递给您的实现。典型用途是检查所选类别，以查看它们是否满足要运行命令的条件。</p>
<p>在此示例中，辅助功能检查允许在没有活动选择或至少选择了一面墙时单击按钮：</p>
<p>代码区域 3-5：设置命令可用性</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SampleAccessibilityCheck</span> : <span class="title">IExternalCommandAvailability</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">IsCommandAvailable</span>(<span class="params">AutodeskAutodesk.Revit.UI.UIApplication applicationData,</span></span></span><br><span class="line"><span class="params"><span class="function">                CategorySet selectedCategories</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">                <span class="comment">// Allow button click if there is no active selection</span></span><br><span class="line">                <span class="keyword">if</span> (selectedCategories.IsEmpty)</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="comment">// Allow button click if there is at least one wall selected</span></span><br><span class="line">                <span class="keyword">foreach</span> (Category c <span class="keyword">in</span> selectedCategories)</span><br><span class="line">                &#123;</span><br><span class="line">                        <span class="keyword">if</span> (c.Id.IntegerValue == (<span class="built_in">int</span>)BuiltInCategory.OST_Walls)</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h2 id="外部应用程序"><a href="#外部应用程序" class="headerlink" title="外部应用程序"></a>外部应用程序</h2><p>开发人员可以通过外部应用程序和外部命令添加功能。功能区选项卡和功能区面板使用外部应用程序进行自定义。功能区面板按钮绑定到外部命令。</p>
<h3 id="IExternalApplication"><a href="#IExternalApplication" class="headerlink" title="IExternalApplication"></a>IExternalApplication</h3><p>若要将外部应用程序添加到 Revit，请创建一个实现 IExternalApplication 接口的对象。IExternalApplication 接口有两个抽象方法，即 OnStartup() 和 OnShutdown()，您可以在外部应用程序中重写它们。Revit 在启动时调用 OnStartup()，在关闭时调用 OnShutdown()。</p>
<p>这是 OnStartup() 和 OnShutdown() 抽象定义：</p>
<p>代码区域 3-6：OnShutdown() 和 OnStartup()</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IExternalApplication</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">public</span> Autodesk.Revit.UI.<span class="function">Result <span class="title">OnStartup</span>(<span class="params">UIControlledApplication application</span>)</span>;</span><br><span class="line">        <span class="keyword">public</span> Autodesk.Revit.UI.<span class="function">Result <span class="title">OnShutdown</span>(<span class="params">UIControlledApplication application</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>UIControlledApplication 参数提供对某些 Revit 事件的访问，并允许自定义功能区面板和控件以及添加功能区选项卡。例如，UIControlledApplication 的公共事件 DialogBoxShowing 可用于捕获正在显示的对话框的事件。以下代码段注册了在显示对话框之前调用的处理函数。</p>
<p>代码区域 3-7：DialogBoxShowing 事件</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">application.DialogBoxShowing += <span class="keyword">new</span> </span><br><span class="line">        EventHandler&lt;Autodesk.Revit.Events.DialogBoxShowingEventArgs&gt;(AppDialogShowing);</span><br></pre></td></tr></table></figure>

<p>下面的代码示例说明了如何使用 UIControlledApplication 类型注册事件处理程序并在事件发生时处理事件。</p>
<p>代码区域 3-8：使用 ControlledApplication</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Application_DialogBoxShowing</span> : <span class="title">IExternalApplication</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">// Implement the OnStartup method to register events when Revit starts.</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Result <span class="title">OnStartup</span>(<span class="params">UIControlledApplication application</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">                <span class="comment">// Register related events</span></span><br><span class="line">                application.DialogBoxShowing += </span><br><span class="line">        <span class="keyword">new</span> EventHandler&lt;Autodesk.Revit.UI.Events.DialogBoxShowingEventArgs&gt;(AppDialogShowing);</span><br><span class="line">                <span class="keyword">return</span> Result.Succeeded;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Implement this method to unregister the subscribed events when Revit exits.</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Result <span class="title">OnShutdown</span>(<span class="params">UIControlledApplication application</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">    </span><br><span class="line">                <span class="comment">// unregister events</span></span><br><span class="line">                application.DialogBoxShowing -= </span><br><span class="line">        <span class="keyword">new</span> EventHandler&lt;Autodesk.Revit.UI.Events.DialogBoxShowingEventArgs&gt;(AppDialogShowing);</span><br><span class="line">                <span class="keyword">return</span> Result.Succeeded;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// The DialogBoxShowing event handler, which allow you to </span></span><br><span class="line">        <span class="comment">// do some work before the dialog shows</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">AppDialogShowing</span>(<span class="params"><span class="built_in">object</span> sender, DialogBoxShowingEventArgs <span class="keyword">args</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Get the help id of the showing dialog</span></span><br><span class="line">            <span class="built_in">string</span> dialogId = <span class="keyword">args</span>.DialogId;</span><br><span class="line">    </span><br><span class="line">            <span class="comment">// return if the dialog has no DialogId (such as with a Task Dialog)</span></span><br><span class="line">            <span class="keyword">if</span> (dialogId == <span class="string">&quot;&quot;</span>)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">            <span class="comment">// Show the prompt message and allow the user to close the dialog directly.</span></span><br><span class="line">            TaskDialog taskDialog = <span class="keyword">new</span> TaskDialog(<span class="string">&quot;Revit&quot;</span>);</span><br><span class="line">            taskDialog.MainContent = <span class="string">&quot;A Revit dialog is about to be opened.\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;The DialogId of this dialog is &quot;</span> + dialogId + <span class="string">&quot;\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;Press &#x27;Cancel&#x27; to immediately dismiss the dialog&quot;</span>;</span><br><span class="line">            taskDialog.CommonButtons = TaskDialogCommonButtons.Ok |</span><br><span class="line">                                         TaskDialogCommonButtons.Cancel;</span><br><span class="line">            TaskDialogResult result = taskDialog.Show();</span><br><span class="line">            <span class="keyword">if</span> (TaskDialogResult.Cancel == result)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// dismiss the Revit dialog </span></span><br><span class="line">                <span class="keyword">args</span>.OverrideResult(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h2 id="插件注册"><a href="#插件注册" class="headerlink" title="插件注册"></a>插件注册</h2><p>需要注册外部命令和外部应用程序才能显示在 Revit 中。可以通过将它们添加到 .addin 清单文件来注册它们。外部命令和应用程序在 Revit 中的列出顺序取决于 Revit 启动时的读入顺序。</p>
<h3 id="清单文件"><a href="#清单文件" class="headerlink" title="清单文件"></a>清单文件</h3><p>Revit API 应用程序通过 .addin 清单文件注册到 Revit。将清单文件放置在用户系统上的两个位置之一时，Revit 会自动读取这些文件：</p>
<ul>
<li>C:\ProgramData\Autodesk\Revit\Addins\Revit 2018\</li>
<li>C:\Users\AppData\Roaming\Autodesk\Revit\Addins\Revit 2018\</li>
</ul>
<p>在启动期间，Revit 将读取和处理这些位置中名为 .addin 的所有文件。用户特定位置和所有用户位置中的所有文件都被视为一起，并按字母顺序加载。如果所有用户清单文件与特定于用户的清单文件同名，则忽略所有用户清单文件。在每个清单文件中，外部命令和外部应用程序将按照它们的列出顺序加载。</p>
<p>添加一个 ExternalCommand 的基本文件如下所示：</p>
<p>代码区域 3-9：清单 .addin ExternalCommand</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span> standalone=<span class="string">&quot;no&quot;</span>?&gt;</span><br><span class="line">&lt;RevitAddIns&gt;</span><br><span class="line">        &lt;AddIn Type=<span class="string">&quot;Command&quot;</span>&gt;</span><br><span class="line">                &lt;Assembly&gt;c:\MyProgram\MyProgram.dll&lt;/Assembly&gt;</span><br><span class="line">                &lt;AddInId&gt;<span class="number">76</span>eb700a<span class="number">-2</span>c85<span class="number">-4888</span>-a78d<span class="number">-31429</span>ecae9ed&lt;/AddInId&gt;</span><br><span class="line">                &lt;FullClassName&gt;Revit.Samples.SampleCommand&lt;/FullClassName&gt;</span><br><span class="line">                &lt;Text&gt;Sample command&lt;/Text&gt;</span><br><span class="line">                &lt;VendorId&gt;ADSK&lt;/VendorId&gt;</span><br><span class="line">                &lt;VendorDescription&gt;Autodesk, www.autodesk.com&lt;/VendorDescription&gt; </span><br><span class="line">                &lt;VisibilityMode&gt;NotVisibleInFamily&lt;/VisibilityMode&gt;</span><br><span class="line">                &lt;Discipline&gt;Structure&lt;/Discipline&gt;</span><br><span class="line">                &lt;Discipline&gt;Architecture&lt;/Discipline&gt;</span><br><span class="line">                &lt;AvailabilityClassName&gt;Revit.Samples.SampleAccessibilityCheck&lt;/AvailabilityClassName&gt;</span><br><span class="line">                &lt;LongDescription&gt;</span><br><span class="line">                        This <span class="keyword">is</span> the <span class="built_in">long</span> description <span class="keyword">for</span> my command.</span><br><span class="line">                        This <span class="keyword">is</span> another descriptive paragraph, <span class="keyword">with</span> notes about how to use the command properly.</span><br><span class="line">                &lt;/LongDescription&gt;</span><br><span class="line">                &lt;TooltipImage&gt;c:\MyProgram\Autodesk.png&lt;/TooltipImage&gt;</span><br><span class="line">                &lt;LargeImage&gt;c:\MyProgram\MyProgramIcon.png&lt;/LargeImage&gt;</span><br><span class="line">        &lt;/AddIn&gt;</span><br><span class="line">&lt;/RevitAddIns&gt;</span><br></pre></td></tr></table></figure>

<p>添加一个 ExternalApplication 的基本文件如下所示：</p>
<p>代码区域 3-10：清单 .addin ExternalApplication</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span> standalone=<span class="string">&quot;no&quot;</span>?&gt;</span><br><span class="line">&lt;RevitAddIns&gt;</span><br><span class="line">&lt;AddIn Type=<span class="string">&quot;Application&quot;</span>&gt;</span><br><span class="line">                &lt;Name&gt;SampleApplication&lt;/Name&gt;</span><br><span class="line">                &lt;Assembly&gt;c:\MyProgram\MyProgram.dll&lt;/Assembly&gt;</span><br><span class="line">                &lt;AddInId&gt;<span class="number">604B</span>1052-F742<span class="number">-4951</span><span class="number">-8576</span>-C261D1993107&lt;/AddInId&gt;</span><br><span class="line">                &lt;FullClassName&gt;Revit.Samples.SampleApplication&lt;/FullClassName&gt;</span><br><span class="line">                &lt;VendorId&gt;ADSK&lt;/VendorId&gt;</span><br><span class="line">                &lt;VendorDescription&gt;Autodesk, www.autodesk.com&lt;/VendorDescription&gt;</span><br><span class="line">&lt;/AddIn&gt;</span><br><span class="line">&lt;/RevitAddIns&gt;</span><br></pre></td></tr></table></figure>

<p>添加一个 DB 级 External Application 的基本文件如下所示：</p>
<p>代码区域：manifest .addin ExternalDBApplication</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span> standalone=<span class="string">&quot;no&quot;</span>?&gt;</span><br><span class="line">&lt;RevitAddIns&gt;</span><br><span class="line">&lt;AddIn Type=<span class="string">&quot;DBApplication&quot;</span>&gt;</span><br><span class="line">                &lt;Assembly&gt;c:\MyDBLevelApplication\MyDBLevelApplication.dll&lt;/Assembly&gt;</span><br><span class="line">                &lt;AddInId&gt;DA3D570A<span class="number">-1</span>AB3<span class="number">-4</span>a4b-B09F<span class="number">-8</span>C15DFEC6BF0&lt;/AddInId&gt;</span><br><span class="line"></span><br><span class="line">                &lt;FullClassName&gt;MyCompany.MyDBLevelAddIn&lt;/FullClassName&gt;</span><br><span class="line">    </span><br><span class="line">                &lt;Name&gt;My DB-Level AddIn&lt;/Name&gt;                    </span><br><span class="line">                &lt;VendorId&gt;ADSK&lt;/VendorId&gt;</span><br><span class="line">                &lt;VendorDescription&gt;Autodesk, www.autodesk.com&lt;/VendorDescription&gt;</span><br><span class="line"></span><br><span class="line">&lt;/AddIn&gt;</span><br><span class="line">&lt;/RevitAddIns&gt;</span><br></pre></td></tr></table></figure>

<p>单个清单文件中可以提供多个 AddIn 元素。</p>
<p>下表描述了可用的 XML 标记：</p>
<table>
<thead>
<tr>
<th><strong>Tag 标记</strong></th>
<th><strong>Description 描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Assembly 程序集</td>
<td>附加模块程序集文件的完整路径。所有 ExternalCommands 和 ExternalApplications 都需要。</td>
</tr>
<tr>
<td>FullClassName 类的全名</td>
<td>程序集文件中实现 IExternalCommand 或 IExternalApplication 的类的全名。所有 ExternalCommands 和 ExternalApplications 都需要。</td>
</tr>
<tr>
<td>AddInId</td>
<td>一个 GUID，表示此特定应用程序的 ID。AddInIds 对于 Revit 的给定会话必须是唯一的。Autodesk 建议您为每个已注册的应用程序或命令生成唯一的 GUID。所有 ExternalCommands 和 ExternalApplications 都需要。</td>
</tr>
<tr>
<td>Name 名字</td>
<td>应用程序的名称。必填;仅适用于 ExternalApplications。</td>
</tr>
<tr>
<td>Text</td>
<td>按钮的名称。自选;仅将此标记用于 ExternalCommands。默认值为 “External Tool”。</td>
</tr>
<tr>
<td>VendorId 供应商 ID</td>
<td>Revit 中的某些操作（例如，可扩展存储的标识）可能使用的唯一供应商标识符。这必须是唯一的，因此我们建议使用域名的反向版本，例如 com.autodesk 或 uk.co.autodesk。</td>
</tr>
<tr>
<td>VendorDescription 供应商描述</td>
<td>包含供应商的法定名称和&#x2F;或其他相关信息的描述。自选。</td>
</tr>
<tr>
<td>Description 描述</td>
<td>命令的简短描述将用作按钮工具提示。自选;仅将此标记用于 ExternalCommands。默认值为仅包含命令文本的工具提示。</td>
</tr>
<tr>
<td>VisibilityMode 可见性模式</td>
<td>外部命令可见的模式。可以为此选项设置多个值。自选;仅将此标记用于 ExternalCommands。默认情况下，在所有模式下显示命令，包括当没有活动文档时。以前编写的需要针对活动文档运行的外部命令应进行修改，以确保代码在没有活动文档时处理命令的调用，或者应用 NotVisibleWhenNoActiveDocument 模式。有关更多信息，请参阅下表。</td>
</tr>
<tr>
<td>Discipline 学科</td>
<td>外部命令将在其中可见的学科。可以为此选项设置多个值。自选;仅将此标记用于 ExternalCommands。默认情况下，在所有领域中显示该命令。如果列出了任何特定领域，则该命令将仅在这些领域中可见。有关更多信息，请参阅下表。</td>
</tr>
<tr>
<td>AvailabilityClassName 可用性类名称</td>
<td>程序集文件中实现 IExternalCommandAvailability 的类的全名。此类允许根据上下文有选择地将命令按钮灰显。自选;仅将此标记用于 ExternalCommands。默认命令是只要可见就可用的命令。</td>
</tr>
<tr>
<td>LargeImage 大图像</td>
<td>用于 External Tools 下拉菜单中的按钮的图标。自选;仅将此标记用于 ExternalCommands。默认情况下，显示不带图标的按钮。</td>
</tr>
<tr>
<td>SmallImage 小图像</td>
<td>按钮提升到快速访问工具栏时使用的图标。自选;仅将此标记用于 ExternalCommands。默认情况下，显示不带图标的快速访问工具栏按钮，这可能会使用户感到困惑。</td>
</tr>
<tr>
<td>LongDescription 长描述</td>
<td>命令的详细说明将用作按钮扩展工具提示的一部分，当鼠标悬停在命令上较长时间时显示。自选;仅将此标记用于 ExternalCommands。如果未提供此属性和 TooltipImage，则按钮将没有扩展的工具提示。</td>
</tr>
<tr>
<td>TooltipImage Tooltip图像</td>
<td>作为按钮扩展工具提示的一部分显示的图像文件，当鼠标悬停在命令上较长时间时显示。自选;仅将此标记用于 ExternalCommands。如果未提供此属性和 TooltipImage，则按钮将没有扩展的工具提示。</td>
</tr>
<tr>
<td>LanguageType 语言类型</td>
<td>外部工具按钮的 Text、Description、LargeImage、LongDescription 和 TooltipImage 的本地化设置。Revit 将从指定的语言资源 dll 加载资源值。该值可以是 Revit 支持的 11 种语言之一。如果未指定 LanguageType，则将自动加载当前 Revit 会话使用的语言资源。有关更多详细信息，请参阅本地化部分。</td>
</tr>
<tr>
<td>AllowLoadIntoExistingSession</td>
<td>加载权限的标志。设置为 false 可防止 Revit 在不重新启动的情况下自动加载新添加的 .addin 清单文件中的附加模块。自选。默认情况下。Revit 将自动从新添加的 .addin 清单文件加载附加模块，而无需重新启动 Revit。</td>
</tr>
</tbody></table>
<p>VisibilityMode 成员</p>
<table>
<thead>
<tr>
<th><strong>Member Name 成员名称</strong></th>
<th><strong>Description 描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>AlwaysVisible 始终可见</td>
<td>该命令在 Revit API 支持的所有可能模式下都可用。</td>
</tr>
<tr>
<td>NotVisibleInProject 项目中不可见</td>
<td>当项目文档处于活动状态时，该命令是不可见的。</td>
</tr>
<tr>
<td>NotVisibleInFamily 族项目中不可见</td>
<td>当族文档处于活动状态时，该命令不可见。</td>
</tr>
<tr>
<td>NotVisibleWhenNoActiveDocument 无活动视图不可见</td>
<td>当没有活动文档时，该命令是不可见的。</td>
</tr>
</tbody></table>
<p>学科成员</p>
<table>
<thead>
<tr>
<th><strong>Member Name 会员名称</strong></th>
<th><strong>Description 描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Any 任何</td>
<td>该命令在 Revit API 支持的所有可能领域中均可用。</td>
</tr>
<tr>
<td>Architecture 建筑</td>
<td>该命令在 Autodesk Revit Architecture 中可见。</td>
</tr>
<tr>
<td>Structure 结构</td>
<td>该命令在 Autodesk Revit Structure 中可见。</td>
</tr>
<tr>
<td>StructuralAnalysis 结构分析</td>
<td>当 Structural Analysis 领域编辑工具可用时，该命令可见。</td>
</tr>
<tr>
<td>MassingAndSite 体量与现场</td>
<td>当 体量 和 场地 领域 编辑工具可用时，该命令可见。</td>
</tr>
<tr>
<td>EnergyAnalysis 能量分析</td>
<td>当 Energy Analysis 领域编辑工具可用时，该命令可见。</td>
</tr>
<tr>
<td>Mechanical 机械</td>
<td>当 Mechanical 领域编辑工具可用时（例如，在 Autodesk Revit MEP 中），该命令可见。</td>
</tr>
<tr>
<td>Electrical 电气</td>
<td>当 Electrical 领域编辑工具可用时（例如，在 Autodesk Revit MEP 中），该命令可见。</td>
</tr>
<tr>
<td>Piping 管道</td>
<td>当管道领域编辑工具可用时（例如，在 Autodesk Revit MEP 中），该命令可见。</td>
</tr>
<tr>
<td>MechanicalAnalysis 机械分析</td>
<td>当 Mechanical Analysis 领域编辑工具可用时，该命令可见。</td>
</tr>
<tr>
<td>PipingAnalysis 管道分析</td>
<td>当“管道分析”领域编辑工具可用时，该命令可见。</td>
</tr>
<tr>
<td>ElectricalAnalysis 电气分析</td>
<td>当 Electrical Analysis 领域编辑工具可用时，该命令可见。</td>
</tr>
</tbody></table>
<p>用于清单文件的 .NET Add-in Utility</p>
<p>代码区域 3-11：创建和编辑清单文件</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//create a new addin manifest</span></span><br><span class="line">RevitAddInManifest Manifest = <span class="keyword">new</span> RevitAddInManifest();</span><br><span class="line"></span><br><span class="line"><span class="comment">//create an external command</span></span><br><span class="line">RevitAddInCommand command1 = <span class="keyword">new</span> RevitAddInCommand(<span class="string">&quot;full path\assemblyName.dll&quot;</span>, </span><br><span class="line">     Guid.NewGuid(), <span class="string">&quot;namespace.className&quot;</span>);</span><br><span class="line">command1.Description = <span class="string">&quot;description&quot;</span>;</span><br><span class="line">command1.Text = <span class="string">&quot;display text&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// this command only visible in Revit MEP, Structure, and only visible </span></span><br><span class="line"><span class="comment">// in Project document or when no document at all</span></span><br><span class="line">command1.Discipline = Discipline.Mechanical | Discipline.Electrical |</span><br><span class="line">                        Discipline.Piping | Discipline.Structure;</span><br><span class="line">command1.VisibilityMode = VisibilityMode.NotVisibleInFamily;</span><br><span class="line"></span><br><span class="line"><span class="comment">//create an external application</span></span><br><span class="line">RevitAddInApplication application1 = <span class="keyword">new</span> RevitAddInApplication(<span class="string">&quot;appName&quot;</span>,</span><br><span class="line">    <span class="string">&quot;full path\assemblyName.dll&quot;</span>, Guid.NewGuid(), <span class="string">&quot;namespace.className&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//add both command(s) and application(s) into manifest</span></span><br><span class="line">Manifest.AddInCommands.Add(command1);</span><br><span class="line">Manifest.AddInApplications.Add(application1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//save manifest to a file</span></span><br><span class="line">RevitProduct revitProduct1 = RevitProductUtility.GetAllInstalledRevitProducts()[<span class="number">0</span>];</span><br><span class="line">Manifest.SaveAs(revitProduct1.AllUsersAddInFolder + <span class="string">&quot;\RevitAddInUtilitySample.addin&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>代码区域 3-12：读取现有清单文件</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">RevitProduct revitProduct1 = RevitProductUtility.GetAllInstalledRevitProducts()[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">RevitAddInManifest revitAddInManifest = </span><br><span class="line">     Autodesk.RevitAddIns.AddInManifestUtility.GetRevitAddInManifest(</span><br><span class="line">          revitProduct1.AllUsersAddInFolder + <span class="string">&quot;\RevitAddInUtilitySample.addin&quot;</span>);</span><br></pre></td></tr></table></figure>



<h2 id="对-Revit-插件进行数字签名"><a href="#对-Revit-插件进行数字签名" class="headerlink" title="对 Revit 插件进行数字签名"></a>对 Revit 插件进行数字签名</h2><p>Revit 会检查插件的安全凭据。如果插件未使用受信任的证书颁发机构颁发的证书进行数字签名，则 Revit 会在打开时弹出一个对话框，询问用户确认他&#x2F;她是否要加载应用程序。下图显示了检测到未签名的加载项时的安全警告对话框示例。用户可以选择：1） 允许从现在开始始终加载同一插件，2） 仅加载这次并下次再次询问，以及 3） 不允许加载插件。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/UnsignedAddIn.png"></p>
<p>如果您是专业开发人员，并且您的应用程序已由受信任的证书颁发机构进行数字签名，则您的附加模块已与 Revit 中的数字签名检入兼容。以下部分适用于编写附加模块但不熟悉 Revit 中的数字签名的开发人员。</p>
<h3 id="对应用程序进行数字签名"><a href="#对应用程序进行数字签名" class="headerlink" title="对应用程序进行数字签名"></a>对应用程序进行数字签名</h3><p>如果您是 Revit 附加模块的发布者，则必须使用自己的证书对附加模块进行签名。</p>
<p>要使用自己的证书对加载项进行签名，您首先需要从数字证书供应商处购买数字签名。获取证书 （cer） 或个人信息交换 （pfx） 文件后，您可以使用 signtool 对 DLL 进行签名。或者，您也可以使用在线 Authenticode 签名服务，例如 Symantec 的 Secure App Service - <a href="https://www.symantec.com/code-signing/secure-app-service/%E3%80%82">https://www.symantec.com/code-signing/secure-app-service/。</a></p>
<ul>
<li><p>数字证书供应商</p>
<p>以下是提供数字证书的供应商的非详尽列表：<br>Symantec - <a href="http://www.symantec.com/">www.symantec.com</a><br>DigiCert - <a href="http://www.digicert.com/">www.digicert.com</a><br>VERISIGN - <a href="http://www.verisign.com/">www.verisign.com</a><br>Thawte - <a href="http://www.thawte.com/">www.thawte.com</a></p>
</li>
<li><p>使用 “signtool” 进行签名</p>
<p>您可以使用 signtool.exe.ASPX） 工具对 .NET dll 进行签名。该工具会自动随 Visual Studio 一起安装。要运行该工具，请使用 Developer Command Prompt。以下是命令行参数的格式：<br>命令区域：使用 signtool</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">signtool.exe sign /fd SHA256 /f &lt;.pfx-file-name&gt; /p  .dl</span><br></pre></td></tr></table></figure>

<p>其中 &#x2F;fd 是要使用的文件摘要算法的标志。这里我们使用 SHA256。（SHA 代表安全哈希算法。signtool 默认值为 SHA1。我们建议使用 SHA256，这是一个更新、更安全的版本。&lt;.pfx-file-name&gt; 是您从供应商处获取的 .pfx（个人信息交换）文件的名称。是您在获取 PFX 文件时指定的密码。.dll 是要签名的 DLL 的名称。</p>
<p>例如，如果您在任意文件夹中运行命令，则上述命令可能如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;C:\Program Files (x86)\Windows Kits\8.1\bin\x64\signtool&quot; sign /fd SHA256 /f &quot;C:/Dev/MyCert.pfx&quot; /p &quot;password123&quot; “C:/Dev/HelloRevit.dll”</span><br></pre></td></tr></table></figure>

<p>注意：signtool 的确切位置在您的环境中可能有所不同。<br>使用授权证书对 DLL 进行签名后，Revit 在加载附加模块时将不再弹出安全警告对话框。<br>您还可以在 Visual Studio 的 Post-Built Event 部分包含该命令，以用于应用程序项目属性。<br>命令区域：构建后事件签名</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;C:\Program Files\Microsoft SDKs\Windows\v7.1\Bin\signtool.exe&quot; /fd SHA256 sign /f</span><br><span class="line">&quot;C:\Autodesk\MyCert.pfx&quot; /p MyPassword &quot;$(TargetDir)$(TargetFileName)&quot;</span><br></pre></td></tr></table></figure>

<p>在签名时添加时间戳也是值得的（signtool.exe 中的 &#x2F;td 和 &#x2F;tr 开关）;否则，当证书过期时，应用程序将变得不受信任。添加时间戳可确保应用程序在过期之前签名，就永远受信任（除非证书被吊销）：<br>命令区域：添加时间戳</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">signtool.exe timestamp /td sha256 /tr  .dll</span><br></pre></td></tr></table></figure>

<p>例如，以下代码使用 verisign 时间戳服务器：<br>命令区域：时间戳示例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">signtool.exe timestamp /td sha256 /tr &quot;http://sha256timestamp.ws.symantec.com/sha256/&quot; HelloRevit.dll</span><br></pre></td></tr></table></figure>

<p>注意：上例中使用的 &#x2F;td sha256 和 &#x2F;tr 开关用于使用 sha256 时间戳进行签名。从 2017 年 1 月 1 日开始，Microsoft 会将 SHA1 时间戳视为未签名。有关更多详细信息，请参阅这篇文章。</p>
</li>
</ul>
<h3 id="制作自己的证书以供测试和内部使用"><a href="#制作自己的证书以供测试和内部使用" class="headerlink" title="制作自己的证书以供测试和内部使用"></a>制作自己的证书以供测试和内部使用</h3><p>您可以制作自己的数字证书，以便在公司内部进行测试或使用。</p>
<p>创建自己的数字证书</p>
<ul>
<li>使用 MakeCert.exe. ASPX)工具创建数字证书。</li>
<li>使用 Pvk2Pfx.exe 工具创建个人信息交换 （pfx） 文件。</li>
<li>对应用程序进行数字签名。</li>
<li>将数字证书导入 Windows 证书存储区。（CertMgr.msc 或 CertUtil.exe.aspx</li>
</ul>
<p>1、创建数字证书</p>
<p>您可以使用 MakeCert.exe.ASPX)工具制作您自己的数字证书以供测试和内部使用。以下是命令格式：</p>
<p>命令区域：创建证书命令格式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MakeCert.exe -r -sv .pvk -n &quot;CN=&quot; .cer -b  -e </span><br></pre></td></tr></table></figure>

<p>其中 是你创建的 pvk 文件的名称，是你分配给 pvk 文件的密码。是认证文件或 .cer 文件的名称。是 .pfx 的名称。是要分配给 .pfx 文件的密码。</p>
<p>例如：</p>
<p>命令区域：MakeCert.exe示例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;C:\Program Files\Microsoft SDKs\Windows\v7.1\Bin\MakeCert.exe&quot; -r -sv MyCert.pvk -n &quot;CN=DevABC&quot; MyCert.cer -b 01/01/2016 -e 12/31/2016</span><br></pre></td></tr></table></figure>

<p>或:</p>
<p>命令区域：MakeCert.exe示例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;C:\Program Files (x86)\Windows Kits\8.1\bin\x64\makecert.exe&quot; -r -sv MyCert.pvk -n &quot;CN=DevABC&quot; MyCert.cer -b 01/01/2016 -e 12/31/2016</span><br></pre></td></tr></table></figure>

<p>此命令将弹出“创建私钥密码”对话框。在对话框中输入私钥密码。如果系统要求输入密码，请再次输入。完成所有操作后，您将在命令窗口中看到一条消息“成功”，并创建 .cer 和 .pvk 文件。</p>
<p>2、转换为 PFX</p>
<p>下一步是使用 pvk2pfx.exe 工具将数字证书转换为个人信息交换 （pfx） 文件。在此步骤中，您需要在上述步骤中创建的 .pvk 文件、.cer 文件和密码。命令格式如下所示：</p>
<p>命令区域：转换为 PFX 命令格式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> pvk2pfx.exe&quot; -pvk .pvk -pi  -spc .cer </span><br><span class="line">-pfx  -po </span><br></pre></td></tr></table></figure>

<p>其中 是存储私钥的文件的名称，是开发者的名字，是证书文件的名称，是证书生效的日期（格式为 mm&#x2F;dd&#x2F;yyyy），是证书的有效期结束的日期。 </p>
<p>例如：</p>
<p>命令区域：转换为 PFX 示例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;C:\Program Files (x86)\Windows Kits\8.1\bin\x64\pvk2pfx.exe&quot; -pvk MyCert.pvk -pi password123 -spc MyCert.cer -pfx MyCert.pfx -po password234</span><br></pre></td></tr></table></figure>

<p>操作成功后，命令结束，不显示错误消息，并将创建一个 .pfx 文件。</p>
<p>3、拥有 pfx 文件后，您可以对应用程序进行数字签名。</p>
<p>4、将数字证书导入 Windows 证书存储区</p>
<p>制作自己的数字证书时，还需要执行的另一个步骤是将其导入计算机。您可以在 Certificate Manager （CertMgr.msc.ASPX）） 或 CertUtils.exe 工具。这里我们使用 UI 工具。请参阅此处了解替代方案。</p>
<ul>
<li>从开始 &gt;&gt; 运行 &gt;&gt; CertMgr.msc。（或在 Windows 8.1&#x2F;10 上，右键单击“开始”&gt;&gt; 运行 &gt;&gt; CertMgr.msc）CertMgr 打开。<br>在 CertMgr 对话框中，右键单击 Trusted Publishers &gt;&gt; All Tasks &gt;&gt; Import …</li>
<li>按照证书导入向导中的说明进行操作。单击 Next。</li>
<li>在询问“Files to Import”的对话框中，选择要导入的 pfx 文件。</li>
<li>在 “Password” 对话框中，输入密码。保持“包括所有扩展属性”的选中状态。</li>
<li>选择“将所有证书放在以下存储中”，然后单击下一步。</li>
<li>确认并完成。</li>
</ul>
<p>如果您看到“Import a new Private signature key（导入新的私有签名密钥）”对话框，请单击“确定”。（这部分可能因您的环境而异。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/certmgr.png"></p>
<p>对 Trusted Root Certification Authorities 重复相同的步骤。此步骤用于验证数字签名的二进制文件。</p>
<h3 id="数字签名参考"><a href="#数字签名参考" class="headerlink" title="数字签名参考"></a>数字签名参考</h3><ul>
<li><p>The following references provide more information on digitally signing apps.<br>以下参考资料提供了有关对应用程序进行数字签名的更多信息。</p>
<h2 id="Revit-Help-Revit-帮助"><a href="#Revit-Help-Revit-帮助" class="headerlink" title="Revit Help Revit 帮助"></a>Revit Help Revit 帮助</h2><ul>
<li><p><a href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=GUID-1C5947F2-4525-4B9F-9764-4D83D9FD2157">About Digital Signatures 关于数字签名</a></p>
</li>
<li><p><a href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=GUID-900A3EBF-A809-4A0E-96ED-5EEC965A2728">Security: Signed File or Add-In<br>安全性：签名文件或加载项</a></p>
</li>
<li><p><a href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=GUID-36D29367-A540-4CFD-9773-4995BF1DF08A">Security: Unsigned File or Add-In<br>安全性：未签名的文件或加载项</a></p>
</li>
<li><p><a href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=GUID-A5654402-D25A-4993-9059-0486B36AA708">Security: Invalid Signature<br>安全性：签名无效</a></p>
<h2 id="Microsoft-and-Other-Sites-Microsoft-和其他网站"><a href="#Microsoft-and-Other-Sites-Microsoft-和其他网站" class="headerlink" title="Microsoft and Other Sites Microsoft 和其他网站"></a>Microsoft and Other Sites Microsoft 和其他网站</h2></li>
<li><p><a href="https://msdn.microsoft.com/en-us/library/windows/desktop/jj835835(v=vs.85).aspx?f=255&mspperror=-2147217396">How to sign an app package using SignTool</a><br><a href="https://msdn.microsoft.com/en-us/library/windows/desktop/jj835835(v=vs.85">如何使用 SignTool 对应用程序包进行签名</a>.aspx？f&#x3D;255&amp;mspperror&#x3D;-2147217396）</p>
</li>
<li><p><a href="http://stackoverflow.com/questions/5510063/makecert-exe-missing-in-windows-7-how-to-get-it-and-use-it/9153635#9153635#9153635">makecert.exe missing in windows 7, how to get it and use it<br>Windows 7 中缺少makecert.exe，如何获取和使用它</a></p>
</li>
<li><p>The truth about SHA1, SHA-256 and Code Signing Certificates<br>关于 SHA1、SHA-256 和代码签名证书的真相</p>
<h2 id="AutoCAD-references-AutoCAD-参考"><a href="#AutoCAD-references-AutoCAD-参考" class="headerlink" title="AutoCAD references AutoCAD 参考"></a>AutoCAD references AutoCAD 参考</h2></li>
</ul>
<p><strong>AutoCAD Blog AutoCAD 博客</strong></p>
<ul>
<li><p><a href="http://adndevblog.typepad.com/autocad/2015/01/digitally-signing-plug-in-files.html">http://adndevblog.typepad.com/autocad/2015/01/digitally-signing-plug-in-files.html</a></p>
</li>
<li><p><a href="http://through-the-interface.typepad.com/through_the_interface/2015/05/signing-your-application-modules-for-autocad-2016-part-1.html">http://through-the-interface.typepad.com/through_the_interface/2015/05/signing-your-application-modules-for-autocad-2016-part-1.html</a></p>
<p><strong>AutoCAD Help AutoCAD 帮助</strong></p>
</li>
<li><p><a href="http://help-staging.autodesk.com/view/ACD/2016/ENU/?guid=GUID-3DA95353-9EF3-4E29-9671-6AEB7704EBE6">To Digitally Sign a Binary (ObjectARX or Managed .NET) File<br>对二进制（ObjectARX 或托管 .NET）文件进行数字签名</a></p>
</li>
<li><p><a href="http://help-staging.autodesk.com/view/ACD/2016/ENU/?guid=GUID-AA7BBBED-98D0-4003-8C80-D66173664DBA">To Digitally Sign a Binary (ObjectARX or Managed .NET) File with a Post-Build Event in Microsoft Visual Studio<br>在 Microsoft Visual Studio 中使用构建后事件对二进制（ObjectARX 或托管 .NET）文件进行数字签名</a></p>
</li>
<li><p><a href="http://help-staging.autodesk.com/view/ACD/2016/ENU/?guid=GUID-26D7B31C-4165-410C-9FC4-2D556749D517">To Make a Digital Certificate<br>制作数字证书</a></p>
</li>
<li><p><a href="http://help-staging.autodesk.com/view/ACD/2016/ENU/?guid=GUID-DC1B25FE-E063-486C-B90C-565AB5E87BBC">To Create A Personal Information Exchange (PFX) File<br>创建个人信息交换 （PFX） 文件</a></p>
</li>
<li><p><a href="http://help-staging.autodesk.com/view/ACD/2016/ENU/?guid=GUID-19D6716A-0AD1-4A7A-82BA-A067E6D65F66">To Import a Digital Certificate<br>导入数字证书</a></p>
</li>
</ul>
</li>
</ul>
<h2 id="本地化"><a href="#本地化" class="headerlink" title="本地化"></a>本地化</h2><p>您可以让 Revit 本地化外部命令按钮的用户可见资源（包括文字、大图标图像、长短描述以及工具提示图像）。您需要创建一个 .NET Satellite DLL，其中包含按钮的字符串、图像和图标。然后更改 .addin 文件中的标签值，使其与 Satellite dll 中的资源名称相对应，但前面要加上 @character。所以标签：</p>
<p>代码区域 3-13：非本地化文本输入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Extension Manager</span><br></pre></td></tr></table></figure>

<p>成为：</p>
<p>代码区域 3-14：本地化文本输入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@ExtensionText</span><br></pre></td></tr></table></figure>

<p>其中 ExtensionText 是在附属 DLL 中找到的资源的名称。</p>
<p>附属 DLL 应位于具有语言区域性语言名称的目录中，例如 en 或 en-US。该目录应位于包含加载项程序集的目录中。请参阅 <a href="http://msdn.microsoft.com/en-us/library/e9zazcx5.aspx">http://msdn.microsoft.com/en-us/library/e9zazcx5.aspx</a> 以创建托管的附属 DLL。</p>
<p>通过使用 LanguageType 标记显式指定语言和区域性，可以强制 Revit 使用特定语言资源 DLL，而不管 Revit 会话的语言如何。</p>
<p>代码区域 3-15：使用 LanguageType 标记</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">English_USA</span><br></pre></td></tr></table></figure>

<p>例如，上面的条目将强制 Revit 始终加载 en-US Satellite 中的值，并在考虑外部命令清单文件的可本地化成员时忽略当前的 Revit 语言和区域性设置。</p>
<p>Revit 支持 Autodesk.Revit.ApplicationServices.LanguageType 枚举类型中定义的 11 种语言：English_USA、德语、西班牙语、法语、意大利语、荷兰语、Chinese_Simplified语、Chinese_Traditional、日语、韩语和俄语。</p>
<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><p>Revit API 提供了多个用于配置 ExternalCommand 和 ExternalApplication 行为的特性。</p>
<h3 id="TransactionAttribute"><a href="#TransactionAttribute" class="headerlink" title="TransactionAttribute"></a>TransactionAttribute</h3><p>自定义属性 Autodesk.Revit.Attributes.TransactionMode 必须应用于 IExternalCommand 接口的实现类，以控制外部命令的事务行为。此选项没有默认值。此模式控制 API 框架在调用命令时预期如何使用事务。支持的值为：</p>
<p>TransactionMode.Manual - Revit 不会创建事务（但如果外部命令返回失败，它将创建一个外部事务组以回滚所有更改）。相反，您可以根据需要使用 Transactions、SubTransaction 和 TransactionGroups 的组合。您必须遵守有关使用交易和相关类的所有规则。您必须为您的交易命名，这些名称将出现在 Undo 菜单中。Revit 将检查从外部命令返回时，所有事务（包括组和子事务）是否已正确关闭。否则，Revit 将放弃对模型所做的所有更改。</p>
<p>TransactionMode.ReadOnly - 不会创建任何事务 （或组） ，并且在命令的生存期内不得创建任何事务。External Command 只能使用从模型中读取的方法。如果命令尝试启动事务（或组）或尝试写入模型，则会引发异常。</p>
<p>在任一模式下，TransactionMode 仅适用于活动文档。您可以在执行命令的过程中打开其他文档，并且可以完全控制在这些其他文档上创建和使用 Transactions、SubTransactions 和 TransactionGroups（即使在 ReadOnly 模式下也是如此）。<br>例如，要将外部命令设置为使用手动事务模式：</p>
<p>代码区域 3-18：TransactionAttribute</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">Transaction(TransactionMode.Manual)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Command</span> : <span class="title">IExternalCommand</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">public</span> Autodesk.Revit.IExternalCommand.<span class="function">Result <span class="title">Execute</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">                Autodesk.Revit.ExternalCommandData commandData,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="keyword">ref</span> <span class="built_in">string</span> message, Autodesk.Revit.DB.ElementSet elements</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">                <span class="comment">// Command implementation, which modifies the active document directly </span></span><br><span class="line">                <span class="comment">// after starting a new transaction</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请参阅 事务。</p>
<h3 id="JournalingAttribute"><a href="#JournalingAttribute" class="headerlink" title="JournalingAttribute"></a>JournalingAttribute</h3><p>可以选择将自定义属性 Autodesk.Revit.Attributes.JournalingAttribute 应用于 IExternalCommand 接口的实现类，以控制外部命令执行期间的日记行为。日记有两个选项： </p>
<p>JournalMode.NoCommandData - ExternalCommandData.JournalData 映射的内容未写入 Revit 日志。此选项允许 Revit API 调用根据需要写入日志。此选项允许调用 Revit UI 进行选择或响应任务对话框的命令正确重放。</p>
<p>JournalMode.UsingCommandData - 使用命令数据中提供的 IDictionary&lt;String,String&gt;。这将隐藏外部命令调用与 IDictionary&lt;String,String&gt;条目之间的所有 Revit 日志条目。调用 Revit UI 进行选择或响应任务对话框的命令可能无法正确重放。如果未指定 JournalingAttribute，则这是默认值。</p>
<p>代码区域 3-19：JournalingAttribute</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Journaling(JournalingMode.UsingCommandData)]</span><br><span class="line">public class Command : IExternalCommand</span><br><span class="line">&#123;</span><br><span class="line">        public Autodesk.Revit.IExternalCommand.Result Execute(</span><br><span class="line">                Autodesk.Revit.ExternalCommandData commandData, </span><br><span class="line">                ref string message, Autodesk.Revit.DB.ElementSet elements)</span><br><span class="line">        &#123;</span><br><span class="line">                return Autodesk.Revit.UI.Result.Succeeded;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Revit-异常"><a href="#Revit-异常" class="headerlink" title="Revit 异常"></a>Revit 异常</h2><p>当 API 方法遇到非致命错误时，它们会引发异常。Revit附加模块应捕获异常。Revit API 帮助文件指定了特定方法通常遇到的异常。所有 Revit API 方法都会引发 Autodesk.Revit.Exceptions.ApplicationException 的子类。这些异常与标准 .NET 异常非常相似，例如：</p>
<ul>
<li>ArgumentException ArgumentException（参数异常）</li>
<li>InvalidOperationException</li>
<li>FileNotFoundException</li>
</ul>
<p>但是，其中一些子类对于 Revit 是唯一的：</p>
<ul>
<li>AutoJoinFailedException</li>
<li>RegenerationFailedException</li>
<li>ModificationOutsideTransactionException</li>
</ul>
<p>此外，还有一种称为 InternalException 的特殊异常类型，它表示未预料到的失败路径。此类异常会附带额外的诊断信息，这些信息可以传回 Autodesk 进行诊断。</p>
<h2 id="功能区面板和控件"><a href="#功能区面板和控件" class="headerlink" title="功能区面板和控件"></a>功能区面板和控件</h2><p>Revit 提供了 API 解决方案来集成自定义功能区面板和控件。</p>
<p>这些 API 与 IExternalApplication 一起使用。自定义功能区面板可以添加到“加载项”选项卡、“分析”选项卡或新的自定义功能区选项卡中。</p>
<p>面板可以包括大按钮和小按钮，这些按钮可以是简单的按钮、包含多个命令的下拉按钮，也可以是拆分按钮，这些按钮是附加了默认按钮的下拉按钮。除了按钮之外，面板还可以包括单选按钮组、组合框和文本框。面板还可以包含垂直分隔符，以帮助将命令分隔到逻辑组中。最后，面板可以包含一个滑出控件，可通过单击面板底部来访问该控件。</p>
<p>有关开发符合 Autodesk 所用标准的用户界面的信息，请参见 API 用户界面指南部分中的功能区指南。</p>
<h3 id="创建新的-Ribbon-选项卡"><a href="#创建新的-Ribbon-选项卡" class="headerlink" title="创建新的 Ribbon 选项卡"></a>创建新的 Ribbon 选项卡</h3><p>虽然可以将功能区面板添加到“加载项”或“分析”选项卡中，但也可以将其添加到新的自定义功能区选项卡中。仅在必要时才应使用此选项。为确保标准 Revit 功能区选项卡保持可见，自定义功能区选项卡限制为 20 个。下图显示了一个新的功能区选项卡，其中包含一个功能区面板和一些简单的控件。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/NewRibbonTab.jpg" alt="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/NewRibbonTab.jpg"></p>
<p>下面是生成上述功能区选项卡的代码。</p>
<p>代码区域：“新建功能区”选项卡</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public Result OnStartup(UIControlledApplication application)</span><br><span class="line">&#123;</span><br><span class="line">    // Create a custom ribbon tab</span><br><span class="line">    String tabName = &quot;This Tab Name&quot;;</span><br><span class="line">    application.CreateRibbonTab(tabName);</span><br><span class="line"></span><br><span class="line">    // Create two push buttons</span><br><span class="line">    PushButtonData button1 = new PushButtonData(&quot;Button1&quot;, &quot;My Button #1&quot;,</span><br><span class="line">        @&quot;C:\ExternalCommands.dll&quot;, &quot;Revit.Test.Command1&quot;);</span><br><span class="line">    PushButtonData button2 = new PushButtonData(&quot;Button2&quot;, &quot;My Button #2&quot;,</span><br><span class="line">        @&quot;C:\ExternalCommands.dll&quot;, &quot;Revit.Test.Command2&quot;);</span><br><span class="line">    </span><br><span class="line">    // Create a ribbon panel</span><br><span class="line">    RibbonPanel m_projectPanel = application.CreateRibbonPanel(tabName, &quot;This Panel Name&quot;); </span><br><span class="line">    </span><br><span class="line">    // Add the buttons to the panel</span><br><span class="line">    List projectButtons = new List();</span><br><span class="line">    projectButtons.AddRange(m_projectPanel.AddStackedItems(button1, button2));</span><br><span class="line">    </span><br><span class="line">    return Result.Succeeded;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="创建新的-Ribbon-面板和控件"><a href="#创建新的-Ribbon-面板和控件" class="headerlink" title="创建新的 Ribbon 面板和控件"></a>创建新的 Ribbon 面板和控件</h3><p>下图显示了使用各种功能区面板控件的 Add-Ins （加载项） 选项卡上的功能区面板。以下部分更详细地介绍了这些控件，并提供了用于创建功能区每个部分的代码示例。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-EC547A32-2941-4731-A9C9-135CEDAB4DF0-low.png" alt="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-EC547A32-2941-4731-A9C9-135CEDAB4DF0-low.png"></p>
<p>图 14：新的功能区面板和控件</p>
<p>以下代码概述了创建如上图所示的功能区面板所采取的步骤。此示例中调用的每个函数将在本节后面的后续示例中提供。这些示例假定有一个位于 D：\ Sample\HelloWorld\bin\Debug\Hello.dll 的程序集，其中包含外部命令类型：</p>
<ul>
<li>Hello.HelloButton</li>
<li>Hello.HelloOne </li>
<li>Hello.HelloTwo</li>
<li>Hello.HelloThree </li>
<li>Hello.HelloA </li>
<li>Hello.HelloB </li>
<li>Hello.HelloC </li>
<li>Hello.HelloRed </li>
<li>Hello.HelloBlue</li>
<li>Hello.HelloGreen</li>
</ul>
<p>代码区域：功能区面板和控件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public Result OnStartup(Autodesk.Revit.UI.UIControlledApplication app)</span><br><span class="line">&#123;</span><br><span class="line">        RibbonPanel panel = app.CreateRibbonPanel(&quot;New Ribbon Panel&quot;);</span><br><span class="line"></span><br><span class="line">        AddRadioGroup(panel);</span><br><span class="line">        panel.AddSeparator();</span><br><span class="line">        AddPushButton(panel);</span><br><span class="line">        AddSplitButton(panel);</span><br><span class="line">        AddStackedButtons(panel);</span><br><span class="line">        AddSlideOut(panel);</span><br><span class="line">    </span><br><span class="line">        return Result.Succeeded;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h3 id="Ribbon-Panel-功能区面板"><a href="#Ribbon-Panel-功能区面板" class="headerlink" title="Ribbon Panel 功能区面板"></a>Ribbon Panel 功能区面板</h3><p>自定义功能区面板可以添加到“加载项”选项卡（默认）或“分析”选项卡中，也可以添加到新的自定义功能区选项卡中。可以将各种类型的功能区控件添加到功能区面板中，下一节将更详细地讨论这些控件。所有功能区控件都具有一些通用属性和功能。<br>功能区控件类<br>每个功能区控件都有两个与之关联的类 - 一个派生自 RibbonItemData，用于创建控件（即 SplitButtonData）并将其添加到功能区面板，另一个派生自 RibbonItem（即 SplitButton），表示将项添加到面板后的项目。RibbonItemData（和派生类）中提供的属性也可从 RibbonItem（和相应的派生类）中获得。可以在将控件添加到面板之前设置这些属性，也可以在将控件添加到面板之后使用 RibbonItem 类进行设置。</p>
<h4 id="Tooltips-工具提示"><a href="#Tooltips-工具提示" class="headerlink" title="Tooltips 工具提示"></a>Tooltips 工具提示</h4><p>大多数控件都可以设置工具提示（使用 ToolTip 属性），当用户将鼠标移到控件上时，将显示该工具提示。当用户长时间将鼠标悬停在控件上时，将使用 LongDescription 和 ToolTipImage 属性显示扩展工具提示。如果 LongDescription 和 ToolTipImage 均未设置，则不会显示扩展的工具提示。如果未提供工具提示，则当鼠标移动到控件上时，将显示控件的文本 （RibbonItem.ItemText）。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-261A8653-F926-4D87-8352-E86BF03EC3D0-low.png" alt="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-261A8653-F926-4D87-8352-E86BF03EC3D0-low.png"></p>
<h4 id="Contextual-Help-上下文帮助"><a href="#Contextual-Help-上下文帮助" class="headerlink" title="Contextual Help 上下文帮助"></a>Contextual Help 上下文帮助</h4><p>控件可以具有与之关联的上下文帮助。当用户将鼠标悬停在控件上并按 F1 时，将触发上下文帮助。上下文帮助选项包括链接到外部 URL、启动本地安装的帮助 （chm） 文件或链接到 Autodesk 帮助 Wiki 上的主题。ContextualHelp 类用于创建一种上下文帮助类型，然后 RibbonItem.SetContextualHelp()（或 RibbonItemData.SetContextualHelp()）将其与控件相关联。当 ContextualHelp 实例与控件关联时，当鼠标悬停在控件上时，文本“按 F1 获取更多帮助”将出现在工具提示下方，如下所示。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/ContextualHelp.jpg" alt="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/ContextualHelp.jpg"></p>
<p>下面的示例将新的 ContextualHelp 与按钮控件相关联。将鼠标悬停在按钮上时按 F1 将在新的浏览器窗口中打开 Autodesk 主页。</p>
<p>代码区域：上下文帮助</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void AddPushButton(RibbonPanel panel)</span><br><span class="line">&#123;</span><br><span class="line">    PushButton pushButton = panel.AddItem(new PushButtonData(&quot;HelloWorld&quot;,</span><br><span class="line">        &quot;HelloWorld&quot;, @&quot;D:\Sample\HelloWorld\bin\Debug\HelloWorld.dll&quot;, &quot;HelloWorld.CsHelloWorld&quot;)) as PushButton;</span><br><span class="line"></span><br><span class="line">    // Set ToolTip and contextual help</span><br><span class="line">    pushButton.ToolTip = &quot;Say Hello World&quot;;</span><br><span class="line">    ContextualHelp contextHelp = new ContextualHelp(ContextualHelpType.Url,</span><br><span class="line">        &quot;http://www.autodesk.com&quot;);</span><br><span class="line">    pushButton.SetContextualHelp(contextHelp);</span><br><span class="line">    </span><br><span class="line">    // Set the large image shown on button</span><br><span class="line">    pushButton.LargeImage =</span><br><span class="line">        new BitmapImage(new Uri(@&quot;D:\Sample\HelloWorld\bin\Debug\39-Globe_32x32.png&quot;));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ContextualHelp 类具有一个 Launch() 方法，可以调用该方法来随时显示由此 ContextualHelp 对象的内容指定的帮助主题，这与在控件处于活动状态时按下 F1 键时相同。这允许将帮助主题与加载项应用程序创建的对话框中的用户界面组件相关联。<br>将图像与控件关联 </p>
<p>所有这些控件都可以使用 LargeImage 属性具有与其关联的图像。与大型控件（如非堆叠功能区和下拉按钮）关联的图像的最佳大小为 32×32 像素，但较大的图像将进行调整以适合按钮。堆叠按钮和小控件（如文本框和组合框）应具有 16×16 像素的图像集。大按钮还应为 Image 属性设置 16×16 像素的图像。如果命令移动到快速访问工具栏，则使用此图像。如果未设置 Image 属性，则当命令移动到快速访问工具栏时，将不显示任何图像。请注意，如果使用大于 16×16 像素的图像，则不会调整它以适应工具栏。 ToolTipImage 将显示在扩展工具提示中的 LongDescription 下方（如果提供）。此图像没有建议的大小。</p>
<h4 id="功能区控制可用性"><a href="#功能区控制可用性" class="headerlink" title="功能区控制可用性"></a>功能区控制可用性</h4><p> 可以使用 RibbonItem.Enabled 属性启用或禁用功能区控件，也可以使用 RibbonItem.Visible 属性使功能区控件可见或不可见。</p>
<h4 id="功能区控件"><a href="#功能区控件" class="headerlink" title="功能区控件"></a>功能区控件</h4><p> 除了以下控件之外，还可以将垂直分隔符添加到功能区面板，以对相关的控件集进行分组。</p>
<h5 id="按钮"><a href="#按钮" class="headerlink" title="按钮"></a>按钮</h5><p>您可以向面板添加三种类型的按钮：简单按钮、下拉按钮和拆分按钮。图 14 中的 HelloWorld 按钮是一个按钮。按下该按钮时，将触发相应的命令。 除了 Enabled 属性之外，PushButton 还具有 AvailabilityClassName 属性，该属性可用于设置 IExternalCommandAvailability 接口的名称，该接口控制命令何时可用。</p>
<p>代码区域：添加按钮</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void AddPushButton(RibbonPanel panel)</span><br><span class="line">&#123;</span><br><span class="line">        PushButton pushButton = panel.AddItem(new PushButtonData(&quot;HelloWorld&quot;,</span><br><span class="line">                &quot;HelloWorld&quot;, @&quot;D:\HelloWorld.dll&quot;, &quot;HelloWorld.CsHelloWorld&quot;)) as PushButton;</span><br><span class="line"></span><br><span class="line">        pushButton.ToolTip = &quot;Say Hello World&quot;;</span><br><span class="line">        // Set the large image shown on button</span><br><span class="line">        pushButton.LargeImage = </span><br><span class="line">                new BitmapImage(new Uri(@&quot;D:\Sample\HelloWorld\bin\Debug\39-Globe_32x32.png&quot;));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Drop-down-buttons-下拉按钮"><a href="#Drop-down-buttons-下拉按钮" class="headerlink" title="Drop-down buttons 下拉按钮"></a>Drop-down buttons 下拉按钮</h5><p>下拉按钮展开后，可在下拉菜单中显示两个或多个命令。在 Revit API 中，下拉按钮称为 PulldownButtons。可以在下拉菜单中的项目之间添加水平分隔符。</p>
<p>下拉菜单中的每个命令也可以具有关联的 LargeImage，如上面的示例所示。</p>
<p>Split buttons 拆分按钮</p>
<p>拆分按钮是附加了默认按钮的下拉按钮。按钮的上半部分类似于按钮，而下半部分用作下拉按钮。图 14 中的 Option One 按钮是一个拆分按钮。</p>
<p>最初，按钮将是下拉列表中的顶部项目。但是，通过使用 IsSynchronizedWithCurrentItem 属性，默认命令（显示为拆分按钮的上半部分）可以与上次使用的命令同步。默认情况下，它将同步。在上面图 14 的 split 按钮中选择选项 2 将产生：</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-FCBB9C72-5786-4B34-BF1F-E41A99F446C3-low.png" alt="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-FCBB9C72-5786-4B34-BF1F-E41A99F446C3-low.png"></p>
<p>图 16：与当前项目同步的 Split 按钮</p>
<p>请注意，将忽略 SplitButton 的 ToolTip、ToolTipImage 和 LongDescription 属性。而是显示当前按钮的工具提示。<br>代码区域：添加拆分按钮</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">AddSplitButton</span>(<span class="params">RibbonPanel panel</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="built_in">string</span> assembly = <span class="string">@&quot;D:\Sample\HelloWorld\bin\Debug\Hello.dll&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// create push buttons for split button drop down</span></span><br><span class="line">        PushButtonData bOne = <span class="keyword">new</span> PushButtonData(<span class="string">&quot;ButtonNameA&quot;</span>, <span class="string">&quot;Option One&quot;</span>,</span><br><span class="line">         assembly, <span class="string">&quot;Hello.HelloOne&quot;</span>);</span><br><span class="line">        bOne.LargeImage = </span><br><span class="line">                <span class="keyword">new</span> BitmapImage(<span class="keyword">new</span> Uri(<span class="string">@&quot;D:\Sample\HelloWorld\bin\Debug\One.bmp&quot;</span>));</span><br><span class="line">    </span><br><span class="line">        PushButtonData bTwo = <span class="keyword">new</span> PushButtonData(<span class="string">&quot;ButtonNameB&quot;</span>, <span class="string">&quot;Option Two&quot;</span>, </span><br><span class="line">                assembly, <span class="string">&quot;Hello.HelloTwo&quot;</span>);</span><br><span class="line">        bTwo.LargeImage =</span><br><span class="line">         <span class="keyword">new</span> BitmapImage(<span class="keyword">new</span> Uri(<span class="string">@&quot;D:\Sample\HelloWorld\bin\Debug\Two.bmp&quot;</span>));</span><br><span class="line">    </span><br><span class="line">        PushButtonData bThree = <span class="keyword">new</span> PushButtonData(<span class="string">&quot;ButtonNameC&quot;</span>, <span class="string">&quot;Option Three&quot;</span>,</span><br><span class="line">         assembly, <span class="string">&quot;Hello.HelloThree&quot;</span>);</span><br><span class="line">        bThree.LargeImage = </span><br><span class="line">                <span class="keyword">new</span> BitmapImage(<span class="keyword">new</span> Uri(<span class="string">@&quot;D:\Sample\HelloWorld\bin\Debug\Three.bmp&quot;</span>));</span><br><span class="line">    </span><br><span class="line">        SplitButtonData sb1 = <span class="keyword">new</span> SplitButtonData(<span class="string">&quot;splitButton1&quot;</span>, <span class="string">&quot;Split&quot;</span>);</span><br><span class="line">        SplitButton sb = panel.AddItem(sb1) <span class="keyword">as</span> SplitButton;</span><br><span class="line">        sb.AddPushButton(bOne);</span><br><span class="line">        sb.AddPushButton(bTwo);</span><br><span class="line">        sb.AddPushButton(bThree);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Radio-buttons-单选按钮"><a href="#Radio-buttons-单选按钮" class="headerlink" title="Radio buttons 单选按钮"></a>Radio buttons 单选按钮</h5><p>单选按钮组是一组互斥的切换按钮;一次只能选择一个。将 RadioButtonGroup 添加到面板后，使用 AddItem() 或 AddItems() 方法将切换按钮添加到该组。切换按钮派生自 PushButton。RadioButtonGroup.Current 属性可用于访问当前选定的按钮。</p>
<p>请注意，工具提示不适用于单选按钮组。相反，当鼠标移动到各个按钮上时，将显示每个切换按钮的工具提示。</p>
<p>代码区域：添加单选按钮组</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">AddRadioGroup</span>(<span class="params">RibbonPanel panel</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">// add radio button group</span></span><br><span class="line">        RadioButtonGroupData radioData = <span class="keyword">new</span> RadioButtonGroupData(<span class="string">&quot;radioGroup&quot;</span>);</span><br><span class="line">        RadioButtonGroup radioButtonGroup = panel.AddItem(radioData) <span class="keyword">as</span> RadioButtonGroup;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// create toggle buttons and add to radio button group</span></span><br><span class="line">        ToggleButtonData tb1 = <span class="keyword">new</span> ToggleButtonData(<span class="string">&quot;toggleButton1&quot;</span>, <span class="string">&quot;Red&quot;</span>);</span><br><span class="line">        tb1.ToolTip = <span class="string">&quot;Red Option&quot;</span>;</span><br><span class="line">        tb1.LargeImage = <span class="keyword">new</span> BitmapImage(<span class="keyword">new</span> Uri(<span class="string">@&quot;D:\Sample\HelloWorld\bin\Debug\Red.bmp&quot;</span>));</span><br><span class="line">        ToggleButtonData tb2 = <span class="keyword">new</span> ToggleButtonData(<span class="string">&quot;toggleButton2&quot;</span>, <span class="string">&quot;Green&quot;</span>);</span><br><span class="line">        tb2.ToolTip = <span class="string">&quot;Green Option&quot;</span>;</span><br><span class="line">        tb2.LargeImage = <span class="keyword">new</span> BitmapImage(<span class="keyword">new</span> Uri(<span class="string">@&quot;D:\Sample\HelloWorld\bin\Debug\Green.bmp&quot;</span>));</span><br><span class="line">        ToggleButtonData tb3 = <span class="keyword">new</span> ToggleButtonData(<span class="string">&quot;toggleButton3&quot;</span>, <span class="string">&quot;Blue&quot;</span>);</span><br><span class="line">        tb3.ToolTip = <span class="string">&quot;Blue Option&quot;</span>;</span><br><span class="line">        tb3.LargeImage = <span class="keyword">new</span> BitmapImage(<span class="keyword">new</span> Uri(<span class="string">@&quot;D:\Sample\HelloWorld\bin\Debug\Blue.bmp&quot;</span>));</span><br><span class="line">        radioButtonGroup.AddItem(tb1);</span><br><span class="line">        radioButtonGroup.AddItem(tb2);</span><br><span class="line">        radioButtonGroup.AddItem(tb3);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Text-box-文本框"><a href="#Text-box-文本框" class="headerlink" title="Text box 文本框"></a>Text box 文本框</h5><p>文本框是供用户输入文本的输入控件。通过将 ShowImageAsButton 属性设置为 true，可以将文本框的图像用作可单击的按钮。默认值为 false。当 ShowImageAsButton 为 false 时，图像显示在文本框的左侧，当它充当按钮时，图像显示在文本框的右端，如图 14 所示。仅当用户按 Enter 键或在图像显示为按钮时单击关联的图像时，才会接受在文本框中输入的文本。否则，文本将恢复为之前的值。<br>除了为文本框提供工具提示外，PromptText 属性还可用于向用户指示要在文本框中输入的信息类型。当文本框为空且没有键盘焦点时，将显示提示文本。此文本以斜体显示。图 14 中的文本框具有提示文本 “Enter a comment”。</p>
<p>可以使用 Width 属性设置文本框的宽度。默认值为 200 个与设备无关的单位。</p>
<p>当用户按 Enter 键时，或者当 ShowImageAsButton 设置为 true 时，当用户单击文本框的关联图像时，将触发 TextBox.EnterPressed 事件。在实现 EnterPressed 事件处理程序时，将 sender 对象强制转换为 TextBox 以获取用户输入的值，如以下示例所示。</p>
<p>代码区域：TextBox.EnterPressed 事件处理程序</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ProcessText</span>(<span class="params"><span class="built_in">object</span> sender, Autodesk.Revit.UI.Events.TextBoxEnterPressedEventArgs <span class="keyword">args</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">// cast sender as TextBox to retrieve text value</span></span><br><span class="line">        TextBox textBox = sender <span class="keyword">as</span> TextBox;</span><br><span class="line">        <span class="built_in">string</span> strText = textBox.Value <span class="keyword">as</span> <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继承的 ItemText 属性对 TextBox 没有影响。用户输入的文本可以从 Value 属性中获取，该属性必须转换为字符串。 有关将 TextBox 添加到功能区面板的示例，包括如何注册上述事件，请参阅堆叠功能区项部分。</p>
<h5 id="组合框"><a href="#组合框" class="headerlink" title="组合框"></a>组合框</h5><p> 组合框是包含一组可选项的下拉列表。将 ComboBox 添加到面板后，使用 AddItem() 或 AddItems() 方法将 ComboBoxMembers 添加到列表中。 还可以将分隔符添加到列表中的单独项中，或者可以选择使用 ComboBoxMember.GroupName 属性对成员进行分组。具有相同 GroupName 的所有成员将分组在一起，并显示组名称的标头。任何未分配 GroupName 的项目都将放置在列表顶部。请注意，在对项目进行分组时，不应使用分隔符，因为它们将放置在组的末尾，而不是按添加顺序放置。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-62DBB2D2-0D7B-4EDC-945B-DC86BAE6BF6F-low.png" alt="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-62DBB2D2-0D7B-4EDC-945B-DC86BAE6BF6F-low.png"></p>
<p>图 17：带分组的组合框 </p>
<p>ComboBox 有三个事件： </p>
<p>CurrentChanged - 当 ComboBox 的当前项发生更改时触发</p>
<p> DropDownClosed - 关闭 ComboBox 的下拉列表时触发  </p>
<p>DropDownClosed - 打开 ComboBox 的下拉菜单时触发 </p>
<p>有关将 ComboBox 添加到功能区面板的示例，请参阅以下有关堆叠功能区项的代码区域。</p>
<h5 id="堆叠面板项目"><a href="#堆叠面板项目" class="headerlink" title="堆叠面板项目"></a>堆叠面板项目</h5><p> 为了节省面板空间，您可以以 2 个或 3 个为一组的形式添加小面板项。堆栈中的每个项都可以是按钮、下拉按钮、组合框或文本框。单选按钮组和拆分按钮不能堆叠。堆叠按钮应具有通过其 Image 属性关联的图像，而不是 LargeImage。16×16 图像非常适合小型堆叠按钮。 以下示例生成图 14 中的堆叠文本框和组合框。</p>
<p>代码区域：将文本框和组合框添加为堆叠项</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">AddStackedButtons</span>(<span class="params">RibbonPanel panel</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        ComboBoxData cbData = <span class="keyword">new</span> ComboBoxData(<span class="string">&quot;comboBox&quot;</span>);</span><br><span class="line"></span><br><span class="line">        TextBoxData textData = <span class="keyword">new</span> TextBoxData(<span class="string">&quot;Text Box&quot;</span>);</span><br><span class="line">        textData.Image = </span><br><span class="line">                <span class="keyword">new</span> BitmapImage(<span class="keyword">new</span> Uri(<span class="string">@&quot;D:\Sample\HelloWorld\bin\Debug\39-Globe_16x16.png&quot;</span>));</span><br><span class="line">        textData.Name = <span class="string">&quot;Text Box&quot;</span>;</span><br><span class="line">        textData.ToolTip = <span class="string">&quot;Enter some text here&quot;</span>;</span><br><span class="line">        textData.LongDescription = <span class="string">&quot;This is text that will appear next to the image&quot;</span> </span><br><span class="line">                + <span class="string">&quot;when the user hovers the mouse over the control&quot;</span>;</span><br><span class="line">        textData.ToolTipImage = </span><br><span class="line">                <span class="keyword">new</span> BitmapImage(<span class="keyword">new</span> Uri(<span class="string">@&quot;D:\Sample\HelloWorld\bin\Debug\39-Globe_32x32.png&quot;</span>));</span><br><span class="line">    </span><br><span class="line">        IList stackedItems = panel.AddStackedItems(textData, cbData);</span><br><span class="line">        <span class="keyword">if</span> (stackedItems.Count &gt; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                TextBox tBox = stackedItems[<span class="number">0</span>] <span class="keyword">as</span> TextBox;</span><br><span class="line">                <span class="keyword">if</span> (tBox != <span class="literal">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                        tBox.PromptText = <span class="string">&quot;Enter a comment&quot;</span>;</span><br><span class="line">                        tBox.ShowImageAsButton = <span class="literal">true</span>;</span><br><span class="line">                        tBox.ToolTip = <span class="string">&quot;Enter some text&quot;</span>;</span><br><span class="line">                        <span class="comment">// Register event handler ProcessText</span></span><br><span class="line">                        tBox.EnterPressed += </span><br><span class="line">                <span class="keyword">new</span> EventHandler&lt;Autodesk.Revit.UI.Events.TextBoxEnterPressedEventArgs&gt;(ProcessText);</span><br><span class="line">                &#125;</span><br><span class="line">    </span><br><span class="line">                ComboBox cBox = stackedItems[<span class="number">1</span>] <span class="keyword">as</span> ComboBox;</span><br><span class="line">                <span class="keyword">if</span> (cBox != <span class="literal">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                        cBox.ItemText = <span class="string">&quot;ComboBox&quot;</span>;</span><br><span class="line">                        cBox.ToolTip = <span class="string">&quot;Select an Option&quot;</span>;</span><br><span class="line">                        cBox.LongDescription = <span class="string">&quot;Select a number or letter&quot;</span>;</span><br><span class="line">    </span><br><span class="line">                        ComboBoxMemberData cboxMemDataA = <span class="keyword">new</span> ComboBoxMemberData(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;Option A&quot;</span>);</span><br><span class="line">                        cboxMemDataA.Image = </span><br><span class="line">                                <span class="keyword">new</span> BitmapImage(<span class="keyword">new</span> Uri(<span class="string">@&quot;D:\Sample\HelloWorld\bin\Debug\A.bmp&quot;</span>));</span><br><span class="line">                        cboxMemDataA.GroupName = <span class="string">&quot;Letters&quot;</span>;</span><br><span class="line">                        cBox.AddItem(cboxMemDataA);</span><br><span class="line">    </span><br><span class="line">                        ComboBoxMemberData cboxMemDataB = <span class="keyword">new</span> ComboBoxMemberData(<span class="string">&quot;B&quot;</span>, <span class="string">&quot;Option B&quot;</span>);</span><br><span class="line">                        cboxMemDataB.Image = </span><br><span class="line">                                <span class="keyword">new</span> BitmapImage(<span class="keyword">new</span> Uri(<span class="string">@&quot;D:\Sample\HelloWorld\bin\Debug\B.bmp&quot;</span>));</span><br><span class="line">                        cboxMemDataB.GroupName = <span class="string">&quot;Letters&quot;</span>;</span><br><span class="line">                        cBox.AddItem(cboxMemDataB);</span><br><span class="line">    </span><br><span class="line">                        ComboBoxMemberData cboxMemData = <span class="keyword">new</span> ComboBoxMemberData(<span class="string">&quot;One&quot;</span>, <span class="string">&quot;Option 1&quot;</span>);</span><br><span class="line">                        cboxMemData.Image = </span><br><span class="line">                                <span class="keyword">new</span> BitmapImage(<span class="keyword">new</span> Uri(<span class="string">@&quot;D:\Sample\HelloWorld\bin\Debug\One.bmp&quot;</span>));</span><br><span class="line">                        cboxMemData.GroupName = <span class="string">&quot;Numbers&quot;</span>;</span><br><span class="line">                        cBox.AddItem(cboxMemData);</span><br><span class="line">                        ComboBoxMemberData cboxMemData2 = <span class="keyword">new</span> ComboBoxMemberData(<span class="string">&quot;Two&quot;</span>, <span class="string">&quot;Option 2&quot;</span>);</span><br><span class="line">                        cboxMemData2.Image = </span><br><span class="line">                                <span class="keyword">new</span> BitmapImage(<span class="keyword">new</span> Uri(<span class="string">@&quot;D:\Sample\HelloWorld\bin\Debug\Two.bmp&quot;</span>));</span><br><span class="line">                        cboxMemData2.GroupName = <span class="string">&quot;Numbers&quot;</span>;</span><br><span class="line">                        cBox.AddItem(cboxMemData2);</span><br><span class="line">                        ComboBoxMemberData cboxMemData3 = <span class="keyword">new</span> ComboBoxMemberData(<span class="string">&quot;Three&quot;</span>, <span class="string">&quot;Option 3&quot;</span>);</span><br><span class="line">                        cboxMemData3.Image = </span><br><span class="line">                                <span class="keyword">new</span> BitmapImage(<span class="keyword">new</span> Uri(<span class="string">@&quot;D:\Sample\HelloWorld\bin\Debug\Three.bmp&quot;</span>));</span><br><span class="line">                        cboxMemData3.GroupName = <span class="string">&quot;Numbers&quot;</span>;</span><br><span class="line">                        cBox.AddItem(cboxMemData3);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Slide-out-panel-滑出面板"><a href="#Slide-out-panel-滑出面板" class="headerlink" title="Slide-out panel 滑出面板"></a>Slide-out panel 滑出面板</h5><p>使用 RibbonPanel.AddSlideOut() 方法将幻灯片向功能区面板的底部添加。添加滑出后，面板底部会显示一个箭头，单击该箭头时将显示滑出。调用 AddSlideOut() 后，用于向面板添加新项的后续调用将添加到滑出式面板，因此必须在将所有其他控件添加到功能区面板后添加滑出式控件。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-5B17EB5F-D4B4-472D-9033-B11C35F7E40B-low.png" alt="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-5B17EB5F-D4B4-472D-9033-B11C35F7E40B-low.png"></p>
<p>图 18：滑出</p>
<p>以下示例生成上面所示的滑出：</p>
<p>代码区域：TextBox.EnterPressed 事件处理程序</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">AddSlideOut</span>(<span class="params">RibbonPanel panel</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="built_in">string</span> assembly = <span class="string">@&quot;D:\Sample\HelloWorld\bin\Debug\Hello.dll&quot;</span>;</span><br><span class="line"></span><br><span class="line">        panel.AddSlideOut();</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// create some controls for the slide out</span></span><br><span class="line">        PushButtonData b1 = <span class="keyword">new</span> PushButtonData(<span class="string">&quot;ButtonName1&quot;</span>, <span class="string">&quot;Button 1&quot;</span>, </span><br><span class="line">                assembly, <span class="string">&quot;Hello.HelloButton&quot;</span>);</span><br><span class="line">        b1.LargeImage = </span><br><span class="line">                <span class="keyword">new</span> BitmapImage(<span class="keyword">new</span> Uri(<span class="string">@&quot;D:\Sample\HelloWorld\bin\Debug\39-Globe_32x32.png&quot;</span>));</span><br><span class="line">        PushButtonData b2 = <span class="keyword">new</span> PushButtonData(<span class="string">&quot;ButtonName2&quot;</span>, <span class="string">&quot;Button 2&quot;</span>, </span><br><span class="line">                assembly, <span class="string">&quot;Hello.HelloTwo&quot;</span>);</span><br><span class="line">        b2.LargeImage =</span><br><span class="line">                <span class="keyword">new</span> BitmapImage(<span class="keyword">new</span> Uri(<span class="string">@&quot;D:\Sample\HelloWorld\bin\Debug\39-Globe_16x16.png&quot;</span>));</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// items added after call to AddSlideOut() are added to slide-out automatically</span></span><br><span class="line">        panel.AddItem(b1);</span><br><span class="line">        panel.AddItem(b2);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Revit-样式的任务对话框"><a href="#Revit-样式的任务对话框" class="headerlink" title="Revit 样式的任务对话框"></a>Revit 样式的任务对话框</h2><p>TaskDialog 是简单 Windows MessageBox 的 Revit 样式替代方案。它可用于显示信息和接收来自用户的简单输入。它具有一组通用的控件，这些控件按标准顺序排列，以确保与 Revit 的其余部分保持一致的外观。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-6D0C2A00-3CB5-4963-B108-515FA6924728-low.png" alt="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-6D0C2A00-3CB5-4963-B108-515FA6924728-low.png"></p>
<p>图 19：Revit 风格的任务对话框</p>
<p>有两种方法可以创建任务对话框并向用户显示。</p>
<p>第一个选项是构造 TaskDialog，单独设置其属性，并使用实例方法 Show() 向用户显示它。</p>
<p>第二种方法是使用静态 Show() 方法之一在一个步骤中构建和显示对话框。使用 static 方法时，只能指定选项的子集。<br>有关开发符合 Autodesk 使用的标准的任务对话框的信息，请参见 API 用户界面准则部分中的对话框准则。</p>
<p>以下示例显示如何创建和显示上面显示的任务对话框。</p>
<p>代码区域 3-27：显示 Revit 样式的 TaskDialog</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">Autodesk.Revit.Attributes.Transaction(Autodesk.Revit.Attributes.TransactionMode.ReadOnly)</span>]</span><br><span class="line"><span class="keyword">class</span> <span class="title">TaskDialogExample</span> : <span class="title">IExternalCommand</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">public</span> Autodesk.Revit.UI.<span class="function">Result <span class="title">Execute</span>(<span class="params">ExternalCommandData commandData, <span class="keyword">ref</span> <span class="built_in">string</span> message, Autodesk.Revit.DB.ElementSet elements</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">                <span class="comment">// Get the application and document from external command data.</span></span><br><span class="line">                Application app = commandData.Application.Application;</span><br><span class="line">                Document activeDoc = commandData.Application.ActiveUIDocument.Document;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Creates a Revit task dialog to communicate information to the user.</span></span><br><span class="line">                TaskDialog mainDialog = <span class="keyword">new</span> TaskDialog(<span class="string">&quot;Hello, Revit!&quot;</span>);</span><br><span class="line">                mainDialog.MainInstruction = <span class="string">&quot;Hello, Revit!&quot;</span>;</span><br><span class="line">                mainDialog.MainContent = </span><br><span class="line">                        <span class="string">&quot;This sample shows how to use a Revit task dialog to communicate with the user.&quot;</span> </span><br><span class="line">                        + <span class="string">&quot;The command links below open additional task dialogs with more information.&quot;</span>;</span><br><span class="line">    </span><br><span class="line">                <span class="comment">// Add commmandLink options to task dialog</span></span><br><span class="line">                mainDialog.AddCommandLink(TaskDialogCommandLinkId.CommandLink1,</span><br><span class="line">                         <span class="string">&quot;View information about the Revit installation&quot;</span>);</span><br><span class="line">                mainDialog.AddCommandLink(TaskDialogCommandLinkId.CommandLink2, </span><br><span class="line">                                <span class="string">&quot;View information about the active document&quot;</span>);</span><br><span class="line">    </span><br><span class="line">                <span class="comment">// Set common buttons and default button. If no CommonButton or CommandLink is added,</span></span><br><span class="line">                <span class="comment">// task dialog will show a Close button by default</span></span><br><span class="line">                mainDialog.CommonButtons = TaskDialogCommonButtons.Close;</span><br><span class="line">                mainDialog.DefaultButton = TaskDialogResult.Close;</span><br><span class="line">    </span><br><span class="line">                <span class="comment">// Set footer text. Footer text is usually used to link to the help document.</span></span><br><span class="line">                mainDialog.FooterText = </span><br><span class="line">                        <span class="string">&quot;&quot;</span>                          + <span class="string">&quot;Click here for the Revit API Developer Center&quot;</span>;</span><br><span class="line">    </span><br><span class="line">                TaskDialogResult tResult = mainDialog.Show();</span><br><span class="line">    </span><br><span class="line">                <span class="comment">// If the user clicks the first command link, a simple Task Dialog </span></span><br><span class="line">                <span class="comment">// with only a Close button shows information about the Revit installation. </span></span><br><span class="line">                <span class="keyword">if</span> (TaskDialogResult.CommandLink1 == tResult)</span><br><span class="line">                &#123;</span><br><span class="line">                        TaskDialog dialog_CommandLink1 = <span class="keyword">new</span> TaskDialog(<span class="string">&quot;Revit Build Information&quot;</span>);</span><br><span class="line">                        dialog_CommandLink1.MainInstruction = </span><br><span class="line">                                <span class="string">&quot;Revit Version Name is: &quot;</span> + app.VersionName + <span class="string">&quot;\n&quot;</span></span><br><span class="line">                         + <span class="string">&quot;Revit Version Number is: &quot;</span> + app.VersionNumber + <span class="string">&quot;\n&quot;</span> </span><br><span class="line">                                + <span class="string">&quot;Revit Version Build is: &quot;</span> + app.VersionBuild;</span><br><span class="line">    </span><br><span class="line">                        dialog_CommandLink1.Show();</span><br><span class="line">    </span><br><span class="line">                &#125;</span><br><span class="line">    </span><br><span class="line">                <span class="comment">// If the user clicks the second command link, a simple Task Dialog </span></span><br><span class="line">                <span class="comment">// created by static method shows information about the active document</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (TaskDialogResult.CommandLink2 == tResult)</span><br><span class="line">                &#123;</span><br><span class="line">                        TaskDialog.Show(<span class="string">&quot;Active Document Information&quot;</span>, </span><br><span class="line">                                <span class="string">&quot;Active document: &quot;</span> + activeDoc.Title + <span class="string">&quot;\n&quot;</span></span><br><span class="line">                         + <span class="string">&quot;Active view name: &quot;</span> + activeDoc.ActiveView.Name);</span><br><span class="line">                &#125;</span><br><span class="line">    </span><br><span class="line">                <span class="keyword">return</span> Autodesk.Revit.UI.Result.Succeeded;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="数据库级外部应用程序"><a href="#数据库级外部应用程序" class="headerlink" title="数据库级外部应用程序"></a>数据库级外部应用程序</h2><p>数据库级附加模块是外部应用程序，不会向 Revit UI 添加任何内容。当应用程序的目的是将事件和&#x2F;或更新程序分配给 Revit 会话时，可以使用数据库级外部应用程序。</p>
<p>要向 Revit 添加 DB 级外部应用程序，请创建一个实现 IExternalDBApplication 接口的对象。</p>
<p>IExternalDBApplication 接口有两个抽象方法：OnStartup() 和 OnShutdown()，您可以在 DB 级外部应用程序中重写它们。</p>
<p>Revit 在启动时调用 OnStartup()，在关闭时调用 OnShutdown()。这与 IExternalApplication 非常相似，但请注意，这些方法返回 Autodesk.Revit.DB.ExternalDBApplicationResult 而不是 Autodesk.Revit.UI.Result，并使用 ControlledApplication 而不是 UIControlledApplication。</p>
<p>代码区域：IExternalDBApplication OnShutdown() 和 OnStartup()</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IExternalDBApplication</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">public</span> Autodesk.Revit.DB.<span class="function">ExternalDBApplicationResult <span class="title">OnStartup</span>(<span class="params">ControlledApplication application</span>)</span>;</span><br><span class="line">        <span class="keyword">public</span> Autodesk.Revit.DB.<span class="function">ExternalDBApplicationResult <span class="title">OnShutdown</span>(<span class="params">ControlledApplication application</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ControlledApplication 参数提供对 Revit 数据库事件的访问。数据库级应用程序将响应的事件和更新程序可以在 OnStartup 方法中注册。</p>
<h2 id="注：翻译自Revit-API-Developers-Guide"><a href="#注：翻译自Revit-API-Developers-Guide" class="headerlink" title="注：翻译自Revit API Developers Guide"></a><em><strong>注：</strong></em>翻译自<a href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_html">Revit API Developers Guide</a></h2>]]></content>
      <categories>
        <category>Revit二次开发人员指南</category>
      </categories>
      <tags>
        <tag>Revit</tag>
      </tags>
  </entry>
  <entry>
    <title>01开始</title>
    <url>/2024/11/23/%E4%BA%8C%E5%BC%80%E6%8C%87%E5%8D%97/01%E5%BC%80%E5%A7%8B/</url>
    <content><![CDATA[<h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a><a href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_Introduction_Getting_Started_html">开始</a></h1><p>Revit 平台 API 可通过与 Microsoft .NET Framework 4.5.2 或 4.6 兼容的任何语言（如 Visual C# 或 Visual Basic .NET （VB.NET））进行完全访问。Visual C# 和 VB.NET 通常用于开发 Revit 平台 API 应用程序。但是，本手册的重点是使用 Visual C# 开发应用程序。</p>
<h2 id="欢迎使用-Revit-Platform-API"><a href="#欢迎使用-Revit-Platform-API" class="headerlink" title="欢迎使用 Revit Platform API"></a>欢迎使用 Revit Platform API</h2><p>所有基于 Autodesk Revit 的产品都是参数化建筑信息模型 （BIM） 工具。这样的工具可以看作是用于构建 3D 模型的 CAD 程序，而不是一组单独的图纸文件。Autodesk Revit 建模是通过柱、墙、门和窗等真实世界的元素完成的。用户可以创建模型的视图，包括平面图、剖面图和详图索引。所有这些视图都是直接从 3D 物理模型生成的，因此在一个视图中所做的更改将自动传播到所有其他视图。此过程几乎消除了在模型中进行更改时更新多个图纸和细节的需要。</p>
<p>Autodesk Revit API 旨在反映与程序的图形用户界面相同的用户交互范例。因此，了解 API 的第一步是学习如何使用该程序。如果您是 Autodesk Revit 新手，我们建议您首先阅读教程，您可以通过程序的“帮助”菜单访问这些教程。您可能还会发现，参加当地 Autodesk 经销商提供的培训课程会很有帮助。这将帮助您快速掌握该程序</p>
<h3 id="Revit-平台-API-简介"><a href="#Revit-平台-API-简介" class="headerlink" title="Revit 平台 API 简介"></a>Revit 平台 API 简介</h3><p>Revit .NET API 允许您使用任何符合 .NET 的语言（包括 Visual Basic.NET、C# 和 C++&#x2F;CLI）进行编程。Autodesk Revit 提供了一个 API，旨在允许高级用户和外部应用程序开发人员将其应用程序与 Autodesk Revit 集成。强烈建议您在尝试使用 Autodesk Revit API 之前熟悉 Autodesk Revit 及其功能。可以通过 Autodesk Developer Network （ADN） 找到培训。</p>
<p>学习 Revit 可以帮助您：</p>
<ul>
<li>与 Revit UI 和命令保持一致。无缝设计您的插件应用程序。</li>
<li>高效且有效地掌握 API 类和类成员。</li>
<li>如果您不熟悉 Revit 或 BIM，请在 <a href="http://www.autodesk.com/revit">www.autodesk.com/revit</a> 的 Revit 产品中心了解更多信息。</li>
</ul>
<h3 id="您可以使用-Revit-Platform-API-做什么？"><a href="#您可以使用-Revit-Platform-API-做什么？" class="headerlink" title="您可以使用 Revit Platform API 做什么？"></a>您可以使用 Revit Platform API 做什么？</h3><p>以下是 API 适用的一般区域：</p>
<ul>
<li>在 Autodesk Revit 用户界面中创建附加模块和宏以自动执行重复性任务。</li>
<li>通过自动检查错误来执行项目设计标准。</li>
<li>提取项目数据进行分析并生成报告。</li>
<li>导入外部数据以创建新元素或参数值。</li>
<li>将其他应用程序（包括分析应用程序）集成到 Autodesk Revit 产品中。</li>
<li>自动创建 Autodesk Revit 项目文档。</li>
</ul>
<h3 id="开始需要什么"><a href="#开始需要什么" class="headerlink" title="开始需要什么"></a>开始需要什么</h3><ul>
<li><p>对 Autodesk Revit 有深入的了解。</p>
</li>
<li><p>基于 Autodesk Revit 的产品的安装，包括软件开发工具包。</p>
</li>
<li><p>MS Visual Studio 2015 Express Edition（C# 或 VB.NET）。但是，建议使用 Microsoft Visual Studio 2015 Professional，因为 Express 版本不支持 DLL 调试。或者，您也可以使用 Revit 中内置的 SharpDevelop 开发环境。</p>
</li>
<li><p>具有一定的基于 .NET 的开发语言经验。（Autodesk Revit API 示例以 C# 和 Visual Basic.NET 提供。</p>
</li>
</ul>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>Autodesk Revit API 随基于 Autodesk Revit 的产品的默认安装一起自动安装。任何基于 .NET 的应用程序都将引用位于 Revit Program 目录中的 RevitAPI.dll 和 RevitAPIUI.dll。该RevitAPI.dll包含用于在数据库级别访问 Revit 的应用程序、文档、图元和参数的方法。RevitAPIUI.dll包含与 Revit 用户界面的操作和自定义相关的界面。</p>
<p>请注意，RevitAPIIFC.dll、RevitAPIMacros.dll 和 RevitAPIUIMacros.dll 中存在其他 API 功能，这些功能也随 Revit 一起安装，但这些部件并非立即需要开始使用。</p>
<p>Autodesk Revit API 软件开发工具包 （SDK） 从 Autodesk Revit 安装的“工具和实用程序”部分安装。</p>
<h3 id="开发要求"><a href="#开发要求" class="headerlink" title="开发要求"></a>开发要求</h3><p>Autodesk Revit API 需要 Microsoft .NET Framework 4.5.2 或 4.6。Revit 的二进制文件是使用 .NET 4.5.2 构建的。但是，Revit 使用 .NET 4.6 中的运行时。</p>
<p>要编辑和调试 API 应用程序，您需要一个交互式开发环境，例如 Microsoft Visual Studio 2015 Professional 或适用于 C# 或 Visual Basic.NET 的 MS Visual Studio Express Editions 之一。（建议使用 Visual Studio Professional，因为 Express 版本不支持 DLL 调试。使用 Autodesk Revit API 进行开发时，请确保您的项目引用 Autodesk Revit Program 目录中包含的两个 DLL：RevitAPI.dll 和 RevitAPIUI.dll。</p>
<p>需要一些编程技能才能有效地使用 API。如果您是编程初学者，我们强烈建议您学习 Visual Studio 2015 Microsoft 以及 C# 或 Visual Basic.NET 等兼容语言之一。有很多好书和课程可以帮助你入门。</p>
<h3 id="用户使用手册"><a href="#用户使用手册" class="headerlink" title="用户使用手册"></a>用户使用手册</h3><p>本文档是 Revit SDK 的一部分。它介绍了如何使用 Revit Platform API 实现 Revit 附加模块应用程序。</p>
<p>在创建 Revit Platform API 附加模块应用程序之前，请通读手册并尝试示例代码。如果您已经对 Revit Platform API 有一定的经验，您可能只想查看“注释”和“疑难解答”部分。</p>
<ul>
<li><p>Revit Platform API 简介</p>
<p>前两章介绍了 Revit Platform API，并概述了用户手册。<br>欢迎使用 Revit 平台 API - 在创建第一个附加模块之前，介绍 Revit 平台 API 的简介和必要的必备知识。<br>入门 - 使用 Visual Studio 2010 创建第一个 Hello World 加载项应用程序的分步说明，以及涵盖主要加载项功能的其他四个演练。</p>
</li>
<li><p>基础主题</p>
<p>这些章节介绍了 Revit Platform API 的基本机制和功能。<br>附加模块集成 - 讨论如何将附加模块集成到 Revit UI 中，并由用户命令或特定 Revit 事件（如程序启动）调用。<br>应用程序和文档 - 应用程序和文档类分别表示 Revit 平台 API 中的 Revit 应用程序和项目文件。本章介绍基本概念以及相关章节的链接。<br>元素要点 - Revit 项目中的大部分数据位于元素集合中。本章讨论基本的 Element 机制、分类和功能。<br>筛选 - 筛选用于从文档中获取一组元素。<br>选择 - 使用文档中的选定元素集。<br>参数- 大多数元素信息都存储为参数。本章讨论参数功能。<br>集合- 实用程序集合类型，如 Array、Map、Set 集合和相关的迭代器。</p>
</li>
<li><p>元素主题</p>
<p>元素是根据元素分类引入的。在阅读各个元素之前，请确保先阅读元素要点和参数章节。<br>编辑元素 - 了解如何移动、旋转、删除、镜像、分组和阵列元素。<br>墙、地板、天花板、屋顶和洞口 - 讨论元素、它们对应的 ElementType（表示内置位置构造）以及 API 中不同类型的洞口。<br>族实例 - 了解族和族实例、族和族实例特征之间的关系，以及如何加载或创建它们。<br>族创建 - 了解如何创建和修改 Revit 族文档。<br>概念设计 - 讨论如何在 Revit 概念体量文档中创建复杂的几何图形和形状。<br>基准和信息元素 - 了解如何设置网格、添加标高、使用设计选项等。<br>注释元素 - 讨论文档注释，包括添加尺寸、详图曲线、标记和注释符号。<br>草图绘制 - 草图函数包括 2D 和 3D 草图类，例如 SketchPlane、ModelCurve、GenericForm 等。<br>视图 - 了解查看模型和组件的不同方式，以及如何在 API 中操作视图。<br>材质 - 材质数据是一个元素，用于标识项目中使用的物理材质以及纹理、颜色等。</p>
</li>
<li><p>高级主题</p>
<p>几何图形 - 讨论 API 中用于描述模型的图形表示的图形相关类型，包括描述和存储几何图形信息的三个类。<br>地点和位置 - 定义项目位置，包括城市、国家&#x2F;地区、纬度和经度。<br>共享参数 - 共享参数是包含参数规范的外部文本文件。本章介绍如何通过 Revit Platform API 访问共享参数。<br>事务 - 介绍 Transaction 的两种用途以及使用 Transaction 时必须考虑的限制。<br>事件 - 讨论如何利用 Revit 事件。<br>动态模型更新 - 了解如何使用更新程序修改模型以响应文档中的更改。<br>失败提交和处理 - 了解如何提交失败并与 Revit 的失败处理机制进行交互。<br>分析可视化 - 如何在 Revit 项目中显示分析结果。</p>
</li>
<li><p>特定学科</p>
<p>Revit 包括用于建筑、结构工程和 MEP 工程的特定于领域的功能。某些 API 仅适用于特定功能集。<br>建筑设计- 讨论特定于 Revit 的建筑功能的 API。<br>结构工程 - 讨论特定于 Revit 的结构工程功能的 API。<br>MEP工程 - 讨论特定于 Revit 的机械、电气和卫浴功能的 API。</p>
</li>
<li><p>其他</p>
<p>词汇表 - 本文档中使用的术语定义。<br>附录 - 其他信息，如常见问题、使用 Visual Basic.Net 进行编程等。</p>
</li>
</ul>
<h3 id="文档约定"><a href="#文档约定" class="headerlink" title="文档约定"></a>文档约定</h3><p>本文档包含命名空间格式的类名，例如 Autodesk.Revit.DB.Element。在 C++&#x2F;CLI 中，Autodesk.Revit.Element 是 Autodesk::Revit::DB::Element。由于本手册中仅使用 C# 作为示例代码，因此默认命名空间为 Autodesk.Revit.DB。如果要在 Visual Basic 中查看代码，可以在 SDK 示例目录中找到几个 VB.NET 应用程序。</p>
<ul>
<li>索引属性</li>
</ul>
<p>  某些 Revit Platform API 类特性已“编入索引”，或在 API 帮助文件 （RevitAPI.chm） 中描述为过载。例如，Element.Geometry 属性。在本文档的文本中，这些属性称为属性，尽管您可以通过在属性名称前面加上“get_”或“set_”来访问它们，就好像它们是 C# 代码中的方法一样。例如，若要使用 Element.Geometry（Options） 属性，请使用 Element.get_Geometry（Options）。</p>
<h3 id="此版本中的新增功能"><a href="#此版本中的新增功能" class="headerlink" title="此版本中的新增功能"></a>此版本中的新增功能</h3><p>有关更改和新功能的信息，请参见 RevitAPI.chm（包含在 Revit API SDK 中）中的“新特性”部分。</p>
<h2 id="使用-Autodesk-Revit-API"><a href="#使用-Autodesk-Revit-API" class="headerlink" title="使用 Autodesk Revit API"></a>使用 Autodesk Revit API</h2><p>Autodesk Revit API 软件开发工具包 （SDK） 从 Autodesk Revit 安装的“工具和实用程序”部分安装。在 SDK 中，有一些示例文件可帮助您更好地了解 API 及其用法。每个示例文件都有一个示例 .addin 清单文件，其中包含您需要编辑并放入相应文件夹的信息，Autodesk Revit 将在启动时访问该文件夹。</p>
<p>RevitAPI.chm 是 Autodesk Revit API 参考文档帮助 chm 文件，包含在 SDK 包的 \Revit 2018 SDK\ 文件夹中。</p>
<h3 id="部署选项"><a href="#部署选项" class="headerlink" title="部署选项"></a>部署选项</h3><p>Autodesk Revit API 仅支持进程内 DLL。这意味着您的 API 应用程序将被编译为加载到 Autodesk Revit 进程中的 DLL。<br>Autodesk Revit API 仅支持单线程访问。这意味着您的 API 应用程序必须在主线程中执行所有 Autodesk Revit API 调用（由 Autodesk Revit 进程在各种 API 入口点调用），并且您的 API 应用程序无法维护其他线程中的操作，并期望它们能够随时调用 Autodesk Revit。（有关可能的例外情况，请参阅高级主题 External_Events）。</p>
<p>可以使用 Autodesk Revit API 创建两种类型的 DLL：外部命令和外部应用程序。</p>
<ul>
<li><p>外部命令</p>
<p>Autodesk Revit API 允许您向 Autodesk Revit 的用户界面添加新命令。这些命令将出现在 ‘External Tools’ 下拉菜单下的 Add-ins 选项卡中，如图 1 所示。通过 API，外部工具命令可以访问 Autodesk Revit 数据库以及当前选定的图元。<br><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/HelloWorldCommand.png"><br>图 1：添加到 Revit 的外部工具</p>
</li>
<li><p>外部应用程序</p>
<p>Autodesk Revit API 还允许您添加外部应用程序。这些应用程序在 Autodesk Revit 启动和关闭期间调用。他们可以在 Add-ins 选项卡中创建新面板，如图 2 所示。他们还可以注册处理程序，以便对 Autodesk Revit 用户界面中发生的事件做出反应。<br><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/HelloWorldRibbonPanel.png"><br>图 2：Revit 中添加了新面板和控件</p>
</li>
<li><p>REX 插件</p>
<p>REX （Revit Extensions） 是一个 API 框架，它允许您在 .NET 中为 Revit 构建应用程序，类似于实现 IExternalCommand 的类。REX 旨在通过内置资源为您提供更高级的开发环境，例如：<br>自动对话框创建和显。<br>用于处理单位和几何图形的库。<br>内置基于命令的架构，使菜单和工具栏开发更加容易。<br>用于访问对 Revit 应用程序对象的引用的标准机制。<br>自动部署和安装插件，便于调试。有关更多详细信息，请参见“\Revit 2018 SDK\REX SDK\”文件夹。</p>
</li>
</ul>
<h3 id="插件注册"><a href="#插件注册" class="headerlink" title="插件注册"></a>插件注册</h3><p>Revit API 提供了通过 .addin 清单文件注册 API 应用程序的功能。<br>当清单文件放置在用户系统上的两个位置之一时，Revit 将自动读取这些文件：</p>
<ul>
<li>C：\ProgramData\Autodesk\Revit\Addins\2018\</li>
<li>C：\Users\AppData\Roaming\Autodesk\Revit\Addins\2018\ 在启动期间，Revit 将读取和处理这些位置中名为 .addin 的所有文件。</li>
</ul>
<p>添加一个 ExternalCommand 的基本文件如下所示：</p>
<p>代码区域：ExternalCommand 的基本清单文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-16&quot; standalone=&quot;no&quot;?&gt;</span><br><span class="line"></span><br><span class="line">c:\MyProgram\MyProgram.dll</span><br><span class="line">76eb700a-2c85-4888-a78d-31429ecae9ed</span><br><span class="line">Revit.Samples.SampleCommand</span><br><span class="line">Sample command</span><br><span class="line">NotVisibleInFamily</span><br><span class="line">NotVisibleInMEP</span><br><span class="line">Revit.Samples.SampleAccessibilityCheck </span><br></pre></td></tr></table></figure>

<p>添加一个 ExternalApplication 的基本文件如下所示：</p>
<p>代码区域：ExternalApplication 的基本清单文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-16&quot; standalone=&quot;no&quot;?&gt;</span><br><span class="line"></span><br><span class="line">My sample application</span><br><span class="line">c:\MyProgram\MyProgram.dll</span><br><span class="line">604B1052-F742-4951-8576-C261D1993107</span><br><span class="line">Revit.Samples.SampleApplication</span><br></pre></td></tr></table></figure>

<p>单个清单文件中可以添加多个 AddIn 元素。</p>
<p>请参阅插件注册以了解有关 .addin 文件的可用 XML 标签的更多信息。</p>
<h3 id="外部命令"><a href="#外部命令" class="headerlink" title="外部命令"></a>外部命令</h3><p>从技术上讲，外部命令是支持 Autodesk.Revit.UI.IExternalCommand 接口的公开 .NET 对象。此外，在相应的目录中必须有一个 .addin 清单文件，每个此类对象都有一个条目，以便 Revit 能够“看到”并使用命令。</p>
<ul>
<li><p>IExternalCommand 接口</p>
<p>接口的声明 （VB.NET） 如下：<br>代码区域：VB.NET IExternalCommand 接口</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Function Execute(ByVal commandData As Autodesk.Revit.UI.ExternalCommandData,</span><br><span class="line">ByRef message As String,</span><br><span class="line">ByVal elements As Autodesk.Revit.DB.ElementSet)</span><br><span class="line">As Result</span><br></pre></td></tr></table></figure>
<ul>
<li><p>Parameters 参数</p>
<p>commandData ：此参数中传递的对象包含对正在执行命令的重要信息。此数据包括 Autodesk Revit Application 对象以及当前活动的视图。<br>message ：可以设置消息字符串，以便在命令终止时向用户提供特定消息。此消息的显示方式取决于函数的返回值。有关更多详细信息，请参阅备注部分。<br>elemtnts：最初，这是一个可以包含 Autodesk Revit 元素的空集。当命令终止时，可能会根据返回值显示此集中的元素。有关更多详细信息，请参阅备注部分。</p>
</li>
<li><p>Return value 返回值</p>
<p>result：返回值可以是以下值之一：<br>Success ：如果命令按预期成功且没有任何未处理的错误情况，则返回。外部命令将在 Autodesk Revit 用户界面中显示为可撤消的操作。<br>Cancelled ：此值指定用户请求取消命令。在执行外部命令期间对 Autodesk Revit 对象所做的任何更改都将被撤消。可能会发布一条消息，请参阅 备注 部分。<br>Failure ：失败表示外部命令以某种方式失败，无法恢复。在执行外部命令期间对 Autodesk Revit 对象所做的任何更改都将被撤消。将发布一条消息，请参阅 备注 部分。</p>
</li>
<li><p>Remarks 备注</p>
<p>如果命令被取消或失败，则使用 message 和 elements 参数。<br>Cancelled:外部命令已取消，并且消息参数由外部命令设置，则在将执行返回给 Autodesk Revit 时，将显示该消息。如果未设置 message 参数，则不会显示任何消息，并且命令将静默退出。<br>Failed: 如果外部命令失败，则将显示 message 参数的内容。如果元素集包含 Autodesk Revit 元素，则在显示错误消息时，这些元素将高亮显示，从而使开发人员能够向用户显示有问题的元素。</p>
</li>
</ul>
</li>
<li><p>使用 Autodesk Revit API 外部命令</p>
<p>用户在 Autodesk Revit 中打开&#x2F;创建项目<br>用户从 Add-ins 选项卡上的 External Tools 下拉菜单中选择外部命令。<br>用户可以选择在调用外部工具程序之前选择多个 Autodesk Revit 图元。如果这样做，程序可以决定仅对所选成员执行其功能。<br>API 程序从 Autodesk Revit 获取焦点并执行所需的任务。通常，在应用程序完成其工作之前，可能需要一个对话框来获取用户输入。<br>一旦插件工具完成其功能或被用户关闭，程序将根据需要更新 Autodesk Revit 模型并从外部命令返回，从而将焦点重新放在 Autodesk Revit 上。</p>
</li>
<li><p>外部命令对象生存期</p>
<p>当 Autodesk Revit 中没有其他命令或编辑模式处于活动状态时，已注册的外部命令将变为启用状态。选取后，将创建 command 对象并调用 Execute 方法。此方法返回 Autodesk Revit 后，命令对象将被销毁。由于这种销毁，数据无法在命令执行之间保留在对象中。如果您希望数据持久保存，您可以使用外部文件或数据库来实现。如果您希望数据保留在 Autodesk Revit 项目中，您可以使用共享参数机制来存储此数据。</p>
</li>
</ul>
<h3 id="外部应用程序"><a href="#外部应用程序" class="headerlink" title="外部应用程序"></a>外部应用程序</h3><p>从技术上讲，外部应用程序是支持 Autodesk.Revit.IExternalApplication 接口的公开 .NET 对象。此外，在相应的目录中必须有一个 .addin 清单文件，每个此类对象都有一个条目，以便 Autodesk Revit 能够在 Autodesk Revit 启动时加载这些应用程序。</p>
<ul>
<li><p>IExternalApplication 接口</p>
<p>接口的声明 （C#） 如下所示：<br>代码区域：IExternalApplication 接口</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Autodesk.Revit.UI.IExternalApplication.Result OnShutdown(Autodesk.Revit.UIControlledApplication application)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>Parameters 参数</p>
<p>application：在此参数中传递的对象包含对正在调用的命令 OnStartup 和 OnShutdown 非常重要的信息。此对象提供 Autodesk Revit Application 的有限访问方法，如 VersionName、VersionNumber;以及某些事件的委托，例如 OnDocumentOpened、OnDocumentSaved</p>
</li>
<li><p>Return Value 返回值</p>
<p>result：返回值可以是以下值之一：<br>Success：如果外部应用程序按预期成功且没有任何未处理的错误情况，则返回此结果。<br>Failure: ：失败表示外部应用程序以某种方式失败，无法从中恢复。<br>Cancelled：此值指定取消外部应用程序。</p>
</li>
</ul>
</li>
<li><p>外部应用程序对象生存期</p>
<p>当 Autodesk Revit 启动时，将创建外部应用程序对象并调用 OnStartup 方法。此方法成功返回到 Autodesk Revit 后，外部应用程序对象将在整个 Autodesk Revit 会话期间保留。当 Autodesk Revit 关闭时，将调用 OnShutdown 方法。</p>
</li>
</ul>
<h3 id="在-Microsoft-Visual-Studio-中调试应用程序"><a href="#在-Microsoft-Visual-Studio-中调试应用程序" class="headerlink" title="在 Microsoft Visual Studio 中调试应用程序"></a>在 Microsoft Visual Studio 中调试应用程序</h3><p>以下说明适用于 Visual Studio Professional。相关选项在 Visual Studio Express 版本中不可用。<br>调试独立应用程序 （EXE） 与需要其他程序来启动它的外部应用程序 （DLL） 之间存在一些差异。要调试使用 Autodesk Revit API 的应用程序，需要由 Autodesk Revit 激活该应用程序。要在开发人员环境中进行调试时执行此操作，您需要：</p>
<ul>
<li>打开或新建一个Revit项目</li>
<li>打开 API 应用程序的 Visual Studio 项目。（例如，Samples 文件夹中的 AnalyticalSupportData_Info.csproj）</li>
<li>在Visual Studio 的调试中选则附加到进程，选择revit.exe</li>
</ul>
<h3 id="单位系统"><a href="#单位系统" class="headerlink" title="单位系统"></a>单位系统</h3><p>Revit 单位系统使用以下基本单位：</p>
<table>
<thead>
<tr>
<th><strong>基本单位</strong></th>
<th><strong>Revit中的单位</strong></th>
<th><strong>单位制</strong></th>
</tr>
</thead>
<tbody><tr>
<td>长度</td>
<td>Feet (ft) 英尺</td>
<td>Imperial 英制</td>
</tr>
<tr>
<td>角度</td>
<td>Radian 弧度</td>
<td>Metric 公制</td>
</tr>
<tr>
<td>质量</td>
<td>Kilogram (kg)</td>
<td>Metric 公制</td>
</tr>
<tr>
<td>时间</td>
<td>Seconds (s)</td>
<td>Metric 公制</td>
</tr>
<tr>
<td>电流</td>
<td>Ampere (A)</td>
<td>Metric 公制</td>
</tr>
<tr>
<td>温度</td>
<td>Kelvin (K)</td>
<td>Metric 公制</td>
</tr>
<tr>
<td>发光强度</td>
<td>Candela (cd)</td>
<td>Metric 公制</td>
</tr>
</tbody></table>
<h3 id="存储和访问应用程序的自定义数据"><a href="#存储和访问应用程序的自定义数据" class="headerlink" title="存储和访问应用程序的自定义数据"></a>存储和访问应用程序的自定义数据</h3><p>通常，链接到 Autodesk Revit 的程序需要的信息不被Autodesk Revit 模型数据库使用。用户可以通过多种方式输入此类附加信息。信息的输入方式和位置取决于其用途：</p>
<ul>
<li>如果信息是常规类型，并且用户希望在 Autodesk Revit 中查看和编辑它，则应将其存储为可见的项目或共享参数。</li>
<li>如果信息需要在 Autodesk Revit 模型不断发展时保留在 Autodesk Revit 模型中，但不需要可见，则可以将其作为不可见的项目或共享参数或使用可扩展存储存储在 Autodesk Revit 模型中。</li>
<li>如果信息特定于单个附加程序，并且太大而无法实际存储在 Autodesk Revit 模型中，例如可能会更改的大量建筑产品的规格，则最佳解决方案可能是创建一个并发模型数据库来存储程序特定信息。在这种情况下，使用每个元素的元素 UniqueId 属性作为数据库的键可能很有用，因为元素的 UniqueId 在模型中是稳定的。</li>
</ul>
<h2 id="演练"><a href="#演练" class="headerlink" title="演练"></a>演练</h2><p>如果您不熟悉 Revit Platform API，则以下主题是帮助您了解该产品的良好起点。演练提供了常见方案的分步说明，可帮助您了解产品或特定功能。以下演练将帮助您开始使用 Revit Platform API：</p>
<ul>
<li>演练：Hello World - 演示如何使用 Revit 平台 API 创建附加模块。</li>
<li>演练：添加 Hello World 功能区面板 - 演示如何添加自定义功能区面板。</li>
<li>演练：检索选定元素 - 演示如何检索选定元素。</li>
<li>演练：检索筛选的元素 -演示如何根据筛选条件检索元素。</li>
</ul>
<h2 id="演练：Hello-World"><a href="#演练：Hello-World" class="headerlink" title="演练：Hello World"></a><a href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_Introduction_Getting_Started_Walkthrough_Hello_World_html">演练：Hello World</a></h2><p>使用 Revit 平台 API 和 C# 按照提供的说明创建 Hello World 程序。有关如何使用 VB.NET 创建加载项应用程序的信息，请参阅 Hello World for VB.NET 。</p>
<p>Hello World 演练涵盖以下主题：</p>
<ul>
<li>Create a new project. 创建新项目。</li>
<li>Add references. 添加引用。</li>
<li>Change the class name. 更改类名。</li>
<li>Write the code 编写代码</li>
<li>Debug the add-in. 调试插件。</li>
</ul>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/HelloWorldCommand.png"></p>
<h2 id="演练：添加-Hello-World-功能区面板"><a href="#演练：添加-Hello-World-功能区面板" class="headerlink" title="演练：添加 Hello World 功能区面板"></a><a href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_Introduction_Getting_Started_Walkthrough_Add_Hello_World_Ribbon_Panel_html">演练：添加 Hello World 功能区面板</a></h2><p>在“演练：Hello World”部分中，您将了解如何创建附加模块应用程序并在 Revit 中调用它。您还将学习如何创建 .addin 清单文件，以将 Add-in 应用程序注册为外部工具。在 Revit 中调用附加模块应用程序的另一种方法是通过自定义功能区面板。</p>
<p><img src="https://help.autodesk.com/cloudhelp/2018/ENU/Revit-API/images/GUID-8EBB8680-BCD5-4983-829F-55288BBC16B6-low.png"></p>
<h2 id="演练：检索选定元素"><a href="#演练：检索选定元素" class="headerlink" title="演练：检索选定元素"></a><a href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_Introduction_Getting_Started_Walkthrough_Retrieve_Selected_Elements_html">演练：检索选定元素</a></h2><p>本节将向您介绍一个附加模块应用程序，该应用程序可从 Revit 中获取选定的图元。<br>获取所选元素后，您可以获取元素的属性或参数。更多信息，请参见参数。</p>
<h2 id="演练：检索筛选的元素"><a href="#演练：检索筛选的元素" class="headerlink" title="演练：检索筛选的元素"></a><a href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_Introduction_Getting_Started_Walkthrough_Retrieve_Filtered_Elements_html">演练：检索筛选的元素</a></h2><p>您可以使用过滤器仅选择满足特定条件的元素。有关创建和使用元素过滤器的更多信息，请参阅元素检索。<br>此示例检索文档中的所有门，并返回门元素列表。</p>
<h2 id="注：翻译自Revit-API-Developers-Guide"><a href="#注：翻译自Revit-API-Developers-Guide" class="headerlink" title="注：翻译自Revit API Developers Guide"></a><em><strong>注：</strong></em>翻译自<a href="https://help.autodesk.com/view/RVT/2018/ENU/?guid=Revit_API_Revit_API_Developers_Guide_html">Revit API Developers Guide</a></h2>]]></content>
      <categories>
        <category>Revit二次开发人员指南</category>
      </categories>
      <tags>
        <tag>Revit</tag>
      </tags>
  </entry>
</search>
